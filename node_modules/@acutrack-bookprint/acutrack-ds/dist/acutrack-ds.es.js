import * as React from "react";
import React__default, { useEffect, useState, useRef, createContext, useContext, useCallback, useLayoutEffect, useMemo, useId as useId$1, useInsertionEffect as useInsertionEffect$1, Children, isValidElement, Fragment, createElement as createElement$1, forwardRef, Component, cloneElement, useSyncExternalStore } from "react";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { flushSync, createPortal } from "react-dom";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (Object.prototype.hasOwnProperty.call(n2, "__esModule")) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a3 = function a4() {
      var isInstance = false;
      try {
        isInstance = this instanceof a4;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a3.prototype = f2.prototype;
  } else a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a3, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a3;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config.key && (key = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config)
        "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    config = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== config ? config : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
  hasRequiredReactJsxRuntime_development = 1;
  "production" !== process.env.NODE_ENV && (function() {
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch ("number" === typeof type.tag && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return (type.displayName || "Context") + ".Provider";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x2) {
            }
        }
      return null;
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e2) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(
          JSCompiler_inline_result,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          JSCompiler_inline_result$jscomp$0
        );
        return testStringCoercion(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE) return "<>";
      if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x2) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
      if (hasOwnProperty.call(config, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
        if (getter && getter.isReactWarning) return false;
      }
      return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          displayName
        ));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      ));
      componentName = this.props.ref;
      return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self2, source, owner, props, debugStack, debugTask) {
      self2 = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      null !== (void 0 !== self2 ? self2 : null) ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self2, debugStack, debugTask) {
      var children = config.children;
      if (void 0 !== children)
        if (isStaticChildren)
          if (isArrayImpl(children)) {
            for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else validateChildKeys(children);
      if (hasOwnProperty.call(config, "key")) {
        children = getComponentNameFromType(type);
        var keys = Object.keys(config).filter(function(k2) {
          return "key" !== k2;
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
          'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
          isStaticChildren,
          children,
          keys,
          children
        ), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      children && defineKeyPropWarningGetter(
        maybeKey,
        "function" === typeof type ? type.displayName || type.name || "Unknown" : type
      );
      return ReactElement(
        type,
        children,
        self2,
        source,
        getOwner(),
        maybeKey,
        debugStack,
        debugTask
      );
    }
    function validateChildKeys(node) {
      "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React2 = React__default, REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React2 = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React2.react_stack_bottom_frame.bind(
      React2,
      UnknownOwner
    )();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
    reactJsxRuntime_development.jsx = function(type, config, maybeKey, source, self2) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        false,
        source,
        self2,
        trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
    reactJsxRuntime_development.jsxs = function(type, config, maybeKey, source, self2) {
      var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(
        type,
        config,
        maybeKey,
        true,
        source,
        self2,
        trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
      );
    };
  })();
  return reactJsxRuntime_development;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  if (process.env.NODE_ENV === "production") {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  } else {
    jsxRuntime.exports = requireReactJsxRuntime_development();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
const useOnClickOutside = (ref, handler) => {
  useEffect(() => {
    const listener = (event) => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      const target = event.target;
      if (target.closest('[data-calendar-nav="true"]')) {
        return;
      }
      handler(event);
    };
    document.addEventListener("mousedown", listener);
    document.addEventListener("touchstart", listener);
    return () => {
      document.removeEventListener("mousedown", listener);
      document.removeEventListener("touchstart", listener);
    };
  }, [ref, handler]);
};
const useCopyToClipboard = () => {
  const [isCopied, setIsCopied] = useState(false);
  const copy2 = (text) => {
    if (isCopied) return;
    navigator.clipboard.writeText(text).then(() => {
      setIsCopied(true);
      setTimeout(() => {
        setIsCopied(false);
      }, 2e3);
    }).catch((err) => {
      console.error("Failed to copy text: ", err);
    });
  };
  return [copy2, isCopied];
};
const sizeMap = {
  xs: "text-xs",
  sm: "text-sm",
  md: "text-base",
  lg: "text-lg",
  xl: "text-xl",
  "2xl": "text-2xl",
  "3xl": "text-3xl"
};
const Icon = ({
  children,
  className = "",
  size: size2 = "md",
  filled = false,
  weight = 400,
  opticalSize = 24,
  ariaHidden = false,
  ariaLabel
}) => {
  if (!children || typeof children !== "string") {
    console.warn("Icon component requires a valid icon name as children");
    return null;
  }
  const iconName = children;
  document.fonts?.check('1em "Material Symbols Outlined"') || document.fonts?.check("1em Material Symbols Outlined") || true;
  const sizeClass = sizeMap[size2] || size2;
  const fontVariationSettings = `'FILL' ${filled ? 1 : 0}, 'wght' ${weight}, 'GRAD' 0, 'opsz' ${opticalSize}`;
  const accessibilityProps = ariaHidden ? { "aria-hidden": true } : { "aria-label": ariaLabel || children };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      className: `material-symbols-outlined inline-flex items-center justify-center select-none ${sizeClass} ${className}`,
      style: {
        "--font-variation-settings": fontVariationSettings,
        fontVariationSettings,
        lineHeight: "1",
        fontFamily: '"Material Symbols Outlined", system-ui, sans-serif',
        padding: 0,
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center"
      },
      ...accessibilityProps,
      children: iconName
    }
  );
};
const Badge = ({
  children,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "sm",
  variant = "default",
  color: color2 = "primary",
  isBordered = true,
  isRounded = true,
  radius = "full",
  hasShadow = false,
  isInteractive = false,
  onClick,
  isDismissible = false,
  onDismiss,
  hasIcon = false,
  icon,
  isPulsing = false,
  isLoading = false,
  isFullWidth = false,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  ...props
}) => {
  const sizeClasses2 = {
    xs: "px-1.5 py-0.5 text-xs",
    sm: "px-2.5 py-0.5 text-xs",
    md: "px-3 py-1 text-sm",
    lg: "px-4 py-1.5 text-base",
    xl: "px-5 py-2 text-lg",
    "2xl": "px-6 py-2.5 text-xl"
  };
  const getVariantStyles2 = () => {
    const baseStyles = {
      default: "bg-bg-tertiary text-text-primary border-bg-tertiary dark:bg-dark-bg-tertiary dark:text-dark-text-primary dark:border-dark-bg-tertiary",
      primary: "bg-brand-orange text-white border-brand-orange dark:bg-brand-orange dark:text-white dark:border-brand-orange",
      secondary: "bg-brand-navy/10 text-brand-navy border-brand-navy/20 dark:bg-dark-brand-navy/10 dark:text-dark-brand-navy dark:border-dark-brand-navy/20",
      info: "bg-system-info text-white border-system-info dark:bg-system-info-dark-bg dark:text-system-info-light-text dark:border-system-info",
      success: "bg-system-success text-white border-system-success dark:bg-system-success-dark-bg dark:text-system-success-light-text dark:border-system-success",
      warning: "bg-system-warning-light text-system-warning-dark border border-system-warning-border dark:bg-system-warning-dark-bg dark:text-system-warning-light-text dark:border-system-warning",
      error: "bg-system-error text-white border-system-error dark:bg-system-error-dark-bg dark:text-system-error-light-text dark:border-system-error",
      outline: "bg-transparent border border-brand-navy text-brand-navy dark:border-dark-brand-orange dark:text-dark-brand-orange",
      ghost: "bg-transparent text-text-secondary dark:text-dark-text-secondary",
      filled: "bg-brand-navy text-white border-brand-navy dark:bg-dark-brand-navy dark:text-white dark:border-dark-brand-navy"
    };
    const hoverStyles = {
      default: "hover:bg-bg-secondary dark:hover:bg-dark-bg-secondary",
      primary: "hover:bg-brand-orange-hover dark:hover:bg-brand-orange-hover",
      secondary: "hover:bg-brand-navy/20 dark:hover:bg-dark-brand-navy/20",
      info: "hover:bg-system-info-dark dark:hover:bg-system-info",
      success: "hover:bg-system-success-dark dark:hover:bg-system-success",
      warning: "hover:bg-system-warning-border/40 dark:hover:bg-system-warning",
      error: "hover:bg-system-error-dark dark:hover:bg-system-error",
      outline: "hover:bg-brand-navy hover:text-white dark:hover:bg-dark-brand-orange dark:hover:text-white",
      ghost: "hover:bg-bg-tertiary hover:text-text-primary dark:hover:bg-dark-bg-tertiary dark:hover:text-dark-text-primary",
      filled: "hover:bg-brand-navy-hover dark:hover:bg-dark-brand-navy-hover"
    };
    if (isInteractive || isDismissible || onClick) {
      return `${baseStyles[variant]} ${hoverStyles[variant]}`;
    }
    return baseStyles[variant];
  };
  const colorClasses2 = {
    primary: "",
    success: "",
    warning: "",
    danger: "",
    info: "",
    neutral: ""
  };
  const getRadiusClass2 = () => {
    if (isRounded === false) return "rounded-none";
    switch (radius) {
      case "none":
        return "rounded-none";
      case "sm":
        return "rounded-sm";
      case "md":
        return "rounded";
      case "lg":
        return "rounded-lg";
      case "xl":
        return "rounded-xl";
      case "full":
        return "rounded-full";
      default:
        return "rounded-full";
    }
  };
  const baseClasses = `inline-flex items-center font-bold transition-all duration-200`;
  const sizeClass = sizeClasses2[size2];
  const variantClass = getVariantStyles2();
  const borderClass = isBordered ? "" : "border-0";
  const roundedClass = getRadiusClass2();
  const shadowClass = hasShadow ? "shadow-sm" : "";
  const interactiveClass = isInteractive ? "cursor-pointer hover:scale-105 active:scale-95" : "";
  const pulsingClass = isPulsing ? "animate-pulse" : "";
  const loadingClass = "";
  const widthClass = isFullWidth ? "w-full justify-center" : "";
  const transparentClass = isTransparent ? "bg-transparent" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-brand-orange to-brand-orange-hover" : "";
  const customColorClass = customColor ? `bg-[${customColor}]` : "";
  const combinedClasses = [
    baseClasses,
    sizeClass,
    variantClass,
    colorClasses2[color2],
    borderClass,
    roundedClass,
    shadowClass,
    interactiveClass,
    pulsingClass,
    loadingClass,
    widthClass,
    transparentClass,
    gradientClass,
    customColorClass,
    containerClassName,
    className
  ].filter(Boolean).join(" ");
  const handleDismiss = (e2) => {
    e2.stopPropagation();
    onDismiss?.();
  };
  const focusRingClass = isInteractive ? "outline-none focus-visible:ring-2 focus-visible:ring-brand-orange focus-visible:ring-offset-2 dark:focus-visible:ring-dark-brand-orange" : "";
  const badgeContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: [combinedClasses, focusRingClass].filter(Boolean).join(" "),
      style,
      onClick: isInteractive ? onClick : void 0,
      role: isInteractive ? "button" : void 0,
      tabIndex: isInteractive ? 0 : void 0,
      onKeyDown: isInteractive ? (e2) => {
        if (e2.key === "Enter" || e2.key === " ") {
          e2.preventDefault();
          onClick?.();
        }
      } : void 0,
      ...props,
      children: [
        isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xs", className: "mr-2 animate-spin", children: "refresh" }),
        !isLoading && hasIcon && icon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-2", children: icon }),
        children,
        isDismissible && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            onClick: handleDismiss,
            className: "ml-2 p-0.5 hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary rounded-full transition-colors outline-none focus-visible:ring-2 focus-visible:ring-current focus-visible:ring-offset-1",
            "aria-label": "Dismiss badge",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xs", children: "close" })
          }
        )
      ]
    }
  );
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative inline-block", children: [
      badgeContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-brand-navy dark:bg-dark-brand-navy rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-brand-navy dark:border-t-dark-brand-navy" })
      ] })
    ] });
  }
  return badgeContent;
};
const Accordion = ({
  title,
  children,
  containerClassName = "",
  headerClassName = "",
  contentClassName = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  isOpenByDefault = false,
  isBordered = true,
  isRounded = true,
  hasShadow = false,
  isDisabled = false,
  hasIcon = true,
  isAnimated = true,
  isFullWidth = true,
  isLoading = false,
  customIcon,
  hasTooltip = false,
  tooltipText,
  badge,
  onToggle,
  ...props
}) => {
  const [isOpen, setIsOpen] = React__default.useState(isOpenByDefault);
  const sizeClasses2 = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-base",
    lg: "text-lg",
    xl: "text-xl"
  };
  const variantClasses2 = {
    // Default: soft panel, no border — FAQ / low-emphasis (Material, Apple HIG)
    default: "bg-bg-tertiary dark:bg-dark-bg-primary rounded-lg shadow-none border-0",
    // Minimal: no container chrome — transparent, divider only (minimal FAQ)
    minimal: "bg-transparent dark:bg-transparent shadow-none border-0 rounded-none",
    // Bordered: classic 1px frame + light fill (Bootstrap, Semantic)
    bordered: "bg-bg-secondary dark:bg-dark-bg-tertiary border border-border-color dark:border-dark-border-color rounded-lg shadow-none",
    // Outlined: strong 2px frame, transparent fill (high emphasis)
    outlined: "bg-transparent dark:bg-transparent border-2 border-border-color dark:border-dark-border-color rounded-lg shadow-none",
    // Elevated: card with shadow, no border (Material card)
    elevated: "bg-white dark:bg-dark-bg-primary rounded-lg shadow-md dark:shadow-lg border-0",
    // Filled: solid panel, subtle border (emphasized block)
    filled: "bg-bg-secondary dark:bg-dark-bg-tertiary rounded-lg shadow-none border border-border-color/60 dark:border-dark-border-color/60"
  };
  const colorClasses2 = {
    primary: "",
    success: "border-system-success dark:border-system-success",
    warning: "border-system-warning dark:border-system-warning",
    danger: "border-system-error dark:border-system-error",
    info: "border-system-info dark:border-system-info"
  };
  const needsExtraBorder = variant === "default" && isBordered && color2 !== "primary";
  const extraBorderClass = needsExtraBorder ? "border border-border-color dark:border-dark-border-color" : "";
  const handleToggle = () => {
    if (!isDisabled) {
      const newState = !isOpen;
      setIsOpen(newState);
      onToggle?.(newState);
    }
  };
  const baseClasses = "group";
  const roundedOverride = !isRounded ? "rounded-none" : "";
  const shadowClass = hasShadow && variant !== "elevated" ? "shadow-md" : "";
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const disabledClass = isDisabled ? "opacity-50 cursor-not-allowed" : "cursor-pointer";
  const animatedClass = isAnimated ? "transition-all duration-300" : "";
  const containerClasses = [
    baseClasses,
    sizeClasses2[size2],
    variantClasses2[variant],
    colorClasses2[color2],
    extraBorderClass,
    roundedOverride,
    shadowClass,
    widthClass,
    disabledClass,
    animatedClass,
    containerClassName
  ].filter(Boolean).join(" ");
  const headerVariantClasses = {
    default: "",
    minimal: "border-b border-border-color/70 dark:border-dark-border-subtle",
    bordered: "bg-bg-tertiary/50 dark:bg-dark-bg-primary/50",
    outlined: "",
    elevated: "bg-gray-50/80 dark:bg-dark-bg-tertiary/80",
    filled: "bg-bg-tertiary/60 dark:bg-dark-bg-primary/60"
  };
  const contentBorderClass = variant === "minimal" ? "border-t border-border-color/70 dark:border-dark-border-subtle" : "border-t border-border-color dark:border-dark-border-color";
  const accordionContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, style, ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `flex items-center justify-between p-4 list-none outline-none focus-visible:ring-2 focus-visible:ring-brand-orange focus-visible:ring-offset-2 dark:focus-visible:ring-dark-brand-orange rounded ${headerVariantClasses[variant]} ${headerClassName}`,
        onClick: handleToggle,
        role: "button",
        tabIndex: isDisabled ? -1 : 0,
        onKeyDown: (e2) => {
          if (e2.key === "Enter" || e2.key === " ") {
            e2.preventDefault();
            handleToggle();
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2 flex-1 min-w-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-text-primary dark:text-dark-text-primary", children: title }),
            badge != null && (typeof badge === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { size: "sm", variant: "default", color: "primary", children: badge }) : badge)
          ] }),
          isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) : hasIcon && (customIcon || /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `transition-transform duration-300 ${isOpen ? "-rotate-180" : ""}`, children: "expand_more" }))
        ]
      }
    ),
    isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `prose prose-sm dark:prose-invert max-w-none p-4 pt-4 text-text-secondary dark:text-dark-text-secondary ${contentBorderClass} ${contentClassName}`, children })
  ] });
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      accordionContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return accordionContent;
};
const Alert = ({
  title,
  description,
  children,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "info",
  color: color2 = "primary",
  isDismissible = false,
  isBordered = true,
  isRounded = true,
  hasShadow = false,
  hasIcon = true,
  customIcon,
  hasCloseButton = true,
  onDismiss,
  isLoading = false,
  isPulsing = false,
  isFullWidth = true,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  isAnimated = true,
  hasDismissTimeout = false,
  dismissTimeout = 5e3,
  hasProgressBar = false,
  hasSound = false,
  isPersistent = false,
  ...props
}) => {
  const [isOpen, setIsOpen] = useState(true);
  const [progress2, setProgress] = useState(100);
  const sizeClasses2 = {
    xs: "text-xs p-3",
    sm: "text-sm p-3",
    md: "text-base p-4",
    lg: "text-lg p-5",
    xl: "text-xl p-6"
  };
  const iconSizeMap = {
    xs: "sm",
    sm: "md",
    md: "lg",
    lg: "xl",
    xl: "2xl"
  };
  const colorClasses2 = {
    success: "bg-system-success-light border border-system-success dark:bg-system-success-dark-bg dark:border-system-success",
    warning: "bg-system-warning-light border border-system-warning-border dark:bg-system-warning-dark-bg dark:border-system-warning",
    danger: "bg-system-error-light border border-system-error dark:bg-system-error-dark-bg dark:border-system-error",
    info: "bg-system-info-light border border-system-info dark:bg-system-info-dark-bg dark:border-system-info"
  };
  React__default.useEffect(() => {
    if (hasDismissTimeout && !isPersistent && dismissTimeout > 0) {
      const timer = setInterval(() => {
        setProgress((prev) => {
          if (prev <= 0) {
            setIsOpen(false);
            onDismiss?.();
            return 0;
          }
          return prev - 100 / (dismissTimeout / 100);
        });
      }, 100);
      return () => clearInterval(timer);
    }
  }, [hasDismissTimeout, dismissTimeout, isPersistent, onDismiss]);
  React__default.useEffect(() => {
  }, [hasSound, isOpen]);
  if (!isOpen) return null;
  const content = description || children;
  const variantConfig = {
    info: {
      icon: "info",
      containerClasses: colorClasses2.info,
      textClasses: "text-system-info-dark dark:text-system-info-light-text",
      titleClasses: "text-system-info-dark dark:text-system-info-light-text font-bold"
    },
    success: {
      icon: "check_circle",
      containerClasses: colorClasses2.success,
      textClasses: "text-system-success-dark dark:text-system-success-light-text",
      titleClasses: "text-system-success-dark dark:text-system-success-light-text font-bold"
    },
    warning: {
      icon: "warning",
      containerClasses: colorClasses2.warning,
      textClasses: "text-system-warning-dark dark:text-system-warning-light-text",
      titleClasses: "text-system-warning-dark dark:text-system-warning-light-text font-bold"
    },
    error: {
      icon: "error",
      containerClasses: colorClasses2.danger,
      textClasses: "text-system-error-dark dark:text-system-error-light-text",
      titleClasses: "text-system-error-dark dark:text-system-error-light-text font-bold"
    }
  };
  const validVariant = variantConfig[variant] ? variant : "info";
  const styles = variantConfig[validVariant] || variantConfig.info;
  if (!styles) {
    console.warn(`Alert: Invalid variant "${variant}" provided, falling back to "info"`);
    return null;
  }
  const baseClasses = `flex items-center gap-4 transition-all duration-300`;
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const borderClass = isBordered ? "" : "border-0";
  const roundedClass = isRounded ? "rounded-lg" : "rounded-none";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const animatedClass = isAnimated ? "animate-in slide-in-from-top-2" : "";
  const pulsingClass = isPulsing ? "animate-pulse" : "";
  const transparentClass = isTransparent ? "bg-transparent" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-blue-500 to-purple-500" : "";
  const customColorClass = customColor ? `bg-[${customColor}]` : "";
  const combinedClasses = [
    baseClasses,
    sizeClasses2[size2],
    widthClass,
    styles.containerClasses,
    borderClass,
    roundedClass,
    shadowClass,
    animatedClass,
    pulsingClass,
    transparentClass,
    gradientClass,
    customColorClass,
    containerClassName,
    className
  ].filter(Boolean).join(" ");
  const handleDismiss = () => {
    if (!isPersistent) {
      setIsOpen(false);
      onDismiss?.();
    }
  };
  const alertContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: combinedClasses, style, role: "alert", ...props, children: [
    hasIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center shrink-0", children: customIcon || /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: iconSizeMap[size2], className: styles.textClasses, children: styles.icon }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: styles.titleClasses, children: title }),
      content && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `text-sm mt-1 ${styles.textClasses}`, children: content })
    ] }),
    isDismissible && hasCloseButton && !isPersistent && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: handleDismiss,
        "aria-label": "Dismiss alert",
        className: "flex items-center justify-center rounded-full hover:bg-black/10 dark:hover:bg-white/10 transition-colors shrink-0 w-8 h-8",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: iconSizeMap[size2], className: `${styles.textClasses} !leading-none !m-0`, children: "close" })
      }
    )
  ] });
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      alertContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
    alertContent,
    hasProgressBar && hasDismissTimeout && !isPersistent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-0 left-0 w-full h-1 bg-gray-200 rounded-b-lg overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "h-full bg-current transition-all duration-100",
        style: { width: `${progress2}%` }
      }
    ) })
  ] });
};
const Input = ({
  label,
  id: id2,
  error: error2,
  className = "",
  containerClassName = "",
  labelClassName = "",
  inputClassName = "",
  disabled = false,
  required = false,
  loading = false,
  fullWidth = false,
  width,
  minWidth,
  maxWidth,
  isSuccess = false,
  isWarning = false,
  hasBackground = true,
  hasBorder = true,
  hasFocusRing = true,
  hasRoundedCorners = true,
  hasShadow = false,
  showLabel = true,
  labelMode = "top",
  align = "left",
  radius = "md",
  showHelperText = true,
  showErrorText = true,
  showRequiredIndicator = true,
  helperText,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  leftIcon,
  rightIcon,
  showCharacterCount = false,
  maxCharacters,
  isReadOnly = false,
  hasAutoComplete = true,
  hasSpellCheck = true,
  ariaLabel,
  ariaDescribedBy,
  ariaInvalid,
  validate,
  validateOnBlur = false,
  validateOnChange = false,
  validationDebounceMs = 300,
  ...props
}) => {
  const baseClasses = "focus:outline-none";
  const sizeClasses2 = {
    xs: "h-8 text-xs px-2",
    sm: "h-10 text-sm px-3",
    md: "h-12 text-base px-4",
    lg: "h-14 text-lg px-5",
    xl: "h-16 text-xl px-6"
  };
  const variantClasses2 = {
    primary: "bg-bg-secondary dark:bg-dark-bg-secondary text-text-primary dark:text-dark-text-primary",
    secondary: "bg-bg-tertiary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary",
    outline: "bg-transparent border-2 text-text-primary dark:text-dark-text-primary",
    ghost: "bg-transparent text-text-primary dark:text-dark-text-primary",
    filled: "bg-bg-primary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary"
  };
  const focusBorderByColor = {
    primary: "focus:border-brand-navy dark:focus:border-dark-brand-orange",
    success: "focus:border-system-success dark:focus:border-system-success",
    warning: "focus:border-system-warning-dark dark:focus:border-system-warning",
    danger: "focus:border-system-error dark:focus:border-system-error",
    info: "focus:border-system-info dark:focus:border-system-info"
  };
  const focusRingByColor = {
    primary: "focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    success: "focus:ring-system-success dark:focus:ring-system-success",
    warning: "focus:ring-system-warning dark:focus:ring-system-warning",
    danger: "focus:ring-system-error dark:focus:ring-system-error",
    info: "focus:ring-system-info dark:focus:ring-system-info"
  };
  const stateClasses = {
    default: hasBorder ? "border-border-color dark:border-dark-border-color" : "border-transparent",
    error: "border-2 border-system-error dark:border-system-error focus:border-system-error dark:focus:border-system-error focus:ring-system-error dark:focus:ring-system-error",
    success: "border-2 border-system-success dark:border-system-success",
    warning: "border-2 border-system-warning-dark dark:border-system-warning"
  };
  const isDisabled = disabled || loading;
  const backgroundClasses = isDisabled ? "bg-gray-100 dark:bg-gray-900 text-gray-500 dark:text-gray-500 placeholder:text-gray-400 dark:placeholder:text-gray-600 placeholder:opacity-70" : hasBackground ? variantClasses2[variant] : "bg-transparent";
  const getRadiusClass2 = () => {
    switch (radius) {
      case "none":
        return "rounded-none";
      case "sm":
        return "rounded-sm";
      case "md":
        return "rounded";
      case "lg":
        return "rounded-lg";
      case "xl":
        return "rounded-xl";
      case "full":
        return "rounded-full";
      default:
        return "rounded";
    }
  };
  const roundedClasses = getRadiusClass2();
  const shadowClasses = hasShadow ? "shadow-md" : "";
  const focusClasses = `${focusBorderByColor[color2]} ${hasFocusRing ? `focus:ring-2 focus:ring-offset-2 ${focusRingByColor[color2]}` : ""}`.trim();
  const getWidthClass = () => {
    if (fullWidth) return "w-full";
    switch (width) {
      case "sm":
        return "w-sm";
      case "md":
        return "w-md";
      case "lg":
        return "w-lg";
      case "full":
        return "w-full";
      case "auto":
        return "w-auto";
      case "none":
        return "w-full";
      // 'none' behaves like default (full width)
      default:
        return "w-full";
    }
  };
  const widthClass = getWidthClass();
  const disabledClasses = isDisabled ? "cursor-not-allowed select-none pointer-events-none" : "cursor-text";
  const readOnlyClasses = isReadOnly ? "bg-gray-100 dark:bg-gray-800 cursor-default" : "";
  const isFloatingLabel = labelMode === "floating";
  const [isFocused, setIsFocused] = useState(false);
  const hasValue = props.value != null && String(props.value).trim() !== "";
  const shouldFloatLabel = isFloatingLabel && (hasValue || isFocused);
  const getStateClass = () => {
    if (error2) return stateClasses.error;
    if (isSuccess) return stateClasses.success;
    if (isWarning) return stateClasses.warning;
    if (isDisabled && hasBorder) return "border border-gray-300 dark:border-gray-700";
    if (variant === "ghost" && hasBorder) return "border border-transparent hover:border-border-color dark:hover:border-dark-border-color focus:border-border-color dark:focus:border-dark-border-color";
    return stateClasses.default;
  };
  const getPaddingValue = (size22) => {
    const sizeMap2 = { xs: 8, sm: 12, md: 16, lg: 20, xl: 24 };
    return sizeMap2[size22];
  };
  const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
  const combinedClasses = `acutrack-input ${alignmentClass} ${baseClasses} ${sizeClasses2[size2]} w-full ${backgroundClasses} ${roundedClasses} ${shadowClasses} ${focusClasses} ${getStateClass()} ${disabledClasses} ${readOnlyClasses} ${inputClassName} ${className}`;
  const errorId = error2 ? `${id2}-error` : void 0;
  const helperId = helperText ? `${id2}-helper` : void 0;
  const describedBy = [ariaDescribedBy, errorId, helperId].filter(Boolean).join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${widthClass} ${containerClassName} ${isDisabled ? "cursor-not-allowed dark:opacity-85" : ""}`, children: [
    showLabel && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: `acutrack-input-label ${alignmentClass} ${labelClassName} ${isDisabled ? "text-gray-500 dark:text-gray-500 opacity-70" : ""}`, children: [
      label,
      required && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      showLabel && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "span",
        {
          className: [
            "absolute transition-all duration-200 pointer-events-none z-10",
            leftIcon ? "left-12" : "left-3",
            "text-text-secondary dark:text-dark-text-secondary",
            shouldFloatLabel ? "-top-2.5 text-xs px-1 bg-bg-primary dark:bg-dark-bg-primary" : "top-1/2 -translate-y-1/2",
            isDisabled && "text-gray-500 dark:text-gray-500 opacity-70",
            error2 && "text-system-error-dark",
            isSuccess && "text-green-600 dark:text-green-400"
          ].filter(Boolean).join(" "),
          children: [
            label,
            required && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
          ]
        }
      ),
      leftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute left-3 top-1/2 transform -translate-y-1/2 text-text-secondary dark:text-dark-text-secondary z-0 ${isDisabled ? "opacity-60" : ""}`, children: leftIcon }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: id2,
          className: combinedClasses,
          style: {
            paddingLeft: leftIcon ? `${getPaddingValue(size2) + 24}px` : void 0,
            paddingRight: rightIcon || loading ? `${getPaddingValue(size2) + 24}px` : void 0,
            ...minWidth && { minWidth },
            ...maxWidth && { maxWidth }
          },
          disabled: isDisabled,
          required,
          readOnly: isReadOnly,
          autoComplete: hasAutoComplete ? "on" : "off",
          spellCheck: hasSpellCheck,
          maxLength: maxCharacters,
          "aria-label": ariaLabel,
          "aria-describedby": describedBy || void 0,
          "aria-invalid": ariaInvalid || !!error2,
          "aria-required": required,
          placeholder: isFloatingLabel ? void 0 : props.placeholder,
          onFocus: (e2) => {
            setIsFocused(true);
            props.onFocus?.(e2);
          },
          onBlur: (e2) => {
            setIsFocused(false);
            props.onBlur?.(e2);
          },
          ...(() => {
            const { isSuccess: isSuccess2, isWarning: isWarning2, loading: loading2, placeholder: _p, onFocus, onBlur, ...restProps } = props;
            return restProps;
          })()
        }
      ),
      loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-3 top-1/2 transform -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) }),
      rightIcon && !loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute right-3 top-1/2 transform -translate-y-1/2 text-text-secondary dark:text-dark-text-secondary ${isDisabled ? "opacity-60" : ""}`, children: rightIcon })
    ] }),
    showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { id: errorId, className: "text-sm text-system-error mt-1", role: "alert", "aria-live": "polite", children: error2 }),
    showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { id: helperId, className: `text-sm mt-1 ${isDisabled ? "text-gray-500 dark:text-gray-500 opacity-70" : "text-text-secondary dark:text-dark-text-secondary"}`, children: helperText }),
    showCharacterCount && maxCharacters && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-text-secondary dark:text-dark-text-secondary mt-1 text-right", children: [
      props.value?.toString().length || 0,
      "/",
      maxCharacters
    ] })
  ] });
};
const Autocomplete = ({
  label,
  id: id2,
  options,
  value,
  onChange,
  containerClassName = "",
  inputClassName = "",
  dropdownClassName = "",
  placeholder = "Type to search...",
  isDisabled = false,
  isRequired = false,
  isLoading = false,
  isFullWidth = false,
  width,
  minWidth,
  maxWidth,
  hasBackground = true,
  hasBorder = true,
  hasFocusRing = true,
  hasRoundedCorners = true,
  hasShadow = false,
  showLabel = true,
  showHelperText = true,
  showErrorText = true,
  showRequiredIndicator = true,
  showDescription = false,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  hasFiltering = true,
  hasHighlighting = true,
  showDescriptions = false,
  showIcons = false,
  showClearButton = true,
  showLoadingSpinner = true,
  showNoResultsMessage = true,
  showCreateOption = false,
  showSearchIcon = false,
  showDropdownArrow = true,
  closeOnSelection = true,
  closeOnBlur = true,
  closeOnEscape = true,
  isCaseSensitive = false,
  matchFromStart = false,
  matchWholeWords = false,
  useFuzzySearch = false,
  maxOptions = 10,
  minCharsToFilter = 1,
  filterDebounceMs = 300,
  helperText,
  error: error2,
  description,
  noResultsMessage = "No results found",
  createOptionText = 'Create "{query}"',
  onCreateOption,
  onDropdownOpen,
  onDropdownClose,
  onFilter,
  position = "bottom-start",
  align = "left",
  radius = "md",
  style,
  maxDropdownHeight = "15rem",
  itemLineHeight,
  ...props
}) => {
  const [inputValue, setInputValue] = useState(() => options.find((opt) => opt.value === value)?.label || "");
  const [filteredOptions, setFilteredOptions] = useState([]);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState(-1);
  const wrapperRef = useRef(null);
  const inputRef = useRef(null);
  const getPositionClasses = (pos) => {
    const positionClasses = {
      "top": "bottom-full left-1/2 -translate-x-1/2 mb-2 origin-bottom",
      "top-start": "bottom-full left-0 mb-2 origin-bottom-left",
      "top-end": "bottom-full right-0 mb-2 origin-bottom-right",
      "bottom": "top-full left-1/2 -translate-x-1/2 mt-1 origin-top",
      "bottom-start": "top-full left-0 mt-1 origin-top-left",
      "bottom-end": "top-full right-0 mt-1 origin-top-right",
      "left": "right-full top-1/2 -translate-y-1/2 mr-2 origin-right",
      "left-start": "right-full top-0 mr-2 origin-top-right",
      "left-end": "right-full bottom-0 mr-2 origin-bottom-right",
      "right": "left-full top-1/2 -translate-y-1/2 ml-2 origin-left",
      "right-start": "left-full top-0 ml-2 origin-top-left",
      "right-end": "left-full bottom-0 ml-2 origin-bottom-left"
    };
    return positionClasses[pos] || positionClasses["bottom-start"];
  };
  const getRadiusClass2 = () => {
    switch (radius) {
      case "none":
        return "rounded-none";
      case "sm":
        return "rounded-sm";
      case "md":
        return "rounded";
      case "lg":
        return "rounded-lg";
      case "xl":
        return "rounded-xl";
      case "full":
        return "rounded-full";
      default:
        return "rounded";
    }
  };
  const handleSelect = (option) => {
    setInputValue(option.label);
    onChange(option.value);
    if (closeOnSelection) {
      setIsDropdownOpen(false);
      setFilteredOptions([]);
    }
    onDropdownClose?.();
  };
  const handleChange = (e2) => {
    const query = e2.target.value;
    setInputValue(query);
    if (query && query.length >= minCharsToFilter) {
      let filtered = options;
      if (hasFiltering) {
        if (onFilter) {
          filtered = onFilter(query, options);
        } else {
          filtered = options.filter((opt) => {
            const label2 = opt.label.toLowerCase();
            const searchQuery = isCaseSensitive ? query : query.toLowerCase();
            if (matchWholeWords) {
              return label2.split(" ").some((word) => word === searchQuery);
            } else if (matchFromStart) {
              return label2.startsWith(searchQuery);
            } else {
              return label2.includes(searchQuery);
            }
          });
        }
      }
      setFilteredOptions(filtered.slice(0, maxOptions));
      setIsDropdownOpen(true);
      onDropdownOpen?.();
    } else {
      setFilteredOptions([]);
      setIsDropdownOpen(false);
      onChange("");
    }
  };
  const handleClear = () => {
    setInputValue("");
    onChange("");
    setFilteredOptions([]);
    setIsDropdownOpen(false);
    inputRef.current?.focus();
  };
  const handleKeyDown = (e2) => {
    if (e2.key === "ArrowDown") {
      e2.preventDefault();
      setHighlightedIndex(
        (prev) => prev < filteredOptions.length - 1 ? prev + 1 : prev
      );
    } else if (e2.key === "ArrowUp") {
      e2.preventDefault();
      setHighlightedIndex((prev) => prev > 0 ? prev - 1 : -1);
    } else if (e2.key === "Enter") {
      e2.preventDefault();
      if (highlightedIndex >= 0 && filteredOptions[highlightedIndex]) {
        handleSelect(filteredOptions[highlightedIndex]);
      } else if (showCreateOption && inputValue && !filteredOptions.find((opt) => opt.label === inputValue)) {
        onCreateOption?.(inputValue);
      }
    } else if (e2.key === "Escape" && closeOnEscape) {
      setIsDropdownOpen(false);
      setFilteredOptions([]);
    }
  };
  const handleCreateOption = () => {
    if (onCreateOption && inputValue) {
      onCreateOption(inputValue);
      setIsDropdownOpen(false);
      setFilteredOptions([]);
    }
  };
  useOnClickOutside(wrapperRef, () => {
    if (closeOnBlur) {
      setIsDropdownOpen(false);
      setFilteredOptions([]);
      onDropdownClose?.();
    }
  });
  useEffect(() => {
    setInputValue(options.find((opt) => opt.value === value)?.label || "");
  }, [value, options]);
  const getWidthClass = () => {
    if (isFullWidth) return "w-full";
    switch (width) {
      case "sm":
        return "w-sm";
      case "md":
        return "w-md";
      case "lg":
        return "w-lg";
      case "full":
        return "w-full";
      case "auto":
        return "w-auto";
      case "none":
        return "w-full";
      // 'none' behaves like default (full width)
      default:
        return "w-full";
    }
  };
  const getMinWidthClass = () => {
    if (minWidth) return "";
    return "min-w-24";
  };
  const getMaxWidthClass = () => {
    if (maxWidth) return "";
    return "max-w-full";
  };
  const widthClass = getWidthClass();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `relative ${widthClass} ${getMinWidthClass()} ${getMaxWidthClass()} ${containerClassName}`,
      ref: wrapperRef,
      style: {
        ...minWidth && { minWidth },
        ...maxWidth && { maxWidth },
        ...style
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            id: id2,
            label,
            value: inputValue,
            onChange: handleChange,
            onKeyDown: handleKeyDown,
            placeholder,
            disabled: isDisabled,
            required: isRequired,
            loading: isLoading,
            fullWidth: isFullWidth,
            width,
            minWidth,
            maxWidth,
            hasBackground,
            hasBorder,
            hasFocusRing,
            radius,
            hasShadow,
            showLabel,
            showHelperText,
            showErrorText,
            showRequiredIndicator,
            size: size2,
            variant,
            color: color2,
            align,
            helperText,
            error: error2,
            rightIcon: showClearButton && inputValue ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: handleClear,
                className: "p-1 rounded-full",
                "aria-label": "Clear input",
                children: "×"
              }
            ) : showDropdownArrow ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-text-secondary dark:text-dark-text-secondary data-[state=open]:-rotate-180", children: "unfold_more" }) : void 0,
            className: inputClassName,
            ...props
          }
        ),
        isDropdownOpen && filteredOptions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `absolute z-[9999] w-full bg-bg-secondary dark:bg-dark-bg-secondary border border-border-color dark:border-dark-border-color ${getRadiusClass2()} shadow-lg overflow-y-auto custom-scrollbar ${getPositionClasses(position)} ${dropdownClassName}`,
            style: {
              maxHeight: typeof maxDropdownHeight === "string" ? maxDropdownHeight : `${maxDropdownHeight}px`
            },
            children: [
              filteredOptions.map((option, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handleSelect(option),
                  className: `w-full text-left px-4 text-sm text-text-secondary dark:text-dark-text-secondary hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary hover:text-text-primary dark:hover:text-dark-text-primary transition-colors ${index2 === highlightedIndex ? "bg-bg-tertiary dark:bg-dark-bg-tertiary" : ""}`,
                  style: itemLineHeight !== void 0 ? {
                    paddingTop: typeof itemLineHeight === "string" ? parseInt(itemLineHeight) < 20 ? "0.25rem" : "0.375rem" : itemLineHeight < 1.5 ? "0.25rem" : "0.375rem",
                    paddingBottom: typeof itemLineHeight === "string" ? parseInt(itemLineHeight) < 20 ? "0.25rem" : "0.375rem" : itemLineHeight < 1.5 ? "0.25rem" : "0.375rem"
                  } : {
                    paddingTop: "0.625rem",
                    paddingBottom: "0.625rem"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
                    showIcons && option.icon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-shrink-0", children: option.icon }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2 items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: itemLineHeight !== void 0 ? {
                        lineHeight: typeof itemLineHeight === "string" ? itemLineHeight : itemLineHeight < 10 && itemLineHeight > 0.1 ? itemLineHeight : `${itemLineHeight}px`
                      } : void 0, children: option.label }) }),
                      showDescriptions && option.description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-text-secondary dark:text-dark-text-secondary mt-1", children: option.description })
                    ] })
                  ] })
                },
                option.value
              )),
              showCreateOption && inputValue && !filteredOptions.find((opt) => opt.label === inputValue) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleCreateOption,
                  className: "w-full text-left px-4 text-sm text-brand-orange border-t border-border-color dark:border-dark-border-color hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary transition-colors",
                  style: itemLineHeight !== void 0 ? {
                    paddingTop: typeof itemLineHeight === "string" ? parseInt(itemLineHeight) < 20 ? "0.25rem" : "0.375rem" : itemLineHeight < 1.5 ? "0.25rem" : "0.375rem",
                    paddingBottom: typeof itemLineHeight === "string" ? parseInt(itemLineHeight) < 20 ? "0.25rem" : "0.375rem" : itemLineHeight < 1.5 ? "0.25rem" : "0.375rem"
                  } : {
                    paddingTop: "0.625rem",
                    paddingBottom: "0.625rem"
                  },
                  children: createOptionText.replace("{query}", inputValue)
                }
              )
            ]
          }
        ),
        isDropdownOpen && filteredOptions.length === 0 && inputValue && showNoResultsMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute z-[9999] w-full bg-bg-secondary dark:bg-dark-bg-secondary border border-border-color dark:border-dark-border-color ${getRadiusClass2()} shadow-lg px-4 py-3 text-sm text-text-secondary dark:text-dark-text-secondary ${getPositionClasses(position)}`, children: noResultsMessage })
      ]
    }
  );
};
const Avatar = ({
  src,
  name,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  status,
  // State Props
  disabled = false,
  loading = false,
  isInteractive = false,
  isPulsing = false,
  // Feature Props
  hasBorder = false,
  isRounded = true,
  hasShadow = false,
  hasFallbackIcon = false,
  hasTooltip = false,
  hasStatusIndicator = true,
  hasGradient = false,
  hasRing = false,
  hasBadge = false,
  hasHoverEffect = false,
  // Content Props
  fallbackIcon,
  tooltipText,
  customColor,
  ringColor,
  badgeContent,
  // Event Handlers
  onClick,
  ...props
}) => {
  const getInitials = (name2) => {
    const parts = name2.split(" ").filter(Boolean);
    if (parts.length === 0) return "?";
    const first = parts[0][0];
    const last = parts.length > 1 ? parts[parts.length - 1][0] : "";
    return `${first}${last}`.toUpperCase();
  };
  const sizeClasses2 = {
    xs: "h-6 w-6 text-xs",
    sm: "h-8 w-8 text-sm",
    md: "h-10 w-10 text-base",
    lg: "h-12 w-12 text-lg",
    xl: "h-16 w-16 text-xl",
    "2xl": "h-20 w-20 text-2xl"
  };
  const variantClasses2 = {
    default: "",
    circular: "rounded-full",
    rounded: "rounded-lg",
    square: "rounded-none"
  };
  const colorClasses2 = {
    primary: "bg-primary-500 text-white",
    success: "bg-success-500 text-white",
    warning: "bg-warning-500 text-white",
    danger: "bg-danger-500 text-white",
    info: "bg-info-500 text-white",
    neutral: "bg-gray-500 text-white"
  };
  const statusSizeClasses = {
    xs: "h-1.5 w-1.5",
    sm: "h-2 w-2",
    md: "h-2.5 w-2.5",
    lg: "h-3 w-3",
    xl: "h-4 w-4",
    "2xl": "h-5 w-5"
  };
  const statusConfig = {
    online: "bg-system-success",
    away: "bg-system-warning",
    offline: "bg-text-secondary/50",
    busy: "bg-system-error",
    invisible: "bg-gray-400"
  };
  const baseClasses = "relative inline-block shrink-0";
  const sizeClass = sizeClasses2[size2];
  const variantClass = variantClasses2[variant];
  const colorClass = colorClasses2[color2];
  const borderClass = hasBorder ? "border-2 border-border-color dark:border-dark-border-color" : "";
  const roundedClass = isRounded ? "rounded-full" : "rounded-none";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const interactiveClass = isInteractive && !disabled ? "cursor-pointer" : "";
  const loadingClass = loading ? "animate-pulse" : "";
  const pulsingClass = isPulsing ? "animate-pulse" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-brand-orange to-brand-orange-hover" : "";
  const customColorClass = customColor ? `bg-[${customColor}]` : "";
  const ringClass = hasRing ? `ring-2 ${ringColor ? `ring-${ringColor}` : "ring-brand-orange"}` : "";
  const hoverClass = hasHoverEffect && !disabled ? "hover:scale-105 transition-transform duration-200" : "";
  const disabledClass = disabled ? "opacity-50 cursor-not-allowed" : "";
  const combinedClasses = [
    baseClasses,
    sizeClass,
    variantClass,
    colorClass,
    borderClass,
    roundedClass,
    shadowClass,
    interactiveClass,
    loadingClass,
    pulsingClass,
    gradientClass,
    customColorClass,
    ringClass,
    hoverClass,
    disabledClass,
    className
  ].filter(Boolean).join(" ");
  const focusRingClass = onClick && !disabled ? "outline-none focus-visible:ring-2 focus-visible:ring-brand-orange focus-visible:ring-offset-2 dark:focus-visible:ring-dark-brand-orange" : "";
  const avatarContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: [combinedClasses, focusRingClass].filter(Boolean).join(" "),
      style,
      onClick: !disabled ? onClick : void 0,
      role: onClick && !disabled ? "button" : void 0,
      tabIndex: onClick && !disabled ? 0 : void 0,
      onKeyDown: onClick && !disabled ? (e2) => {
        if (e2.key === "Enter" || e2.key === " ") {
          e2.preventDefault();
          onClick?.(e2);
        }
      } : void 0,
      "aria-label": onClick && !disabled && typeof name === "string" ? name : void 0,
      ...props,
      children: [
        loading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full w-full rounded-full bg-bg-tertiary dark:bg-dark-bg-tertiary flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) }) : src ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src, alt: name, className: "h-full w-full rounded-full object-cover" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `h-full w-full rounded-full ${hasGradient ? "bg-gradient-to-r from-brand-orange to-brand-orange-hover" : customColor || "bg-brand-navy"} flex items-center justify-center font-bold text-white`, children: hasFallbackIcon && fallbackIcon ? fallbackIcon : getInitials(name) }),
        hasBadge && badgeContent && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute -top-1 -right-1 h-5 w-5 flex items-center justify-center rounded-full bg-brand-orange text-white text-xs font-bold", children: badgeContent }),
        status && hasStatusIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `absolute bottom-0 right-0 block rounded-full ring-2 ring-bg-secondary dark:ring-dark-bg-secondary ${statusSizeClasses[size2]} ${statusConfig[status]}` })
      ]
    }
  );
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `group relative ${containerClassName}`, children: [
      avatarContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClassName, children: avatarContent });
};
const Banner = ({
  children,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "info",
  color: color2 = "primary",
  onDismiss,
  actions,
  isDismissible = true,
  isBordered = true,
  isRounded = true,
  hasShadow = false,
  hasIcon = true,
  hasCloseButton = true,
  isLoading = false,
  isPulsing = false,
  isFullWidth = true,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  isAnimated = true,
  hasDismissTimeout = false,
  dismissTimeout = 5e3,
  hasProgressBar = false,
  hasSound = false,
  isPersistent = false,
  hasTitle = false,
  title,
  hasDescription = false,
  description,
  ...props
}) => {
  const [isOpen, setIsOpen] = useState(true);
  const [progress2, setProgress] = useState(100);
  const sizeClasses2 = {
    xs: "text-xs p-2",
    sm: "text-sm p-3",
    md: "text-base p-4",
    lg: "text-lg p-5",
    xl: "text-xl p-6"
  };
  const colorClasses2 = {
    primary: "bg-blue-100 text-blue-800 border border-blue-200 dark:bg-blue-900/40 dark:text-blue-200 dark:border-blue-800/40",
    success: "bg-green-100 text-green-800 border border-green-200 dark:bg-green-900/40 dark:text-green-200 dark:border-green-800/40",
    warning: "bg-amber-100 text-amber-800 border border-amber-200 dark:bg-amber-900/40 dark:text-amber-200 dark:border-amber-800/40",
    danger: "bg-red-100 text-red-800 border border-red-200 dark:bg-red-900/40 dark:text-red-200 dark:border-red-800/40",
    info: "bg-blue-100 text-blue-800 border border-blue-200 dark:bg-blue-900/40 dark:text-blue-200 dark:border-blue-800/40"
  };
  React__default.useEffect(() => {
    if (hasDismissTimeout && !isPersistent && dismissTimeout > 0) {
      const timer = setInterval(() => {
        setProgress((prev) => {
          if (prev <= 0) {
            setIsOpen(false);
            onDismiss?.();
            return 0;
          }
          return prev - 100 / (dismissTimeout / 100);
        });
      }, 100);
      return () => clearInterval(timer);
    }
  }, [hasDismissTimeout, dismissTimeout, isPersistent, onDismiss]);
  React__default.useEffect(() => {
  }, [hasSound, isOpen]);
  if (!isOpen) return null;
  const handleDismiss = () => {
    if (!isPersistent) {
      if (onDismiss) {
        onDismiss();
      } else {
        setIsOpen(false);
      }
    }
  };
  const variantConfig = {
    info: {
      icon: "info",
      classes: colorClasses2[color2]
    },
    success: {
      icon: "check_circle",
      classes: colorClasses2[color2]
    },
    warning: {
      icon: "warning",
      classes: colorClasses2[color2]
    },
    error: {
      icon: "error",
      classes: colorClasses2[color2]
    }
  };
  const styles = variantConfig[variant];
  const baseClasses = "flex items-center gap-4 transition-all duration-300";
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const borderClass = isBordered ? "" : "border-0";
  const roundedClass = isRounded ? "rounded-lg" : "rounded-none";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const animatedClass = isAnimated ? "animate-in slide-in-from-top-2" : "";
  const pulsingClass = isPulsing ? "animate-pulse" : "";
  const transparentClass = isTransparent ? "bg-transparent" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-blue-500 to-purple-500" : "";
  const customColorClass = customColor ? `bg-[${customColor}]` : "";
  const combinedClasses = [
    baseClasses,
    sizeClasses2[size2],
    widthClass,
    styles.classes,
    borderClass,
    roundedClass,
    shadowClass,
    animatedClass,
    pulsingClass,
    transparentClass,
    gradientClass,
    customColorClass,
    containerClassName,
    className
  ].filter(Boolean).join(" ");
  const bannerContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: combinedClasses, style, role: "alert", ...props, children: [
    isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-6 w-6 border-2 border-current border-t-transparent shrink-0" }) : hasIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "2xl", className: "shrink-0", children: styles.icon }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-grow font-medium text-sm", children: [
      hasTitle && title && /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-bold mb-1", children: title }),
      hasDescription && description ? description : children
    ] }),
    actions && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shrink-0", children: actions }),
    isDismissible && hasCloseButton && !isPersistent && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: handleDismiss,
        "aria-label": "Dismiss banner",
        className: "-mr-1 p-1 rounded-full hover:bg-black/10 dark:hover:bg-white/10 transition-colors",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", children: "close" })
      }
    )
  ] });
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      bannerContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
    bannerContent,
    hasProgressBar && hasDismissTimeout && !isPersistent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-0 left-0 w-full h-1 bg-gray-200 rounded-b-lg overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "h-full bg-current transition-all duration-100",
        style: { width: `${progress2}%` }
      }
    ) })
  ] });
};
function cn(...inputs) {
  const classes = [];
  for (const input of inputs) {
    if (!input) continue;
    if (typeof input === "string" || typeof input === "number") {
      classes.push(String(input));
    } else if (Array.isArray(input)) {
      const nested = cn(...input);
      if (nested) classes.push(nested);
    } else if (typeof input === "object") {
      for (const [key, value] of Object.entries(input)) {
        if (value) classes.push(key);
      }
    }
  }
  return classes.join(" ");
}
const BreadcrumbContext = createContext(null);
const useBreadcrumbContext = () => {
  const context = useContext(BreadcrumbContext);
  if (!context) {
    throw new Error("Breadcrumb components must be used within a Breadcrumb component");
  }
  return context;
};
const BreadcrumbBase = ({
  children,
  size: size2 = "md",
  variant = "default",
  separator = "/",
  hasSeparator = true,
  className,
  // Legacy props
  group,
  section,
  items
}) => {
  const sizeClasses2 = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-base",
    lg: "text-lg",
    xl: "text-xl"
  };
  const variantClasses2 = {
    default: "",
    minimal: "text-text-secondary dark:text-dark-text-secondary",
    elevated: "bg-bg-secondary dark:bg-dark-bg-secondary shadow-md rounded-lg p-3",
    bordered: "border border-border-color dark:border-dark-border-color rounded-lg p-3",
    filled: "bg-bg-tertiary dark:bg-dark-bg-tertiary rounded-lg p-3"
  };
  const contextValue = {
    size: size2,
    variant,
    separator,
    hasSeparator
  };
  if (group && section) {
    const breadcrumbItems = [
      { label: group, href: "#" },
      { label: section, href: "#", isActive: true }
    ];
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "nav",
      {
        className: cn(
          "flex items-center space-x-2 font-medium tracking-wider",
          sizeClasses2[size2],
          variantClasses2[variant],
          className
        ),
        "aria-label": "Breadcrumb",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbList, { children: breadcrumbItems.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React__default.Fragment, { children: [
          index2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbSeparator, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbItem, { children: item.isActive ? /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbPage, { children: item.label }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbLink$1, { href: item.href, children: item.label }) })
        ] }, index2)) })
      }
    ) });
  }
  if (items && items.length > 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "nav",
      {
        className: cn(
          "flex items-center space-x-2 font-medium tracking-wider",
          sizeClasses2[size2],
          variantClasses2[variant],
          className
        ),
        "aria-label": "Breadcrumb",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbList, { children: items.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React__default.Fragment, { children: [
          index2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbSeparator, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(BreadcrumbItem, { children: [
            item.icon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-2", children: item.icon }),
            item.isActive ? /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbPage, { children: item.label }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbLink$1, { href: item.href, children: item.label })
          ] })
        ] }, index2)) })
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BreadcrumbContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "nav",
    {
      className: cn(
        "flex items-center space-x-2 font-medium tracking-wider",
        sizeClasses2[size2],
        variantClasses2[variant],
        className
      ),
      "aria-label": "Breadcrumb",
      children
    }
  ) });
};
const BreadcrumbList = ({
  children,
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: cn("flex items-center space-x-2", className), children });
};
const BreadcrumbItem = ({
  children,
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: cn("flex items-center", className), children });
};
const BreadcrumbLink$1 = ({
  children,
  href,
  onClick,
  isActive = false,
  className
}) => {
  useBreadcrumbContext();
  const handleClick = () => {
    if (onClick) {
      onClick();
    }
  };
  if (isActive) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: cn(
          "text-brand-orange dark:text-dark-brand-orange font-semibold",
          className
        ),
        "aria-current": "page",
        children
      }
    );
  }
  const linkClasses = cn(
    "text-text-primary dark:text-dark-text-primary hover:text-brand-orange dark:hover:text-dark-brand-orange transition-colors cursor-pointer",
    className
  );
  if (href) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href, className: linkClasses, onClick: handleClick, children });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: linkClasses, onClick: handleClick, children });
};
const BreadcrumbPage = ({
  children,
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      className: cn(
        "text-brand-orange dark:text-dark-brand-orange font-semibold",
        className
      ),
      "aria-current": "page",
      children
    }
  );
};
const BreadcrumbSeparator = ({
  children,
  className
}) => {
  const { separator, hasSeparator } = useBreadcrumbContext();
  if (!hasSeparator) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("text-text-secondary dark:text-dark-text-secondary mx-2", className), children: children || separator });
};
const BreadcrumbEllipsis = ({
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: cn("text-text-secondary dark:text-dark-text-secondary", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "more_horiz" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "More items" })
  ] });
};
const BreadcrumbCompound = BreadcrumbBase;
BreadcrumbCompound.List = BreadcrumbList;
BreadcrumbCompound.Item = BreadcrumbItem;
BreadcrumbCompound.Link = BreadcrumbLink$1;
BreadcrumbCompound.Page = BreadcrumbPage;
BreadcrumbCompound.Separator = BreadcrumbSeparator;
BreadcrumbCompound.Ellipsis = BreadcrumbEllipsis;
const BrowserCompatibility = ({
  children,
  title,
  description,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "warning",
  // State Props
  isDisabled = false,
  isLoading = false,
  isExpanded = true,
  isCollapsible = false,
  isInteractive = false,
  isEditable = false,
  isSearchable = false,
  isFilterable = false,
  isSortable = false,
  // Feature Props
  hasBackground = true,
  hasBorder = true,
  isRounded = true,
  hasShadow = false,
  hasTitleBar = false,
  hasDescription = false,
  hasToolbar = false,
  hasFooter = false,
  hasBrowserIcons = true,
  hasVersionBadges = true,
  hasSupportIndicators = true,
  hasDetailedNotes = true,
  hasCompatibilityMatrix = false,
  hasLegend = true,
  // Layout Props
  isResponsive = true,
  hasFixedWidth = false,
  isFullWidth = true,
  hasFixedHeight = false,
  isScrollable = false,
  isCentered = false,
  hasMaxWidth = false,
  hasMinWidth = false,
  hasMaxHeight = false,
  hasMinHeight = false,
  // Content Props
  headerContent,
  footerContent,
  toolbarContent,
  browserSupport = [],
  compatibilityMatrix = {},
  legendContent,
  emptyStateContent,
  loadingStateContent,
  errorStateContent,
  // Event Handlers
  onClick,
  onFocus,
  onBlur,
  onToggle,
  onBrowserSupportUpdate,
  onCompatibilityMatrixUpdate,
  ...props
}) => {
  const [expanded, setExpanded] = useState(isExpanded);
  const [searchTerm, setSearchTerm] = useState("");
  const [filterLevel, setFilterLevel] = useState("all");
  const defaultBrowserSupport = [
    { name: "Chrome", version: "90+", supported: true, level: "full", lastTested: "120" },
    { name: "Firefox", version: "88+", supported: true, level: "full", lastTested: "115" },
    { name: "Safari", version: "14+", supported: true, level: "full", lastTested: "17" },
    { name: "Edge", version: "90+", supported: true, level: "full", lastTested: "120" },
    { name: "IE", version: "11", supported: false, level: "none", notes: "Not supported", lastTested: "11" }
  ];
  const finalBrowserSupport = browserSupport.length > 0 ? browserSupport : defaultBrowserSupport;
  const sizeClasses2 = {
    xs: "p-2 gap-2 text-xs",
    sm: "p-3 gap-3 text-sm",
    md: "p-4 gap-4 text-sm",
    lg: "p-6 gap-6 text-base",
    xl: "p-8 gap-8 text-lg"
  };
  const variantClasses2 = {
    default: "bg-amber-50 dark:bg-amber-900/40 border-amber-200 dark:border-amber-500/30",
    minimal: "bg-transparent border-transparent",
    elevated: "bg-amber-50 dark:bg-amber-900/40 border-amber-200 dark:border-amber-500/30 shadow-lg",
    bordered: "bg-amber-50 dark:bg-amber-900/40 border-2 border-amber-300 dark:border-amber-600",
    filled: "bg-amber-100 dark:bg-amber-800/60 border-amber-300 dark:border-amber-600"
  };
  const handleToggle = () => {
    if (isCollapsible && !isDisabled) {
      const newExpanded = !expanded;
      setExpanded(newExpanded);
      onToggle?.(newExpanded);
    }
  };
  const handleSearch = (term) => {
    setSearchTerm(term);
  };
  const handleFilterLevel = (level) => {
    setFilterLevel(level);
  };
  const filteredBrowserSupport = finalBrowserSupport.filter((browser) => {
    const matchesSearch = !searchTerm || browser.name.toLowerCase().includes(searchTerm.toLowerCase()) || browser.version.toLowerCase().includes(searchTerm.toLowerCase()) || browser.notes && browser.notes.toLowerCase().includes(searchTerm.toLowerCase());
    const matchesFilter = filterLevel === "all" || browser.level === filterLevel;
    return matchesSearch && matchesFilter;
  });
  const containerClasses = `
    ${hasBackground ? "bg-amber-50 dark:bg-amber-900/40" : ""}
    ${hasBorder ? "border border-amber-200 dark:border-amber-500/30" : ""}
    ${isRounded ? "rounded-lg" : ""}
    ${hasShadow ? "shadow-md" : ""}
    ${isResponsive ? "w-full" : ""}
    ${hasFixedWidth ? "" : "w-full"}
    ${isFullWidth ? "w-full" : ""}
    ${hasFixedHeight ? "" : "min-h-0"}
    ${isScrollable ? "overflow-auto" : "overflow-hidden"}
    ${isCentered ? "mx-auto" : ""}
    ${hasMaxWidth ? "max-w-7xl" : ""}
    ${hasMinWidth ? "min-w-0" : ""}
    ${hasMaxHeight ? "max-h-96" : ""}
    ${hasMinHeight ? "min-h-0" : ""}
    ${containerClassName}
    ${className}
  `.trim().replace(/\s+/g, " ");
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClasses, style, children: loadingStateContent || /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center h-32", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-amber-500" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-amber-600", children: "Loading compatibility data..." })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, style, ...props, children: [
    (hasTitleBar || title || headerContent) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4 p-3 bg-amber-100 dark:bg-amber-800/60 rounded-t-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        title && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-amber-900 dark:text-amber-100", children: title }),
        description && hasDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-amber-700 dark:text-amber-300", children: description })
      ] }),
      headerContent
    ] }),
    hasToolbar && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4 p-2 bg-amber-100 dark:bg-amber-800/60 border-b border-amber-200 dark:border-amber-600", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        isSearchable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "absolute left-2 top-1/2 transform -translate-y-1/2 w-4 h-4 text-amber-500", children: "search" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Search browsers...",
              value: searchTerm,
              onChange: (e2) => handleSearch(e2.target.value),
              className: "pl-8 pr-3 py-1 text-xs bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 rounded border border-amber-300 dark:border-amber-600 focus:ring-1 focus:ring-amber-500 focus:border-transparent"
            }
          )
        ] }),
        isFilterable && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "select",
          {
            value: filterLevel,
            onChange: (e2) => handleFilterLevel(e2.target.value),
            className: "px-2 py-1 text-xs bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 rounded border border-amber-300 dark:border-amber-600 focus:ring-1 focus:ring-amber-500 focus:border-transparent",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All Levels" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "full", children: "Full Support" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "partial", children: "Partial Support" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "none", children: "No Support" })
            ]
          }
        ),
        isCollapsible && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleToggle,
            disabled: isDisabled,
            className: "px-2 py-1 text-xs bg-amber-200 dark:bg-amber-700 text-amber-800 dark:text-amber-200 rounded hover:bg-amber-300 dark:hover:bg-amber-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3 mr-1", children: expanded ? "expand_less" : "expand_more" }),
              expanded ? "Collapse" : "Expand"
            ]
          }
        )
      ] }),
      toolbarContent
    ] }),
    expanded && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${sizeClasses2[size2]} ${variantClasses2[variant]}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-3", children: [
        hasBrowserIcons && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "!text-xl mt-0.5 shrink-0 text-amber-600 dark:text-amber-400", children: "science" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-amber-800 dark:text-amber-300", children: "Browser Compatibility:" }),
          children && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2", children })
        ] })
      ] }),
      filteredBrowserSupport.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3", children: filteredBrowserSupport.map((browser) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `
                      p-3 rounded-lg border transition-colors
                      ${browser.level === "full" ? "bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-600" : ""}
                      ${browser.level === "partial" ? "bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-600" : ""}
                      ${browser.level === "none" ? "bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-600" : ""}
                      ${isInteractive ? "hover:bg-opacity-80 cursor-pointer" : ""}
                    `.trim().replace(/\s+/g, " "),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-gray-900 dark:text-gray-100", children: browser.name }),
              hasSupportIndicators && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `
                          px-2 py-1 text-xs rounded-full font-medium
                          ${browser.level === "full" ? "bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200" : ""}
                          ${browser.level === "partial" ? "bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-200" : ""}
                          ${browser.level === "none" ? "bg-red-100 dark:bg-red-800 text-red-800 dark:text-red-200" : ""}
                        `.trim().replace(/\s+/g, " "), children: browser.level === "full" ? "✓" : browser.level === "partial" ? "⚠" : "✗" })
            ] }),
            hasVersionBadges && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-600 dark:text-gray-400", children: "Version:" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 text-xs bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded", children: browser.version }),
              browser.lastTested && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-gray-500", children: [
                "(Tested: ",
                browser.lastTested,
                ")"
              ] })
            ] }),
            hasDetailedNotes && browser.notes && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-600 dark:text-gray-400", children: browser.notes })
          ]
        },
        browser.name
      )) }) }),
      hasCompatibilityMatrix && Object.keys(compatibilityMatrix).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium text-amber-900 dark:text-amber-100 mb-3", children: "Compatibility Matrix" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-xs border-collapse", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "border-b border-amber-200 dark:border-amber-600", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "p-2 text-left", children: "Feature" }),
            Object.keys(compatibilityMatrix).map((browser) => /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "p-2 text-center", children: browser }, browser))
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: Object.keys(compatibilityMatrix[Object.keys(compatibilityMatrix)[0]] || {}).map((feature) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "border-b border-amber-100 dark:border-amber-700", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2 font-medium", children: feature }),
            Object.keys(compatibilityMatrix).map((browser) => /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-2 text-center", children: compatibilityMatrix[browser][feature] ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green-600", children: "✓" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-600", children: "✗" }) }, browser))
          ] }, feature)) })
        ] }) })
      ] }),
      hasLegend && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 p-3 bg-amber-100 dark:bg-amber-800/60 rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium text-amber-900 dark:text-amber-100 mb-2", children: "Legend" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-4 text-xs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-3 h-3 bg-green-500 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-700 dark:text-gray-300", children: "Full Support" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-3 h-3 bg-yellow-500 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-700 dark:text-gray-300", children: "Partial Support" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "w-3 h-3 bg-red-500 rounded-full" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-700 dark:text-gray-300", children: "No Support" })
          ] })
        ] }),
        legendContent
      ] })
    ] }),
    hasFooter && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 p-3 bg-amber-100 dark:bg-amber-800/60 rounded-b-lg", children: footerContent || /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between text-xs text-amber-700 dark:text-amber-300", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        filteredBrowserSupport.length,
        " browsers"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        "Last updated: ",
        (/* @__PURE__ */ new Date()).toLocaleDateString()
      ] })
    ] }) })
  ] });
};
function ButtonBase(props, ref) {
  const {
    as: Component2 = "button",
    children,
    className,
    variant = "primary",
    size: size2 = "md",
    leftIcon,
    rightIcon,
    onDarkBackground = false,
    onBrandBackground = false,
    isDisabled = false,
    isLoading = false,
    isFullWidth = false,
    width,
    customWidth,
    minWidth,
    maxWidth,
    hasHoverEffect = true,
    hasActiveEffect = false,
    radius = "md",
    ...rest
  } = props;
  const getRadiusClass2 = () => {
    switch (radius) {
      case "none":
        return "rounded-none";
      case "sm":
        return "rounded-sm";
      case "md":
        return "rounded";
      case "lg":
        return "rounded-lg";
      case "xl":
        return "rounded-xl";
      case "full":
        return "rounded-full";
      default:
        return "rounded";
    }
  };
  const getWidthClass = () => {
    if (customWidth) return "";
    if (isFullWidth) return "w-full";
    switch (width) {
      case "sm":
        return "w-sm";
      case "md":
        return "w-md";
      case "lg":
        return "w-lg";
      case "full":
        return "w-full";
      case "auto":
        return "w-auto";
      case "none":
        return "w-auto";
      // 'none' behaves like default (auto width for buttons)
      default:
        return "w-auto";
    }
  };
  const getMinWidthClass = () => {
    if (customWidth || minWidth) return "";
    return "min-w-24";
  };
  const getMaxWidthClass = () => {
    if (maxWidth) return "";
    return "max-w-full";
  };
  const baseStyles = [
    "font-regular focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 inline-flex items-center justify-center leading-normal whitespace-nowrap disabled:cursor-not-allowed dark:disabled:opacity-60",
    getRadiusClass2()
  ].filter(Boolean).join(" ");
  const getVariantStyles2 = () => {
    const baseVariantStyles = {
      primary: "bg-brand-orange text-white focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:bg-brand-orange/50 disabled:text-white/50 dark:disabled:bg-brand-orange/40 dark:disabled:text-white/40 disabled:cursor-not-allowed",
      secondary: onDarkBackground || onBrandBackground ? "bg-white text-brand-navy focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:bg-white/50 disabled:text-brand-navy/50 disabled:cursor-not-allowed" : "bg-bg-tertiary text-brand-navy focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:bg-bg-tertiary/50 disabled:text-brand-navy/50 disabled:cursor-not-allowed dark:bg-dark-brand-navy/10 dark:text-dark-brand-navy dark:disabled:bg-dark-brand-navy/5 dark:disabled:text-dark-brand-navy/50",
      text: onDarkBackground || onBrandBackground ? "text-white underline-offset-4 focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:text-white/50 disabled:cursor-not-allowed" : "text-brand-navy underline-offset-4 focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:text-text-secondary disabled:cursor-not-allowed dark:text-dark-brand-orange dark:disabled:text-dark-brand-orange/50",
      outline: onDarkBackground || onBrandBackground ? "border border-white text-white focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:border-white/30 disabled:text-white/50 disabled:cursor-not-allowed" : "border border-brand-navy text-brand-navy focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:border-border-color disabled:text-text-secondary disabled:cursor-not-allowed dark:border-dark-brand-orange dark:text-dark-brand-orange dark:disabled:border-dark-brand-orange/30 dark:disabled:text-dark-brand-orange/50",
      dashed: onDarkBackground || onBrandBackground ? "border-2 border-dashed border-white text-white focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:border-white/30 disabled:text-white/70 disabled:cursor-not-allowed" : "border-2 border-dashed border-brand-navy text-brand-navy focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:border-border-color disabled:text-brand-navy/70 disabled:cursor-not-allowed dark:border-dashed dark:border-dark-brand-orange dark:text-dark-brand-orange dark:disabled:border-dark-brand-orange/30 dark:disabled:text-dark-brand-orange/70",
      ghost: onDarkBackground || onBrandBackground ? "text-white/90 bg-transparent focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:text-white/50 disabled:cursor-not-allowed" : "text-text-secondary bg-transparent focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange disabled:text-text-secondary/50 disabled:cursor-not-allowed dark:text-dark-brand-orange dark:disabled:text-dark-brand-orange/50",
      warning: onDarkBackground || onBrandBackground ? "bg-system-warning text-white focus-visible:ring-system-warning dark:focus-visible:ring-system-warning disabled:bg-system-warning/50 disabled:text-white/50 disabled:cursor-not-allowed" : "bg-system-warning-light text-system-warning-dark dark:bg-system-warning-dark-bg dark:text-system-warning-light-text focus-visible:ring-system-warning dark:focus-visible:ring-system-warning disabled:bg-system-warning-light/70 disabled:text-system-warning-dark/50 dark:disabled:bg-system-warning-dark-bg/50 dark:disabled:text-system-warning-light-text/50 disabled:cursor-not-allowed",
      danger: onDarkBackground || onBrandBackground ? "bg-system-error text-white focus-visible:ring-system-error dark:focus-visible:ring-system-error disabled:bg-system-error/50 disabled:text-white/50 disabled:cursor-not-allowed" : "bg-system-error text-white focus-visible:ring-system-error dark:focus-visible:ring-system-error disabled:bg-system-error/50 disabled:text-white/50 dark:disabled:bg-system-error-dark-bg/50 dark:disabled:text-system-error-light-text/50 disabled:cursor-not-allowed",
      info: onDarkBackground || onBrandBackground ? "bg-system-info text-white focus-visible:ring-system-info dark:focus-visible:ring-system-info disabled:bg-system-info/50 disabled:text-white/50 disabled:cursor-not-allowed" : "bg-system-info text-white focus-visible:ring-system-info dark:focus-visible:ring-system-info disabled:bg-system-info/50 disabled:text-white/50 dark:disabled:bg-system-info-dark-bg/50 dark:disabled:text-system-info-light-text/50 disabled:cursor-not-allowed",
      success: onDarkBackground || onBrandBackground ? "bg-system-success text-white focus-visible:ring-system-success dark:focus-visible:ring-system-success disabled:bg-system-success/50 disabled:text-white/50 disabled:cursor-not-allowed" : "bg-system-success text-white focus-visible:ring-system-success dark:focus-visible:ring-system-success disabled:bg-system-success/50 disabled:text-white/50 dark:disabled:bg-system-success-dark-bg/50 dark:disabled:text-system-success-light-text/50 disabled:cursor-not-allowed",
      "grey-primary": onDarkBackground || onBrandBackground ? "bg-grey-200 text-grey-800 focus-visible:ring-grey-400 disabled:bg-grey-100 disabled:text-grey-500 disabled:cursor-not-allowed" : "bg-grey-primary text-white focus-visible:ring-grey-primary disabled:bg-grey-primary/50 disabled:text-white/50 dark:!bg-dark-grey-primary dark:!text-grey-900 dark:focus-visible:ring-dark-grey-primary/30 dark:disabled:!bg-dark-grey-primary/70 dark:disabled:!text-grey-900/50 disabled:cursor-not-allowed",
      "grey-secondary": onDarkBackground || onBrandBackground ? "bg-grey-100 text-grey-700 focus-visible:ring-grey-300 disabled:bg-grey-50 disabled:text-grey-400 disabled:cursor-not-allowed" : "bg-grey-100 text-grey-primary focus-visible:ring-grey-primary/30 disabled:bg-grey-100/50 disabled:text-grey-primary/50 disabled:cursor-not-allowed dark:bg-dark-grey-secondary/10 dark:text-dark-grey-secondary dark:focus-visible:ring-dark-grey-secondary/30 dark:disabled:bg-dark-grey-secondary/5 dark:disabled:text-dark-grey-secondary/50",
      "grey-text": onDarkBackground || onBrandBackground ? "text-grey-200 underline-offset-4 focus-visible:ring-grey-300/30 disabled:text-grey-300/50 disabled:cursor-not-allowed" : "text-grey-primary underline-offset-4 focus-visible:ring-grey-primary/30 disabled:text-grey-400 disabled:cursor-not-allowed dark:text-dark-grey-primary dark:focus-visible:ring-dark-grey-primary/30 dark:disabled:text-dark-grey-primary/50",
      "grey-outline": onDarkBackground || onBrandBackground ? "border border-grey-200 text-grey-200 focus-visible:ring-grey-300 disabled:border-grey-300/30 disabled:text-grey-300/50 disabled:cursor-not-allowed" : "border border-grey-primary text-grey-primary focus-visible:ring-grey-primary/30 disabled:border-grey-300 disabled:text-grey-400 disabled:cursor-not-allowed dark:border-dark-grey-primary dark:text-dark-grey-primary dark:focus-visible:ring-dark-grey-primary/30 dark:disabled:border-dark-grey-primary/30 dark:disabled:text-dark-grey-primary/50",
      "grey-dashed": onDarkBackground || onBrandBackground ? "border-2 border-dashed border-grey-200 text-grey-200 focus-visible:ring-grey-300 dark:focus-visible:ring-grey-300 disabled:border-grey-300/30 disabled:text-grey-300/70 disabled:cursor-not-allowed" : "border-2 border-dashed border-grey-primary text-grey-primary focus-visible:ring-grey-primary/30 dark:focus-visible:ring-dark-grey-primary/30 disabled:border-grey-300 disabled:text-grey-primary/70 disabled:cursor-not-allowed dark:border-dashed dark:border-dark-grey-primary dark:text-dark-grey-primary dark:disabled:border-dark-grey-primary/30 dark:disabled:text-dark-grey-primary/70",
      "grey-ghost": onDarkBackground || onBrandBackground ? "text-grey-800/90 bg-transparent focus-visible:ring-grey-300/30 dark:focus-visible:ring-grey-300/30 disabled:text-grey-300/50 disabled:cursor-not-allowed" : "text-grey-800 bg-transparent focus-visible:ring-grey-primary/30 dark:focus-visible:ring-dark-grey-primary/30 disabled:text-grey-300/50 disabled:cursor-not-allowed dark:text-dark-grey-primary dark:disabled:text-dark-grey-primary/50"
    };
    const hoverStyles = {
      primary: "hover:bg-brand-orange-hover",
      secondary: onDarkBackground || onBrandBackground ? "hover:bg-gray-50" : "hover:bg-brand-navy/10 dark:hover:bg-dark-brand-navy/20 dark:hover:bg-dark-brand-navy/30",
      text: onDarkBackground || onBrandBackground ? "hover:underline" : "hover:underline dark:hover:underline dark:hover:text-dark-brand-orange-hover",
      outline: onDarkBackground || onBrandBackground ? "hover:bg-white hover:text-brand-navy" : "hover:bg-brand-navy hover:text-white dark:hover:bg-dark-brand-orange dark:hover:text-white",
      dashed: onDarkBackground || onBrandBackground ? "hover:bg-white hover:text-brand-navy hover:border-solid disabled:hover:bg-transparent disabled:hover:text-white disabled:hover:border-dashed" : "hover:bg-brand-navy hover:text-white hover:border-solid disabled:hover:bg-transparent disabled:hover:text-brand-navy disabled:hover:border-dashed dark:hover:bg-dark-brand-orange dark:hover:text-white dark:hover:border-solid dark:disabled:hover:bg-transparent dark:disabled:hover:text-dark-brand-orange dark:disabled:hover:border-dashed",
      ghost: onDarkBackground || onBrandBackground ? "hover:bg-white/10 hover:text-white" : "hover:bg-bg-tertiary hover:text-text-primary dark:hover:bg-dark-brand-orange/10 dark:hover:text-dark-brand-orange-hover",
      warning: onDarkBackground || onBrandBackground ? "hover:bg-system-warning-dark hover:text-white" : "hover:bg-system-warning-border dark:hover:bg-system-warning-button dark:hover:text-white",
      danger: onDarkBackground || onBrandBackground ? "hover:bg-system-error-dark" : "hover:bg-system-error-dark dark:hover:bg-system-error-button dark:hover:text-white",
      info: onDarkBackground || onBrandBackground ? "hover:bg-system-info-dark" : "hover:bg-system-info-dark dark:hover:bg-system-info-button dark:hover:text-white",
      success: onDarkBackground || onBrandBackground ? "hover:bg-system-success-dark" : "hover:bg-system-success-dark dark:hover:bg-system-success-button dark:hover:text-white",
      "grey-primary": onDarkBackground || onBrandBackground ? "hover:bg-grey-300 hover:text-grey-900" : "hover:bg-grey-primary-hover dark:hover:!bg-dark-grey-primary-hover dark:hover:!text-grey-900",
      "grey-secondary": onDarkBackground || onBrandBackground ? "hover:bg-grey-200 hover:text-grey-800" : "hover:bg-grey-primary/10 dark:hover:bg-dark-grey-secondary/20 dark:hover:bg-dark-grey-secondary/30",
      "grey-text": onDarkBackground || onBrandBackground ? "hover:underline" : "hover:underline dark:hover:underline dark:hover:text-dark-grey-primary-hover",
      "grey-outline": onDarkBackground || onBrandBackground ? "hover:bg-grey-200 hover:text-grey-800" : "hover:bg-grey-primary hover:text-white dark:hover:bg-dark-grey-primary dark:hover:text-grey-900",
      "grey-dashed": onDarkBackground || onBrandBackground ? "hover:bg-grey-200 hover:text-grey-800 hover:border-solid disabled:hover:bg-transparent disabled:hover:text-grey-200 disabled:hover:border-dashed" : "hover:bg-grey-primary hover:text-white hover:border-solid disabled:hover:bg-transparent disabled:hover:text-grey-primary disabled:hover:border-dashed dark:hover:bg-dark-grey-primary dark:hover:text-grey-900 dark:hover:border-solid dark:disabled:hover:bg-transparent dark:disabled:hover:text-dark-grey-primary dark:disabled:hover:border-dashed",
      "grey-ghost": onDarkBackground || onBrandBackground ? "hover:bg-grey-200/10 hover:text-grey-100" : "hover:bg-grey-100 hover:text-grey-primary dark:hover:bg-dark-grey-primary/10 dark:hover:text-dark-grey-primary-hover"
    };
    const allowHover = hasHoverEffect && !isDisabled && !isLoading;
    return allowHover ? `${baseVariantStyles[variant]} ${hoverStyles[variant]}` : baseVariantStyles[variant];
  };
  const variantStyles = getVariantStyles2();
  const hasTextContent = children !== void 0 && children !== null && children !== "";
  const shouldBeIconOnly = (leftIcon || rightIcon) && !hasTextContent;
  const isIconOnly = shouldBeIconOnly && !isLoading;
  const cloneIconWithSize = (icon, buttonSize) => {
    if (!React__default.isValidElement(icon)) return icon;
    const iconProps = icon.props;
    if (iconProps && typeof iconProps.children === "string") {
      let iconComponentSize;
      if (shouldBeIconOnly) {
        switch (buttonSize) {
          case "xs":
            iconComponentSize = "sm";
            break;
          case "sm":
            iconComponentSize = "md";
            break;
          case "md":
            iconComponentSize = "lg";
            break;
          case "lg":
            iconComponentSize = "xl";
            break;
          case "xl":
            iconComponentSize = "2xl";
            break;
          default:
            iconComponentSize = "md";
        }
      } else {
        iconComponentSize = buttonSize;
      }
      return React__default.cloneElement(icon, {
        ...iconProps,
        size: iconComponentSize
      });
    }
    return icon;
  };
  const sizeStyles = shouldBeIconOnly ? {
    // Same padding for both loading and normal state
    xs: "px-2 py-2",
    sm: "px-2.5 py-2.5",
    md: "px-3 py-3",
    lg: "px-4 py-4",
    xl: "px-5 py-5"
  } : {
    xs: "py-1 px-2 text-xs",
    sm: "py-1.5 px-3 text-sm",
    md: "py-2 px-4 text-base",
    lg: "py-2.5 px-5 text-lg",
    xl: "py-3 px-6 text-xl"
  };
  const spinnerSizeStyles = shouldBeIconOnly ? {
    xs: "w-3 h-3",
    // Match sm icon (text-sm ≈ 14px) - spinner slightly larger
    sm: "w-3 h-3",
    // Match md icon (text-base ≈ 16px)
    md: "w-4 h-4",
    // Match lg icon (text-lg ≈ 18px)
    lg: "w-6 h-6",
    // Match xl icon (text-xl ≈ 20px) - larger for visibility
    xl: "w-8 h-8"
    // Match 2xl icon (text-2xl ≈ 24px)
  } : {
    xs: "h-4 w-4",
    sm: "h-4 w-4",
    md: "h-4 w-4",
    lg: "h-4 w-4",
    xl: "h-4 w-4"
  };
  const combinedClassName = [
    baseStyles,
    variantStyles,
    sizeStyles[size2],
    getWidthClass(),
    // Remove min-width for icon-only buttons (including during loading)
    shouldBeIconOnly ? minWidth ? "" : "min-w-0" : getMinWidthClass(),
    getMaxWidthClass(),
    className
  ].filter(Boolean).join(" ");
  const inlineStyles = {
    ...customWidth && { width: customWidth },
    ...minWidth && { minWidth },
    ...maxWidth && { maxWidth },
    ...rest.style
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Component2,
    {
      className: combinedClassName,
      ref,
      disabled: isDisabled || isLoading,
      style: inlineStyles,
      ...rest,
      children: [
        isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: shouldBeIconOnly ? "flex items-center justify-center" : "mr-2 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `animate-spin rounded-full border-2 border-current border-t-transparent ${spinnerSizeStyles[size2]}` }) }),
        !isLoading && leftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${isIconOnly ? "" : "mr-2"} flex items-center justify-center`, children: cloneIconWithSize(leftIcon, size2) }),
        hasTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "min-w-0 truncate text-center", children }),
        !isLoading && rightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${isIconOnly ? "" : "ml-2"} flex items-center justify-center`, children: cloneIconWithSize(rightIcon, size2) })
      ]
    }
  );
}
const ButtonWithRef = React__default.forwardRef(ButtonBase);
const Button$1 = ButtonWithRef;
const ButtonGroup = ({
  children,
  orientation = "horizontal",
  isAttached = false,
  size: size2 = "md",
  className,
  isDisabled = false,
  isFullWidth = false
}) => {
  const groupClasses = cn(
    "inline-flex",
    orientation === "vertical" ? "flex-col" : "flex-row",
    isAttached ? "gap-0" : "gap-1",
    isFullWidth && "w-full",
    className
  );
  const clonedChildren = React__default.Children.map(children, (child, index2) => {
    if (React__default.isValidElement(child) && child.type === Button$1) {
      const isFirst = index2 === 0;
      const isLast = index2 === React__default.Children.count(children) - 1;
      const groupButtonClasses = cn(
        // Attached styling
        isAttached && [
          orientation === "horizontal" ? [
            "rounded-none",
            isFirst && "rounded-l-md",
            isLast && "rounded-r-md",
            !isFirst && "border-l-0"
          ] : [
            "rounded-none",
            isFirst && "rounded-t-md",
            isLast && "rounded-b-md",
            !isFirst && "border-t-0"
          ]
        ],
        // Full width for individual buttons
        isFullWidth && "flex-1",
        // Disabled state
        isDisabled && "opacity-50 cursor-not-allowed"
      );
      return React__default.cloneElement(child, {
        ...child.props,
        size: size2,
        isDisabled: isDisabled || child.props.isDisabled,
        className: cn(child.props.className, groupButtonClasses)
      });
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: groupClasses, role: "group", children: clonedChildren });
};
ButtonGroup.Button = Button$1;
function tzName(timeZone, date, format2 = "long") {
  return new Intl.DateTimeFormat("en-US", {
    // Enforces engine to render the time. Without the option JavaScriptCore omits it.
    hour: "numeric",
    timeZone,
    timeZoneName: format2
  }).format(date).split(/\s/g).slice(2).join(" ");
}
const offsetFormatCache = {};
const offsetCache = {};
function tzOffset(timeZone, date) {
  try {
    const format2 = offsetFormatCache[timeZone] ||= new Intl.DateTimeFormat("en-US", {
      timeZone,
      timeZoneName: "longOffset"
    }).format;
    const offsetStr = format2(date).split("GMT")[1];
    if (offsetStr in offsetCache) return offsetCache[offsetStr];
    return calcOffset(offsetStr, offsetStr.split(":"));
  } catch {
    if (timeZone in offsetCache) return offsetCache[timeZone];
    const captures = timeZone?.match(offsetRe);
    if (captures) return calcOffset(timeZone, captures.slice(1));
    return NaN;
  }
}
const offsetRe = /([+-]\d\d):?(\d\d)?/;
function calcOffset(cacheStr, values) {
  const hours = +(values[0] || 0);
  const minutes = +(values[1] || 0);
  const seconds = +(values[2] || 0) / 60;
  return offsetCache[cacheStr] = hours * 60 + minutes > 0 ? hours * 60 + minutes + seconds : hours * 60 - minutes - seconds;
}
class TZDateMini extends Date {
  //#region static
  constructor(...args) {
    super();
    if (args.length > 1 && typeof args[args.length - 1] === "string") {
      this.timeZone = args.pop();
    }
    this.internal = /* @__PURE__ */ new Date();
    if (isNaN(tzOffset(this.timeZone, this))) {
      this.setTime(NaN);
    } else {
      if (!args.length) {
        this.setTime(Date.now());
      } else if (typeof args[0] === "number" && (args.length === 1 || args.length === 2 && typeof args[1] !== "number")) {
        this.setTime(args[0]);
      } else if (typeof args[0] === "string") {
        this.setTime(+new Date(args[0]));
      } else if (args[0] instanceof Date) {
        this.setTime(+args[0]);
      } else {
        this.setTime(+new Date(...args));
        adjustToSystemTZ(this);
        syncToInternal(this);
      }
    }
  }
  static tz(tz, ...args) {
    return args.length ? new TZDateMini(...args, tz) : new TZDateMini(Date.now(), tz);
  }
  //#endregion
  //#region time zone
  withTimeZone(timeZone) {
    return new TZDateMini(+this, timeZone);
  }
  getTimezoneOffset() {
    const offset2 = -tzOffset(this.timeZone, this);
    return offset2 > 0 ? Math.floor(offset2) : Math.ceil(offset2);
  }
  //#endregion
  //#region time
  setTime(time2) {
    Date.prototype.setTime.apply(this, arguments);
    syncToInternal(this);
    return +this;
  }
  //#endregion
  //#region date-fns integration
  [Symbol.for("constructDateFrom")](date) {
    return new TZDateMini(+new Date(date), this.timeZone);
  }
  //#endregion
}
const re = /^(get|set)(?!UTC)/;
Object.getOwnPropertyNames(Date.prototype).forEach((method) => {
  if (!re.test(method)) return;
  const utcMethod = method.replace(re, "$1UTC");
  if (!TZDateMini.prototype[utcMethod]) return;
  if (method.startsWith("get")) {
    TZDateMini.prototype[method] = function() {
      return this.internal[utcMethod]();
    };
  } else {
    TZDateMini.prototype[method] = function() {
      Date.prototype[utcMethod].apply(this.internal, arguments);
      syncFromInternal(this);
      return +this;
    };
    TZDateMini.prototype[utcMethod] = function() {
      Date.prototype[utcMethod].apply(this, arguments);
      syncToInternal(this);
      return +this;
    };
  }
});
function syncToInternal(date) {
  date.internal.setTime(+date);
  date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));
}
function syncFromInternal(date) {
  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());
  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());
  adjustToSystemTZ(date);
}
function adjustToSystemTZ(date) {
  const baseOffset = tzOffset(date.timeZone, date);
  const offset2 = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);
  const prevHour = /* @__PURE__ */ new Date(+date);
  prevHour.setUTCHours(prevHour.getUTCHours() - 1);
  const systemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
  const prevHourSystemOffset = -(/* @__PURE__ */ new Date(+prevHour)).getTimezoneOffset();
  const systemDSTChange = systemOffset - prevHourSystemOffset;
  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();
  if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);
  const offsetDiff = systemOffset - offset2;
  if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);
  const systemDate = /* @__PURE__ */ new Date(+date);
  systemDate.setUTCSeconds(0);
  const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;
  const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;
  if (secondsOffset || systemSecondsOffset) {
    date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);
    Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);
  }
  const postBaseOffset = tzOffset(date.timeZone, date);
  const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);
  const postSystemOffset = -(/* @__PURE__ */ new Date(+date)).getTimezoneOffset();
  const postOffsetDiff = postSystemOffset - postOffset;
  const offsetChanged = postOffset !== offset2;
  const postDiff = postOffsetDiff - offsetDiff;
  if (offsetChanged && postDiff) {
    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);
    const newBaseOffset = tzOffset(date.timeZone, date);
    const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);
    const offsetChange = postOffset - newOffset;
    if (offsetChange) {
      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);
      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);
    }
  }
}
class TZDate extends TZDateMini {
  //#region static
  static tz(tz, ...args) {
    return args.length ? new TZDate(...args, tz) : new TZDate(Date.now(), tz);
  }
  //#endregion
  //#region representation
  toISOString() {
    const [sign, hours, minutes] = this.tzComponents();
    const tz = `${sign}${hours}:${minutes}`;
    return this.internal.toISOString().slice(0, -1) + tz;
  }
  toString() {
    return `${this.toDateString()} ${this.toTimeString()}`;
  }
  toDateString() {
    const [day, date, month, year] = this.internal.toUTCString().split(" ");
    return `${day?.slice(0, -1)} ${month} ${date} ${year}`;
  }
  toTimeString() {
    const time2 = this.internal.toUTCString().split(" ")[4];
    const [sign, hours, minutes] = this.tzComponents();
    return `${time2} GMT${sign}${hours}${minutes} (${tzName(this.timeZone, this)})`;
  }
  toLocaleString(locales2, options) {
    return Date.prototype.toLocaleString.call(this, locales2, {
      ...options,
      timeZone: options?.timeZone || this.timeZone
    });
  }
  toLocaleDateString(locales2, options) {
    return Date.prototype.toLocaleDateString.call(this, locales2, {
      ...options,
      timeZone: options?.timeZone || this.timeZone
    });
  }
  toLocaleTimeString(locales2, options) {
    return Date.prototype.toLocaleTimeString.call(this, locales2, {
      ...options,
      timeZone: options?.timeZone || this.timeZone
    });
  }
  //#endregion
  //#region private
  tzComponents() {
    const offset2 = this.getTimezoneOffset();
    const sign = offset2 > 0 ? "-" : "+";
    const hours = String(Math.floor(Math.abs(offset2) / 60)).padStart(2, "0");
    const minutes = String(Math.abs(offset2) % 60).padStart(2, "0");
    return [sign, hours, minutes];
  }
  //#endregion
  withTimeZone(timeZone) {
    return new TZDate(+this, timeZone);
  }
  //#region date-fns integration
  [Symbol.for("constructDateFrom")](date) {
    return new TZDate(+new Date(date), this.timeZone);
  }
  //#endregion
}
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}
function addDays(date, amount, options) {
  const _date = toDate(date, options?.in);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date, amount, options) {
  const _date = toDate(date, options?.in);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
let defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(date, options) {
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}
function getISOWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    context || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}
function startOfDay(date, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function addWeeks(date, amount, options) {
  return addDays(date, amount * 7, options);
}
function addYears(date, amount, options) {
  return addMonths(date, amount * 12, options);
}
function max$1(dates, options) {
  let result;
  let context = options?.in;
  dates.forEach((date) => {
    if (!context && typeof date === "object")
      context = constructFrom.bind(null, date);
    const date_ = toDate(date, context);
    if (!result || result < date_ || isNaN(+date_)) result = date_;
  });
  return constructFrom(context, result || NaN);
}
function min$1(dates, options) {
  let result;
  let context = options?.in;
  dates.forEach((date) => {
    if (!context && typeof date === "object")
      context = constructFrom.bind(null, date);
    const date_ = toDate(date, context);
    if (!result || result > date_ || isNaN(+date_)) result = date_;
  });
  return constructFrom(context, result || NaN);
}
function constructNow(date) {
  return constructFrom(date, Date.now());
}
function isSameDay(laterDate, earlierDate, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return +startOfDay(dateLeft_) === +startOfDay(dateRight_);
}
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(date) {
  return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
}
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}
function endOfDay(date, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfMonth(date, options) {
  const _date = toDate(date, options?.in);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function normalizeInterval(context, interval) {
  const [start, end] = normalizeDates(context, interval.start, interval.end);
  return { start, end };
}
function eachMonthOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options?.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +start : +end;
  const date = reversed ? end : start;
  date.setHours(0, 0, 0, 0);
  date.setDate(1);
  let step = 1;
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start, date));
    date.setMonth(date.getMonth() + step);
  }
  return reversed ? dates.reverse() : dates;
}
function startOfMonth(date, options) {
  const _date = toDate(date, options?.in);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function endOfYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function startOfYear(date, options) {
  const date_ = toDate(date, options?.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}
function eachYearOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options?.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +start : +end;
  const date = reversed ? end : start;
  date.setHours(0, 0, 0, 0);
  date.setMonth(0, 1);
  let step = 1;
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start, date));
    date.setFullYear(date.getFullYear() + step);
  }
  return reversed ? dates.reverse() : dates;
}
function endOfWeek(date, options) {
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfISOWeek(date, options) {
  return endOfWeek(date, { ...options, weekStartsOn: 1 });
}
const formatDistanceLocale$4 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance$4 = (token, count2, options) => {
  let result;
  const tokenValue = formatDistanceLocale$4[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats$4 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats$4 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats$4 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$4 = {
  date: buildFormatLongFn({
    formats: dateFormats$4,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$4,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$4,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$4 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative$4 = (token, _date, _baseDate, _options) => formatRelativeLocale$4[token];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}
const eraValues$4 = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues$4 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues$4 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues$4 = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues$4 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues$4 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber$4 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "st";
      case 2:
        return number2 + "nd";
      case 3:
        return number2 + "rd";
    }
  }
  return number2 + "th";
};
const localize$4 = {
  ordinalNumber: ordinalNumber$4,
  era: buildLocalizeFn({
    values: eraValues$4,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$4,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$4,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$4,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$4,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$4,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern$4 = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern$4 = /\d+/i;
const matchEraPatterns$4 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns$4 = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns$4 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns$4 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$4 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns$4 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$4 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns$4 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$4 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns$4 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match$4 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$4,
    parsePattern: parseOrdinalNumberPattern$4,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$4,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$4,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$4,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$4,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$4,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$4,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$4,
    defaultParseWidth: "any"
  })
};
const enUS$1 = {
  code: "en-US",
  formatDistance: formatDistance$4,
  formatLong: formatLong$4,
  formatRelative: formatRelative$4,
  localize: localize$4,
  match: match$4,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(date, options) {
  const _date = toDate(date, options?.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function getISOWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date, options) {
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(options?.in || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros(number2, targetLength) {
  const sign = number2 < 0 ? "-" : "";
  const output = Math.abs(number2).toString().padStart(targetLength, "0");
  return sign + output;
}
const lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
const dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    return addLeadingZeros(+date, token.length);
  }
};
function formatTimezoneShort(offset2, delimiter = "") {
  const sign = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, delimiter) {
  if (offset2 % 60 === 0) {
    const sign = offset2 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, delimiter);
}
function formatTimezone(offset2, delimiter = "") {
  const sign = offset2 > 0 ? "-" : "+";
  const absOffset = Math.abs(offset2);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options) {
  const defaultOptions2 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions2.locale ?? enUS$1;
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const originalDate = toDate(date, options?.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
function getDaysInMonth(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth = constructFrom(_date, 0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function getMonth(date, options) {
  return toDate(date, options?.in).getMonth();
}
function getYear(date, options) {
  return toDate(date, options?.in).getFullYear();
}
function isAfter(date, dateToCompare) {
  return +toDate(date) > +toDate(dateToCompare);
}
function isBefore(date, dateToCompare) {
  return +toDate(date) < +toDate(dateToCompare);
}
function isSameWeek(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return +startOfWeek(laterDate_, options) === +startOfWeek(earlierDate_, options);
}
function isSameMonth(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() === earlierDate_.getFullYear() && laterDate_.getMonth() === earlierDate_.getMonth();
}
function isSameYear(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() === earlierDate_.getFullYear();
}
function isToday(date, options) {
  return isSameDay(
    constructFrom(date, date),
    constructNow(date)
  );
}
function setMonth(date, month, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const midMonth = constructFrom(date, 0);
  midMonth.setFullYear(year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(midMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}
function setYear(date, year, options) {
  const date_ = toDate(date, options?.in);
  if (isNaN(+date_)) return constructFrom(date, NaN);
  date_.setFullYear(year);
  return date_;
}
function subMonths(date, amount, options) {
  return addMonths(date, -1, options);
}
const FIVE_WEEKS = 5;
const FOUR_WEEKS = 4;
function getBroadcastWeeksInMonth(month, dateLib) {
  const firstDayOfMonth = dateLib.startOfMonth(month);
  const firstDayOfWeek = firstDayOfMonth.getDay() > 0 ? firstDayOfMonth.getDay() : 7;
  const broadcastStartDate = dateLib.addDays(month, -firstDayOfWeek + 1);
  const lastDateOfLastWeek = dateLib.addDays(broadcastStartDate, FIVE_WEEKS * 7 - 1);
  const numberOfWeeks = dateLib.getMonth(month) === dateLib.getMonth(lastDateOfLastWeek) ? FIVE_WEEKS : FOUR_WEEKS;
  return numberOfWeeks;
}
function startOfBroadcastWeek(date, dateLib) {
  const firstOfMonth = dateLib.startOfMonth(date);
  const dayOfWeek = firstOfMonth.getDay();
  if (dayOfWeek === 1) {
    return firstOfMonth;
  } else if (dayOfWeek === 0) {
    return dateLib.addDays(firstOfMonth, -1 * 6);
  } else {
    return dateLib.addDays(firstOfMonth, -1 * (dayOfWeek - 1));
  }
}
function endOfBroadcastWeek(date, dateLib) {
  const startDate = startOfBroadcastWeek(date, dateLib);
  const numberOfWeeks = getBroadcastWeeksInMonth(date, dateLib);
  const endDate = dateLib.addDays(startDate, numberOfWeeks * 7 - 1);
  return endDate;
}
const formatDistanceLocale$3 = {
  lessThanXSeconds: {
    standalone: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden"
    },
    withPreposition: {
      one: "weniger als 1 Sekunde",
      other: "weniger als {{count}} Sekunden"
    }
  },
  xSeconds: {
    standalone: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden"
    },
    withPreposition: {
      one: "1 Sekunde",
      other: "{{count}} Sekunden"
    }
  },
  halfAMinute: {
    standalone: "eine halbe Minute",
    withPreposition: "einer halben Minute"
  },
  lessThanXMinutes: {
    standalone: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten"
    },
    withPreposition: {
      one: "weniger als 1 Minute",
      other: "weniger als {{count}} Minuten"
    }
  },
  xMinutes: {
    standalone: {
      one: "1 Minute",
      other: "{{count}} Minuten"
    },
    withPreposition: {
      one: "1 Minute",
      other: "{{count}} Minuten"
    }
  },
  aboutXHours: {
    standalone: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden"
    },
    withPreposition: {
      one: "etwa 1 Stunde",
      other: "etwa {{count}} Stunden"
    }
  },
  xHours: {
    standalone: {
      one: "1 Stunde",
      other: "{{count}} Stunden"
    },
    withPreposition: {
      one: "1 Stunde",
      other: "{{count}} Stunden"
    }
  },
  xDays: {
    standalone: {
      one: "1 Tag",
      other: "{{count}} Tage"
    },
    withPreposition: {
      one: "1 Tag",
      other: "{{count}} Tagen"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen"
    },
    withPreposition: {
      one: "etwa 1 Woche",
      other: "etwa {{count}} Wochen"
    }
  },
  xWeeks: {
    standalone: {
      one: "1 Woche",
      other: "{{count}} Wochen"
    },
    withPreposition: {
      one: "1 Woche",
      other: "{{count}} Wochen"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monate"
    },
    withPreposition: {
      one: "etwa 1 Monat",
      other: "etwa {{count}} Monaten"
    }
  },
  xMonths: {
    standalone: {
      one: "1 Monat",
      other: "{{count}} Monate"
    },
    withPreposition: {
      one: "1 Monat",
      other: "{{count}} Monaten"
    }
  },
  aboutXYears: {
    standalone: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahre"
    },
    withPreposition: {
      one: "etwa 1 Jahr",
      other: "etwa {{count}} Jahren"
    }
  },
  xYears: {
    standalone: {
      one: "1 Jahr",
      other: "{{count}} Jahre"
    },
    withPreposition: {
      one: "1 Jahr",
      other: "{{count}} Jahren"
    }
  },
  overXYears: {
    standalone: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahre"
    },
    withPreposition: {
      one: "mehr als 1 Jahr",
      other: "mehr als {{count}} Jahren"
    }
  },
  almostXYears: {
    standalone: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahre"
    },
    withPreposition: {
      one: "fast 1 Jahr",
      other: "fast {{count}} Jahren"
    }
  }
};
const formatDistance$3 = (token, count2, options) => {
  let result;
  const tokenValue = options?.addSuffix ? formatDistanceLocale$3[token].withPreposition : formatDistanceLocale$3[token].standalone;
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count2));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return "vor " + result;
    }
  }
  return result;
};
const dateFormats$3 = {
  full: "EEEE, do MMMM y",
  // Montag, 7. Januar 2018
  long: "do MMMM y",
  // 7. Januar 2018
  medium: "do MMM y",
  // 7. Jan. 2018
  short: "dd.MM.y"
  // 07.01.2018
};
const timeFormats$3 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$3 = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong$3 = {
  date: buildFormatLongFn({
    formats: dateFormats$3,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$3,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$3,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$3 = {
  lastWeek: "'letzten' eeee 'um' p",
  yesterday: "'gestern um' p",
  today: "'heute um' p",
  tomorrow: "'morgen um' p",
  nextWeek: "eeee 'um' p",
  other: "P"
};
const formatRelative$3 = (token, _date, _baseDate, _options) => formatRelativeLocale$3[token];
const eraValues$3 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"]
};
const quarterValues$3 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
};
const monthValues$3 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mär",
    "Apr",
    "Mai",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Okt",
    "Nov",
    "Dez"
  ],
  wide: [
    "Januar",
    "Februar",
    "März",
    "April",
    "Mai",
    "Juni",
    "Juli",
    "August",
    "September",
    "Oktober",
    "November",
    "Dezember"
  ]
};
const formattingMonthValues$1 = {
  narrow: monthValues$3.narrow,
  abbreviated: [
    "Jan.",
    "Feb.",
    "März",
    "Apr.",
    "Mai",
    "Juni",
    "Juli",
    "Aug.",
    "Sep.",
    "Okt.",
    "Nov.",
    "Dez."
  ],
  wide: monthValues$3.wide
};
const dayValues$3 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: [
    "Sonntag",
    "Montag",
    "Dienstag",
    "Mittwoch",
    "Donnerstag",
    "Freitag",
    "Samstag"
  ]
};
const dayPeriodValues$3 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  }
};
const formattingDayPeriodValues$3 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  }
};
const ordinalNumber$3 = (dirtyNumber) => {
  const number2 = Number(dirtyNumber);
  return number2 + ".";
};
const localize$3 = {
  ordinalNumber: ordinalNumber$3,
  era: buildLocalizeFn({
    values: eraValues$3,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$3,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$3,
    formattingValues: formattingMonthValues$1,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$3,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$3,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$3,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$3 = /^(\d+)(\.)?/i;
const parseOrdinalNumberPattern$3 = /\d+/i;
const matchEraPatterns$3 = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
};
const parseEraPatterns$3 = {
  any: [/^v/i, /^n/i]
};
const matchQuarterPatterns$3 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
const parseQuarterPatterns$3 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$3 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(j[aä]n|feb|mär[z]?|apr|mai|jun[i]?|jul[i]?|aug|sep|okt|nov|dez)\.?/i,
  wide: /^(januar|februar|märz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
};
const parseMonthPatterns$3 = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^j[aä]/i,
    /^f/i,
    /^mär/i,
    /^ap/i,
    /^mai/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns$3 = {
  narrow: /^[smdmf]/i,
  short: /^(so|mo|di|mi|do|fr|sa)/i,
  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
};
const parseDayPatterns$3 = {
  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns$3 = {
  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
};
const parseDayPeriodPatterns$3 = {
  any: {
    am: /^v/i,
    pm: /^n/i,
    midnight: /^Mitte/i,
    noon: /^Mitta/i,
    morning: /morgens/i,
    afternoon: /nachmittags/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /abends/i,
    night: /nachts/i
    // will never be matched. Night is matched by `pm`
  }
};
const match$3 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$3,
    parsePattern: parseOrdinalNumberPattern$3,
    valueCallback: (value) => parseInt(value)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$3,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$3,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$3,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$3,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$3,
    defaultParseWidth: "any"
  })
};
const de$3 = {
  code: "de",
  formatDistance: formatDistance$3,
  formatLong: formatLong$3,
  formatRelative: formatRelative$3,
  localize: localize$3,
  match: match$3,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const formatDistanceLocale$2 = {
  lessThanXSeconds: {
    one: "menos de un segundo",
    other: "menos de {{count}} segundos"
  },
  xSeconds: {
    one: "1 segundo",
    other: "{{count}} segundos"
  },
  halfAMinute: "medio minuto",
  lessThanXMinutes: {
    one: "menos de un minuto",
    other: "menos de {{count}} minutos"
  },
  xMinutes: {
    one: "1 minuto",
    other: "{{count}} minutos"
  },
  aboutXHours: {
    one: "alrededor de 1 hora",
    other: "alrededor de {{count}} horas"
  },
  xHours: {
    one: "1 hora",
    other: "{{count}} horas"
  },
  xDays: {
    one: "1 día",
    other: "{{count}} días"
  },
  aboutXWeeks: {
    one: "alrededor de 1 semana",
    other: "alrededor de {{count}} semanas"
  },
  xWeeks: {
    one: "1 semana",
    other: "{{count}} semanas"
  },
  aboutXMonths: {
    one: "alrededor de 1 mes",
    other: "alrededor de {{count}} meses"
  },
  xMonths: {
    one: "1 mes",
    other: "{{count}} meses"
  },
  aboutXYears: {
    one: "alrededor de 1 año",
    other: "alrededor de {{count}} años"
  },
  xYears: {
    one: "1 año",
    other: "{{count}} años"
  },
  overXYears: {
    one: "más de 1 año",
    other: "más de {{count}} años"
  },
  almostXYears: {
    one: "casi 1 año",
    other: "casi {{count}} años"
  }
};
const formatDistance$2 = (token, count2, options) => {
  let result;
  const tokenValue = formatDistanceLocale$2[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "en " + result;
    } else {
      return "hace " + result;
    }
  }
  return result;
};
const dateFormats$2 = {
  full: "EEEE, d 'de' MMMM 'de' y",
  long: "d 'de' MMMM 'de' y",
  medium: "d MMM y",
  short: "dd/MM/y"
};
const timeFormats$2 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
const dateTimeFormats$2 = {
  full: "{{date}} 'a las' {{time}}",
  long: "{{date}} 'a las' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong$2 = {
  date: buildFormatLongFn({
    formats: dateFormats$2,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$2,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$2,
    defaultWidth: "full"
  })
};
const formatRelativeLocale$2 = {
  lastWeek: "'el' eeee 'pasado a la' p",
  yesterday: "'ayer a la' p",
  today: "'hoy a la' p",
  tomorrow: "'mañana a la' p",
  nextWeek: "eeee 'a la' p",
  other: "P"
};
const formatRelativeLocalePlural = {
  lastWeek: "'el' eeee 'pasado a las' p",
  yesterday: "'ayer a las' p",
  today: "'hoy a las' p",
  tomorrow: "'mañana a las' p",
  nextWeek: "eeee 'a las' p",
  other: "P"
};
const formatRelative$2 = (token, date, _baseDate, _options) => {
  if (date.getHours() !== 1) {
    return formatRelativeLocalePlural[token];
  } else {
    return formatRelativeLocale$2[token];
  }
};
const eraValues$2 = {
  narrow: ["AC", "DC"],
  abbreviated: ["AC", "DC"],
  wide: ["antes de cristo", "después de cristo"]
};
const quarterValues$2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["T1", "T2", "T3", "T4"],
  wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
};
const monthValues$2 = {
  narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
  abbreviated: [
    "ene",
    "feb",
    "mar",
    "abr",
    "may",
    "jun",
    "jul",
    "ago",
    "sep",
    "oct",
    "nov",
    "dic"
  ],
  wide: [
    "enero",
    "febrero",
    "marzo",
    "abril",
    "mayo",
    "junio",
    "julio",
    "agosto",
    "septiembre",
    "octubre",
    "noviembre",
    "diciembre"
  ]
};
const dayValues$2 = {
  narrow: ["d", "l", "m", "m", "j", "v", "s"],
  short: ["do", "lu", "ma", "mi", "ju", "vi", "sá"],
  abbreviated: ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
  wide: [
    "domingo",
    "lunes",
    "martes",
    "miércoles",
    "jueves",
    "viernes",
    "sábado"
  ]
};
const dayPeriodValues$2 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "mañana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "mañana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "mañana",
    afternoon: "tarde",
    evening: "tarde",
    night: "noche"
  }
};
const formattingDayPeriodValues$2 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mn",
    noon: "md",
    morning: "de la mañana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la mañana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "medianoche",
    noon: "mediodia",
    morning: "de la mañana",
    afternoon: "de la tarde",
    evening: "de la tarde",
    night: "de la noche"
  }
};
const ordinalNumber$2 = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  return number2 + "º";
};
const localize$2 = {
  ordinalNumber: ordinalNumber$2,
  era: buildLocalizeFn({
    values: eraValues$2,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$2,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$2,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$2,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$2,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$2,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$2 = /^(\d+)(º)?/i;
const parseOrdinalNumberPattern$2 = /\d+/i;
const matchEraPatterns$2 = {
  narrow: /^(ac|dc|a|d)/i,
  abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
  wide: /^(antes de cristo|antes de la era com[uú]n|despu[eé]s de cristo|era com[uú]n)/i
};
const parseEraPatterns$2 = {
  any: [/^ac/i, /^dc/i],
  wide: [
    /^(antes de cristo|antes de la era com[uú]n)/i,
    /^(despu[eé]s de cristo|era com[uú]n)/i
  ]
};
const matchQuarterPatterns$2 = {
  narrow: /^[1234]/i,
  abbreviated: /^T[1234]/i,
  wide: /^[1234](º)? trimestre/i
};
const parseQuarterPatterns$2 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$2 = {
  narrow: /^[efmajsond]/i,
  abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
  wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
};
const parseMonthPatterns$2 = {
  narrow: [
    /^e/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^en/i,
    /^feb/i,
    /^mar/i,
    /^abr/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^ago/i,
    /^sep/i,
    /^oct/i,
    /^nov/i,
    /^dic/i
  ]
};
const matchDayPatterns$2 = {
  narrow: /^[dlmjvs]/i,
  short: /^(do|lu|ma|mi|ju|vi|s[áa])/i,
  abbreviated: /^(dom|lun|mar|mi[ée]|jue|vie|s[áa]b)/i,
  wide: /^(domingo|lunes|martes|mi[ée]rcoles|jueves|viernes|s[áa]bado)/i
};
const parseDayPatterns$2 = {
  narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
  any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
};
const matchDayPeriodPatterns$2 = {
  narrow: /^(a|p|mn|md|(de la|a las) (mañana|tarde|noche))/i,
  any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (mañana|tarde|noche))/i
};
const parseDayPeriodPatterns$2 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mn/i,
    noon: /^md/i,
    morning: /mañana/i,
    afternoon: /tarde/i,
    evening: /tarde/i,
    night: /noche/i
  }
};
const match$2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$2,
    parsePattern: parseOrdinalNumberPattern$2,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$2,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$2,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$2,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$2,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$2,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$2,
    defaultParseWidth: "any"
  })
};
const es$1 = {
  code: "es",
  formatDistance: formatDistance$2,
  formatLong: formatLong$2,
  formatRelative: formatRelative$2,
  localize: localize$2,
  match: match$2,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
function declension(scheme, count2) {
  if (scheme.one !== void 0 && count2 === 1) {
    return scheme.one;
  }
  const rem10 = count2 % 10;
  const rem100 = count2 % 100;
  if (rem10 === 1 && rem100 !== 11) {
    return scheme.singularNominative.replace("{{count}}", String(count2));
  } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
    return scheme.singularGenitive.replace("{{count}}", String(count2));
  } else {
    return scheme.pluralGenitive.replace("{{count}}", String(count2));
  }
}
function buildLocalizeTokenFn(scheme) {
  return (count2, options) => {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        if (scheme.future) {
          return declension(scheme.future, count2);
        } else {
          return "через " + declension(scheme.regular, count2);
        }
      } else {
        if (scheme.past) {
          return declension(scheme.past, count2);
        } else {
          return declension(scheme.regular, count2) + " назад";
        }
      }
    } else {
      return declension(scheme.regular, count2);
    }
  };
}
const formatDistanceLocale$1 = {
  lessThanXSeconds: buildLocalizeTokenFn({
    regular: {
      one: "меньше секунды",
      singularNominative: "меньше {{count}} секунды",
      singularGenitive: "меньше {{count}} секунд",
      pluralGenitive: "меньше {{count}} секунд"
    },
    future: {
      one: "меньше, чем через секунду",
      singularNominative: "меньше, чем через {{count}} секунду",
      singularGenitive: "меньше, чем через {{count}} секунды",
      pluralGenitive: "меньше, чем через {{count}} секунд"
    }
  }),
  xSeconds: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} секунда",
      singularGenitive: "{{count}} секунды",
      pluralGenitive: "{{count}} секунд"
    },
    past: {
      singularNominative: "{{count}} секунду назад",
      singularGenitive: "{{count}} секунды назад",
      pluralGenitive: "{{count}} секунд назад"
    },
    future: {
      singularNominative: "через {{count}} секунду",
      singularGenitive: "через {{count}} секунды",
      pluralGenitive: "через {{count}} секунд"
    }
  }),
  halfAMinute: (_count, options) => {
    if (options?.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "через полминуты";
      } else {
        return "полминуты назад";
      }
    }
    return "полминуты";
  },
  lessThanXMinutes: buildLocalizeTokenFn({
    regular: {
      one: "меньше минуты",
      singularNominative: "меньше {{count}} минуты",
      singularGenitive: "меньше {{count}} минут",
      pluralGenitive: "меньше {{count}} минут"
    },
    future: {
      one: "меньше, чем через минуту",
      singularNominative: "меньше, чем через {{count}} минуту",
      singularGenitive: "меньше, чем через {{count}} минуты",
      pluralGenitive: "меньше, чем через {{count}} минут"
    }
  }),
  xMinutes: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} минута",
      singularGenitive: "{{count}} минуты",
      pluralGenitive: "{{count}} минут"
    },
    past: {
      singularNominative: "{{count}} минуту назад",
      singularGenitive: "{{count}} минуты назад",
      pluralGenitive: "{{count}} минут назад"
    },
    future: {
      singularNominative: "через {{count}} минуту",
      singularGenitive: "через {{count}} минуты",
      pluralGenitive: "через {{count}} минут"
    }
  }),
  aboutXHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "около {{count}} часа",
      singularGenitive: "около {{count}} часов",
      pluralGenitive: "около {{count}} часов"
    },
    future: {
      singularNominative: "приблизительно через {{count}} час",
      singularGenitive: "приблизительно через {{count}} часа",
      pluralGenitive: "приблизительно через {{count}} часов"
    }
  }),
  xHours: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} час",
      singularGenitive: "{{count}} часа",
      pluralGenitive: "{{count}} часов"
    }
  }),
  xDays: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} день",
      singularGenitive: "{{count}} дня",
      pluralGenitive: "{{count}} дней"
    }
  }),
  aboutXWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "около {{count}} недели",
      singularGenitive: "около {{count}} недель",
      pluralGenitive: "около {{count}} недель"
    },
    future: {
      singularNominative: "приблизительно через {{count}} неделю",
      singularGenitive: "приблизительно через {{count}} недели",
      pluralGenitive: "приблизительно через {{count}} недель"
    }
  }),
  xWeeks: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} неделя",
      singularGenitive: "{{count}} недели",
      pluralGenitive: "{{count}} недель"
    }
  }),
  aboutXMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "около {{count}} месяца",
      singularGenitive: "около {{count}} месяцев",
      pluralGenitive: "около {{count}} месяцев"
    },
    future: {
      singularNominative: "приблизительно через {{count}} месяц",
      singularGenitive: "приблизительно через {{count}} месяца",
      pluralGenitive: "приблизительно через {{count}} месяцев"
    }
  }),
  xMonths: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} месяц",
      singularGenitive: "{{count}} месяца",
      pluralGenitive: "{{count}} месяцев"
    }
  }),
  aboutXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "около {{count}} года",
      singularGenitive: "около {{count}} лет",
      pluralGenitive: "около {{count}} лет"
    },
    future: {
      singularNominative: "приблизительно через {{count}} год",
      singularGenitive: "приблизительно через {{count}} года",
      pluralGenitive: "приблизительно через {{count}} лет"
    }
  }),
  xYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "{{count}} год",
      singularGenitive: "{{count}} года",
      pluralGenitive: "{{count}} лет"
    }
  }),
  overXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "больше {{count}} года",
      singularGenitive: "больше {{count}} лет",
      pluralGenitive: "больше {{count}} лет"
    },
    future: {
      singularNominative: "больше, чем через {{count}} год",
      singularGenitive: "больше, чем через {{count}} года",
      pluralGenitive: "больше, чем через {{count}} лет"
    }
  }),
  almostXYears: buildLocalizeTokenFn({
    regular: {
      singularNominative: "почти {{count}} год",
      singularGenitive: "почти {{count}} года",
      pluralGenitive: "почти {{count}} лет"
    },
    future: {
      singularNominative: "почти через {{count}} год",
      singularGenitive: "почти через {{count}} года",
      pluralGenitive: "почти через {{count}} лет"
    }
  })
};
const formatDistance$1 = (token, count2, options) => {
  return formatDistanceLocale$1[token](count2, options);
};
const dateFormats$1 = {
  full: "EEEE, d MMMM y 'г.'",
  long: "d MMMM y 'г.'",
  medium: "d MMM y 'г.'",
  short: "dd.MM.y"
};
const timeFormats$1 = {
  full: "H:mm:ss zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
const dateTimeFormats$1 = {
  any: "{{date}}, {{time}}"
};
const formatLong$1 = {
  date: buildFormatLongFn({
    formats: dateFormats$1,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1,
    defaultWidth: "any"
  })
};
const accusativeWeekdays = [
  "воскресенье",
  "понедельник",
  "вторник",
  "среду",
  "четверг",
  "пятницу",
  "субботу"
];
function lastWeek(day) {
  const weekday = accusativeWeekdays[day];
  switch (day) {
    case 0:
      return "'в прошлое " + weekday + " в' p";
    case 1:
    case 2:
    case 4:
      return "'в прошлый " + weekday + " в' p";
    case 3:
    case 5:
    case 6:
      return "'в прошлую " + weekday + " в' p";
  }
}
function thisWeek(day) {
  const weekday = accusativeWeekdays[day];
  if (day === 2) {
    return "'во " + weekday + " в' p";
  } else {
    return "'в " + weekday + " в' p";
  }
}
function nextWeek(day) {
  const weekday = accusativeWeekdays[day];
  switch (day) {
    case 0:
      return "'в следующее " + weekday + " в' p";
    case 1:
    case 2:
    case 4:
      return "'в следующий " + weekday + " в' p";
    case 3:
    case 5:
    case 6:
      return "'в следующую " + weekday + " в' p";
  }
}
const formatRelativeLocale$1 = {
  lastWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options)) {
      return thisWeek(day);
    } else {
      return lastWeek(day);
    }
  },
  yesterday: "'вчера в' p",
  today: "'сегодня в' p",
  tomorrow: "'завтра в' p",
  nextWeek: (date, baseDate, options) => {
    const day = date.getDay();
    if (isSameWeek(date, baseDate, options)) {
      return thisWeek(day);
    } else {
      return nextWeek(day);
    }
  },
  other: "P"
};
const formatRelative$1 = (token, date, baseDate, options) => {
  const format2 = formatRelativeLocale$1[token];
  if (typeof format2 === "function") {
    return format2(date, baseDate, options);
  }
  return format2;
};
const eraValues$1 = {
  narrow: ["до н.э.", "н.э."],
  abbreviated: ["до н. э.", "н. э."],
  wide: ["до нашей эры", "нашей эры"]
};
const quarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["1-й кв.", "2-й кв.", "3-й кв.", "4-й кв."],
  wide: ["1-й квартал", "2-й квартал", "3-й квартал", "4-й квартал"]
};
const monthValues$1 = {
  narrow: ["Я", "Ф", "М", "А", "М", "И", "И", "А", "С", "О", "Н", "Д"],
  abbreviated: [
    "янв.",
    "фев.",
    "март",
    "апр.",
    "май",
    "июнь",
    "июль",
    "авг.",
    "сент.",
    "окт.",
    "нояб.",
    "дек."
  ],
  wide: [
    "январь",
    "февраль",
    "март",
    "апрель",
    "май",
    "июнь",
    "июль",
    "август",
    "сентябрь",
    "октябрь",
    "ноябрь",
    "декабрь"
  ]
};
const formattingMonthValues = {
  narrow: ["Я", "Ф", "М", "А", "М", "И", "И", "А", "С", "О", "Н", "Д"],
  abbreviated: [
    "янв.",
    "фев.",
    "мар.",
    "апр.",
    "мая",
    "июн.",
    "июл.",
    "авг.",
    "сент.",
    "окт.",
    "нояб.",
    "дек."
  ],
  wide: [
    "января",
    "февраля",
    "марта",
    "апреля",
    "мая",
    "июня",
    "июля",
    "августа",
    "сентября",
    "октября",
    "ноября",
    "декабря"
  ]
};
const dayValues$1 = {
  narrow: ["В", "П", "В", "С", "Ч", "П", "С"],
  short: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
  abbreviated: ["вск", "пнд", "втр", "срд", "чтв", "птн", "суб"],
  wide: [
    "воскресенье",
    "понедельник",
    "вторник",
    "среда",
    "четверг",
    "пятница",
    "суббота"
  ]
};
const dayPeriodValues$1 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "полн.",
    noon: "полд.",
    morning: "утро",
    afternoon: "день",
    evening: "веч.",
    night: "ночь"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "полн.",
    noon: "полд.",
    morning: "утро",
    afternoon: "день",
    evening: "веч.",
    night: "ночь"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "полночь",
    noon: "полдень",
    morning: "утро",
    afternoon: "день",
    evening: "вечер",
    night: "ночь"
  }
};
const formattingDayPeriodValues$1 = {
  narrow: {
    am: "ДП",
    pm: "ПП",
    midnight: "полн.",
    noon: "полд.",
    morning: "утра",
    afternoon: "дня",
    evening: "веч.",
    night: "ночи"
  },
  abbreviated: {
    am: "ДП",
    pm: "ПП",
    midnight: "полн.",
    noon: "полд.",
    morning: "утра",
    afternoon: "дня",
    evening: "веч.",
    night: "ночи"
  },
  wide: {
    am: "ДП",
    pm: "ПП",
    midnight: "полночь",
    noon: "полдень",
    morning: "утра",
    afternoon: "дня",
    evening: "вечера",
    night: "ночи"
  }
};
const ordinalNumber$1 = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  const unit = options?.unit;
  let suffix;
  if (unit === "date") {
    suffix = "-е";
  } else if (unit === "week" || unit === "minute" || unit === "second") {
    suffix = "-я";
  } else {
    suffix = "-й";
  }
  return number2 + suffix;
};
const localize$1 = {
  ordinalNumber: ordinalNumber$1,
  era: buildLocalizeFn({
    values: eraValues$1,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues$1,
    defaultWidth: "wide",
    formattingValues: formattingMonthValues,
    defaultFormattingWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1,
    defaultWidth: "any",
    formattingValues: formattingDayPeriodValues$1,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern$1 = /^(\d+)(-?(е|я|й|ое|ье|ая|ья|ый|ой|ий|ый))?/i;
const parseOrdinalNumberPattern$1 = /\d+/i;
const matchEraPatterns$1 = {
  narrow: /^((до )?н\.?\s?э\.?)/i,
  abbreviated: /^((до )?н\.?\s?э\.?)/i,
  wide: /^(до нашей эры|нашей эры|наша эра)/i
};
const parseEraPatterns$1 = {
  any: [/^д/i, /^н/i]
};
const matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^[1234](-?[ыои]?й?)? кв.?/i,
  wide: /^[1234](-?[ыои]?й?)? квартал/i
};
const parseQuarterPatterns$1 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns$1 = {
  narrow: /^[яфмаисонд]/i,
  abbreviated: /^(янв|фев|март?|апр|ма[йя]|июн[ья]?|июл[ья]?|авг|сент?|окт|нояб?|дек)\.?/i,
  wide: /^(январ[ья]|феврал[ья]|марта?|апрел[ья]|ма[йя]|июн[ья]|июл[ья]|августа?|сентябр[ья]|октябр[ья]|октябр[ья]|ноябр[ья]|декабр[ья])/i
};
const parseMonthPatterns$1 = {
  narrow: [
    /^я/i,
    /^ф/i,
    /^м/i,
    /^а/i,
    /^м/i,
    /^и/i,
    /^и/i,
    /^а/i,
    /^с/i,
    /^о/i,
    /^н/i,
    /^я/i
  ],
  any: [
    /^я/i,
    /^ф/i,
    /^мар/i,
    /^ап/i,
    /^ма[йя]/i,
    /^июн/i,
    /^июл/i,
    /^ав/i,
    /^с/i,
    /^о/i,
    /^н/i,
    /^д/i
  ]
};
const matchDayPatterns$1 = {
  narrow: /^[впсч]/i,
  short: /^(вс|во|пн|по|вт|ср|чт|че|пт|пя|сб|су)\.?/i,
  abbreviated: /^(вск|вос|пнд|пон|втр|вто|срд|сре|чтв|чет|птн|пят|суб).?/i,
  wide: /^(воскресень[ея]|понедельника?|вторника?|сред[аы]|четверга?|пятниц[аы]|суббот[аы])/i
};
const parseDayPatterns$1 = {
  narrow: [/^в/i, /^п/i, /^в/i, /^с/i, /^ч/i, /^п/i, /^с/i],
  any: [/^в[ос]/i, /^п[он]/i, /^в/i, /^ср/i, /^ч/i, /^п[ят]/i, /^с[уб]/i]
};
const matchDayPeriodPatterns$1 = {
  narrow: /^([дп]п|полн\.?|полд\.?|утр[оа]|день|дня|веч\.?|ноч[ьи])/i,
  abbreviated: /^([дп]п|полн\.?|полд\.?|утр[оа]|день|дня|веч\.?|ноч[ьи])/i,
  wide: /^([дп]п|полночь|полдень|утр[оа]|день|дня|вечера?|ноч[ьи])/i
};
const parseDayPeriodPatterns$1 = {
  any: {
    am: /^дп/i,
    pm: /^пп/i,
    midnight: /^полн/i,
    noon: /^полд/i,
    morning: /^у/i,
    afternoon: /^д[ен]/i,
    evening: /^в/i,
    night: /^н/i
  }
};
const match$1 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: "any"
  })
};
const ru$1 = {
  code: "ru",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 1
  }
};
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "不到 1 秒",
    other: "不到 {{count}} 秒"
  },
  xSeconds: {
    one: "1 秒",
    other: "{{count}} 秒"
  },
  halfAMinute: "半分钟",
  lessThanXMinutes: {
    one: "不到 1 分钟",
    other: "不到 {{count}} 分钟"
  },
  xMinutes: {
    one: "1 分钟",
    other: "{{count}} 分钟"
  },
  xHours: {
    one: "1 小时",
    other: "{{count}} 小时"
  },
  aboutXHours: {
    one: "大约 1 小时",
    other: "大约 {{count}} 小时"
  },
  xDays: {
    one: "1 天",
    other: "{{count}} 天"
  },
  aboutXWeeks: {
    one: "大约 1 个星期",
    other: "大约 {{count}} 个星期"
  },
  xWeeks: {
    one: "1 个星期",
    other: "{{count}} 个星期"
  },
  aboutXMonths: {
    one: "大约 1 个月",
    other: "大约 {{count}} 个月"
  },
  xMonths: {
    one: "1 个月",
    other: "{{count}} 个月"
  },
  aboutXYears: {
    one: "大约 1 年",
    other: "大约 {{count}} 年"
  },
  xYears: {
    one: "1 年",
    other: "{{count}} 年"
  },
  overXYears: {
    one: "超过 1 年",
    other: "超过 {{count}} 年"
  },
  almostXYears: {
    one: "将近 1 年",
    other: "将近 {{count}} 年"
  }
};
const formatDistance = (token, count2, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count2));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "内";
    } else {
      return result + "前";
    }
  }
  return result;
};
const dateFormats = {
  full: "y'年'M'月'd'日' EEEE",
  long: "y'年'M'月'd'日'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
const timeFormats = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
const dateTimeFormats = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
function checkWeek(date, baseDate, options) {
  const baseFormat = "eeee p";
  if (isSameWeek(date, baseDate, options)) {
    return baseFormat;
  } else if (date.getTime() > baseDate.getTime()) {
    return "'下个'" + baseFormat;
  }
  return "'上个'" + baseFormat;
}
const formatRelativeLocale = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'昨天' p",
  today: "'今天' p",
  tomorrow: "'明天' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: "PP p"
};
const formatRelative = (token, date, baseDate, options) => {
  const format2 = formatRelativeLocale[token];
  if (typeof format2 === "function") {
    return format2(date, baseDate, options);
  }
  return format2;
};
const eraValues = {
  narrow: ["前", "公元"],
  abbreviated: ["前", "公元"],
  wide: ["公元前", "公元"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["第一季", "第二季", "第三季", "第四季"],
  wide: ["第一季度", "第二季度", "第三季度", "第四季度"]
};
const monthValues = {
  narrow: [
    "一",
    "二",
    "三",
    "四",
    "五",
    "六",
    "七",
    "八",
    "九",
    "十",
    "十一",
    "十二"
  ],
  abbreviated: [
    "1月",
    "2月",
    "3月",
    "4月",
    "5月",
    "6月",
    "7月",
    "8月",
    "9月",
    "10月",
    "11月",
    "12月"
  ],
  wide: [
    "一月",
    "二月",
    "三月",
    "四月",
    "五月",
    "六月",
    "七月",
    "八月",
    "九月",
    "十月",
    "十一月",
    "十二月"
  ]
};
const dayValues = {
  narrow: ["日", "一", "二", "三", "四", "五", "六"],
  short: ["日", "一", "二", "三", "四", "五", "六"],
  abbreviated: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
  wide: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
};
const dayPeriodValues = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "凌晨",
    noon: "午",
    morning: "早",
    afternoon: "下午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "凌晨",
    noon: "午",
    morning: "早",
    afternoon: "下午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  }
};
const ordinalNumber = (dirtyNumber, options) => {
  const number2 = Number(dirtyNumber);
  switch (options?.unit) {
    case "date":
      return number2.toString() + "日";
    case "hour":
      return number2.toString() + "时";
    case "minute":
      return number2.toString() + "分";
    case "second":
      return number2.toString() + "秒";
    default:
      return "第 " + number2.toString();
  }
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
const matchOrdinalNumberPattern = /^(第\s*)?\d+(日|时|分|秒)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
const parseEraPatterns = {
  any: [/^(前)/i, /^(公元)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻钟/i
};
const parseQuarterPatterns = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
const matchMonthPatterns = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
const parseMonthPatterns = {
  narrow: [
    /^一/i,
    /^二/i,
    /^三/i,
    /^四/i,
    /^五/i,
    /^六/i,
    /^七/i,
    /^八/i,
    /^九/i,
    /^十(?!(一|二))/i,
    /^十一/i,
    /^十二/i
  ],
  any: [
    /^一|1/i,
    /^二|2/i,
    /^三|3/i,
    /^四|4/i,
    /^五|5/i,
    /^六|6/i,
    /^七|7/i,
    /^八|8/i,
    /^九|9/i,
    /^十(?!(一|二))|10/i,
    /^十一|11/i,
    /^十二|12/i
  ]
};
const matchDayPatterns = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^周[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
const parseDayPatterns = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
const matchDayPeriodPatterns = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const zhCN$1 = {
  code: "zh-CN",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const enUS = {
  ...enUS$1,
  labels: {
    labelDayButton: (date, modifiers, options, dateLib) => {
      let formatDate2;
      if (dateLib && typeof dateLib.format === "function") {
        formatDate2 = dateLib.format.bind(dateLib);
      } else {
        formatDate2 = (d2, pattern) => format(d2, pattern, { locale: enUS$1, ...options });
      }
      let label = formatDate2(date, "PPPP");
      if (modifiers.today)
        label = `Today, ${label}`;
      if (modifiers.selected)
        label = `${label}, selected`;
      return label;
    },
    labelMonthDropdown: "Choose the Month",
    labelNext: "Go to the Next Month",
    labelPrevious: "Go to the Previous Month",
    labelWeekNumber: (weekNumber) => `Week ${weekNumber}`,
    labelYearDropdown: "Choose the Year",
    labelGrid: (date, options, dateLib) => {
      let formatDate2;
      if (dateLib && typeof dateLib.format === "function") {
        formatDate2 = dateLib.format.bind(dateLib);
      } else {
        formatDate2 = (d2, pattern) => format(d2, pattern, { locale: enUS$1, ...options });
      }
      return formatDate2(date, "LLLL yyyy");
    },
    labelGridcell: (date, modifiers, options, dateLib) => {
      let formatDate2;
      if (dateLib && typeof dateLib.format === "function") {
        formatDate2 = dateLib.format.bind(dateLib);
      } else {
        formatDate2 = (d2, pattern) => format(d2, pattern, { locale: enUS$1, ...options });
      }
      let label = formatDate2(date, "PPPP");
      if (modifiers?.today) {
        label = `Today, ${label}`;
      }
      return label;
    },
    labelNav: "Navigation bar",
    labelWeekNumberHeader: "Week Number",
    labelWeekday: (date, options, dateLib) => {
      let formatDate2;
      if (dateLib && typeof dateLib.format === "function") {
        formatDate2 = dateLib.format.bind(dateLib);
      } else {
        formatDate2 = (d2, pattern) => format(d2, pattern, { locale: enUS$1, ...options });
      }
      return formatDate2(date, "cccc");
    }
  }
};
class DateLib {
  /**
   * Creates an instance of `DateLib`.
   *
   * @param options Configuration options for the date library.
   * @param overrides Custom overrides for the date library functions.
   */
  constructor(options, overrides) {
    this.Date = Date;
    this.today = () => {
      if (this.overrides?.today) {
        return this.overrides.today();
      }
      if (this.options.timeZone) {
        return TZDate.tz(this.options.timeZone);
      }
      return new this.Date();
    };
    this.newDate = (year, monthIndex, date) => {
      if (this.overrides?.newDate) {
        return this.overrides.newDate(year, monthIndex, date);
      }
      if (this.options.timeZone) {
        return new TZDate(year, monthIndex, date, this.options.timeZone);
      }
      return new Date(year, monthIndex, date);
    };
    this.addDays = (date, amount) => {
      return this.overrides?.addDays ? this.overrides.addDays(date, amount) : addDays(date, amount);
    };
    this.addMonths = (date, amount) => {
      return this.overrides?.addMonths ? this.overrides.addMonths(date, amount) : addMonths(date, amount);
    };
    this.addWeeks = (date, amount) => {
      return this.overrides?.addWeeks ? this.overrides.addWeeks(date, amount) : addWeeks(date, amount);
    };
    this.addYears = (date, amount) => {
      return this.overrides?.addYears ? this.overrides.addYears(date, amount) : addYears(date, amount);
    };
    this.differenceInCalendarDays = (dateLeft, dateRight) => {
      return this.overrides?.differenceInCalendarDays ? this.overrides.differenceInCalendarDays(dateLeft, dateRight) : differenceInCalendarDays(dateLeft, dateRight);
    };
    this.differenceInCalendarMonths = (dateLeft, dateRight) => {
      return this.overrides?.differenceInCalendarMonths ? this.overrides.differenceInCalendarMonths(dateLeft, dateRight) : differenceInCalendarMonths(dateLeft, dateRight);
    };
    this.eachMonthOfInterval = (interval) => {
      return this.overrides?.eachMonthOfInterval ? this.overrides.eachMonthOfInterval(interval) : eachMonthOfInterval(interval);
    };
    this.eachYearOfInterval = (interval) => {
      const years = this.overrides?.eachYearOfInterval ? this.overrides.eachYearOfInterval(interval) : eachYearOfInterval(interval);
      const uniqueYears = new Set(years.map((d2) => this.getYear(d2)));
      if (uniqueYears.size === years.length) {
        return years;
      }
      const yearsArray = [];
      uniqueYears.forEach((y2) => {
        yearsArray.push(new Date(y2, 0, 1));
      });
      return yearsArray;
    };
    this.endOfBroadcastWeek = (date) => {
      return this.overrides?.endOfBroadcastWeek ? this.overrides.endOfBroadcastWeek(date) : endOfBroadcastWeek(date, this);
    };
    this.endOfISOWeek = (date) => {
      return this.overrides?.endOfISOWeek ? this.overrides.endOfISOWeek(date) : endOfISOWeek(date);
    };
    this.endOfMonth = (date) => {
      return this.overrides?.endOfMonth ? this.overrides.endOfMonth(date) : endOfMonth(date);
    };
    this.endOfWeek = (date, options2) => {
      return this.overrides?.endOfWeek ? this.overrides.endOfWeek(date, options2) : endOfWeek(date, this.options);
    };
    this.endOfYear = (date) => {
      return this.overrides?.endOfYear ? this.overrides.endOfYear(date) : endOfYear(date);
    };
    this.format = (date, formatStr, _options) => {
      const formatted = this.overrides?.format ? this.overrides.format(date, formatStr, this.options) : format(date, formatStr, this.options);
      if (this.options.numerals && this.options.numerals !== "latn") {
        return this.replaceDigits(formatted);
      }
      return formatted;
    };
    this.getISOWeek = (date) => {
      return this.overrides?.getISOWeek ? this.overrides.getISOWeek(date) : getISOWeek(date);
    };
    this.getMonth = (date, _options) => {
      return this.overrides?.getMonth ? this.overrides.getMonth(date, this.options) : getMonth(date, this.options);
    };
    this.getYear = (date, _options) => {
      return this.overrides?.getYear ? this.overrides.getYear(date, this.options) : getYear(date, this.options);
    };
    this.getWeek = (date, _options) => {
      return this.overrides?.getWeek ? this.overrides.getWeek(date, this.options) : getWeek(date, this.options);
    };
    this.isAfter = (date, dateToCompare) => {
      return this.overrides?.isAfter ? this.overrides.isAfter(date, dateToCompare) : isAfter(date, dateToCompare);
    };
    this.isBefore = (date, dateToCompare) => {
      return this.overrides?.isBefore ? this.overrides.isBefore(date, dateToCompare) : isBefore(date, dateToCompare);
    };
    this.isDate = (value) => {
      return this.overrides?.isDate ? this.overrides.isDate(value) : isDate(value);
    };
    this.isSameDay = (dateLeft, dateRight) => {
      return this.overrides?.isSameDay ? this.overrides.isSameDay(dateLeft, dateRight) : isSameDay(dateLeft, dateRight);
    };
    this.isSameMonth = (dateLeft, dateRight) => {
      return this.overrides?.isSameMonth ? this.overrides.isSameMonth(dateLeft, dateRight) : isSameMonth(dateLeft, dateRight);
    };
    this.isSameYear = (dateLeft, dateRight) => {
      return this.overrides?.isSameYear ? this.overrides.isSameYear(dateLeft, dateRight) : isSameYear(dateLeft, dateRight);
    };
    this.max = (dates) => {
      return this.overrides?.max ? this.overrides.max(dates) : max$1(dates);
    };
    this.min = (dates) => {
      return this.overrides?.min ? this.overrides.min(dates) : min$1(dates);
    };
    this.setMonth = (date, month) => {
      return this.overrides?.setMonth ? this.overrides.setMonth(date, month) : setMonth(date, month);
    };
    this.setYear = (date, year) => {
      return this.overrides?.setYear ? this.overrides.setYear(date, year) : setYear(date, year);
    };
    this.startOfBroadcastWeek = (date, _dateLib) => {
      return this.overrides?.startOfBroadcastWeek ? this.overrides.startOfBroadcastWeek(date, this) : startOfBroadcastWeek(date, this);
    };
    this.startOfDay = (date) => {
      return this.overrides?.startOfDay ? this.overrides.startOfDay(date) : startOfDay(date);
    };
    this.startOfISOWeek = (date) => {
      return this.overrides?.startOfISOWeek ? this.overrides.startOfISOWeek(date) : startOfISOWeek(date);
    };
    this.startOfMonth = (date) => {
      return this.overrides?.startOfMonth ? this.overrides.startOfMonth(date) : startOfMonth(date);
    };
    this.startOfWeek = (date, _options) => {
      return this.overrides?.startOfWeek ? this.overrides.startOfWeek(date, this.options) : startOfWeek(date, this.options);
    };
    this.startOfYear = (date) => {
      return this.overrides?.startOfYear ? this.overrides.startOfYear(date) : startOfYear(date);
    };
    this.options = { locale: enUS, ...options };
    this.overrides = overrides;
  }
  /**
   * Generates a mapping of Arabic digits (0-9) to the target numbering system
   * digits.
   *
   * @since 9.5.0
   * @returns A record mapping Arabic digits to the target numerals.
   */
  getDigitMap() {
    const { numerals = "latn" } = this.options;
    const formatter = new Intl.NumberFormat("en-US", {
      numberingSystem: numerals
    });
    const digitMap = {};
    for (let i2 = 0; i2 < 10; i2++) {
      digitMap[i2.toString()] = formatter.format(i2);
    }
    return digitMap;
  }
  /**
   * Replaces Arabic digits in a string with the target numbering system digits.
   *
   * @since 9.5.0
   * @param input The string containing Arabic digits.
   * @returns The string with digits replaced.
   */
  replaceDigits(input) {
    const digitMap = this.getDigitMap();
    return input.replace(/\d/g, (digit) => digitMap[digit] || digit);
  }
  /**
   * Formats a number using the configured numbering system.
   *
   * @since 9.5.0
   * @param value The number to format.
   * @returns The formatted number as a string.
   */
  formatNumber(value) {
    return this.replaceDigits(value.toString());
  }
  /**
   * Returns the preferred ordering for month and year labels for the current
   * locale.
   */
  getMonthYearOrder() {
    const code = this.options.locale?.code;
    if (!code) {
      return "month-first";
    }
    return DateLib.yearFirstLocales.has(code) ? "year-first" : "month-first";
  }
  /**
   * Formats the month/year pair respecting locale conventions.
   *
   * @since 9.11.0
   */
  formatMonthYear(date) {
    const { locale, timeZone, numerals } = this.options;
    const localeCode = locale?.code;
    if (localeCode && DateLib.yearFirstLocales.has(localeCode)) {
      try {
        const intl = new Intl.DateTimeFormat(localeCode, {
          month: "long",
          year: "numeric",
          timeZone,
          numberingSystem: numerals
        });
        const formatted = intl.format(date);
        return formatted;
      } catch {
      }
    }
    const pattern = this.getMonthYearOrder() === "year-first" ? "y LLLL" : "LLLL y";
    return this.format(date, pattern);
  }
}
DateLib.yearFirstLocales = /* @__PURE__ */ new Set([
  "eu",
  "hu",
  "ja",
  "ja-Hira",
  "ja-JP",
  "ko",
  "ko-KR",
  "lt",
  "lt-LT",
  "lv",
  "lv-LV",
  "mn",
  "mn-MN",
  "zh",
  "zh-CN",
  "zh-HK",
  "zh-TW"
]);
const defaultDateLib = new DateLib();
class CalendarDay {
  constructor(date, displayMonth, dateLib = defaultDateLib) {
    this.date = date;
    this.displayMonth = displayMonth;
    this.outside = Boolean(displayMonth && !dateLib.isSameMonth(date, displayMonth));
    this.dateLib = dateLib;
    this.isoDate = dateLib.format(date, "yyyy-MM-dd");
    this.displayMonthId = dateLib.format(displayMonth, "yyyy-MM");
    this.dateMonthId = dateLib.format(date, "yyyy-MM");
  }
  /**
   * Checks if this day is equal to another `CalendarDay`, considering both the
   * date and the displayed month.
   *
   * @param day The `CalendarDay` to compare with.
   * @returns `true` if the days are equal, otherwise `false`.
   */
  isEqualTo(day) {
    return this.dateLib.isSameDay(day.date, this.date) && this.dateLib.isSameMonth(day.displayMonth, this.displayMonth);
  }
}
class CalendarMonth {
  constructor(month, weeks) {
    this.date = month;
    this.weeks = weeks;
  }
}
class CalendarWeek {
  constructor(weekNumber, days) {
    this.days = days;
    this.weekNumber = weekNumber;
  }
}
function Button(props) {
  return React__default.createElement("button", { ...props });
}
function CaptionLabel(props) {
  return React__default.createElement("span", { ...props });
}
function Chevron(props) {
  const { size: size2 = 24, orientation = "left", className } = props;
  return (
    // biome-ignore lint/a11y/noSvgWithoutTitle: handled by the parent component
    React__default.createElement(
      "svg",
      { className, width: size2, height: size2, viewBox: "0 0 24 24" },
      orientation === "up" && React__default.createElement("polygon", { points: "6.77 17 12.5 11.43 18.24 17 20 15.28 12.5 8 5 15.28" }),
      orientation === "down" && React__default.createElement("polygon", { points: "6.77 8 12.5 13.57 18.24 8 20 9.72 12.5 17 5 9.72" }),
      orientation === "left" && React__default.createElement("polygon", { points: "16 18.112 9.81111111 12 16 5.87733333 14.0888889 4 6 12 14.0888889 20" }),
      orientation === "right" && React__default.createElement("polygon", { points: "8 18.112 14.18888889 12 8 5.87733333 9.91111111 4 18 12 9.91111111 20" })
    )
  );
}
function Day(props) {
  const { day, modifiers, ...tdProps } = props;
  return React__default.createElement("td", { ...tdProps });
}
function DayButton(props) {
  const { day, modifiers, ...buttonProps } = props;
  const ref = React__default.useRef(null);
  React__default.useEffect(() => {
    if (modifiers.focused)
      ref.current?.focus();
  }, [modifiers.focused]);
  return React__default.createElement("button", { ref, ...buttonProps });
}
var UI;
(function(UI2) {
  UI2["Root"] = "root";
  UI2["Chevron"] = "chevron";
  UI2["Day"] = "day";
  UI2["DayButton"] = "day_button";
  UI2["CaptionLabel"] = "caption_label";
  UI2["Dropdowns"] = "dropdowns";
  UI2["Dropdown"] = "dropdown";
  UI2["DropdownRoot"] = "dropdown_root";
  UI2["Footer"] = "footer";
  UI2["MonthGrid"] = "month_grid";
  UI2["MonthCaption"] = "month_caption";
  UI2["MonthsDropdown"] = "months_dropdown";
  UI2["Month"] = "month";
  UI2["Months"] = "months";
  UI2["Nav"] = "nav";
  UI2["NextMonthButton"] = "button_next";
  UI2["PreviousMonthButton"] = "button_previous";
  UI2["Week"] = "week";
  UI2["Weeks"] = "weeks";
  UI2["Weekday"] = "weekday";
  UI2["Weekdays"] = "weekdays";
  UI2["WeekNumber"] = "week_number";
  UI2["WeekNumberHeader"] = "week_number_header";
  UI2["YearsDropdown"] = "years_dropdown";
})(UI || (UI = {}));
var DayFlag;
(function(DayFlag2) {
  DayFlag2["disabled"] = "disabled";
  DayFlag2["hidden"] = "hidden";
  DayFlag2["outside"] = "outside";
  DayFlag2["focused"] = "focused";
  DayFlag2["today"] = "today";
})(DayFlag || (DayFlag = {}));
var SelectionState;
(function(SelectionState2) {
  SelectionState2["range_end"] = "range_end";
  SelectionState2["range_middle"] = "range_middle";
  SelectionState2["range_start"] = "range_start";
  SelectionState2["selected"] = "selected";
})(SelectionState || (SelectionState = {}));
var Animation;
(function(Animation2) {
  Animation2["weeks_before_enter"] = "weeks_before_enter";
  Animation2["weeks_before_exit"] = "weeks_before_exit";
  Animation2["weeks_after_enter"] = "weeks_after_enter";
  Animation2["weeks_after_exit"] = "weeks_after_exit";
  Animation2["caption_after_enter"] = "caption_after_enter";
  Animation2["caption_after_exit"] = "caption_after_exit";
  Animation2["caption_before_enter"] = "caption_before_enter";
  Animation2["caption_before_exit"] = "caption_before_exit";
})(Animation || (Animation = {}));
function Dropdown$1(props) {
  const { options, className, components: components2, classNames, ...selectProps } = props;
  const cssClassSelect = [classNames[UI.Dropdown], className].join(" ");
  const selectedOption = options?.find(({ value }) => value === selectProps.value);
  return React__default.createElement(
    "span",
    { "data-disabled": selectProps.disabled, className: classNames[UI.DropdownRoot] },
    React__default.createElement(components2.Select, { className: cssClassSelect, ...selectProps }, options?.map(({ value, label, disabled }) => React__default.createElement(components2.Option, { key: value, value, disabled }, label))),
    React__default.createElement(
      "span",
      { className: classNames[UI.CaptionLabel], "aria-hidden": true },
      selectedOption?.label,
      React__default.createElement(components2.Chevron, { orientation: "down", size: 18, className: classNames[UI.Chevron] })
    )
  );
}
function DropdownNav(props) {
  return React__default.createElement("div", { ...props });
}
function Footer$1(props) {
  return React__default.createElement("div", { ...props });
}
function Month(props) {
  const { calendarMonth, displayIndex, ...divProps } = props;
  return React__default.createElement("div", { ...divProps }, props.children);
}
function MonthCaption(props) {
  const { calendarMonth, displayIndex, ...divProps } = props;
  return React__default.createElement("div", { ...divProps });
}
function MonthGrid(props) {
  return React__default.createElement("table", { ...props });
}
function Months(props) {
  return React__default.createElement("div", { ...props });
}
const dayPickerContext = createContext(void 0);
function useDayPicker() {
  const context = useContext(dayPickerContext);
  if (context === void 0) {
    throw new Error("useDayPicker() must be used within a custom component.");
  }
  return context;
}
function MonthsDropdown(props) {
  const { components: components2 } = useDayPicker();
  return React__default.createElement(components2.Dropdown, { ...props });
}
function Nav(props) {
  const { onPreviousClick, onNextClick, previousMonth, nextMonth, ...navProps } = props;
  const { components: components2, classNames, labels: { labelPrevious: labelPrevious2, labelNext: labelNext2 } } = useDayPicker();
  const handleNextClick = useCallback((e2) => {
    if (nextMonth) {
      onNextClick?.(e2);
    }
  }, [nextMonth, onNextClick]);
  const handlePreviousClick = useCallback((e2) => {
    if (previousMonth) {
      onPreviousClick?.(e2);
    }
  }, [previousMonth, onPreviousClick]);
  return React__default.createElement(
    "nav",
    { ...navProps },
    React__default.createElement(
      components2.PreviousMonthButton,
      { type: "button", className: classNames[UI.PreviousMonthButton], tabIndex: previousMonth ? void 0 : -1, "aria-disabled": previousMonth ? void 0 : true, "aria-label": labelPrevious2(previousMonth), onClick: handlePreviousClick },
      React__default.createElement(components2.Chevron, { disabled: previousMonth ? void 0 : true, className: classNames[UI.Chevron], orientation: "left" })
    ),
    React__default.createElement(
      components2.NextMonthButton,
      { type: "button", className: classNames[UI.NextMonthButton], tabIndex: nextMonth ? void 0 : -1, "aria-disabled": nextMonth ? void 0 : true, "aria-label": labelNext2(nextMonth), onClick: handleNextClick },
      React__default.createElement(components2.Chevron, { disabled: nextMonth ? void 0 : true, orientation: "right", className: classNames[UI.Chevron] })
    )
  );
}
function NextMonthButton(props) {
  const { components: components2 } = useDayPicker();
  return React__default.createElement(components2.Button, { ...props });
}
function Option(props) {
  return React__default.createElement("option", { ...props });
}
function PreviousMonthButton(props) {
  const { components: components2 } = useDayPicker();
  return React__default.createElement(components2.Button, { ...props });
}
function Root(props) {
  const { rootRef, ...rest } = props;
  return React__default.createElement("div", { ...rest, ref: rootRef });
}
function Select$1(props) {
  return React__default.createElement("select", { ...props });
}
function Week(props) {
  const { week, ...trProps } = props;
  return React__default.createElement("tr", { ...trProps });
}
function Weekday(props) {
  return React__default.createElement("th", { ...props });
}
function Weekdays(props) {
  return React__default.createElement(
    "thead",
    { "aria-hidden": true },
    React__default.createElement("tr", { ...props })
  );
}
function WeekNumber(props) {
  const { week, ...thProps } = props;
  return React__default.createElement("th", { ...thProps });
}
function WeekNumberHeader(props) {
  return React__default.createElement("th", { ...props });
}
function Weeks(props) {
  return React__default.createElement("tbody", { ...props });
}
function YearsDropdown(props) {
  const { components: components2 } = useDayPicker();
  return React__default.createElement(components2.Dropdown, { ...props });
}
const components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Button,
  CaptionLabel,
  Chevron,
  Day,
  DayButton,
  Dropdown: Dropdown$1,
  DropdownNav,
  Footer: Footer$1,
  Month,
  MonthCaption,
  MonthGrid,
  Months,
  MonthsDropdown,
  Nav,
  NextMonthButton,
  Option,
  PreviousMonthButton,
  Root,
  Select: Select$1,
  Week,
  WeekNumber,
  WeekNumberHeader,
  Weekday,
  Weekdays,
  Weeks,
  YearsDropdown
}, Symbol.toStringTag, { value: "Module" }));
function rangeIncludesDate(range, date, excludeEnds = false, dateLib = defaultDateLib) {
  let { from, to } = range;
  const { differenceInCalendarDays: differenceInCalendarDays2, isSameDay: isSameDay2 } = dateLib;
  if (from && to) {
    const isRangeInverted = differenceInCalendarDays2(to, from) < 0;
    if (isRangeInverted) {
      [from, to] = [to, from];
    }
    const isInRange = differenceInCalendarDays2(date, from) >= (excludeEnds ? 1 : 0) && differenceInCalendarDays2(to, date) >= (excludeEnds ? 1 : 0);
    return isInRange;
  }
  if (!excludeEnds && to) {
    return isSameDay2(to, date);
  }
  if (!excludeEnds && from) {
    return isSameDay2(from, date);
  }
  return false;
}
function isDateInterval(matcher) {
  return Boolean(matcher && typeof matcher === "object" && "before" in matcher && "after" in matcher);
}
function isDateRange(value) {
  return Boolean(value && typeof value === "object" && "from" in value);
}
function isDateAfterType(value) {
  return Boolean(value && typeof value === "object" && "after" in value);
}
function isDateBeforeType(value) {
  return Boolean(value && typeof value === "object" && "before" in value);
}
function isDayOfWeekType(value) {
  return Boolean(value && typeof value === "object" && "dayOfWeek" in value);
}
function isDatesArray(value, dateLib) {
  return Array.isArray(value) && value.every(dateLib.isDate);
}
function dateMatchModifiers(date, matchers, dateLib = defaultDateLib) {
  const matchersArr = !Array.isArray(matchers) ? [matchers] : matchers;
  const { isSameDay: isSameDay2, differenceInCalendarDays: differenceInCalendarDays2, isAfter: isAfter2 } = dateLib;
  return matchersArr.some((matcher) => {
    if (typeof matcher === "boolean") {
      return matcher;
    }
    if (dateLib.isDate(matcher)) {
      return isSameDay2(date, matcher);
    }
    if (isDatesArray(matcher, dateLib)) {
      return matcher.some((matcherDate) => isSameDay2(date, matcherDate));
    }
    if (isDateRange(matcher)) {
      return rangeIncludesDate(matcher, date, false, dateLib);
    }
    if (isDayOfWeekType(matcher)) {
      if (!Array.isArray(matcher.dayOfWeek)) {
        return matcher.dayOfWeek === date.getDay();
      }
      return matcher.dayOfWeek.includes(date.getDay());
    }
    if (isDateInterval(matcher)) {
      const diffBefore = differenceInCalendarDays2(matcher.before, date);
      const diffAfter = differenceInCalendarDays2(matcher.after, date);
      const isDayBefore = diffBefore > 0;
      const isDayAfter = diffAfter < 0;
      const isClosedInterval = isAfter2(matcher.before, matcher.after);
      if (isClosedInterval) {
        return isDayAfter && isDayBefore;
      } else {
        return isDayBefore || isDayAfter;
      }
    }
    if (isDateAfterType(matcher)) {
      return differenceInCalendarDays2(date, matcher.after) > 0;
    }
    if (isDateBeforeType(matcher)) {
      return differenceInCalendarDays2(matcher.before, date) > 0;
    }
    if (typeof matcher === "function") {
      return matcher(date);
    }
    return false;
  });
}
function createGetModifiers(days, props, navStart, navEnd, dateLib) {
  const { disabled, hidden, modifiers, showOutsideDays, broadcastCalendar, today = dateLib.today() } = props;
  const { isSameDay: isSameDay2, isSameMonth: isSameMonth2, startOfMonth: startOfMonth2, isBefore: isBefore2, endOfMonth: endOfMonth2, isAfter: isAfter2 } = dateLib;
  const computedNavStart = navStart && startOfMonth2(navStart);
  const computedNavEnd = navEnd && endOfMonth2(navEnd);
  const internalModifiersMap = {
    [DayFlag.focused]: [],
    [DayFlag.outside]: [],
    [DayFlag.disabled]: [],
    [DayFlag.hidden]: [],
    [DayFlag.today]: []
  };
  const customModifiersMap = {};
  for (const day of days) {
    const { date, displayMonth } = day;
    const isOutside = Boolean(displayMonth && !isSameMonth2(date, displayMonth));
    const isBeforeNavStart = Boolean(computedNavStart && isBefore2(date, computedNavStart));
    const isAfterNavEnd = Boolean(computedNavEnd && isAfter2(date, computedNavEnd));
    const isDisabled = Boolean(disabled && dateMatchModifiers(date, disabled, dateLib));
    const isHidden3 = Boolean(hidden && dateMatchModifiers(date, hidden, dateLib)) || isBeforeNavStart || isAfterNavEnd || // Broadcast calendar will show outside days as default
    !broadcastCalendar && !showOutsideDays && isOutside || broadcastCalendar && showOutsideDays === false && isOutside;
    const isToday2 = isSameDay2(date, today);
    if (isOutside)
      internalModifiersMap.outside.push(day);
    if (isDisabled)
      internalModifiersMap.disabled.push(day);
    if (isHidden3)
      internalModifiersMap.hidden.push(day);
    if (isToday2)
      internalModifiersMap.today.push(day);
    if (modifiers) {
      Object.keys(modifiers).forEach((name) => {
        const modifierValue = modifiers?.[name];
        const isMatch = modifierValue ? dateMatchModifiers(date, modifierValue, dateLib) : false;
        if (!isMatch)
          return;
        if (customModifiersMap[name]) {
          customModifiersMap[name].push(day);
        } else {
          customModifiersMap[name] = [day];
        }
      });
    }
  }
  return (day) => {
    const dayFlags = {
      [DayFlag.focused]: false,
      [DayFlag.disabled]: false,
      [DayFlag.hidden]: false,
      [DayFlag.outside]: false,
      [DayFlag.today]: false
    };
    const customModifiers = {};
    for (const name in internalModifiersMap) {
      const days2 = internalModifiersMap[name];
      dayFlags[name] = days2.some((d2) => d2 === day);
    }
    for (const name in customModifiersMap) {
      customModifiers[name] = customModifiersMap[name].some((d2) => d2 === day);
    }
    return {
      ...dayFlags,
      // custom modifiers should override all the previous ones
      ...customModifiers
    };
  };
}
function getClassNamesForModifiers(modifiers, classNames, modifiersClassNames = {}) {
  const modifierClassNames = Object.entries(modifiers).filter(([, active]) => active === true).reduce((previousValue, [key]) => {
    if (modifiersClassNames[key]) {
      previousValue.push(modifiersClassNames[key]);
    } else if (classNames[DayFlag[key]]) {
      previousValue.push(classNames[DayFlag[key]]);
    } else if (classNames[SelectionState[key]]) {
      previousValue.push(classNames[SelectionState[key]]);
    }
    return previousValue;
  }, [classNames[UI.Day]]);
  return modifierClassNames;
}
function getComponents(customComponents) {
  return {
    ...components,
    ...customComponents
  };
}
function getDataAttributes(props) {
  const dataAttributes = {
    "data-mode": props.mode ?? void 0,
    "data-required": "required" in props ? props.required : void 0,
    "data-multiple-months": props.numberOfMonths && props.numberOfMonths > 1 || void 0,
    "data-week-numbers": props.showWeekNumber || void 0,
    "data-broadcast-calendar": props.broadcastCalendar || void 0,
    "data-nav-layout": props.navLayout || void 0
  };
  Object.entries(props).forEach(([key, val]) => {
    if (key.startsWith("data-")) {
      dataAttributes[key] = val;
    }
  });
  return dataAttributes;
}
function getDefaultClassNames() {
  const classNames = {};
  for (const key in UI) {
    classNames[UI[key]] = `rdp-${UI[key]}`;
  }
  for (const key in DayFlag) {
    classNames[DayFlag[key]] = `rdp-${DayFlag[key]}`;
  }
  for (const key in SelectionState) {
    classNames[SelectionState[key]] = `rdp-${SelectionState[key]}`;
  }
  for (const key in Animation) {
    classNames[Animation[key]] = `rdp-${Animation[key]}`;
  }
  return classNames;
}
function formatCaption(month, options, dateLib) {
  const lib = dateLib ?? new DateLib(options);
  return lib.formatMonthYear(month);
}
const formatMonthCaption = formatCaption;
function formatDay(date, options, dateLib) {
  return (dateLib ?? new DateLib(options)).format(date, "d");
}
function formatMonthDropdown(month, dateLib = defaultDateLib) {
  return dateLib.format(month, "LLLL");
}
function formatWeekdayName(weekday, options, dateLib) {
  return (dateLib ?? new DateLib(options)).format(weekday, "cccccc");
}
function formatWeekNumber(weekNumber, dateLib = defaultDateLib) {
  if (weekNumber < 10) {
    return dateLib.formatNumber(`0${weekNumber.toLocaleString()}`);
  }
  return dateLib.formatNumber(`${weekNumber.toLocaleString()}`);
}
function formatWeekNumberHeader() {
  return ``;
}
function formatYearDropdown(year, dateLib = defaultDateLib) {
  return dateLib.format(year, "yyyy");
}
const formatYearCaption = formatYearDropdown;
const defaultFormatters = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  formatCaption,
  formatDay,
  formatMonthCaption,
  formatMonthDropdown,
  formatWeekNumber,
  formatWeekNumberHeader,
  formatWeekdayName,
  formatYearCaption,
  formatYearDropdown
}, Symbol.toStringTag, { value: "Module" }));
function getFormatters(customFormatters) {
  if (customFormatters?.formatMonthCaption && !customFormatters.formatCaption) {
    customFormatters.formatCaption = customFormatters.formatMonthCaption;
  }
  if (customFormatters?.formatYearCaption && !customFormatters.formatYearDropdown) {
    customFormatters.formatYearDropdown = customFormatters.formatYearCaption;
  }
  return {
    ...defaultFormatters,
    ...customFormatters
  };
}
function labelDayButton(date, modifiers, options, dateLib) {
  let label = (dateLib ?? new DateLib(options)).format(date, "PPPP");
  if (modifiers.today)
    label = `Today, ${label}`;
  if (modifiers.selected)
    label = `${label}, selected`;
  return label;
}
const labelDay = labelDayButton;
function labelGrid(date, options, dateLib) {
  const lib = dateLib ?? new DateLib(options);
  return lib.formatMonthYear(date);
}
const labelCaption = labelGrid;
function labelGridcell(date, modifiers, options, dateLib) {
  let label = (dateLib ?? new DateLib(options)).format(date, "PPPP");
  if (modifiers?.today) {
    label = `Today, ${label}`;
  }
  return label;
}
function labelMonthDropdown(_options) {
  return "Choose the Month";
}
function labelNav() {
  return "";
}
const defaultLabel = "Go to the Next Month";
function labelNext(_month, _options) {
  return defaultLabel;
}
function labelPrevious(_month) {
  return "Go to the Previous Month";
}
function labelWeekday(date, options, dateLib) {
  return (dateLib ?? new DateLib(options)).format(date, "cccc");
}
function labelWeekNumber(weekNumber, _options) {
  return `Week ${weekNumber}`;
}
function labelWeekNumberHeader(_options) {
  return "Week Number";
}
function labelYearDropdown(_options) {
  return "Choose the Year";
}
const defaultLabels = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  labelCaption,
  labelDay,
  labelDayButton,
  labelGrid,
  labelGridcell,
  labelMonthDropdown,
  labelNav,
  labelNext,
  labelPrevious,
  labelWeekNumber,
  labelWeekNumberHeader,
  labelWeekday,
  labelYearDropdown
}, Symbol.toStringTag, { value: "Module" }));
const resolveLabel = (defaultLabel2, customLabel, localeLabel) => {
  if (customLabel)
    return customLabel;
  if (localeLabel) {
    return typeof localeLabel === "function" ? localeLabel : (..._args) => localeLabel;
  }
  return defaultLabel2;
};
function getLabels(customLabels, options) {
  const localeLabels = options.locale?.labels ?? {};
  return {
    ...defaultLabels,
    ...customLabels ?? {},
    labelDayButton: resolveLabel(labelDayButton, customLabels?.labelDayButton, localeLabels.labelDayButton),
    labelMonthDropdown: resolveLabel(labelMonthDropdown, customLabels?.labelMonthDropdown, localeLabels.labelMonthDropdown),
    labelNext: resolveLabel(labelNext, customLabels?.labelNext, localeLabels.labelNext),
    labelPrevious: resolveLabel(labelPrevious, customLabels?.labelPrevious, localeLabels.labelPrevious),
    labelWeekNumber: resolveLabel(labelWeekNumber, customLabels?.labelWeekNumber, localeLabels.labelWeekNumber),
    labelYearDropdown: resolveLabel(labelYearDropdown, customLabels?.labelYearDropdown, localeLabels.labelYearDropdown),
    labelGrid: resolveLabel(labelGrid, customLabels?.labelGrid, localeLabels.labelGrid),
    labelGridcell: resolveLabel(labelGridcell, customLabels?.labelGridcell, localeLabels.labelGridcell),
    labelNav: resolveLabel(labelNav, customLabels?.labelNav, localeLabels.labelNav),
    labelWeekNumberHeader: resolveLabel(labelWeekNumberHeader, customLabels?.labelWeekNumberHeader, localeLabels.labelWeekNumberHeader),
    labelWeekday: resolveLabel(labelWeekday, customLabels?.labelWeekday, localeLabels.labelWeekday)
  };
}
function getMonthOptions(displayMonth, navStart, navEnd, formatters2, dateLib) {
  const { startOfMonth: startOfMonth2, startOfYear: startOfYear2, endOfYear: endOfYear2, eachMonthOfInterval: eachMonthOfInterval2, getMonth: getMonth2 } = dateLib;
  const months = eachMonthOfInterval2({
    start: startOfYear2(displayMonth),
    end: endOfYear2(displayMonth)
  });
  const options = months.map((month) => {
    const label = formatters2.formatMonthDropdown(month, dateLib);
    const value = getMonth2(month);
    const disabled = navStart && month < startOfMonth2(navStart) || navEnd && month > startOfMonth2(navEnd) || false;
    return { value, label, disabled };
  });
  return options;
}
function getStyleForModifiers(dayModifiers, styles = {}, modifiersStyles = {}) {
  let style = { ...styles?.[UI.Day] };
  Object.entries(dayModifiers).filter(([, active]) => active === true).forEach(([modifier]) => {
    style = {
      ...style,
      ...modifiersStyles?.[modifier]
    };
  });
  return style;
}
function getWeekdays(dateLib, ISOWeek, broadcastCalendar, today) {
  const referenceToday = today ?? dateLib.today();
  const start = broadcastCalendar ? dateLib.startOfBroadcastWeek(referenceToday, dateLib) : ISOWeek ? dateLib.startOfISOWeek(referenceToday) : dateLib.startOfWeek(referenceToday);
  const days = [];
  for (let i2 = 0; i2 < 7; i2++) {
    const day = dateLib.addDays(start, i2);
    days.push(day);
  }
  return days;
}
function getYearOptions(navStart, navEnd, formatters2, dateLib, reverse = false) {
  if (!navStart)
    return void 0;
  if (!navEnd)
    return void 0;
  const { startOfYear: startOfYear2, endOfYear: endOfYear2, eachYearOfInterval: eachYearOfInterval2, getYear: getYear2 } = dateLib;
  const firstNavYear = startOfYear2(navStart);
  const lastNavYear = endOfYear2(navEnd);
  const years = eachYearOfInterval2({ start: firstNavYear, end: lastNavYear });
  if (reverse)
    years.reverse();
  return years.map((year) => {
    const label = formatters2.formatYearDropdown(year, dateLib);
    return {
      value: getYear2(year),
      label,
      disabled: false
    };
  });
}
function createNoonOverrides(timeZone, options = {}) {
  const { weekStartsOn, locale } = options;
  const fallbackWeekStartsOn = weekStartsOn ?? locale?.options?.weekStartsOn ?? 0;
  const toNoonTZDate = (date) => {
    const normalizedDate = typeof date === "number" || typeof date === "string" ? new Date(date) : date;
    return new TZDate(normalizedDate.getFullYear(), normalizedDate.getMonth(), normalizedDate.getDate(), 12, 0, 0, timeZone);
  };
  const toCalendarDate = (date) => {
    const zoned = toNoonTZDate(date);
    return new Date(zoned.getFullYear(), zoned.getMonth(), zoned.getDate(), 0, 0, 0, 0);
  };
  return {
    today: () => {
      return toNoonTZDate(TZDate.tz(timeZone));
    },
    newDate: (year, monthIndex, date) => {
      return new TZDate(year, monthIndex, date, 12, 0, 0, timeZone);
    },
    startOfDay: (date) => {
      return toNoonTZDate(date);
    },
    startOfWeek: (date, options2) => {
      const base = toNoonTZDate(date);
      const weekStartsOnValue = options2?.weekStartsOn ?? fallbackWeekStartsOn;
      const diff = (base.getDay() - weekStartsOnValue + 7) % 7;
      base.setDate(base.getDate() - diff);
      return base;
    },
    startOfISOWeek: (date) => {
      const base = toNoonTZDate(date);
      const diff = (base.getDay() - 1 + 7) % 7;
      base.setDate(base.getDate() - diff);
      return base;
    },
    startOfMonth: (date) => {
      const base = toNoonTZDate(date);
      base.setDate(1);
      return base;
    },
    startOfYear: (date) => {
      const base = toNoonTZDate(date);
      base.setMonth(0, 1);
      return base;
    },
    endOfWeek: (date, options2) => {
      const base = toNoonTZDate(date);
      const weekStartsOnValue = options2?.weekStartsOn ?? fallbackWeekStartsOn;
      const endDow = (weekStartsOnValue + 6) % 7;
      const diff = (endDow - base.getDay() + 7) % 7;
      base.setDate(base.getDate() + diff);
      return base;
    },
    endOfISOWeek: (date) => {
      const base = toNoonTZDate(date);
      const diff = (7 - base.getDay()) % 7;
      base.setDate(base.getDate() + diff);
      return base;
    },
    endOfMonth: (date) => {
      const base = toNoonTZDate(date);
      base.setMonth(base.getMonth() + 1, 0);
      return base;
    },
    endOfYear: (date) => {
      const base = toNoonTZDate(date);
      base.setMonth(11, 31);
      return base;
    },
    eachMonthOfInterval: (interval) => {
      const start = toNoonTZDate(interval.start);
      const end = toNoonTZDate(interval.end);
      const result = [];
      const cursor = new TZDate(start.getFullYear(), start.getMonth(), 1, 12, 0, 0, timeZone);
      const endKey = end.getFullYear() * 12 + end.getMonth();
      while (cursor.getFullYear() * 12 + cursor.getMonth() <= endKey) {
        result.push(new TZDate(cursor, timeZone));
        cursor.setMonth(cursor.getMonth() + 1, 1);
      }
      return result;
    },
    // Normalize to noon once before arithmetic (avoid DST/midnight edge cases),
    // mutate the same TZDate, and return it.
    addDays: (date, amount) => {
      const base = toNoonTZDate(date);
      base.setDate(base.getDate() + amount);
      return base;
    },
    addWeeks: (date, amount) => {
      const base = toNoonTZDate(date);
      base.setDate(base.getDate() + amount * 7);
      return base;
    },
    addMonths: (date, amount) => {
      const base = toNoonTZDate(date);
      base.setMonth(base.getMonth() + amount);
      return base;
    },
    addYears: (date, amount) => {
      const base = toNoonTZDate(date);
      base.setFullYear(base.getFullYear() + amount);
      return base;
    },
    eachYearOfInterval: (interval) => {
      const start = toNoonTZDate(interval.start);
      const end = toNoonTZDate(interval.end);
      const years = [];
      const cursor = new TZDate(start.getFullYear(), 0, 1, 12, 0, 0, timeZone);
      while (cursor.getFullYear() <= end.getFullYear()) {
        years.push(new TZDate(cursor, timeZone));
        cursor.setFullYear(cursor.getFullYear() + 1, 0, 1);
      }
      return years;
    },
    getWeek: (date, options2) => {
      const base = toCalendarDate(date);
      return getWeek(base, {
        weekStartsOn: options2?.weekStartsOn ?? fallbackWeekStartsOn,
        firstWeekContainsDate: options2?.firstWeekContainsDate ?? locale?.options?.firstWeekContainsDate ?? 1
      });
    },
    getISOWeek: (date) => {
      const base = toCalendarDate(date);
      return getISOWeek(base);
    },
    differenceInCalendarDays: (dateLeft, dateRight) => {
      const left = toCalendarDate(dateLeft);
      const right = toCalendarDate(dateRight);
      return differenceInCalendarDays(left, right);
    },
    differenceInCalendarMonths: (dateLeft, dateRight) => {
      const left = toCalendarDate(dateLeft);
      const right = toCalendarDate(dateRight);
      return differenceInCalendarMonths(left, right);
    }
  };
}
const asHtmlElement = (element) => {
  if (element instanceof HTMLElement)
    return element;
  return null;
};
const queryMonthEls = (element) => [
  ...element.querySelectorAll("[data-animated-month]") ?? []
];
const queryMonthEl = (element) => asHtmlElement(element.querySelector("[data-animated-month]"));
const queryCaptionEl = (element) => asHtmlElement(element.querySelector("[data-animated-caption]"));
const queryWeeksEl = (element) => asHtmlElement(element.querySelector("[data-animated-weeks]"));
const queryNavEl = (element) => asHtmlElement(element.querySelector("[data-animated-nav]"));
const queryWeekdaysEl = (element) => asHtmlElement(element.querySelector("[data-animated-weekdays]"));
function useAnimation(rootElRef, enabled, { classNames, months, focused, dateLib }) {
  const previousRootElSnapshotRef = useRef(null);
  const previousMonthsRef = useRef(months);
  const animatingRef = useRef(false);
  useLayoutEffect(() => {
    const previousMonths = previousMonthsRef.current;
    previousMonthsRef.current = months;
    if (!enabled || !rootElRef.current || // safety check because the ref can be set to anything by consumers
    !(rootElRef.current instanceof HTMLElement) || // validation required for the animation to work as expected
    months.length === 0 || previousMonths.length === 0 || months.length !== previousMonths.length) {
      return;
    }
    const isSameMonth2 = dateLib.isSameMonth(months[0].date, previousMonths[0].date);
    const isAfterPreviousMonth = dateLib.isAfter(months[0].date, previousMonths[0].date);
    const captionAnimationClass = isAfterPreviousMonth ? classNames[Animation.caption_after_enter] : classNames[Animation.caption_before_enter];
    const weeksAnimationClass = isAfterPreviousMonth ? classNames[Animation.weeks_after_enter] : classNames[Animation.weeks_before_enter];
    const previousRootElSnapshot = previousRootElSnapshotRef.current;
    const rootElSnapshot = rootElRef.current.cloneNode(true);
    if (rootElSnapshot instanceof HTMLElement) {
      const currentMonthElsSnapshot = queryMonthEls(rootElSnapshot);
      currentMonthElsSnapshot.forEach((currentMonthElSnapshot) => {
        if (!(currentMonthElSnapshot instanceof HTMLElement))
          return;
        const previousMonthElSnapshot = queryMonthEl(currentMonthElSnapshot);
        if (previousMonthElSnapshot && currentMonthElSnapshot.contains(previousMonthElSnapshot)) {
          currentMonthElSnapshot.removeChild(previousMonthElSnapshot);
        }
        const captionEl = queryCaptionEl(currentMonthElSnapshot);
        if (captionEl) {
          captionEl.classList.remove(captionAnimationClass);
        }
        const weeksEl = queryWeeksEl(currentMonthElSnapshot);
        if (weeksEl) {
          weeksEl.classList.remove(weeksAnimationClass);
        }
      });
      previousRootElSnapshotRef.current = rootElSnapshot;
    } else {
      previousRootElSnapshotRef.current = null;
    }
    if (animatingRef.current || isSameMonth2 || // skip animation if a day is focused because it can cause issues to the animation and is better for a11y
    focused) {
      return;
    }
    const previousMonthEls = previousRootElSnapshot instanceof HTMLElement ? queryMonthEls(previousRootElSnapshot) : [];
    const currentMonthEls = queryMonthEls(rootElRef.current);
    if (currentMonthEls?.every((el) => el instanceof HTMLElement) && previousMonthEls && previousMonthEls.every((el) => el instanceof HTMLElement)) {
      animatingRef.current = true;
      rootElRef.current.style.isolation = "isolate";
      const navEl = queryNavEl(rootElRef.current);
      if (navEl) {
        navEl.style.zIndex = "1";
      }
      currentMonthEls.forEach((currentMonthEl, index2) => {
        const previousMonthEl = previousMonthEls[index2];
        if (!previousMonthEl) {
          return;
        }
        currentMonthEl.style.position = "relative";
        currentMonthEl.style.overflow = "hidden";
        const captionEl = queryCaptionEl(currentMonthEl);
        if (captionEl) {
          captionEl.classList.add(captionAnimationClass);
        }
        const weeksEl = queryWeeksEl(currentMonthEl);
        if (weeksEl) {
          weeksEl.classList.add(weeksAnimationClass);
        }
        const cleanUp = () => {
          animatingRef.current = false;
          if (rootElRef.current) {
            rootElRef.current.style.isolation = "";
          }
          if (navEl) {
            navEl.style.zIndex = "";
          }
          if (captionEl) {
            captionEl.classList.remove(captionAnimationClass);
          }
          if (weeksEl) {
            weeksEl.classList.remove(weeksAnimationClass);
          }
          currentMonthEl.style.position = "";
          currentMonthEl.style.overflow = "";
          if (currentMonthEl.contains(previousMonthEl)) {
            currentMonthEl.removeChild(previousMonthEl);
          }
        };
        previousMonthEl.style.pointerEvents = "none";
        previousMonthEl.style.position = "absolute";
        previousMonthEl.style.overflow = "hidden";
        previousMonthEl.setAttribute("aria-hidden", "true");
        const previousWeekdaysEl = queryWeekdaysEl(previousMonthEl);
        if (previousWeekdaysEl) {
          previousWeekdaysEl.style.opacity = "0";
        }
        const previousCaptionEl = queryCaptionEl(previousMonthEl);
        if (previousCaptionEl) {
          previousCaptionEl.classList.add(isAfterPreviousMonth ? classNames[Animation.caption_before_exit] : classNames[Animation.caption_after_exit]);
          previousCaptionEl.addEventListener("animationend", cleanUp);
        }
        const previousWeeksEl = queryWeeksEl(previousMonthEl);
        if (previousWeeksEl) {
          previousWeeksEl.classList.add(isAfterPreviousMonth ? classNames[Animation.weeks_before_exit] : classNames[Animation.weeks_after_exit]);
        }
        currentMonthEl.insertBefore(previousMonthEl, currentMonthEl.firstChild);
      });
    }
  });
}
function getDates(displayMonths, maxDate, props, dateLib) {
  const firstMonth = displayMonths[0];
  const lastMonth = displayMonths[displayMonths.length - 1];
  const { ISOWeek, fixedWeeks, broadcastCalendar } = props ?? {};
  const { addDays: addDays2, differenceInCalendarDays: differenceInCalendarDays2, differenceInCalendarMonths: differenceInCalendarMonths2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfMonth: endOfMonth2, endOfWeek: endOfWeek2, isAfter: isAfter2, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
  const startWeekFirstDate = broadcastCalendar ? startOfBroadcastWeek2(firstMonth, dateLib) : ISOWeek ? startOfISOWeek2(firstMonth) : startOfWeek2(firstMonth);
  const displayMonthsWeekEnd = broadcastCalendar ? endOfBroadcastWeek2(lastMonth) : ISOWeek ? endOfISOWeek2(endOfMonth2(lastMonth)) : endOfWeek2(endOfMonth2(lastMonth));
  const constraintWeekEnd = maxDate && (broadcastCalendar ? endOfBroadcastWeek2(maxDate) : ISOWeek ? endOfISOWeek2(maxDate) : endOfWeek2(maxDate));
  const gridEndDate = constraintWeekEnd && isAfter2(displayMonthsWeekEnd, constraintWeekEnd) ? constraintWeekEnd : displayMonthsWeekEnd;
  const nOfDays = differenceInCalendarDays2(gridEndDate, startWeekFirstDate);
  const nOfMonths = differenceInCalendarMonths2(lastMonth, firstMonth) + 1;
  const dates = [];
  for (let i2 = 0; i2 <= nOfDays; i2++) {
    const date = addDays2(startWeekFirstDate, i2);
    dates.push(date);
  }
  const nrOfDaysWithFixedWeeks = broadcastCalendar ? 35 : 42;
  const extraDates = nrOfDaysWithFixedWeeks * nOfMonths;
  if (fixedWeeks && dates.length < extraDates) {
    const daysToAdd = extraDates - dates.length;
    for (let i2 = 0; i2 < daysToAdd; i2++) {
      const date = addDays2(dates[dates.length - 1], 1);
      dates.push(date);
    }
  }
  return dates;
}
function getDays(calendarMonths) {
  const initialDays = [];
  return calendarMonths.reduce((days, month) => {
    const weekDays = month.weeks.reduce((weekDays2, week) => {
      return weekDays2.concat(week.days.slice());
    }, initialDays.slice());
    return days.concat(weekDays.slice());
  }, initialDays.slice());
}
function getDisplayMonths(firstDisplayedMonth, calendarEndMonth, props, dateLib) {
  const { numberOfMonths = 1 } = props;
  const months = [];
  for (let i2 = 0; i2 < numberOfMonths; i2++) {
    const month = dateLib.addMonths(firstDisplayedMonth, i2);
    if (calendarEndMonth && month > calendarEndMonth) {
      break;
    }
    months.push(month);
  }
  return months;
}
function getInitialMonth(props, navStart, navEnd, dateLib) {
  const { month, defaultMonth, today = dateLib.today(), numberOfMonths = 1 } = props;
  let initialMonth = month || defaultMonth || today;
  const { differenceInCalendarMonths: differenceInCalendarMonths2, addMonths: addMonths2, startOfMonth: startOfMonth2 } = dateLib;
  if (navEnd && differenceInCalendarMonths2(navEnd, initialMonth) < numberOfMonths - 1) {
    const offset2 = -1 * (numberOfMonths - 1);
    initialMonth = addMonths2(navEnd, offset2);
  }
  if (navStart && differenceInCalendarMonths2(initialMonth, navStart) < 0) {
    initialMonth = navStart;
  }
  return startOfMonth2(initialMonth);
}
function getMonths(displayMonths, dates, props, dateLib) {
  const { addDays: addDays2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfMonth: endOfMonth2, endOfWeek: endOfWeek2, getISOWeek: getISOWeek2, getWeek: getWeek2, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
  const dayPickerMonths = displayMonths.reduce((months, month) => {
    const firstDateOfFirstWeek = props.broadcastCalendar ? startOfBroadcastWeek2(month, dateLib) : props.ISOWeek ? startOfISOWeek2(month) : startOfWeek2(month);
    const lastDateOfLastWeek = props.broadcastCalendar ? endOfBroadcastWeek2(month) : props.ISOWeek ? endOfISOWeek2(endOfMonth2(month)) : endOfWeek2(endOfMonth2(month));
    const monthDates = dates.filter((date) => {
      return date >= firstDateOfFirstWeek && date <= lastDateOfLastWeek;
    });
    const nrOfDaysWithFixedWeeks = props.broadcastCalendar ? 35 : 42;
    if (props.fixedWeeks && monthDates.length < nrOfDaysWithFixedWeeks) {
      const extraDates = dates.filter((date) => {
        const daysToAdd = nrOfDaysWithFixedWeeks - monthDates.length;
        return date > lastDateOfLastWeek && date <= addDays2(lastDateOfLastWeek, daysToAdd);
      });
      monthDates.push(...extraDates);
    }
    const weeks = monthDates.reduce((weeks2, date) => {
      const weekNumber = props.ISOWeek ? getISOWeek2(date) : getWeek2(date);
      const week = weeks2.find((week2) => week2.weekNumber === weekNumber);
      const day = new CalendarDay(date, month, dateLib);
      if (!week) {
        weeks2.push(new CalendarWeek(weekNumber, [day]));
      } else {
        week.days.push(day);
      }
      return weeks2;
    }, []);
    const dayPickerMonth = new CalendarMonth(month, weeks);
    months.push(dayPickerMonth);
    return months;
  }, []);
  if (!props.reverseMonths) {
    return dayPickerMonths;
  } else {
    return dayPickerMonths.reverse();
  }
}
function getNavMonths(props, dateLib) {
  let { startMonth, endMonth } = props;
  const { startOfYear: startOfYear2, startOfDay: startOfDay2, startOfMonth: startOfMonth2, endOfMonth: endOfMonth2, addYears: addYears2, endOfYear: endOfYear2, newDate, today } = dateLib;
  const { fromYear, toYear, fromMonth, toMonth } = props;
  if (!startMonth && fromMonth) {
    startMonth = fromMonth;
  }
  if (!startMonth && fromYear) {
    startMonth = dateLib.newDate(fromYear, 0, 1);
  }
  if (!endMonth && toMonth) {
    endMonth = toMonth;
  }
  if (!endMonth && toYear) {
    endMonth = newDate(toYear, 11, 31);
  }
  const hasYearDropdown = props.captionLayout === "dropdown" || props.captionLayout === "dropdown-years";
  if (startMonth) {
    startMonth = startOfMonth2(startMonth);
  } else if (fromYear) {
    startMonth = newDate(fromYear, 0, 1);
  } else if (!startMonth && hasYearDropdown) {
    startMonth = startOfYear2(addYears2(props.today ?? today(), -100));
  }
  if (endMonth) {
    endMonth = endOfMonth2(endMonth);
  } else if (toYear) {
    endMonth = newDate(toYear, 11, 31);
  } else if (!endMonth && hasYearDropdown) {
    endMonth = endOfYear2(props.today ?? today());
  }
  return [
    startMonth ? startOfDay2(startMonth) : startMonth,
    endMonth ? startOfDay2(endMonth) : endMonth
  ];
}
function getNextMonth(firstDisplayedMonth, calendarEndMonth, options, dateLib) {
  if (options.disableNavigation) {
    return void 0;
  }
  const { pagedNavigation, numberOfMonths = 1 } = options;
  const { startOfMonth: startOfMonth2, addMonths: addMonths2, differenceInCalendarMonths: differenceInCalendarMonths2 } = dateLib;
  const offset2 = pagedNavigation ? numberOfMonths : 1;
  const month = startOfMonth2(firstDisplayedMonth);
  if (!calendarEndMonth) {
    return addMonths2(month, offset2);
  }
  const monthsDiff = differenceInCalendarMonths2(calendarEndMonth, firstDisplayedMonth);
  if (monthsDiff < numberOfMonths) {
    return void 0;
  }
  return addMonths2(month, offset2);
}
function getPreviousMonth(firstDisplayedMonth, calendarStartMonth, options, dateLib) {
  if (options.disableNavigation) {
    return void 0;
  }
  const { pagedNavigation, numberOfMonths } = options;
  const { startOfMonth: startOfMonth2, addMonths: addMonths2, differenceInCalendarMonths: differenceInCalendarMonths2 } = dateLib;
  const offset2 = pagedNavigation ? numberOfMonths ?? 1 : 1;
  const month = startOfMonth2(firstDisplayedMonth);
  if (!calendarStartMonth) {
    return addMonths2(month, -offset2);
  }
  const monthsDiff = differenceInCalendarMonths2(month, calendarStartMonth);
  if (monthsDiff <= 0) {
    return void 0;
  }
  return addMonths2(month, -offset2);
}
function getWeeks(months) {
  const initialWeeks = [];
  return months.reduce((weeks, month) => {
    return weeks.concat(month.weeks.slice());
  }, initialWeeks.slice());
}
function useControlledValue(defaultValue, controlledValue) {
  const [uncontrolledValue, setValue] = useState(defaultValue);
  const value = controlledValue === void 0 ? uncontrolledValue : controlledValue;
  return [value, setValue];
}
function useCalendar(props, dateLib) {
  const [navStart, navEnd] = getNavMonths(props, dateLib);
  const { startOfMonth: startOfMonth2, endOfMonth: endOfMonth2 } = dateLib;
  const initialMonth = getInitialMonth(props, navStart, navEnd, dateLib);
  const [firstMonth, setFirstMonth] = useControlledValue(
    initialMonth,
    // initialMonth is always computed from props.month if provided
    props.month ? initialMonth : void 0
  );
  useEffect(() => {
    const newInitialMonth = getInitialMonth(props, navStart, navEnd, dateLib);
    setFirstMonth(newInitialMonth);
  }, [props.timeZone]);
  const { months, weeks, days, previousMonth, nextMonth } = useMemo(() => {
    const displayMonths = getDisplayMonths(firstMonth, navEnd, { numberOfMonths: props.numberOfMonths }, dateLib);
    const dates = getDates(displayMonths, props.endMonth ? endOfMonth2(props.endMonth) : void 0, {
      ISOWeek: props.ISOWeek,
      fixedWeeks: props.fixedWeeks,
      broadcastCalendar: props.broadcastCalendar
    }, dateLib);
    const months2 = getMonths(displayMonths, dates, {
      broadcastCalendar: props.broadcastCalendar,
      fixedWeeks: props.fixedWeeks,
      ISOWeek: props.ISOWeek,
      reverseMonths: props.reverseMonths
    }, dateLib);
    const weeks2 = getWeeks(months2);
    const days2 = getDays(months2);
    const previousMonth2 = getPreviousMonth(firstMonth, navStart, props, dateLib);
    const nextMonth2 = getNextMonth(firstMonth, navEnd, props, dateLib);
    return {
      months: months2,
      weeks: weeks2,
      days: days2,
      previousMonth: previousMonth2,
      nextMonth: nextMonth2
    };
  }, [
    dateLib,
    firstMonth.getTime(),
    navEnd?.getTime(),
    navStart?.getTime(),
    props.disableNavigation,
    props.broadcastCalendar,
    props.endMonth?.getTime(),
    props.fixedWeeks,
    props.ISOWeek,
    props.numberOfMonths,
    props.pagedNavigation,
    props.reverseMonths
  ]);
  const { disableNavigation, onMonthChange } = props;
  const isDayInCalendar = (day) => weeks.some((week) => week.days.some((d2) => d2.isEqualTo(day)));
  const goToMonth = (date) => {
    if (disableNavigation) {
      return;
    }
    let newMonth = startOfMonth2(date);
    if (navStart && newMonth < startOfMonth2(navStart)) {
      newMonth = startOfMonth2(navStart);
    }
    if (navEnd && newMonth > startOfMonth2(navEnd)) {
      newMonth = startOfMonth2(navEnd);
    }
    setFirstMonth(newMonth);
    onMonthChange?.(newMonth);
  };
  const goToDay = (day) => {
    if (isDayInCalendar(day)) {
      return;
    }
    goToMonth(day.date);
  };
  const calendar = {
    months,
    weeks,
    days,
    navStart,
    navEnd,
    previousMonth,
    nextMonth,
    goToMonth,
    goToDay
  };
  return calendar;
}
var FocusTargetPriority;
(function(FocusTargetPriority2) {
  FocusTargetPriority2[FocusTargetPriority2["Today"] = 0] = "Today";
  FocusTargetPriority2[FocusTargetPriority2["Selected"] = 1] = "Selected";
  FocusTargetPriority2[FocusTargetPriority2["LastFocused"] = 2] = "LastFocused";
  FocusTargetPriority2[FocusTargetPriority2["FocusedModifier"] = 3] = "FocusedModifier";
})(FocusTargetPriority || (FocusTargetPriority = {}));
function isFocusableDay(modifiers) {
  return !modifiers[DayFlag.disabled] && !modifiers[DayFlag.hidden] && !modifiers[DayFlag.outside];
}
function calculateFocusTarget(days, getModifiers, isSelected, lastFocused) {
  let focusTarget;
  let foundFocusTargetPriority = -1;
  for (const day of days) {
    const modifiers = getModifiers(day);
    if (isFocusableDay(modifiers)) {
      if (modifiers[DayFlag.focused] && foundFocusTargetPriority < FocusTargetPriority.FocusedModifier) {
        focusTarget = day;
        foundFocusTargetPriority = FocusTargetPriority.FocusedModifier;
      } else if (lastFocused?.isEqualTo(day) && foundFocusTargetPriority < FocusTargetPriority.LastFocused) {
        focusTarget = day;
        foundFocusTargetPriority = FocusTargetPriority.LastFocused;
      } else if (isSelected(day.date) && foundFocusTargetPriority < FocusTargetPriority.Selected) {
        focusTarget = day;
        foundFocusTargetPriority = FocusTargetPriority.Selected;
      } else if (modifiers[DayFlag.today] && foundFocusTargetPriority < FocusTargetPriority.Today) {
        focusTarget = day;
        foundFocusTargetPriority = FocusTargetPriority.Today;
      }
    }
  }
  if (!focusTarget) {
    focusTarget = days.find((day) => isFocusableDay(getModifiers(day)));
  }
  return focusTarget;
}
function getFocusableDate(moveBy, moveDir, refDate, navStart, navEnd, props, dateLib) {
  const { ISOWeek, broadcastCalendar } = props;
  const { addDays: addDays2, addMonths: addMonths2, addWeeks: addWeeks2, addYears: addYears2, endOfBroadcastWeek: endOfBroadcastWeek2, endOfISOWeek: endOfISOWeek2, endOfWeek: endOfWeek2, max: max2, min: min2, startOfBroadcastWeek: startOfBroadcastWeek2, startOfISOWeek: startOfISOWeek2, startOfWeek: startOfWeek2 } = dateLib;
  const moveFns = {
    day: addDays2,
    week: addWeeks2,
    month: addMonths2,
    year: addYears2,
    startOfWeek: (date) => broadcastCalendar ? startOfBroadcastWeek2(date, dateLib) : ISOWeek ? startOfISOWeek2(date) : startOfWeek2(date),
    endOfWeek: (date) => broadcastCalendar ? endOfBroadcastWeek2(date) : ISOWeek ? endOfISOWeek2(date) : endOfWeek2(date)
  };
  let focusableDate = moveFns[moveBy](refDate, moveDir === "after" ? 1 : -1);
  if (moveDir === "before" && navStart) {
    focusableDate = max2([navStart, focusableDate]);
  } else if (moveDir === "after" && navEnd) {
    focusableDate = min2([navEnd, focusableDate]);
  }
  return focusableDate;
}
function getNextFocus(moveBy, moveDir, refDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt = 0) {
  if (attempt > 365) {
    return void 0;
  }
  const focusableDate = getFocusableDate(moveBy, moveDir, refDay.date, calendarStartMonth, calendarEndMonth, props, dateLib);
  const isDisabled = Boolean(props.disabled && dateMatchModifiers(focusableDate, props.disabled, dateLib));
  const isHidden3 = Boolean(props.hidden && dateMatchModifiers(focusableDate, props.hidden, dateLib));
  const targetMonth = focusableDate;
  const focusDay = new CalendarDay(focusableDate, targetMonth, dateLib);
  if (!isDisabled && !isHidden3) {
    return focusDay;
  }
  return getNextFocus(moveBy, moveDir, focusDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt + 1);
}
function useFocus(props, calendar, getModifiers, isSelected, dateLib) {
  const { autoFocus } = props;
  const [lastFocused, setLastFocused] = useState();
  const focusTarget = calculateFocusTarget(calendar.days, getModifiers, isSelected || (() => false), lastFocused);
  const [focusedDay, setFocused] = useState(autoFocus ? focusTarget : void 0);
  const blur = () => {
    setLastFocused(focusedDay);
    setFocused(void 0);
  };
  const moveFocus = (moveBy, moveDir) => {
    if (!focusedDay)
      return;
    const nextFocus = getNextFocus(moveBy, moveDir, focusedDay, calendar.navStart, calendar.navEnd, props, dateLib);
    if (!nextFocus)
      return;
    if (props.disableNavigation) {
      const isNextInCalendar = calendar.days.some((day) => day.isEqualTo(nextFocus));
      if (!isNextInCalendar) {
        return;
      }
    }
    calendar.goToDay(nextFocus);
    setFocused(nextFocus);
  };
  const isFocusTarget = (day) => {
    return Boolean(focusTarget?.isEqualTo(day));
  };
  const useFocus2 = {
    isFocusTarget,
    setFocused,
    focused: focusedDay,
    blur,
    moveFocus
  };
  return useFocus2;
}
function useMulti(props, dateLib) {
  const { selected: initiallySelected, required, onSelect } = props;
  const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
  const selected = !onSelect ? internallySelected : initiallySelected;
  const { isSameDay: isSameDay2 } = dateLib;
  const isSelected = (date) => {
    return selected?.some((d2) => isSameDay2(d2, date)) ?? false;
  };
  const { min: min2, max: max2 } = props;
  const select = (triggerDate, modifiers, e2) => {
    let newDates = [...selected ?? []];
    if (isSelected(triggerDate)) {
      if (selected?.length === min2) {
        return;
      }
      if (required && selected?.length === 1) {
        return;
      }
      newDates = selected?.filter((d2) => !isSameDay2(d2, triggerDate));
    } else {
      if (selected?.length === max2) {
        newDates = [triggerDate];
      } else {
        newDates = [...newDates, triggerDate];
      }
    }
    if (!onSelect) {
      setSelected(newDates);
    }
    onSelect?.(newDates, triggerDate, modifiers, e2);
    return newDates;
  };
  return {
    selected,
    select,
    isSelected
  };
}
function addToRange(date, initialRange, min2 = 0, max2 = 0, required = false, dateLib = defaultDateLib) {
  const { from, to } = initialRange || {};
  const { isSameDay: isSameDay2, isAfter: isAfter2, isBefore: isBefore2 } = dateLib;
  let range;
  if (!from && !to) {
    range = { from: date, to: min2 > 0 ? void 0 : date };
  } else if (from && !to) {
    if (isSameDay2(from, date)) {
      if (min2 === 0) {
        range = { from, to: date };
      } else if (required) {
        range = { from, to: void 0 };
      } else {
        range = void 0;
      }
    } else if (isBefore2(date, from)) {
      range = { from: date, to: from };
    } else {
      range = { from, to: date };
    }
  } else if (from && to) {
    if (isSameDay2(from, date) && isSameDay2(to, date)) {
      if (required) {
        range = { from, to };
      } else {
        range = void 0;
      }
    } else if (isSameDay2(from, date)) {
      range = { from, to: min2 > 0 ? void 0 : date };
    } else if (isSameDay2(to, date)) {
      range = { from: date, to: min2 > 0 ? void 0 : date };
    } else if (isBefore2(date, from)) {
      range = { from: date, to };
    } else if (isAfter2(date, from)) {
      range = { from, to: date };
    } else if (isAfter2(date, to)) {
      range = { from, to: date };
    } else {
      throw new Error("Invalid range");
    }
  }
  if (range?.from && range?.to) {
    const diff = dateLib.differenceInCalendarDays(range.to, range.from);
    if (max2 > 0 && diff > max2) {
      range = { from: date, to: void 0 };
    } else if (min2 > 1 && diff < min2) {
      range = { from: date, to: void 0 };
    }
  }
  return range;
}
function rangeContainsDayOfWeek(range, dayOfWeek, dateLib = defaultDateLib) {
  const dayOfWeekArr = !Array.isArray(dayOfWeek) ? [dayOfWeek] : dayOfWeek;
  let date = range.from;
  const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);
  const totalDaysLimit = Math.min(totalDays, 6);
  for (let i2 = 0; i2 <= totalDaysLimit; i2++) {
    if (dayOfWeekArr.includes(date.getDay())) {
      return true;
    }
    date = dateLib.addDays(date, 1);
  }
  return false;
}
function rangeOverlaps(rangeLeft, rangeRight, dateLib = defaultDateLib) {
  return rangeIncludesDate(rangeLeft, rangeRight.from, false, dateLib) || rangeIncludesDate(rangeLeft, rangeRight.to, false, dateLib) || rangeIncludesDate(rangeRight, rangeLeft.from, false, dateLib) || rangeIncludesDate(rangeRight, rangeLeft.to, false, dateLib);
}
function rangeContainsModifiers(range, modifiers, dateLib = defaultDateLib) {
  const matchers = Array.isArray(modifiers) ? modifiers : [modifiers];
  const nonFunctionMatchers = matchers.filter((matcher) => typeof matcher !== "function");
  const nonFunctionMatchersResult = nonFunctionMatchers.some((matcher) => {
    if (typeof matcher === "boolean")
      return matcher;
    if (dateLib.isDate(matcher)) {
      return rangeIncludesDate(range, matcher, false, dateLib);
    }
    if (isDatesArray(matcher, dateLib)) {
      return matcher.some((date) => rangeIncludesDate(range, date, false, dateLib));
    }
    if (isDateRange(matcher)) {
      if (matcher.from && matcher.to) {
        return rangeOverlaps(range, { from: matcher.from, to: matcher.to }, dateLib);
      }
      return false;
    }
    if (isDayOfWeekType(matcher)) {
      return rangeContainsDayOfWeek(range, matcher.dayOfWeek, dateLib);
    }
    if (isDateInterval(matcher)) {
      const isClosedInterval = dateLib.isAfter(matcher.before, matcher.after);
      if (isClosedInterval) {
        return rangeOverlaps(range, {
          from: dateLib.addDays(matcher.after, 1),
          to: dateLib.addDays(matcher.before, -1)
        }, dateLib);
      }
      return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);
    }
    if (isDateAfterType(matcher) || isDateBeforeType(matcher)) {
      return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);
    }
    return false;
  });
  if (nonFunctionMatchersResult) {
    return true;
  }
  const functionMatchers = matchers.filter((matcher) => typeof matcher === "function");
  if (functionMatchers.length) {
    let date = range.from;
    const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);
    for (let i2 = 0; i2 <= totalDays; i2++) {
      if (functionMatchers.some((matcher) => matcher(date))) {
        return true;
      }
      date = dateLib.addDays(date, 1);
    }
  }
  return false;
}
function useRange(props, dateLib) {
  const { disabled, excludeDisabled, selected: initiallySelected, required, onSelect } = props;
  const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
  const selected = !onSelect ? internallySelected : initiallySelected;
  const isSelected = (date) => selected && rangeIncludesDate(selected, date, false, dateLib);
  const select = (triggerDate, modifiers, e2) => {
    const { min: min2, max: max2 } = props;
    const newRange = triggerDate ? addToRange(triggerDate, selected, min2, max2, required, dateLib) : void 0;
    if (excludeDisabled && disabled && newRange?.from && newRange.to) {
      if (rangeContainsModifiers({ from: newRange.from, to: newRange.to }, disabled, dateLib)) {
        newRange.from = triggerDate;
        newRange.to = void 0;
      }
    }
    if (!onSelect) {
      setSelected(newRange);
    }
    onSelect?.(newRange, triggerDate, modifiers, e2);
    return newRange;
  };
  return {
    selected,
    select,
    isSelected
  };
}
function useSingle(props, dateLib) {
  const { selected: initiallySelected, required, onSelect } = props;
  const [internallySelected, setSelected] = useControlledValue(initiallySelected, onSelect ? initiallySelected : void 0);
  const selected = !onSelect ? internallySelected : initiallySelected;
  const { isSameDay: isSameDay2 } = dateLib;
  const isSelected = (compareDate) => {
    return selected ? isSameDay2(selected, compareDate) : false;
  };
  const select = (triggerDate, modifiers, e2) => {
    let newDate = triggerDate;
    if (!required && selected && selected && isSameDay2(triggerDate, selected)) {
      newDate = void 0;
    }
    if (!onSelect) {
      setSelected(newDate);
    }
    if (required) {
      onSelect?.(newDate, triggerDate, modifiers, e2);
    } else {
      onSelect?.(newDate, triggerDate, modifiers, e2);
    }
    return newDate;
  };
  return {
    selected,
    select,
    isSelected
  };
}
function useSelection(props, dateLib) {
  const single = useSingle(props, dateLib);
  const multi = useMulti(props, dateLib);
  const range = useRange(props, dateLib);
  switch (props.mode) {
    case "single":
      return single;
    case "multiple":
      return multi;
    case "range":
      return range;
    default:
      return void 0;
  }
}
function toTimeZone(date, timeZone) {
  if (date instanceof TZDate && date.timeZone === timeZone) {
    return date;
  }
  return new TZDate(date, timeZone);
}
function toZoneNoon(date, timeZone, noonSafe) {
  return toTimeZone(date, timeZone);
}
function convertMatcher(matcher, timeZone, noonSafe) {
  if (typeof matcher === "boolean" || typeof matcher === "function") {
    return matcher;
  }
  if (matcher instanceof Date) {
    return toZoneNoon(matcher, timeZone);
  }
  if (Array.isArray(matcher)) {
    return matcher.map((value) => value instanceof Date ? toZoneNoon(value, timeZone) : value);
  }
  if (isDateRange(matcher)) {
    return {
      ...matcher,
      from: matcher.from ? toTimeZone(matcher.from, timeZone) : matcher.from,
      to: matcher.to ? toTimeZone(matcher.to, timeZone) : matcher.to
    };
  }
  if (isDateInterval(matcher)) {
    return {
      before: toZoneNoon(matcher.before, timeZone),
      after: toZoneNoon(matcher.after, timeZone)
    };
  }
  if (isDateAfterType(matcher)) {
    return {
      after: toZoneNoon(matcher.after, timeZone)
    };
  }
  if (isDateBeforeType(matcher)) {
    return {
      before: toZoneNoon(matcher.before, timeZone)
    };
  }
  return matcher;
}
function convertMatchersToTimeZone(matchers, timeZone, noonSafe) {
  if (!matchers) {
    return matchers;
  }
  if (Array.isArray(matchers)) {
    return matchers.map((matcher) => convertMatcher(matcher, timeZone));
  }
  return convertMatcher(matchers, timeZone);
}
function DayPicker(initialProps) {
  let props = initialProps;
  const timeZone = props.timeZone;
  if (timeZone) {
    props = {
      ...initialProps,
      timeZone
    };
    if (props.today) {
      props.today = toTimeZone(props.today, timeZone);
    }
    if (props.month) {
      props.month = toTimeZone(props.month, timeZone);
    }
    if (props.defaultMonth) {
      props.defaultMonth = toTimeZone(props.defaultMonth, timeZone);
    }
    if (props.startMonth) {
      props.startMonth = toTimeZone(props.startMonth, timeZone);
    }
    if (props.endMonth) {
      props.endMonth = toTimeZone(props.endMonth, timeZone);
    }
    if (props.mode === "single" && props.selected) {
      props.selected = toTimeZone(props.selected, timeZone);
    } else if (props.mode === "multiple" && props.selected) {
      props.selected = props.selected?.map((date) => toTimeZone(date, timeZone));
    } else if (props.mode === "range" && props.selected) {
      props.selected = {
        from: props.selected.from ? toTimeZone(props.selected.from, timeZone) : props.selected.from,
        to: props.selected.to ? toTimeZone(props.selected.to, timeZone) : props.selected.to
      };
    }
    if (props.disabled !== void 0) {
      props.disabled = convertMatchersToTimeZone(props.disabled, timeZone);
    }
    if (props.hidden !== void 0) {
      props.hidden = convertMatchersToTimeZone(props.hidden, timeZone);
    }
    if (props.modifiers) {
      const nextModifiers = {};
      Object.keys(props.modifiers).forEach((key) => {
        nextModifiers[key] = convertMatchersToTimeZone(props.modifiers?.[key], timeZone);
      });
      props.modifiers = nextModifiers;
    }
  }
  const { components: components2, formatters: formatters2, labels, dateLib, locale, classNames } = useMemo(() => {
    const locale2 = { ...enUS, ...props.locale };
    const weekStartsOn = props.broadcastCalendar ? 1 : props.weekStartsOn;
    const noonOverrides = props.noonSafe && props.timeZone ? createNoonOverrides(props.timeZone, {
      weekStartsOn,
      locale: locale2
    }) : void 0;
    const overrides = props.dateLib && noonOverrides ? { ...noonOverrides, ...props.dateLib } : props.dateLib ?? noonOverrides;
    const dateLib2 = new DateLib({
      locale: locale2,
      weekStartsOn,
      firstWeekContainsDate: props.firstWeekContainsDate,
      useAdditionalWeekYearTokens: props.useAdditionalWeekYearTokens,
      useAdditionalDayOfYearTokens: props.useAdditionalDayOfYearTokens,
      timeZone: props.timeZone,
      numerals: props.numerals
    }, overrides);
    return {
      dateLib: dateLib2,
      components: getComponents(props.components),
      formatters: getFormatters(props.formatters),
      labels: getLabels(props.labels, dateLib2.options),
      locale: locale2,
      classNames: { ...getDefaultClassNames(), ...props.classNames }
    };
  }, [
    props.locale,
    props.broadcastCalendar,
    props.weekStartsOn,
    props.firstWeekContainsDate,
    props.useAdditionalWeekYearTokens,
    props.useAdditionalDayOfYearTokens,
    props.timeZone,
    props.numerals,
    props.dateLib,
    props.noonSafe,
    props.components,
    props.formatters,
    props.labels,
    props.classNames
  ]);
  if (!props.today) {
    props = { ...props, today: dateLib.today() };
  }
  const { captionLayout, mode, navLayout, numberOfMonths = 1, onDayBlur, onDayClick, onDayFocus, onDayKeyDown, onDayMouseEnter, onDayMouseLeave, onNextClick, onPrevClick, showWeekNumber, styles } = props;
  const { formatCaption: formatCaption2, formatDay: formatDay2, formatMonthDropdown: formatMonthDropdown2, formatWeekNumber: formatWeekNumber2, formatWeekNumberHeader: formatWeekNumberHeader2, formatWeekdayName: formatWeekdayName2, formatYearDropdown: formatYearDropdown2 } = formatters2;
  const calendar = useCalendar(props, dateLib);
  const { days, months, navStart, navEnd, previousMonth, nextMonth, goToMonth } = calendar;
  const getModifiers = createGetModifiers(days, props, navStart, navEnd, dateLib);
  const { isSelected, select, selected: selectedValue } = useSelection(props, dateLib) ?? {};
  const { blur, focused, isFocusTarget, moveFocus, setFocused } = useFocus(props, calendar, getModifiers, isSelected ?? (() => false), dateLib);
  const { labelDayButton: labelDayButton2, labelGridcell: labelGridcell2, labelGrid: labelGrid2, labelMonthDropdown: labelMonthDropdown2, labelNav: labelNav2, labelPrevious: labelPrevious2, labelNext: labelNext2, labelWeekday: labelWeekday2, labelWeekNumber: labelWeekNumber2, labelWeekNumberHeader: labelWeekNumberHeader2, labelYearDropdown: labelYearDropdown2 } = labels;
  const weekdays = useMemo(() => getWeekdays(dateLib, props.ISOWeek, props.broadcastCalendar, props.today), [dateLib, props.ISOWeek, props.broadcastCalendar, props.today]);
  const isInteractive = mode !== void 0 || onDayClick !== void 0;
  const handlePreviousClick = useCallback(() => {
    if (!previousMonth)
      return;
    goToMonth(previousMonth);
    onPrevClick?.(previousMonth);
  }, [previousMonth, goToMonth, onPrevClick]);
  const handleNextClick = useCallback(() => {
    if (!nextMonth)
      return;
    goToMonth(nextMonth);
    onNextClick?.(nextMonth);
  }, [goToMonth, nextMonth, onNextClick]);
  const handleDayClick = useCallback((day, m2) => (e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    setFocused(day);
    if (m2.disabled) {
      return;
    }
    select?.(day.date, m2, e2);
    onDayClick?.(day.date, m2, e2);
  }, [select, onDayClick, setFocused]);
  const handleDayFocus = useCallback((day, m2) => (e2) => {
    setFocused(day);
    onDayFocus?.(day.date, m2, e2);
  }, [onDayFocus, setFocused]);
  const handleDayBlur = useCallback((day, m2) => (e2) => {
    blur();
    onDayBlur?.(day.date, m2, e2);
  }, [blur, onDayBlur]);
  const handleDayKeyDown = useCallback((day, modifiers) => (e2) => {
    const keyMap = {
      ArrowLeft: [
        e2.shiftKey ? "month" : "day",
        props.dir === "rtl" ? "after" : "before"
      ],
      ArrowRight: [
        e2.shiftKey ? "month" : "day",
        props.dir === "rtl" ? "before" : "after"
      ],
      ArrowDown: [e2.shiftKey ? "year" : "week", "after"],
      ArrowUp: [e2.shiftKey ? "year" : "week", "before"],
      PageUp: [e2.shiftKey ? "year" : "month", "before"],
      PageDown: [e2.shiftKey ? "year" : "month", "after"],
      Home: ["startOfWeek", "before"],
      End: ["endOfWeek", "after"]
    };
    if (keyMap[e2.key]) {
      e2.preventDefault();
      e2.stopPropagation();
      const [moveBy, moveDir] = keyMap[e2.key];
      moveFocus(moveBy, moveDir);
    }
    onDayKeyDown?.(day.date, modifiers, e2);
  }, [moveFocus, onDayKeyDown, props.dir]);
  const handleDayMouseEnter = useCallback((day, modifiers) => (e2) => {
    onDayMouseEnter?.(day.date, modifiers, e2);
  }, [onDayMouseEnter]);
  const handleDayMouseLeave = useCallback((day, modifiers) => (e2) => {
    onDayMouseLeave?.(day.date, modifiers, e2);
  }, [onDayMouseLeave]);
  const handleMonthChange = useCallback((date) => (e2) => {
    const selectedMonth = Number(e2.target.value);
    const month = dateLib.setMonth(dateLib.startOfMonth(date), selectedMonth);
    goToMonth(month);
  }, [dateLib, goToMonth]);
  const handleYearChange = useCallback((date) => (e2) => {
    const selectedYear = Number(e2.target.value);
    const month = dateLib.setYear(dateLib.startOfMonth(date), selectedYear);
    goToMonth(month);
  }, [dateLib, goToMonth]);
  const { className, style } = useMemo(() => ({
    className: [classNames[UI.Root], props.className].filter(Boolean).join(" "),
    style: { ...styles?.[UI.Root], ...props.style }
  }), [classNames, props.className, props.style, styles]);
  const dataAttributes = getDataAttributes(props);
  const rootElRef = useRef(null);
  useAnimation(rootElRef, Boolean(props.animate), {
    classNames,
    months,
    focused,
    dateLib
  });
  const contextValue = {
    dayPickerProps: props,
    selected: selectedValue,
    select,
    isSelected,
    months,
    nextMonth,
    previousMonth,
    goToMonth,
    getModifiers,
    components: components2,
    classNames,
    styles,
    labels,
    formatters: formatters2
  };
  return React__default.createElement(
    dayPickerContext.Provider,
    { value: contextValue },
    React__default.createElement(
      components2.Root,
      { rootRef: props.animate ? rootElRef : void 0, className, style, dir: props.dir, id: props.id, lang: props.lang, nonce: props.nonce, title: props.title, role: props.role, "aria-label": props["aria-label"], "aria-labelledby": props["aria-labelledby"], ...dataAttributes },
      React__default.createElement(
        components2.Months,
        { className: classNames[UI.Months], style: styles?.[UI.Months] },
        !props.hideNavigation && !navLayout && React__default.createElement(components2.Nav, { "data-animated-nav": props.animate ? "true" : void 0, className: classNames[UI.Nav], style: styles?.[UI.Nav], "aria-label": labelNav2(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth, nextMonth }),
        months.map((calendarMonth, displayIndex) => {
          return React__default.createElement(
            components2.Month,
            {
              "data-animated-month": props.animate ? "true" : void 0,
              className: classNames[UI.Month],
              style: styles?.[UI.Month],
              // biome-ignore lint/suspicious/noArrayIndexKey: breaks animation
              key: displayIndex,
              displayIndex,
              calendarMonth
            },
            navLayout === "around" && !props.hideNavigation && displayIndex === 0 && React__default.createElement(
              components2.PreviousMonthButton,
              { type: "button", className: classNames[UI.PreviousMonthButton], tabIndex: previousMonth ? void 0 : -1, "aria-disabled": previousMonth ? void 0 : true, "aria-label": labelPrevious2(previousMonth), onClick: handlePreviousClick, "data-animated-button": props.animate ? "true" : void 0 },
              React__default.createElement(components2.Chevron, { disabled: previousMonth ? void 0 : true, className: classNames[UI.Chevron], orientation: props.dir === "rtl" ? "right" : "left" })
            ),
            React__default.createElement(components2.MonthCaption, { "data-animated-caption": props.animate ? "true" : void 0, className: classNames[UI.MonthCaption], style: styles?.[UI.MonthCaption], calendarMonth, displayIndex }, captionLayout?.startsWith("dropdown") ? React__default.createElement(
              components2.DropdownNav,
              { className: classNames[UI.Dropdowns], style: styles?.[UI.Dropdowns] },
              (() => {
                const monthControl = captionLayout === "dropdown" || captionLayout === "dropdown-months" ? React__default.createElement(components2.MonthsDropdown, { key: "month", className: classNames[UI.MonthsDropdown], "aria-label": labelMonthDropdown2(), classNames, components: components2, disabled: Boolean(props.disableNavigation), onChange: handleMonthChange(calendarMonth.date), options: getMonthOptions(calendarMonth.date, navStart, navEnd, formatters2, dateLib), style: styles?.[UI.Dropdown], value: dateLib.getMonth(calendarMonth.date) }) : React__default.createElement("span", { key: "month" }, formatMonthDropdown2(calendarMonth.date, dateLib));
                const yearControl = captionLayout === "dropdown" || captionLayout === "dropdown-years" ? React__default.createElement(components2.YearsDropdown, { key: "year", className: classNames[UI.YearsDropdown], "aria-label": labelYearDropdown2(dateLib.options), classNames, components: components2, disabled: Boolean(props.disableNavigation), onChange: handleYearChange(calendarMonth.date), options: getYearOptions(navStart, navEnd, formatters2, dateLib, Boolean(props.reverseYears)), style: styles?.[UI.Dropdown], value: dateLib.getYear(calendarMonth.date) }) : React__default.createElement("span", { key: "year" }, formatYearDropdown2(calendarMonth.date, dateLib));
                const controls = dateLib.getMonthYearOrder() === "year-first" ? [yearControl, monthControl] : [monthControl, yearControl];
                return controls;
              })(),
              React__default.createElement("span", { role: "status", "aria-live": "polite", style: {
                border: 0,
                clip: "rect(0 0 0 0)",
                height: "1px",
                margin: "-1px",
                overflow: "hidden",
                padding: 0,
                position: "absolute",
                width: "1px",
                whiteSpace: "nowrap",
                wordWrap: "normal"
              } }, formatCaption2(calendarMonth.date, dateLib.options, dateLib))
            ) : React__default.createElement(components2.CaptionLabel, { className: classNames[UI.CaptionLabel], role: "status", "aria-live": "polite" }, formatCaption2(calendarMonth.date, dateLib.options, dateLib))),
            navLayout === "around" && !props.hideNavigation && displayIndex === numberOfMonths - 1 && React__default.createElement(
              components2.NextMonthButton,
              { type: "button", className: classNames[UI.NextMonthButton], tabIndex: nextMonth ? void 0 : -1, "aria-disabled": nextMonth ? void 0 : true, "aria-label": labelNext2(nextMonth), onClick: handleNextClick, "data-animated-button": props.animate ? "true" : void 0 },
              React__default.createElement(components2.Chevron, { disabled: nextMonth ? void 0 : true, className: classNames[UI.Chevron], orientation: props.dir === "rtl" ? "left" : "right" })
            ),
            displayIndex === numberOfMonths - 1 && navLayout === "after" && !props.hideNavigation && React__default.createElement(components2.Nav, { "data-animated-nav": props.animate ? "true" : void 0, className: classNames[UI.Nav], style: styles?.[UI.Nav], "aria-label": labelNav2(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth, nextMonth }),
            React__default.createElement(
              components2.MonthGrid,
              { role: "grid", "aria-multiselectable": mode === "multiple" || mode === "range", "aria-label": labelGrid2(calendarMonth.date, dateLib.options, dateLib) || void 0, className: classNames[UI.MonthGrid], style: styles?.[UI.MonthGrid] },
              !props.hideWeekdays && React__default.createElement(
                components2.Weekdays,
                { "data-animated-weekdays": props.animate ? "true" : void 0, className: classNames[UI.Weekdays], style: styles?.[UI.Weekdays] },
                showWeekNumber && React__default.createElement(components2.WeekNumberHeader, { "aria-label": labelWeekNumberHeader2(dateLib.options), className: classNames[UI.WeekNumberHeader], style: styles?.[UI.WeekNumberHeader], scope: "col" }, formatWeekNumberHeader2()),
                weekdays.map((weekday) => React__default.createElement(components2.Weekday, { "aria-label": labelWeekday2(weekday, dateLib.options, dateLib), className: classNames[UI.Weekday], key: String(weekday), style: styles?.[UI.Weekday], scope: "col" }, formatWeekdayName2(weekday, dateLib.options, dateLib)))
              ),
              React__default.createElement(components2.Weeks, { "data-animated-weeks": props.animate ? "true" : void 0, className: classNames[UI.Weeks], style: styles?.[UI.Weeks] }, calendarMonth.weeks.map((week) => {
                return React__default.createElement(
                  components2.Week,
                  { className: classNames[UI.Week], key: week.weekNumber, style: styles?.[UI.Week], week },
                  showWeekNumber && React__default.createElement(components2.WeekNumber, { week, style: styles?.[UI.WeekNumber], "aria-label": labelWeekNumber2(week.weekNumber, {
                    locale
                  }), className: classNames[UI.WeekNumber], scope: "row", role: "rowheader" }, formatWeekNumber2(week.weekNumber, dateLib)),
                  week.days.map((day) => {
                    const { date } = day;
                    const modifiers = getModifiers(day);
                    modifiers[DayFlag.focused] = !modifiers.hidden && Boolean(focused?.isEqualTo(day));
                    modifiers[SelectionState.selected] = isSelected?.(date) || modifiers.selected;
                    if (isDateRange(selectedValue)) {
                      const { from, to } = selectedValue;
                      modifiers[SelectionState.range_start] = Boolean(from && to && dateLib.isSameDay(date, from));
                      modifiers[SelectionState.range_end] = Boolean(from && to && dateLib.isSameDay(date, to));
                      modifiers[SelectionState.range_middle] = rangeIncludesDate(selectedValue, date, true, dateLib);
                    }
                    const style2 = getStyleForModifiers(modifiers, styles, props.modifiersStyles);
                    const className2 = getClassNamesForModifiers(modifiers, classNames, props.modifiersClassNames);
                    const ariaLabel = !isInteractive && !modifiers.hidden ? labelGridcell2(date, modifiers, dateLib.options, dateLib) : void 0;
                    return React__default.createElement(components2.Day, { key: `${day.isoDate}_${day.displayMonthId}`, day, modifiers, className: className2.join(" "), style: style2, role: "gridcell", "aria-selected": modifiers.selected || void 0, "aria-label": ariaLabel, "data-day": day.isoDate, "data-month": day.outside ? day.dateMonthId : void 0, "data-selected": modifiers.selected || void 0, "data-disabled": modifiers.disabled || void 0, "data-hidden": modifiers.hidden || void 0, "data-outside": day.outside || void 0, "data-focused": modifiers.focused || void 0, "data-today": modifiers.today || void 0 }, !modifiers.hidden && isInteractive ? React__default.createElement(components2.DayButton, { className: classNames[UI.DayButton], style: styles?.[UI.DayButton], type: "button", day, modifiers, disabled: !modifiers.focused && modifiers.disabled || void 0, "aria-disabled": modifiers.focused && modifiers.disabled || void 0, tabIndex: isFocusTarget(day) ? 0 : -1, "aria-label": labelDayButton2(date, modifiers, dateLib.options, dateLib), onClick: handleDayClick(day, modifiers), onBlur: handleDayBlur(day, modifiers), onFocus: handleDayFocus(day, modifiers), onKeyDown: handleDayKeyDown(day, modifiers), onMouseEnter: handleDayMouseEnter(day, modifiers), onMouseLeave: handleDayMouseLeave(day, modifiers) }, formatDay2(date, dateLib.options, dateLib)) : !modifiers.hidden && formatDay2(day.date, dateLib.options, dateLib));
                  })
                );
              }))
            )
          );
        })
      ),
      props.footer && React__default.createElement(components2.Footer, { className: classNames[UI.Footer], style: styles?.[UI.Footer], role: "status", "aria-live": "polite" }, props.footer)
    )
  );
}
const LanguageContext = React__default.createContext({
  language: "en",
  sources: [],
  setLanguage: () => {
    console.warn("setLanguage called outside of LanguageProvider");
  }
});
const LanguageProvider = ({ children, sources }) => {
  const [language, setLanguageState] = useState(() => {
    if (typeof window !== "undefined") {
      const savedLanguage = localStorage.getItem("language");
      return savedLanguage || "en";
    }
    return "en";
  });
  const setLanguage = (newLanguage) => {
    setLanguageState(newLanguage);
    if (typeof window !== "undefined") {
      localStorage.setItem("language", newLanguage);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageContext.Provider, { value: { language, sources, setLanguage }, children });
};
const useLanguage = () => {
  const context = useContext(LanguageContext);
  if (!context) {
    throw new Error("useLanguage must be used within a LanguageProvider");
  }
  return context;
};
const ui_i18n = {
  en: {
    expand: "Expand",
    collapse: "Collapse",
    lightmode: "Light Mode",
    darkmode: "Dark Mode",
    light: "light",
    lightTitle: "Light",
    dark: "dark",
    darkTitle: "Dark",
    switchtotheme: "Switch to {theme} theme",
    today: "Today",
    clear: "Clear",
    days: {
      monday: "Monday",
      tuesday: "Tuesday",
      wednesday: "Wednesday",
      thursday: "Thursday",
      friday: "Friday",
      saturday: "Saturday",
      sunday: "Sunday"
    },
    daysthreeletterformat: {
      monday: "Mon",
      tuesday: "Tue",
      wednesday: "Wed",
      thursday: "Thu",
      friday: "Fri",
      saturday: "Sat",
      sunday: "Sun"
    },
    daystwoletterformat: {
      monday: "MO",
      tuesday: "TU",
      wednesday: "WE",
      thursday: "TH",
      friday: "FR",
      saturday: "SA",
      sunday: "SU"
    },
    months: {
      january: "January",
      february: "February",
      march: "March",
      april: "April",
      may: "May",
      june: "June",
      july: "July",
      august: "August",
      september: "September",
      october: "October",
      november: "November",
      december: "December"
    },
    monthsthreeletterformat: {
      january: "Jan",
      february: "Feb",
      march: "Mar",
      april: "Apr",
      may: "May",
      june: "Jun",
      july: "Jul",
      august: "Aug",
      september: "Sep",
      october: "Oct",
      november: "Nov",
      december: "Dec"
    }
  },
  es: {
    expand: "Expandir",
    collapse: "Colapsar",
    lightmode: "Modo Claro",
    darkmode: "Modo Oscuro",
    switchtotheme: "Cambiar al tema {theme}",
    light: "claro",
    lightTitle: "Claro",
    dark: "oscuro",
    darkTitle: "Oscuro",
    today: "Hoy",
    clear: "Borrar",
    days: {
      monday: "Lunes",
      tuesday: "Martes",
      wednesday: "Miércoles",
      thursday: "Jueves",
      friday: "Viernes",
      saturday: "Sábado",
      sunday: "Domingo"
    },
    daysthreeletterformat: {
      monday: "Lun",
      tuesday: "Mar",
      wednesday: "Mié",
      thursday: "Jue",
      friday: "Vie",
      saturday: "Sáb",
      sunday: "Dom"
    },
    daystwoletterformat: {
      monday: "LU",
      tuesday: "MA",
      wednesday: "MI",
      thursday: "JU",
      friday: "VI",
      saturday: "SA",
      sunday: "DO"
    },
    months: {
      january: "Enero",
      february: "Febrero",
      march: "Marzo",
      april: "Abril",
      may: "Mayo",
      june: "Junio",
      july: "Julio",
      august: "Agosto",
      september: "Septiembre",
      october: "Octubre",
      november: "Noviembre",
      december: "Diciembre"
    },
    monthsthreeletterformat: {
      january: "Ene",
      february: "Feb",
      march: "Mar",
      april: "Abr",
      may: "May",
      june: "Jun",
      july: "Jul",
      august: "Ago",
      september: "Sep",
      october: "Oct",
      november: "Nov",
      december: "Dic"
    }
  },
  de: {
    expand: "Erweitern",
    collapse: "Reduzieren",
    lightmode: "Heller Modus",
    darkmode: "Dunkler Modus",
    light: "hell",
    lightTitle: "Hell",
    dark: "dunkel",
    darkTitle: "Dunkel",
    switchtotheme: "Zum {theme}-Modus wechseln",
    today: "Heute",
    clear: "Löschen",
    days: {
      monday: "Montag",
      tuesday: "Dienstag",
      wednesday: "Mittwoch",
      thursday: "Donnerstag",
      friday: "Freitag",
      saturday: "Samstag",
      sunday: "Sonntag"
    },
    daysthreeletterformat: {
      monday: "Mo",
      tuesday: "Di",
      wednesday: "Mi",
      thursday: "Do",
      friday: "Fr",
      saturday: "Sa",
      sunday: "So"
    },
    daystwoletterformat: {
      monday: "MO",
      tuesday: "DI",
      wednesday: "MI",
      thursday: "DO",
      friday: "FR",
      saturday: "SA",
      sunday: "SO"
    },
    months: {
      january: "Januar",
      february: "Februar",
      march: "März",
      april: "April",
      may: "Mai",
      june: "Juni",
      july: "Juli",
      august: "August",
      september: "September",
      october: "Oktober",
      november: "November",
      december: "Dezember"
    },
    monthsthreeletterformat: {
      january: "Jan",
      february: "Feb",
      march: "Mär",
      april: "Apr",
      may: "Mai",
      june: "Jun",
      july: "Jul",
      august: "Aug",
      september: "Sep",
      october: "Okt",
      november: "Nov",
      december: "Dez"
    }
  },
  ru: {
    expand: "Развернуть",
    collapse: "Свернуть",
    lightmode: "Светлый режим",
    darkmode: "Тёмный режим",
    light: "светлая",
    lightTitle: "Светлая",
    dark: "тёмная",
    darkTitle: "Тёмная",
    switchtotheme: "Переключиться на тему {theme}",
    today: "Сегодня",
    clear: "Очистить",
    days: {
      monday: "Понедельник",
      tuesday: "Вторник",
      wednesday: "Среда",
      thursday: "Четверг",
      friday: "Пятница",
      saturday: "Суббота",
      sunday: "Воскресенье"
    },
    daysthreeletterformat: {
      monday: "Пн",
      tuesday: "Вт",
      wednesday: "Ср",
      thursday: "Чт",
      friday: "Пт",
      saturday: "Сб",
      sunday: "Вс"
    },
    daystwoletterformat: {
      monday: "ПН",
      tuesday: "ВТ",
      wednesday: "СР",
      thursday: "ЧТ",
      friday: "ПТ",
      saturday: "СБ",
      sunday: "ВС"
    },
    months: {
      january: "Январь",
      february: "Февраль",
      march: "Март",
      april: "Апрель",
      may: "Май",
      june: "Июнь",
      july: "Июль",
      august: "Август",
      september: "Сентябрь",
      october: "Октябрь",
      november: "Ноябрь",
      december: "Декабрь"
    },
    monthsthreeletterformat: {
      january: "Янв",
      february: "Фев",
      march: "Мар",
      april: "Апр",
      may: "Май",
      june: "Июн",
      july: "Июл",
      august: "Авг",
      september: "Сен",
      october: "Окт",
      november: "Ноя",
      december: "Дек"
    }
  },
  zh: {
    expand: "展开",
    collapse: "收起",
    lightmode: "浅色模式",
    darkmode: "深色模式",
    light: "浅色",
    lightTitle: "浅色",
    dark: "深色",
    darkTitle: "深色",
    switchtotheme: "切换到{theme}主题",
    today: "今天",
    clear: "清除",
    days: {
      monday: "星期一",
      tuesday: "星期二",
      wednesday: "星期三",
      thursday: "星期四",
      friday: "星期五",
      saturday: "星期六",
      sunday: "星期日"
    },
    daysthreeletterformat: {
      monday: "周一",
      tuesday: "周二",
      wednesday: "周三",
      thursday: "周四",
      friday: "周五",
      saturday: "周六",
      sunday: "周日"
    },
    daystwoletterformat: {
      monday: "一",
      tuesday: "二",
      wednesday: "三",
      thursday: "四",
      friday: "五",
      saturday: "六",
      sunday: "日"
    },
    months: {
      january: "一月",
      february: "二月",
      march: "三月",
      april: "四月",
      may: "五月",
      june: "六月",
      july: "七月",
      august: "八月",
      september: "九月",
      october: "十月",
      november: "十一月",
      december: "十二月"
    },
    monthsthreeletterformat: {
      january: "1月",
      february: "2月",
      march: "3月",
      april: "4月",
      may: "5月",
      june: "6月",
      july: "7月",
      august: "8月",
      september: "9月",
      october: "10月",
      november: "11月",
      december: "12月"
    }
  }
};
const de$2 = {
  ...de$3,
  labels: {
    labelDayButton: (date, modifiers, options, dateLib) => {
      const lib = dateLib ?? new DateLib(options);
      let label = lib.format(date, "PPPP");
      if (modifiers.today)
        label = `Heute, ${label}`;
      if (modifiers.selected)
        label = `${label}, ausgewählt`;
      return label;
    },
    labelMonthDropdown: "Monat auswählen",
    labelNext: "Zum nächsten Monat",
    labelPrevious: "Zum vorherigen Monat",
    labelWeekNumber: (weekNumber) => `Woche ${weekNumber}`,
    labelYearDropdown: "Jahr auswählen",
    labelGrid: (date, options, dateLib) => (dateLib ?? new DateLib(options)).formatMonthYear(date),
    labelGridcell: (date, modifiers, options, dateLib) => {
      const lib = dateLib ?? new DateLib(options);
      let label = lib.format(date, "PPPP");
      if (modifiers?.today) {
        label = `Heute, ${label}`;
      }
      return label;
    },
    labelNav: "Navigationsleiste",
    labelWeekNumberHeader: "Wochennummer",
    labelWeekday: (date, options, dateLib) => (dateLib ?? new DateLib(options)).format(date, "cccc")
  }
};
const es = {
  ...es$1,
  labels: {
    labelDayButton: (date, modifiers, options, dateLib) => {
      const lib = dateLib ?? new DateLib(options);
      let label = lib.format(date, "PPPP");
      if (modifiers.today)
        label = `Hoy, ${label}`;
      if (modifiers.selected)
        label = `${label}, seleccionado`;
      return label;
    },
    labelMonthDropdown: "Elegir el mes",
    labelNext: "Ir al mes siguiente",
    labelPrevious: "Ir al mes anterior",
    labelWeekNumber: (weekNumber) => `Semana ${weekNumber}`,
    labelYearDropdown: "Elegir el año",
    labelGrid: (date, options, dateLib) => (dateLib ?? new DateLib(options)).formatMonthYear(date),
    labelGridcell: (date, modifiers, options, dateLib) => {
      const lib = dateLib ?? new DateLib(options);
      let label = lib.format(date, "PPPP");
      if (modifiers?.today) {
        label = `Hoy, ${label}`;
      }
      return label;
    },
    labelNav: "Barra de navegación",
    labelWeekNumberHeader: "Número de semana",
    labelWeekday: (date, options, dateLib) => (dateLib ?? new DateLib(options)).format(date, "cccc")
  }
};
const ru = {
  ...ru$1,
  labels: {
    labelDayButton: (date, modifiers, options, dateLib) => {
      const lib = dateLib ?? new DateLib(options);
      let label = lib.format(date, "PPPP");
      if (modifiers.today)
        label = `Сегодня, ${label}`;
      if (modifiers.selected)
        label = `${label}, выбрано`;
      return label;
    },
    labelMonthDropdown: "Выберите месяц",
    labelNext: "Перейти к следующему месяцу",
    labelPrevious: "Перейти к предыдущему месяцу",
    labelWeekNumber: (weekNumber) => `Неделя ${weekNumber}`,
    labelYearDropdown: "Выберите год",
    labelGrid: (date, options, dateLib) => (dateLib ?? new DateLib(options)).formatMonthYear(date),
    labelGridcell: (date, modifiers, options, dateLib) => {
      const lib = dateLib ?? new DateLib(options);
      let label = lib.format(date, "PPPP");
      if (modifiers?.today) {
        label = `Сегодня, ${label}`;
      }
      return label;
    },
    labelNav: "Панель навигации",
    labelWeekNumberHeader: "Номер недели",
    labelWeekday: (date, options, dateLib) => (dateLib ?? new DateLib(options)).format(date, "cccc")
  }
};
const zhCN = {
  ...zhCN$1,
  labels: {
    labelDayButton: (date, modifiers, options, dateLib) => {
      const lib = dateLib ?? new DateLib(options);
      let label = lib.format(date, "PPPP");
      if (modifiers.today)
        label = `今天，${label}`;
      if (modifiers.selected)
        label = `${label}，已选择`;
      return label;
    },
    labelMonthDropdown: "选择月份",
    labelNext: "前往下个月",
    labelPrevious: "前往上个月",
    labelWeekNumber: (weekNumber) => `第 ${weekNumber} 周`,
    labelYearDropdown: "选择年份",
    labelGrid: (date, options, dateLib) => (dateLib ?? new DateLib(options)).formatMonthYear(date),
    labelGridcell: (date, modifiers, options, dateLib) => {
      const lib = dateLib ?? new DateLib(options);
      let label = lib.format(date, "PPPP");
      if (modifiers?.today) {
        label = `今天，${label}`;
      }
      return label;
    },
    labelNav: "导航栏",
    labelWeekNumberHeader: "周数",
    labelWeekday: (date, options, dateLib) => (dateLib ?? new DateLib(options)).format(date, "cccc")
  }
};
const MONTH_NAMES = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const MONTH_NAMES_SHORT = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
const locales = {
  en: enUS,
  es,
  ru,
  de: de$2,
  zh: zhCN
};
const CALENDAR_TOKENS = {
  typography: {
    fontFamily: {
      body: "font-body"
    }
  },
  spacing: {
    compact: { cell: "28px", padding: "p-2" },
    comfortable: { cell: "36px", padding: "p-3" },
    spacious: { cell: "44px", padding: "p-4" },
    relaxed: { cell: "52px", padding: "p-5" }
  },
  radius: {
    none: "rounded-none",
    sm: "rounded-sm",
    md: "rounded-md",
    lg: "rounded-lg",
    xl: "rounded-xl",
    full: "rounded-full"
  }
};
const useDeprecationWarning$1 = (props, deprecatedProps) => {
  useEffect(() => {
    if (process.env.NODE_ENV === "development") {
      Object.keys(deprecatedProps).forEach((oldProp) => {
        if (props[oldProp] !== void 0) {
          console.warn(`[Calendar] '${oldProp}' is deprecated. ${deprecatedProps[oldProp]}`);
        }
      });
    }
  }, [props, deprecatedProps]);
};
const getColorPalette = (color2) => {
  const palettes = {
    primary: { accent: "#0d9488", accentHover: "#0a6960", accentLight: "rgba(13, 148, 136, 0.12)", accentMedium: "rgba(13, 148, 136, 0.25)", onAccent: "#ffffff" },
    // Secondary: navy-700 (#1B3A7B) for light, navy-500 (#365D9E) for dark mode
    secondary: {
      accent: "#1B3A7B",
      accentHover: "#0f2246",
      accentLight: "rgba(27, 58, 123, 0.12)",
      accentMedium: "rgba(27, 58, 123, 0.25)",
      onAccent: "#ffffff",
      // Dark mode: use lighter navy-500 for better visibility
      accentDark: "#365D9E",
      accentHoverDark: "#5C7EB5",
      accentLightDark: "rgba(54, 93, 158, 0.18)",
      accentMediumDark: "rgba(54, 93, 158, 0.35)"
    },
    success: { accent: "#22c55e", accentHover: "#16a34a", accentLight: "rgba(34, 197, 94, 0.12)", accentMedium: "rgba(34, 197, 94, 0.25)", onAccent: "#ffffff" },
    warning: { accent: "#f59e0b", accentHover: "#d97706", accentLight: "rgba(245, 158, 11, 0.12)", accentMedium: "rgba(245, 158, 11, 0.25)", onAccent: "#ffffff" },
    danger: { accent: "#ef4444", accentHover: "#dc2626", accentLight: "rgba(239, 68, 68, 0.12)", accentMedium: "rgba(239, 68, 68, 0.25)", onAccent: "#ffffff" },
    info: { accent: "#3b82f6", accentHover: "#2563eb", accentLight: "rgba(59, 130, 246, 0.12)", accentMedium: "rgba(59, 130, 246, 0.25)", onAccent: "#ffffff" },
    neutral: { accent: "#374151", accentHover: "#1f2937", accentLight: "rgba(55, 65, 81, 0.12)", accentMedium: "rgba(55, 65, 81, 0.25)", onAccent: "#ffffff" }
  };
  return palettes[color2];
};
const getVariantStyles = (variant, palette) => {
  const variants = {
    solid: {
      selected: `background-color: ${palette.accent}; color: ${palette.onAccent};`,
      selectedHover: `background-color: ${palette.accentHover}; color: ${palette.onAccent};`,
      today: `border: 2px solid ${palette.accent}; font-weight: 700;`,
      hover: `background-color: ${palette.accentLight};`,
      hoverDark: `background-color: ${palette.accentMedium};`
    },
    soft: {
      selected: `background-color: ${palette.accentMedium}; color: ${palette.accent}; font-weight: 600;`,
      selectedHover: `background-color: ${palette.accentMedium}; color: ${palette.accentHover};`,
      today: `background-color: ${palette.accentLight}; border: 1px solid ${palette.accent}; font-weight: 700;`,
      hover: `background-color: ${palette.accentLight};`,
      hoverDark: `background-color: ${palette.accentMedium};`
    },
    outline: {
      selected: `background-color: transparent; border: 2px solid ${palette.accent}; color: ${palette.accent}; font-weight: 600;`,
      selectedHover: `background-color: ${palette.accentLight}; border: 2px solid ${palette.accent}; color: ${palette.accent};`,
      today: `border: 2px dashed ${palette.accent}; font-weight: 700;`,
      hover: `border: 1px solid ${palette.accent}; background-color: transparent;`,
      hoverDark: `border: 1px solid ${palette.accent}; background-color: ${palette.accentLight};`
    },
    minimal: {
      selected: `background-color: ${palette.accentLight}; color: ${palette.accent}; font-weight: 600;`,
      selectedHover: `background-color: ${palette.accentMedium}; color: ${palette.accent};`,
      today: `color: ${palette.accent}; font-weight: 700; text-decoration: underline; text-underline-offset: 4px;`,
      hover: `background-color: rgba(0,0,0,0.04);`,
      hoverDark: `background-color: rgba(255,255,255,0.08);`
    },
    glass: {
      selected: `background: linear-gradient(135deg, ${palette.accent}ee, ${palette.accent}aa); color: ${palette.onAccent}; backdrop-filter: blur(4px);`,
      selectedHover: `background: linear-gradient(135deg, ${palette.accent}, ${palette.accentHover}); color: ${palette.onAccent};`,
      today: `background: ${palette.accentLight}; backdrop-filter: blur(2px); border: 1px solid ${palette.accent}; font-weight: 700;`,
      hover: `background: ${palette.accentLight}; backdrop-filter: blur(2px);`,
      hoverDark: `background: ${palette.accentMedium}; backdrop-filter: blur(2px);`
    }
  };
  return variants[variant];
};
const getSizeConfig = (size2) => {
  const sizes = {
    xs: { cell: 28, nav: 22, dropdown: "text-xs", weekday: "text-[10px]" },
    sm: { cell: 32, nav: 26, dropdown: "text-sm", weekday: "text-xs" },
    md: { cell: 40, nav: 32, dropdown: "text-base", weekday: "text-xs" },
    lg: { cell: 48, nav: 38, dropdown: "text-lg", weekday: "text-sm" },
    xl: { cell: 56, nav: 44, dropdown: "text-xl", weekday: "text-sm" }
  };
  return sizes[size2];
};
const Calendar$1 = (props) => {
  const {
    mode = "single",
    displayMonth,
    onDisplayMonthChange,
    className,
    size: size2 = "md",
    color: color2 = "primary",
    variant = "solid",
    density = "comfortable",
    radius = "lg",
    disabled = false,
    showOutsideDays = true,
    showWeekNumber = false,
    showHeader = true,
    highlightToday = true,
    navigation = "modern",
    numberOfMonths = 1,
    independentNavigation = false,
    fromDate,
    toDate: toDate2,
    fromYear,
    toYear,
    disabledDates,
    weekStartsOn = 0,
    elevated = false,
    bordered = true,
    fullWidth = false,
    animated = true,
    selectedValue,
    displayDate,
    onDisplayDateChange,
    hasShadow,
    isBordered,
    min: min2,
    max: max2
  } = props;
  const { language: contextLanguage } = useLanguage();
  const value = mode === "single" ? props.value : void 0;
  const onDateSelect = mode === "single" ? props.onDateSelect : void 0;
  const rangeValue = mode === "range" ? props.rangeValue : void 0;
  const onRangeSelect = mode === "range" ? props.onRangeSelect : void 0;
  const adjustable = mode === "range" ? props.adjustable ?? false : false;
  const draggable = mode === "range" ? props.draggable ?? true : false;
  const multiValue = mode === "multiple" ? props.multiValue : void 0;
  const onMultiSelect = mode === "multiple" ? props.onMultiSelect : void 0;
  const [isDragging2, setIsDragging] = useState(null);
  const calendarRef = useRef(null);
  const justFinishedDragging = useRef(false);
  const [hoveredDate, setHoveredDate] = useState(void 0);
  const rangeValueRef = useRef(rangeValue);
  rangeValueRef.current = rangeValue;
  const getDisabledMatcher = useCallback(() => {
    if (disabled === true) return true;
    const matchers = [];
    if (disabledDates && disabledDates.length > 0) {
      matchers.push(...disabledDates);
    }
    if (fromDate) {
      matchers.push({ before: fromDate });
    }
    if (toDate2) {
      matchers.push({ after: toDate2 });
    }
    if (matchers.length === 0) return void 0;
    return matchers;
  }, [disabled, disabledDates, fromDate, toDate2]);
  const getRangeSelectionState = useCallback(() => {
    const current = rangeValueRef.current;
    if (!current || !current.from && !current.to) return 0;
    if (current.from && !current.to) return 1;
    if (current.from && current.to) return 2;
    return 0;
  }, []);
  const handleRangeSelection = useCallback((selectedDay) => {
    if (!onRangeSelect) return;
    const currentRange = rangeValueRef.current;
    const currentState = getRangeSelectionState();
    if (currentState === 0) {
      onRangeSelect({ from: selectedDay, to: void 0 });
      return;
    }
    if (currentState === 1 && currentRange?.from) {
      if (selectedDay.getTime() === currentRange.from.getTime()) {
        onRangeSelect({ from: void 0, to: void 0 });
        setHoveredDate(void 0);
        return;
      }
      if (selectedDay < currentRange.from) {
        onRangeSelect({ from: selectedDay, to: currentRange.from });
        return;
      }
      onRangeSelect({ from: currentRange.from, to: selectedDay });
      setHoveredDate(void 0);
      return;
    }
    if (currentState === 2 && currentRange?.from && currentRange?.to) {
      if (adjustable) {
        if (selectedDay < currentRange.from) {
          onRangeSelect({ from: selectedDay, to: currentRange.to });
          return;
        }
        if (selectedDay > currentRange.to) {
          onRangeSelect({ from: currentRange.from, to: selectedDay });
          return;
        }
        const distToStart = Math.abs(selectedDay.getTime() - currentRange.from.getTime());
        const distToEnd = Math.abs(selectedDay.getTime() - currentRange.to.getTime());
        if (distToStart <= distToEnd) {
          onRangeSelect({ from: selectedDay, to: currentRange.to });
        } else {
          onRangeSelect({ from: currentRange.from, to: selectedDay });
        }
        return;
      }
      onRangeSelect({ from: selectedDay, to: void 0 });
      return;
    }
  }, [onRangeSelect, adjustable, getRangeSelectionState]);
  const getHoverPreviewDates = useCallback(() => {
    const currentRange = rangeValueRef.current;
    const currentState = getRangeSelectionState();
    if (currentState !== 1 || !currentRange?.from || !hoveredDate) return [];
    if (hoveredDate.getTime() === currentRange.from.getTime()) return [];
    const dates = [];
    const startDate = hoveredDate < currentRange.from ? hoveredDate : currentRange.from;
    const endDate = hoveredDate > currentRange.from ? hoveredDate : currentRange.from;
    const current = new Date(startDate);
    current.setDate(current.getDate() + 1);
    while (current < endDate) {
      dates.push(new Date(current));
      current.setDate(current.getDate() + 1);
    }
    return dates;
  }, [hoveredDate, getRangeSelectionState]);
  const uniqueId = useId$1().replace(/:/g, "");
  useDeprecationWarning$1(
    { selectedValue, displayDate, onDisplayDateChange, hasShadow, isBordered },
    {
      selectedValue: "Use 'value' instead.",
      displayDate: "Use 'displayMonth' instead.",
      onDisplayDateChange: "Use 'onDisplayMonthChange' instead.",
      hasShadow: "Use 'elevated' instead.",
      isBordered: "Use 'bordered' instead."
    }
  );
  const finalValue = value ?? (selectedValue instanceof Date ? selectedValue : void 0);
  const finalMonth = displayMonth ?? displayDate;
  const finalOnMonthChange = onDisplayMonthChange ?? onDisplayDateChange;
  const finalElevated = elevated || hasShadow;
  const finalBordered = bordered ?? isBordered ?? true;
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const startYear = fromYear ?? currentYear - 100;
  const endYear = toYear ?? currentYear + 10;
  const [showMonthPicker, setShowMonthPicker] = useState(false);
  const [showYearPicker, setShowYearPicker] = useState(false);
  const getInitialYearRange = () => {
    const targetYear = finalMonth?.getFullYear() ?? currentYear;
    let rangeStart = Math.floor(targetYear / 12) * 12;
    if (rangeStart > endYear) {
      rangeStart = Math.floor(endYear / 12) * 12;
    }
    if (rangeStart + 11 < startYear) {
      rangeStart = Math.floor(startYear / 12) * 12;
    }
    return rangeStart;
  };
  const [yearRangeStart, setYearRangeStart] = useState(getInitialYearRange);
  const monthPickerRef = useRef(null);
  const yearPickerRef = useRef(null);
  const defaultRhsMonth = useMemo(() => {
    const date = new Date(finalMonth ?? /* @__PURE__ */ new Date());
    date.setMonth(date.getMonth() + 1);
    return date;
  }, []);
  const [rhsMonth, setRhsMonth] = useState(defaultRhsMonth);
  const [showRhsMonthPicker, setShowRhsMonthPicker] = useState(false);
  const [showRhsYearPicker, setShowRhsYearPicker] = useState(false);
  const [rhsYearRangeStart, setRhsYearRangeStart] = useState(Math.floor(rhsMonth.getFullYear() / 12) * 12);
  const rhsMonthPickerRef = useRef(null);
  const rhsYearPickerRef = useRef(null);
  useEffect(() => {
    const isAnyPickerOpen = showMonthPicker || showYearPicker || showRhsMonthPicker || showRhsYearPicker;
    if (!isAnyPickerOpen) {
      return;
    }
    const handleClickOutside = (event) => {
      if (calendarRef.current && calendarRef.current.contains(event.target)) {
        return;
      }
      setShowMonthPicker(false);
      setShowYearPicker(false);
      setShowRhsMonthPicker(false);
      setShowRhsYearPicker(false);
    };
    const timeoutId = setTimeout(() => {
      document.addEventListener("mousedown", handleClickOutside);
    }, 10);
    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [showMonthPicker, showYearPicker, showRhsMonthPicker, showRhsYearPicker]);
  const handleMonthSelect = useCallback((monthIndex) => {
    const newDate = new Date(finalMonth ?? /* @__PURE__ */ new Date());
    newDate.setMonth(monthIndex);
    finalOnMonthChange?.(newDate);
    setShowMonthPicker(false);
  }, [finalMonth, finalOnMonthChange]);
  const handleYearSelect = useCallback((year) => {
    const newDate = new Date(finalMonth ?? /* @__PURE__ */ new Date());
    newDate.setFullYear(year);
    finalOnMonthChange?.(newDate);
    setShowYearPicker(false);
  }, [finalMonth, finalOnMonthChange]);
  const handlePrevYearRange = () => setYearRangeStart((prev) => Math.max(startYear, prev - 12));
  const handleNextYearRange = () => setYearRangeStart((prev) => Math.min(endYear - 11, prev + 12));
  const handleRhsMonthSelect = useCallback((monthIndex) => {
    const newDate = new Date(rhsMonth);
    newDate.setMonth(monthIndex);
    setRhsMonth(newDate);
    setShowRhsMonthPicker(false);
  }, [rhsMonth]);
  const handleRhsYearSelect = useCallback((year) => {
    const newDate = new Date(rhsMonth);
    newDate.setFullYear(year);
    setRhsMonth(newDate);
    setShowRhsYearPicker(false);
  }, [rhsMonth]);
  const getDateFromElement = useCallback((element) => {
    if (!element) return null;
    const button = element.closest(".rdp-day_button") || element.querySelector(".rdp-day_button");
    if (!button) return null;
    const label = button.getAttribute("aria-label");
    if (!label) return null;
    const dateMatch = label.match(/(\w+),\s+(\w+)\s+(\d+)\w*,\s+(\d+)/);
    if (!dateMatch) return null;
    const [, , monthName, day, year] = dateMatch;
    const monthIndex = MONTH_NAMES.findIndex((m2) => m2.toLowerCase() === monthName.toLowerCase());
    if (monthIndex === -1) return null;
    return new Date(parseInt(year), monthIndex, parseInt(day));
  }, []);
  const handlePointerDown = useCallback((e2) => {
    if (!draggable || mode !== "range" || !rangeValue?.from || !rangeValue?.to) return;
    const target = e2.target;
    const dayCell = target.closest(".rdp-day");
    if (!dayCell) return;
    const isStart = dayCell.classList.contains("rdp-range_start");
    const isEnd = dayCell.classList.contains("rdp-range_end");
    if (isStart && !isEnd) {
      setIsDragging("start");
      e2.target.setPointerCapture?.(e2.pointerId);
      e2.preventDefault();
    } else if (isEnd && !isStart) {
      setIsDragging("end");
      e2.target.setPointerCapture?.(e2.pointerId);
      e2.preventDefault();
    }
  }, [draggable, mode, rangeValue]);
  const handlePointerMove = useCallback((e2) => {
    if (!isDragging2 || !onRangeSelect || !rangeValue?.from || !rangeValue?.to) return;
    const target = document.elementFromPoint(e2.clientX, e2.clientY);
    if (!target) return;
    const dayCell = target.closest(".rdp-day");
    if (!dayCell || dayCell.classList.contains("rdp-disabled") || dayCell.classList.contains("rdp-outside")) return;
    const date = getDateFromElement(dayCell);
    if (!date) return;
    const { from, to } = rangeValue;
    if (isDragging2 === "start") {
      if (date < to) {
        onRangeSelect({ from: date, to });
      }
    } else if (isDragging2 === "end") {
      if (date > from) {
        onRangeSelect({ from, to: date });
      }
    }
  }, [isDragging2, onRangeSelect, rangeValue, getDateFromElement]);
  const handlePointerUp = useCallback((e2) => {
    if (isDragging2) {
      e2.target.releasePointerCapture?.(e2.pointerId);
      setIsDragging(null);
      justFinishedDragging.current = true;
      setTimeout(() => {
        justFinishedDragging.current = false;
      }, 100);
    }
  }, [isDragging2]);
  const handlePointerLeave = useCallback(() => {
    if (isDragging2) {
      setIsDragging(null);
      justFinishedDragging.current = true;
      setTimeout(() => {
        justFinishedDragging.current = false;
      }, 100);
    }
  }, [isDragging2]);
  useEffect(() => {
    if (isDragging2) {
      const handleGlobalPointerUp = () => {
        setIsDragging(null);
        justFinishedDragging.current = true;
        setTimeout(() => {
          justFinishedDragging.current = false;
        }, 100);
      };
      document.addEventListener("pointerup", handleGlobalPointerUp);
      document.addEventListener("pointercancel", handleGlobalPointerUp);
      return () => {
        document.removeEventListener("pointerup", handleGlobalPointerUp);
        document.removeEventListener("pointercancel", handleGlobalPointerUp);
      };
    }
  }, [isDragging2]);
  const palette = useMemo(() => getColorPalette(color2), [color2]);
  const variantStyles = useMemo(() => getVariantStyles(variant, palette), [variant, palette]);
  const sizeConfig2 = useMemo(() => getSizeConfig(size2), [size2]);
  const spacingConfig = CALENDAR_TOKENS.spacing[density];
  const radiusClass = CALENDAR_TOKENS.radius[radius];
  const dayRadius = radius === "full" ? "50%" : radius === "none" ? "0" : "6px";
  const scopedClass = `acutrack-cal-${uniqueId}`;
  const dynamicStyles = `
    /* Reset react-day-picker defaults */
    .${scopedClass} .rdp-root {
      --rdp-accent-color: ${palette.accent};
      --rdp-accent-background-color: ${palette.accent};
      margin: 0;
      font-family: inherit;
    }
    
    /* Remove all default focus outlines */
    .${scopedClass} *:focus {
      outline: none !important;
      box-shadow: none !important;
    }
    
    .${scopedClass} button:focus,
    .${scopedClass} select:focus {
      outline: none !important;
      box-shadow: none !important;
    }

    /* RDP Months Container - Position nav on right */
    .${scopedClass} .rdp-months {
      display: flex;
      flex-direction: ${numberOfMonths > 1 ? "row" : "column"};
      ${numberOfMonths > 1 ? "gap: 1.5rem;" : ""}
      position: relative;
    }
    
    /* Multi-month layout styles */
    ${numberOfMonths > 1 ? `
    .${scopedClass} .rdp-month {
      flex: 1;
    }
    
    /* Navigation style: Buttons - Show plain text labels, hide dropdowns */
    ${navigation === "buttons" ? `
    .${scopedClass} .rdp-month .rdp-caption_label {
      display: flex !important;
      font-weight: 600;
      font-size: ${size2 === "xs" ? "12px" : size2 === "sm" ? "13px" : size2 === "lg" ? "16px" : size2 === "xl" ? "18px" : "14px"};
      color: ${palette.accent};
    }
    .dark .${scopedClass} .rdp-month .rdp-caption_label {
      color: ${palette.accentDark || palette.accent};
    }
    .${scopedClass} .rdp-month .rdp-dropdowns {
      display: none !important;
    }
    ` : `
    /* Navigation style: Dropdown/Modern - Hide plain label, show dropdowns */
    .${scopedClass} .rdp-month .rdp-caption_label {
      display: none !important;
    }
    .${scopedClass} .rdp-month .rdp-dropdowns {
      display: flex !important;
    }
    `}
    
    /* Show nav buttons on ALL months in dual calendar mode */
    .${scopedClass} .rdp-month .rdp-nav {
      display: flex !important;
    }
    
    /* Position nav buttons on right of each month's header */
    .${scopedClass} .rdp-month .rdp-month_caption {
      position: relative;
    }
    ` : ""}
    
    /* Caption / Month-Year Header */
    .${scopedClass} .rdp-month_caption {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 0 0 0.5rem 0;
      margin-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0,0,0,0.06);
      gap: 0.5rem;
    }
    
    .dark .${scopedClass} .rdp-month_caption {
      border-bottom-color: rgba(255,255,255,0.08);
    }
    
    .${scopedClass} .rdp-caption_label {
      display: ${numberOfMonths > 1 ? "flex" : "none"} !important;
      font-weight: 600;
      color: ${palette.accent};
    }
    
    .dark .${scopedClass} .rdp-caption_label {
      color: ${palette.accentDark || palette.accent};
    }
    
    /* Month/Year Dropdowns - On the LEFT */
    .${scopedClass} .rdp-dropdowns {
      display: flex !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
      gap: ${size2 === "xs" ? "0.25rem" : "0.375rem"};
      align-items: center;
      position: relative !important;
    }
    
    .${scopedClass} .rdp-dropdown_root {
      display: inline-flex !important;
      visibility: visible !important;
      position: relative !important;
      height: auto !important;
    }
    
    .${scopedClass} .rdp-dropdown {
      appearance: none !important;
      position: relative !important;
      opacity: 1 !important;
      height: auto !important;
      width: auto !important;
      background: transparent;
      border: none;
      border-radius: 4px;
      padding: ${size2 === "xs" ? "0.125rem 1.25rem 0.125rem 0.25rem" : size2 === "sm" ? "0.1875rem 1.375rem 0.1875rem 0.375rem" : "0.25rem 1.5rem 0.25rem 0.5rem"};
      font-weight: 700;
      font-size: ${size2 === "xs" ? "11px" : size2 === "sm" ? "12px" : size2 === "lg" ? "15px" : size2 === "xl" ? "16px" : "13px"};
      cursor: pointer;
      color: ${palette.accent};
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='${encodeURIComponent(palette.accent)}' stroke-width='2.5'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right ${size2 === "xs" ? "0.125rem" : "0.25rem"} center;
      background-size: ${size2 === "xs" ? "8px" : size2 === "sm" ? "9px" : "10px"};
      transition: all 0.15s ease;
      line-height: 1.2;
    }
    
    .dark .${scopedClass} .rdp-dropdown {
      color: ${palette.accent};
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='${encodeURIComponent(palette.accent)}' stroke-width='2.5'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
    }
    
    .${scopedClass} .rdp-dropdown:hover {
      background-color: ${palette.accentLight};
    }
    
    .dark .${scopedClass} .rdp-dropdown:hover {
      background-color: ${palette.accentMedium};
    }
    
    .${scopedClass} .rdp-chevron {
      display: none;
    }

    /* Navigation Buttons - Positioned absolutely on the RIGHT of header */
    .${scopedClass} .rdp-nav {
      display: flex !important;
      gap: 0.125rem;
      position: absolute !important;
      top: 0;
      right: 0;
      flex-shrink: 0;
      z-index: 1;
    }
    
    .${scopedClass} .rdp-button_previous,
    .${scopedClass} .rdp-button_next {
      width: ${size2 === "xs" ? "20px" : size2 === "sm" ? "24px" : size2 === "lg" ? "32px" : size2 === "xl" ? "36px" : "28px"} !important;
      height: ${size2 === "xs" ? "20px" : size2 === "sm" ? "24px" : size2 === "lg" ? "32px" : size2 === "xl" ? "36px" : "28px"} !important;
      border-radius: 4px;
      display: flex !important;
      align-items: center;
      justify-content: center;
      border: 1px solid transparent;
      background: transparent;
      transition: all 0.15s ease;
      padding: 0;
    }
    
    .${scopedClass} .rdp-button_previous:hover,
    .${scopedClass} .rdp-button_next:hover {
      background-color: ${palette.accentLight};
    }
    
    .dark .${scopedClass} .rdp-button_previous:hover,
    .dark .${scopedClass} .rdp-button_next:hover {
      background-color: ${palette.accentMedium};
    }
    
    .${scopedClass} .rdp-button_previous,
    .${scopedClass} .rdp-button_next {
      color: ${palette.accent};
    }
    
    /* Weekday Headers */
    .${scopedClass} .rdp-weekday {
      width: ${sizeConfig2.cell}px;
      height: ${Math.round(sizeConfig2.cell * 0.7)}px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.5;
      font-size: ${size2 === "xs" ? "9px" : size2 === "sm" ? "10px" : "11px"};
    }
    
    /* Day Cells - Fixed Size */
    .${scopedClass} .rdp-day {
      width: ${sizeConfig2.cell}px !important;
      height: ${sizeConfig2.cell}px !important;
      padding: 0 !important;
    }
    
    .${scopedClass} .rdp-day_button {
      width: ${sizeConfig2.cell}px !important;
      height: ${sizeConfig2.cell}px !important;
      max-width: ${sizeConfig2.cell}px !important;
      max-height: ${sizeConfig2.cell}px !important;
      border-radius: ${dayRadius};
      border: 1px solid transparent;
      font-size: ${size2 === "xs" ? "11px" : size2 === "sm" ? "12px" : size2 === "lg" ? "15px" : size2 === "xl" ? "17px" : "13px"};
      transition: ${animated ? "all 0.15s ease" : "none"};
    }
    
    .${scopedClass} .rdp-day_button:hover:not(:disabled) {
      ${variantStyles.hover}
    }
    
    .dark .${scopedClass} .rdp-day_button:hover:not(:disabled) {
      ${variantStyles.hoverDark || variantStyles.hover}
    }
    
    /* Selected State */
    .${scopedClass} .rdp-selected .rdp-day_button {
      ${variantStyles.selected}
    }
    
    .${scopedClass} .rdp-selected .rdp-day_button:hover {
      ${variantStyles.selectedHover}
    }
    
    /* Today */
    .${scopedClass} .rdp-today:not(.rdp-selected) .rdp-day_button {
      ${highlightToday ? variantStyles.today : ""}
    }
    
    /* Outside Days */
    .${scopedClass} .rdp-outside .rdp-day_button {
      opacity: 0.35;
    }
    
    /* Disabled */
    .${scopedClass} .rdp-disabled .rdp-day_button {
      opacity: 0.25;
      cursor: not-allowed;
    }
    
    /* Week Numbers */
    .${scopedClass} .rdp-week_number {
      width: ${Math.round(sizeConfig2.cell * 0.7)}px;
      font-size: 0.65em;
      opacity: 0.4;
      font-weight: 500;
    }
    
    /* Range Selection - Use higher specificity to override .rdp-selected */
    /* Override react-day-picker CSS variables for range colors */
    .${scopedClass} {
      --rdp-range_middle-background-color: transparent !important;
      --rdp-accent-background-color: transparent !important;
    }
    
    /* Range Start */
    .${scopedClass} .rdp-day.rdp-range_start {
      background: transparent !important;
    }
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button {
      ${variantStyles.selected}
      border-radius: 25% 0 0 25% !important;
    }
    
    /* Range End */
    .${scopedClass} .rdp-day.rdp-range_end {
      background: transparent !important;
    }
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      ${variantStyles.selected}
      border-radius: 0 25% 25% 0 !important;
    }
    
    /* Range Start+End (single day range) */
    .${scopedClass} .rdp-day.rdp-range_start.rdp-range_end .rdp-day_button {
      border-radius: 25% !important;
    }
    
    /* Range Middle - Clear parent background */
    .${scopedClass} .rdp-day.rdp-range_middle,
    .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle {
      background-color: transparent !important;
      background: transparent !important;
    }
    
    /* Variant-specific Range Styling */
    ${variant === "solid" ? `
    /* Solid: Start/End = full color, Middle = 15% opacity */
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background-color: ${palette.accent} !important;
      color: ${palette.onAccent} !important;
    }
    .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: ${palette.accentLight} !important;
      color: ${palette.accent} !important;
      border-radius: 4px !important;
    }
    ` : ""}
    
    ${variant === "soft" ? `
    /* Soft: Start/End = 45% opacity + border, Middle = 12% opacity for clear distinction */
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background-color: ${palette.accent}73 !important;
      border: 2px solid ${palette.accent} !important;
      color: ${palette.onAccent} !important;
      font-weight: 700 !important;
    }
    .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: ${palette.accentLight} !important;
      color: ${palette.accent} !important;
      border-radius: 4px !important;
      border: none !important;
    }
    ` : ""}
    
    ${variant === "outline" ? `
    /* Outline: Start/End = thick border + light fill, Middle = thin border only */
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background-color: ${palette.accentLight} !important;
      border: 2px solid ${palette.accent} !important;
      color: ${palette.accent} !important;
      font-weight: 700 !important;
    }
    .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: transparent !important;
      border: 1px solid ${palette.accent}60 !important;
      color: ${palette.accent} !important;
      border-radius: 4px !important;
    }
    ` : ""}
    
    ${variant === "minimal" ? `
    /* Minimal: Start/End = medium bg + underline, Middle = very light bg */
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background-color: ${palette.accentMedium} !important;
      color: ${palette.accent} !important;
      font-weight: 700 !important;
      text-decoration: underline !important;
      text-underline-offset: 3px !important;
    }
    .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: rgba(0,0,0,0.04) !important;
      color: ${palette.accent} !important;
      border-radius: 4px !important;
    }
    .dark .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: rgba(255,255,255,0.06) !important;
    }
    ` : ""}
    
    ${variant === "glass" ? `
    /* Glass: Start/End = gradient, Middle = very subtle tint with dashed border and darker text */
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background: linear-gradient(135deg, ${palette.accent}dd, ${palette.accent}99) !important;
      color: ${palette.onAccent} !important;
      backdrop-filter: blur(4px) !important;
    }
    .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: ${palette.accent}0c !important;
      color: ${palette.accentHover} !important;
      border-radius: 4px !important;
      font-weight: 600 !important;
      border: 1px dashed ${palette.accent}40 !important;
    }
    ` : ""}
    
    /* Hover for range middle */
    .${scopedClass} .rdp-day.rdp-range_middle:hover .rdp-day_button {
      background-color: ${variant === "glass" ? `${palette.accent}10` : `${palette.accent}30`} !important;
    }
    
    /* Draggable Range Ends - Grab Cursor */
    ${draggable && mode === "range" ? `
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      cursor: grab !important;
      position: relative;
    }
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button:active,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button:active {
      cursor: grabbing !important;
    }
    .${scopedClass}.dragging {
      cursor: grabbing !important;
      user-select: none;
    }
    .${scopedClass}.dragging * {
      cursor: grabbing !important;
    }
    /* Visual indicator for draggable ends - Adaptive color based on variant */
    /* Skip for minimal variant since it already has underline indicator */
    ${variant !== "minimal" ? `
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button::after,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button::after {
      content: '';
      position: absolute;
      bottom: 3px;
      left: 50%;
      transform: translateX(-50%);
      width: 14px;
      height: 4px;
      border-radius: 2px;
      /* Use contrasting color based on variant */
      ${variant === "solid" || variant === "glass" ? `background-color: rgba(255, 255, 255, 0.7); box-shadow: 0 1px 2px rgba(0,0,0,0.2);` : `background-color: ${palette.accent}; opacity: 0.6;`}
    }
    .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button:hover::after,
    .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button:hover::after {
      ${variant === "solid" || variant === "glass" ? `background-color: rgba(255, 255, 255, 0.9);` : `opacity: 0.9;`}
    }
    ` : ""}
    ` : ""}
    
    /* Click Animation */
    ${animated ? `
    .${scopedClass} .rdp-day_button:active:not(:disabled) {
      transform: scale(0.92);
    }
    ` : ""}

    /* Table layout */
    .${scopedClass} .rdp-month_grid {
      border-collapse: separate;
      border-spacing: 2px;
    }
    
    /* Hide default caption when using modern or buttons nav - ONLY for single calendar */
    ${(navigation === "modern" || navigation === "buttons") && numberOfMonths === 1 ? `
    .${scopedClass} .rdp-month_caption {
      display: none !important;
    }
    .${scopedClass} .rdp-nav {
      display: none !important;
    }
    ` : ""}
    
    /* Hide default caption when using independentNavigation - we provide our own header */
    ${independentNavigation && numberOfMonths > 1 ? `
    .${scopedClass} .rdp-month_caption,
    .${scopedClass} .rdp-caption_label {
      display: none !important;
    }
    .${scopedClass} .rdp-nav {
      display: none !important;
    }
    .${scopedClass} .rdp-month {
      margin-top: 0 !important;
      padding-top: 0 !important;
    }
    ` : ""}
    
    /* Dark mode specific colors for secondary */
    ${palette.accentDark ? `
    .dark .${scopedClass} .rdp-dropdown,
    .dark .${scopedClass} .rdp-button_previous,
    .dark .${scopedClass} .rdp-button_next {
      color: ${palette.accentDark};
    }
    .dark .${scopedClass} .rdp-dropdown {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 24 24' fill='none' stroke='${encodeURIComponent(palette.accentDark)}' stroke-width='2.5'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
    }
    .dark .${scopedClass} .rdp-dropdown:hover {
      background-color: ${palette.accentLightDark || palette.accentMedium};
    }
    .dark .${scopedClass} .rdp-button_previous:hover,
    .dark .${scopedClass} .rdp-button_next:hover {
      background-color: ${palette.accentLightDark || palette.accentMedium};
    }
    .dark .${scopedClass} .rdp-selected .rdp-day_button {
      background-color: ${palette.accentDark};
    }
    .dark .${scopedClass} .rdp-selected .rdp-day_button:hover {
      background-color: ${palette.accentHoverDark || palette.accentDark};
    }
    .dark .${scopedClass} .rdp-today:not(.rdp-selected) .rdp-day_button {
      border-color: ${palette.accentDark};
    }
    /* Dark mode: Clear parent backgrounds for range elements */
    .dark .${scopedClass} .rdp-day.rdp-range_start,
    .dark .${scopedClass} .rdp-day.rdp-range_end,
    .dark .${scopedClass} .rdp-day.rdp-range_middle,
    .dark .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle {
      background: transparent !important;
      background-color: transparent !important;
    }
    
    /* Dark mode variant-specific range styling */
    ${variant === "solid" ? `
    .dark .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background-color: ${palette.accentDark || palette.accent} !important;
    }
    .dark .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: ${palette.accentLightDark || palette.accentLight} !important;
      color: ${palette.accentDark || palette.accent} !important;
    }
    ` : ""}
    
    ${variant === "soft" ? `
    .dark .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background-color: ${palette.accentDark || palette.accent}73 !important;
      border: 2px solid ${palette.accentDark || palette.accent} !important;
      color: ${palette.onAccent} !important;
    }
    .dark .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: ${palette.accentLightDark || palette.accentLight} !important;
      color: ${palette.accentDark || palette.accent} !important;
      border: none !important;
    }
    ` : ""}
    
    ${variant === "outline" ? `
    .dark .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background-color: ${palette.accentLightDark || palette.accentLight} !important;
      border: 2px solid ${palette.accentDark || palette.accent} !important;
      color: ${palette.accentDark || palette.accent} !important;
    }
    .dark .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: transparent !important;
      border: 1px solid ${palette.accentDark || palette.accent}50 !important;
      color: ${palette.accentDark || palette.accent} !important;
      border-radius: 4px !important;
    }
    ` : ""}
    
    ${variant === "minimal" ? `
    .dark .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background-color: ${palette.accentMediumDark || palette.accentMedium} !important;
      color: ${palette.accentDark || palette.accent} !important;
    }
    .dark .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: rgba(255,255,255,0.06) !important;
      color: ${palette.accentDark || palette.accent} !important;
      border-radius: 4px !important;
    }
    ` : ""}
    
    ${variant === "glass" ? `
    .dark .${scopedClass} .rdp-day.rdp-range_start .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-range_end .rdp-day_button {
      background: linear-gradient(135deg, ${palette.accentDark || palette.accent}cc, ${palette.accentDark || palette.accent}88) !important;
    }
    .dark .${scopedClass} .rdp-day.rdp-range_middle .rdp-day_button,
    .dark .${scopedClass} .rdp-day.rdp-selected.rdp-range_middle .rdp-day_button {
      background-color: ${palette.accentDark || palette.accent}15 !important;
      color: ${palette.accentLightDark || palette.accentLight || palette.accent} !important;
      border-radius: 4px !important;
      font-weight: 600 !important;
      border: 1px dashed ${palette.accentDark || palette.accent}50 !important;
    }
    ` : ""}
    .dark .${scopedClass} .rdp-day.rdp-range_middle:hover .rdp-day_button {
      background-color: ${variant === "glass" ? `${palette.accentDark || palette.accent}15` : `${palette.accentDark || palette.accent}50`} !important;
    }
    ` : ""}
    
    /* ============================================================================ */
    /* HOVER PREVIEW STYLES - Industry Standard Range Selection UX */
    /* Shows a light preview of the range while hovering (State 1: Awaiting end date) */
    /* ============================================================================ */
    
    /* Hover preview dates - Light background to show potential range */
    .${scopedClass} .rdp-day.range-preview .rdp-day_button {
      background-color: ${palette.accentLight} !important;
      color: ${palette.accent} !important;
      transition: background-color 0.1s ease, color 0.1s ease;
    }
    
    /* Hover preview end date (the currently hovered date) - Slightly stronger */
    .${scopedClass} .rdp-day.range-preview-end .rdp-day_button {
      background-color: ${palette.accentMedium} !important;
      color: ${palette.accent} !important;
      font-weight: 600;
    }
    
    /* Soft variant hover preview */
    ${variant === "soft" ? `
    .${scopedClass} .rdp-day.range-preview .rdp-day_button {
      background-color: ${palette.accentLight} !important;
      border: 1px dashed ${palette.accent}60 !important;
    }
    .${scopedClass} .rdp-day.range-preview-end .rdp-day_button {
      background-color: ${palette.accentMedium} !important;
      border: 1px solid ${palette.accent} !important;
    }
    ` : ""}
    
    /* Outline variant hover preview */
    ${variant === "outline" ? `
    .${scopedClass} .rdp-day.range-preview .rdp-day_button {
      border: 1px dashed ${palette.accent}50 !important;
      background-color: transparent !important;
    }
    .${scopedClass} .rdp-day.range-preview-end .rdp-day_button {
      border: 2px solid ${palette.accent} !important;
      background-color: ${palette.accentLight} !important;
    }
    ` : ""}
    
    /* Minimal variant hover preview */
    ${variant === "minimal" ? `
    .${scopedClass} .rdp-day.range-preview .rdp-day_button {
      background-color: rgba(0,0,0,0.03) !important;
    }
    .${scopedClass} .rdp-day.range-preview-end .rdp-day_button {
      background-color: ${palette.accentLight} !important;
      text-decoration: underline;
      text-underline-offset: 3px;
    }
    ` : ""}
    
    /* Glass variant hover preview */
    ${variant === "glass" ? `
    .${scopedClass} .rdp-day.range-preview .rdp-day_button {
      background: ${palette.accentLight}80 !important;
      backdrop-filter: blur(2px);
    }
    .${scopedClass} .rdp-day.range-preview-end .rdp-day_button {
      background: ${palette.accentMedium}90 !important;
      backdrop-filter: blur(4px);
    }
    ` : ""}
    
    /* Dark mode hover preview */
    .dark .${scopedClass} .rdp-day.range-preview .rdp-day_button {
      background-color: ${palette.accentLightDark || palette.accentLight} !important;
      color: ${palette.accentDark || palette.accent} !important;
    }
    .dark .${scopedClass} .rdp-day.range-preview-end .rdp-day_button {
      background-color: ${palette.accentMediumDark || palette.accentMedium} !important;
      color: ${palette.accentDark || palette.accent} !important;
    }
    
    /* State indicator tooltip - shows "Select start" or "Select end" */
    .${scopedClass} .rdp-day_button[data-range-state="awaiting-end"]:hover::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background-color: ${palette.accentMedium};
      pointer-events: none;
    }
  `;
  const ChevronIcon = ({ orientation = "left" }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    Icon,
    {
      size: size2 === "xs" ? "xs" : size2 === "sm" ? "sm" : size2 === "lg" ? "lg" : size2 === "xl" ? "lg" : "md",
      className: "text-text-secondary dark:text-dark-text-secondary",
      children: orientation === "left" ? "chevron_left" : "chevron_right"
    }
  );
  const MonthGridPicker = () => {
    const currentMonthIndex = (finalMonth ?? /* @__PURE__ */ new Date()).getMonth();
    const isDark = typeof document !== "undefined" && document.documentElement.classList.contains("dark");
    const selectedBgColor = isDark && palette.accentDark ? palette.accentDark : palette.accent;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: monthPickerRef,
        "data-calendar-nav": "true",
        onClick: (e2) => {
          e2.stopPropagation();
          e2.nativeEvent.stopImmediatePropagation();
        },
        onMouseDown: (e2) => {
          e2.stopPropagation();
          e2.nativeEvent.stopImmediatePropagation();
        },
        className: "calendar-month-picker absolute top-full left-0 mt-1 z-50 bg-bg-secondary dark:bg-dark-bg-secondary border border-border-color dark:border-dark-border-color rounded-xl shadow-xl p-3 animate-in fade-in slide-in-from-top-2 duration-200",
        style: { minWidth: "240px" },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-2", children: MONTH_NAMES_SHORT.map((month, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            "data-calendar-nav": "true",
            onClick: (e2) => {
              e2.stopPropagation();
              e2.preventDefault();
              e2.nativeEvent.stopImmediatePropagation();
              requestAnimationFrame(() => {
                handleMonthSelect(index2);
              });
            },
            onMouseDown: (e2) => {
              e2.stopPropagation();
              e2.preventDefault();
              e2.nativeEvent.stopImmediatePropagation();
            },
            className: cn(
              "px-3 py-2 rounded-lg text-sm font-medium transition-all duration-150",
              "hover:scale-105 active:scale-95",
              index2 === currentMonthIndex ? "text-white" : "text-text-primary dark:text-dark-text-primary hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
            ),
            style: index2 === currentMonthIndex ? { backgroundColor: selectedBgColor } : void 0,
            children: ui_i18n[contextLanguage]?.monthsthreeletterformat[month.toLowerCase()] || month
          },
          month
        )) })
      }
    );
  };
  const YearGridPicker = () => {
    const currentYearValue = (finalMonth ?? /* @__PURE__ */ new Date()).getFullYear();
    const years = Array.from({ length: 12 }, (_2, i2) => yearRangeStart + i2).filter((y2) => y2 >= startYear && y2 <= endYear);
    const isDark = typeof document !== "undefined" && document.documentElement.classList.contains("dark");
    const selectedBgColor = isDark && palette.accentDark ? palette.accentDark : palette.accent;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: yearPickerRef,
        "data-calendar-nav": "true",
        onClick: (e2) => {
          e2.stopPropagation();
          e2.nativeEvent.stopImmediatePropagation();
        },
        onMouseDown: (e2) => {
          e2.stopPropagation();
          e2.nativeEvent.stopImmediatePropagation();
        },
        className: "calendar-year-picker absolute top-full left-0 mt-1 z-50 bg-bg-secondary dark:bg-dark-bg-secondary border border-border-color dark:border-dark-border-color rounded-xl shadow-xl p-3 animate-in fade-in slide-in-from-top-2 duration-200",
        style: { minWidth: "240px" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3 pb-2 border-b border-border-color dark:border-dark-border-color", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                "data-calendar-nav": "true",
                onClick: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                  handlePrevYearRange();
                },
                onMouseDown: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                disabled: yearRangeStart <= startYear,
                className: "p-1 rounded-md hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary disabled:opacity-30 disabled:cursor-not-allowed transition-colors",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "chevron_left" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-semibold text-text-primary dark:text-dark-text-primary", children: [
              Math.max(yearRangeStart, startYear),
              " - ",
              Math.min(yearRangeStart + 11, endYear)
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                "data-calendar-nav": "true",
                onClick: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                  handleNextYearRange();
                },
                onMouseDown: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                disabled: yearRangeStart + 12 > endYear,
                className: "p-1 rounded-md hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary disabled:opacity-30 disabled:cursor-not-allowed transition-colors",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "chevron_right" })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-2", children: years.map((year) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              "data-calendar-nav": "true",
              onClick: (e2) => {
                e2.stopPropagation();
                e2.preventDefault();
                e2.nativeEvent.stopImmediatePropagation();
                requestAnimationFrame(() => {
                  handleYearSelect(year);
                });
              },
              onMouseDown: (e2) => {
                e2.stopPropagation();
                e2.preventDefault();
                e2.nativeEvent.stopImmediatePropagation();
              },
              className: cn(
                "px-3 py-2 rounded-lg text-sm font-medium transition-all duration-150",
                "hover:scale-105 active:scale-95",
                year === currentYearValue ? "text-white" : "text-text-primary dark:text-dark-text-primary hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
              ),
              style: year === currentYearValue ? { backgroundColor: selectedBgColor } : void 0,
              children: year
            },
            year
          )) })
        ]
      }
    );
  };
  const getNavButtonSize = () => {
    switch (size2) {
      case "xs":
        return "w-6 h-6";
      case "sm":
        return "w-7 h-7";
      case "lg":
        return "w-9 h-9";
      case "xl":
        return "w-10 h-10";
      default:
        return "w-8 h-8";
    }
  };
  const getTextSize = () => {
    switch (size2) {
      case "xs":
        return "text-sm";
      case "sm":
        return "text-sm";
      case "lg":
        return "text-lg";
      case "xl":
        return "text-xl";
      default:
        return "text-base";
    }
  };
  const CustomNavigationHeader = () => {
    const displayDate2 = finalMonth ?? /* @__PURE__ */ new Date();
    const monthName = MONTH_NAMES[displayDate2.getMonth()];
    const yearValue = displayDate2.getFullYear();
    const isModern = navigation === "modern";
    const handlePrevMonth = () => {
      const newDate = new Date(displayDate2);
      newDate.setMonth(newDate.getMonth() - 1);
      finalOnMonthChange?.(newDate);
    };
    const handleNextMonth = () => {
      const newDate = new Date(displayDate2);
      newDate.setMonth(newDate.getMonth() + 1);
      finalOnMonthChange?.(newDate);
    };
    const getEffectiveColor = (isDark) => isDark && palette.accentDark ? palette.accentDark : palette.accent;
    const getEffectiveHoverBg = (isDark) => {
      if (isDark) {
        return palette.accentLightDark || palette.accentMedium;
      }
      return palette.accentLight;
    };
    const NavArrowButton = ({ onClick, icon }) => {
      const [isHovered, setIsHovered] = useState(false);
      const isDark = typeof document !== "undefined" && document.documentElement.classList.contains("dark");
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          "data-calendar-nav": "true",
          onClick: (e2) => {
            e2.stopPropagation();
            e2.nativeEvent.stopImmediatePropagation();
            onClick();
          },
          onMouseDown: (e2) => {
            e2.stopPropagation();
            e2.nativeEvent.stopImmediatePropagation();
          },
          onMouseEnter: () => setIsHovered(true),
          onMouseLeave: () => setIsHovered(false),
          className: cn(
            "flex items-center justify-center rounded-lg transition-all duration-150 active:scale-90",
            getNavButtonSize()
          ),
          style: {
            color: getEffectiveColor(isDark),
            backgroundColor: isHovered ? getEffectiveHoverBg(isDark) : "transparent"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: size2 === "xs" ? "xs" : size2 === "sm" ? "sm" : "md", children: icon })
        }
      );
    };
    const MonthYearButton = ({ onClick, isOpen, children, showChevron = true }) => {
      const [isHovered, setIsHovered] = useState(false);
      const isDark = typeof document !== "undefined" && document.documentElement.classList.contains("dark");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          "data-calendar-nav": "true",
          onClick: (e2) => {
            e2.stopPropagation();
            e2.preventDefault();
            e2.nativeEvent.stopImmediatePropagation();
            requestAnimationFrame(() => onClick());
          },
          onMouseDown: (e2) => {
            e2.stopPropagation();
            e2.preventDefault();
            e2.nativeEvent.stopImmediatePropagation();
          },
          onMouseEnter: () => setIsHovered(true),
          onMouseLeave: () => setIsHovered(false),
          className: cn(
            "flex items-center gap-1 px-2 py-1 rounded-lg font-semibold transition-all duration-150 active:scale-95",
            getTextSize()
          ),
          style: {
            color: getEffectiveColor(isDark),
            backgroundColor: isHovered ? getEffectiveHoverBg(isDark) : "transparent"
          },
          children: [
            children,
            showChevron && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: getEffectiveColor(isDark) }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: size2 === "xs" ? "xs" : "sm", children: isOpen ? "expand_less" : "expand_more" }) })
          ]
        }
      );
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-3 pb-2 border-b border-border-color/50 dark:border-dark-border-color/50", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-1", children: isModern ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MonthYearButton,
            {
              onClick: () => {
                setShowMonthPicker((prev) => !prev);
                setShowYearPicker(false);
              },
              isOpen: showMonthPicker,
              children: size2 === "xs" ? MONTH_NAMES_SHORT[displayDate2.getMonth()] : monthName
            }
          ),
          showMonthPicker && /* @__PURE__ */ jsxRuntimeExports.jsx(MonthGridPicker, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MonthYearButton,
            {
              onClick: () => {
                setShowYearPicker((prev) => !prev);
                setShowMonthPicker(false);
              },
              isOpen: showYearPicker,
              children: yearValue
            }
          ),
          showYearPicker && /* @__PURE__ */ jsxRuntimeExports.jsx(YearGridPicker, {})
        ] })
      ] }) : (
        /* Buttons style - Just display month/year as text label */
        (() => {
          const isDark = typeof document !== "undefined" && document.documentElement.classList.contains("dark");
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "span",
            {
              className: cn("font-semibold", getTextSize()),
              style: { color: getEffectiveColor(isDark) },
              children: [
                size2 === "xs" ? MONTH_NAMES_SHORT[displayDate2.getMonth()] : monthName,
                " ",
                yearValue
              ]
            }
          );
        })()
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-0.5", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NavArrowButton, { onClick: handlePrevMonth, icon: "chevron_left" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NavArrowButton, { onClick: handleNextMonth, icon: "chevron_right" })
      ] })
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: calendarRef,
      className: cn(
        scopedClass,
        "bg-bg-secondary dark:bg-dark-bg-secondary",
        radiusClass,
        spacingConfig.padding,
        CALENDAR_TOKENS.typography.fontFamily.body,
        sizeConfig2.dropdown,
        finalElevated && "shadow-lg dark:shadow-2xl dark:shadow-black/20",
        finalBordered && "border border-border-color dark:border-dark-border-color",
        fullWidth && "w-full",
        disabled && "opacity-60 pointer-events-none",
        "relative",
        isDragging2 && "dragging",
        className
      ),
      onPointerDown: mode === "range" && draggable ? handlePointerDown : void 0,
      onPointerMove: mode === "range" && isDragging2 ? handlePointerMove : void 0,
      onPointerUp: mode === "range" && isDragging2 ? handlePointerUp : void 0,
      onPointerLeave: mode === "range" && isDragging2 ? handlePointerLeave : void 0,
      onMouseDown: (e2) => {
        const target = e2.target;
        const isNavigationClick = target.closest("[data-calendar-nav]") || target.closest(".calendar-month-picker") || target.closest(".calendar-year-picker");
        if (isNavigationClick) {
          e2.stopPropagation();
        }
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: dynamicStyles }),
        (navigation === "modern" || navigation === "buttons") && showHeader && numberOfMonths === 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(CustomNavigationHeader, {}),
        independentNavigation && numberOfMonths > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2 px-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                navigation === "modern" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      "data-calendar-nav": "true",
                      onClick: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                        setShowMonthPicker(!showMonthPicker);
                        setShowYearPicker(false);
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "flex items-center gap-1 px-2 py-1 rounded-md font-semibold transition-colors",
                        "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                      ),
                      style: { color: palette.accent },
                      children: [
                        size2 === "xs" ? ui_i18n[contextLanguage]?.monthsthreeletterformat[MONTH_NAMES[finalMonth?.getMonth() ?? 0].toLowerCase()] : ui_i18n[contextLanguage]?.months[MONTH_NAMES[finalMonth?.getMonth() ?? 0].toLowerCase()],
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: showMonthPicker ? "expand_less" : "expand_more" })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      "data-calendar-nav": "true",
                      onClick: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                        setShowYearPicker(!showYearPicker);
                        setShowMonthPicker(false);
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "flex items-center gap-1 px-2 py-1 rounded-md font-semibold transition-colors",
                        "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                      ),
                      style: { color: palette.accent },
                      children: [
                        finalMonth?.getFullYear() ?? (/* @__PURE__ */ new Date()).getFullYear(),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: showYearPicker ? "expand_less" : "expand_more" })
                      ]
                    }
                  )
                ] }),
                navigation === "dropdown" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "select",
                    {
                      "data-calendar-nav": "true",
                      value: finalMonth?.getMonth() ?? (/* @__PURE__ */ new Date()).getMonth(),
                      onChange: (e2) => {
                        const newDate = new Date(finalMonth ?? /* @__PURE__ */ new Date());
                        newDate.setMonth(parseInt(e2.target.value));
                        finalOnMonthChange?.(newDate);
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "appearance-none cursor-pointer font-semibold border-0",
                        "bg-transparent focus:outline-none focus:ring-0",
                        "pr-5 bg-no-repeat bg-right"
                      ),
                      style: {
                        color: palette.accent,
                        backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='${encodeURIComponent(palette.accent)}'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/%3E%3C/svg%3E")`,
                        backgroundSize: "16px"
                      },
                      children: MONTH_NAMES.map((month, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: i2, children: ui_i18n[contextLanguage]?.months[month.toLowerCase()] || month }, month))
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "select",
                    {
                      "data-calendar-nav": "true",
                      value: finalMonth?.getFullYear() ?? (/* @__PURE__ */ new Date()).getFullYear(),
                      onChange: (e2) => {
                        const newDate = new Date(finalMonth ?? /* @__PURE__ */ new Date());
                        newDate.setFullYear(parseInt(e2.target.value));
                        finalOnMonthChange?.(newDate);
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "appearance-none cursor-pointer font-semibold border-0",
                        "bg-transparent focus:outline-none focus:ring-0",
                        "pr-5 bg-no-repeat bg-right"
                      ),
                      style: {
                        color: palette.accent,
                        backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='${encodeURIComponent(palette.accent)}'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/%3E%3C/svg%3E")`,
                        backgroundSize: "16px"
                      },
                      children: Array.from({ length: endYear - startYear + 1 }, (_2, i2) => startYear + i2).map((year) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: year, children: year }, year))
                    }
                  )
                ] }),
                navigation === "buttons" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", style: { color: palette.accent }, children: [
                  size2 === "xs" ? ui_i18n[contextLanguage]?.monthsthreeletterformat[MONTH_NAMES[finalMonth?.getMonth() ?? 0].toLowerCase()] : ui_i18n[contextLanguage]?.months[MONTH_NAMES[finalMonth?.getMonth() ?? 0].toLowerCase()],
                  " ",
                  finalMonth?.getFullYear() ?? (/* @__PURE__ */ new Date()).getFullYear()
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-0.5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    "data-calendar-nav": "true",
                    onClick: (e2) => {
                      e2.stopPropagation();
                      e2.nativeEvent.stopImmediatePropagation();
                      const newDate = new Date(finalMonth ?? /* @__PURE__ */ new Date());
                      newDate.setMonth(newDate.getMonth() - 1);
                      finalOnMonthChange?.(newDate);
                    },
                    onMouseDown: (e2) => {
                      e2.stopPropagation();
                      e2.nativeEvent.stopImmediatePropagation();
                    },
                    className: cn(
                      "p-1.5 rounded-md transition-colors",
                      "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                    ),
                    style: { color: palette.accent },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-lg", children: "chevron_left" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    "data-calendar-nav": "true",
                    onClick: (e2) => {
                      e2.stopPropagation();
                      e2.nativeEvent.stopImmediatePropagation();
                      const newDate = new Date(finalMonth ?? /* @__PURE__ */ new Date());
                      newDate.setMonth(newDate.getMonth() + 1);
                      finalOnMonthChange?.(newDate);
                    },
                    onMouseDown: (e2) => {
                      e2.stopPropagation();
                      e2.nativeEvent.stopImmediatePropagation();
                    },
                    className: cn(
                      "p-1.5 rounded-md transition-colors",
                      "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                    ),
                    style: { color: palette.accent },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-lg", children: "chevron_right" })
                  }
                )
              ] })
            ] }),
            navigation === "modern" && showMonthPicker && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                ref: monthPickerRef,
                "data-calendar-nav": "true",
                onClick: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                onMouseDown: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                className: "calendar-month-picker absolute z-50 mt-1 p-3 bg-bg-secondary dark:bg-dark-bg-secondary rounded-lg shadow-lg border border-border-color dark:border-dark-border-color",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-2", children: MONTH_NAMES.map((month, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    "data-calendar-nav": "true",
                    onClick: (e2) => {
                      e2.stopPropagation();
                      e2.preventDefault();
                      e2.nativeEvent.stopImmediatePropagation();
                      requestAnimationFrame(() => handleMonthSelect(i2));
                    },
                    onMouseDown: (e2) => {
                      e2.stopPropagation();
                      e2.preventDefault();
                      e2.nativeEvent.stopImmediatePropagation();
                    },
                    className: cn(
                      "px-3 py-2 text-sm rounded-md transition-colors",
                      (finalMonth?.getMonth() ?? 0) === i2 ? "font-semibold" : "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                    ),
                    style: {
                      backgroundColor: (finalMonth?.getMonth() ?? 0) === i2 ? palette.accent : void 0,
                      color: (finalMonth?.getMonth() ?? 0) === i2 ? "white" : palette.accent
                    },
                    children: size2 === "xs" || size2 === "sm" ? ui_i18n[contextLanguage]?.monthsthreeletterformat[month.toLowerCase()] : ui_i18n[contextLanguage]?.months[month.toLowerCase()]
                  },
                  month
                )) })
              }
            ),
            navigation === "modern" && showYearPicker && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                ref: yearPickerRef,
                "data-calendar-nav": "true",
                onClick: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                onMouseDown: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                className: "calendar-year-picker absolute z-50 mt-1 p-3 bg-bg-secondary dark:bg-dark-bg-secondary rounded-lg shadow-lg border border-border-color dark:border-dark-border-color",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        "data-calendar-nav": "true",
                        onClick: (e2) => {
                          e2.stopPropagation();
                          e2.nativeEvent.stopImmediatePropagation();
                          setYearRangeStart(yearRangeStart - 12);
                        },
                        onMouseDown: (e2) => {
                          e2.stopPropagation();
                          e2.nativeEvent.stopImmediatePropagation();
                        },
                        className: "p-1 rounded hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
                        style: { color: palette.accent },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: "chevron_left" })
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", style: { color: palette.accent }, children: [
                      Math.max(yearRangeStart, startYear),
                      " - ",
                      Math.min(yearRangeStart + 11, endYear)
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        "data-calendar-nav": "true",
                        onClick: (e2) => {
                          e2.stopPropagation();
                          e2.nativeEvent.stopImmediatePropagation();
                          setYearRangeStart(yearRangeStart + 12);
                        },
                        onMouseDown: (e2) => {
                          e2.stopPropagation();
                          e2.nativeEvent.stopImmediatePropagation();
                        },
                        className: "p-1 rounded hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
                        style: { color: palette.accent },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: "chevron_right" })
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-4 gap-2", children: Array.from({ length: 12 }, (_2, i2) => yearRangeStart + i2).map((year) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      "data-calendar-nav": "true",
                      onClick: (e2) => {
                        e2.stopPropagation();
                        e2.preventDefault();
                        e2.nativeEvent.stopImmediatePropagation();
                        requestAnimationFrame(() => handleYearSelect(year));
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.preventDefault();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "px-2 py-2 text-sm rounded-md transition-colors",
                        (finalMonth?.getFullYear() ?? 0) === year ? "font-semibold" : "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                      ),
                      style: {
                        backgroundColor: (finalMonth?.getFullYear() ?? 0) === year ? palette.accent : void 0,
                        color: (finalMonth?.getFullYear() ?? 0) === year ? "white" : palette.accent
                      },
                      children: year
                    },
                    year
                  )) })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DayPicker,
              {
                mode,
                locale: locales[contextLanguage],
                selected: mode === "single" ? finalValue : mode === "range" ? rangeValue : multiValue,
                onSelect: mode === "single" ? onDateSelect : mode === "range" ? (_newRange, selectedDay) => {
                  if (!selectedDay) return;
                  if (justFinishedDragging.current) {
                    return;
                  }
                  handleRangeSelection(selectedDay);
                } : onMultiSelect,
                onDayMouseEnter: mode === "range" ? (day) => {
                  if (getRangeSelectionState() === 1) {
                    setHoveredDate(day);
                  }
                } : void 0,
                onDayMouseLeave: mode === "range" ? () => setHoveredDate(void 0) : void 0,
                modifiers: mode === "range" ? {
                  "range-preview": getHoverPreviewDates(),
                  "range-preview-end": hoveredDate && getRangeSelectionState() === 1 ? [hoveredDate] : []
                } : void 0,
                modifiersClassNames: mode === "range" ? {
                  "range-preview": "range-preview",
                  "range-preview-end": "range-preview-end"
                } : void 0,
                month: finalMonth,
                onMonthChange: finalOnMonthChange,
                numberOfMonths: 1,
                components: {
                  Chevron: ({ orientation }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronIcon, { orientation })
                },
                captionLayout: "label",
                hideNavigation: true,
                startMonth: fromDate || new Date(startYear, 0),
                endMonth: toDate2 || new Date(endYear, 11),
                showOutsideDays,
                disabled: getDisabledMatcher(),
                weekStartsOn,
                showWeekNumber
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2 px-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                navigation === "modern" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      "data-calendar-nav": "true",
                      onClick: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                        setShowRhsMonthPicker(!showRhsMonthPicker);
                        setShowRhsYearPicker(false);
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "flex items-center gap-1 px-2 py-1 rounded-md font-semibold transition-colors",
                        "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                      ),
                      style: { color: palette.accent },
                      children: [
                        size2 === "xs" ? ui_i18n[contextLanguage]?.monthsthreeletterformat[MONTH_NAMES[rhsMonth.getMonth()].toLowerCase()] : ui_i18n[contextLanguage]?.months[MONTH_NAMES[rhsMonth.getMonth()].toLowerCase()],
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: showRhsMonthPicker ? "expand_less" : "expand_more" })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      "data-calendar-nav": "true",
                      onClick: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                        setShowRhsYearPicker(!showRhsYearPicker);
                        setShowRhsMonthPicker(false);
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "flex items-center gap-1 px-2 py-1 rounded-md font-semibold transition-colors",
                        "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                      ),
                      style: { color: palette.accent },
                      children: [
                        rhsMonth.getFullYear(),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: showRhsYearPicker ? "expand_less" : "expand_more" })
                      ]
                    }
                  )
                ] }),
                navigation === "dropdown" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "select",
                    {
                      "data-calendar-nav": "true",
                      value: rhsMonth.getMonth(),
                      onChange: (e2) => {
                        const newDate = new Date(rhsMonth);
                        newDate.setMonth(parseInt(e2.target.value));
                        setRhsMonth(newDate);
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "appearance-none cursor-pointer font-semibold border-0",
                        "bg-transparent focus:outline-none focus:ring-0",
                        "pr-5 bg-no-repeat bg-right"
                      ),
                      style: {
                        color: palette.accent,
                        backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='${encodeURIComponent(palette.accent)}'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/%3E%3C/svg%3E")`,
                        backgroundSize: "16px"
                      },
                      children: MONTH_NAMES.map((month, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: i2, children: ui_i18n[contextLanguage]?.months[month.toLowerCase()] || month }, month))
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "select",
                    {
                      "data-calendar-nav": "true",
                      value: rhsMonth.getFullYear(),
                      onChange: (e2) => {
                        const newDate = new Date(rhsMonth);
                        newDate.setFullYear(parseInt(e2.target.value));
                        setRhsMonth(newDate);
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "appearance-none cursor-pointer font-semibold border-0",
                        "bg-transparent focus:outline-none focus:ring-0",
                        "pr-5 bg-no-repeat bg-right"
                      ),
                      style: {
                        color: palette.accent,
                        backgroundImage: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='${encodeURIComponent(palette.accent)}'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'/%3E%3C/svg%3E")`,
                        backgroundSize: "16px"
                      },
                      children: Array.from({ length: endYear - startYear + 1 }, (_2, i2) => startYear + i2).map((year) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: year, children: year }, year))
                    }
                  )
                ] }),
                navigation === "buttons" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-semibold", style: { color: palette.accent }, children: [
                  size2 === "xs" ? MONTH_NAMES_SHORT[rhsMonth.getMonth()] : MONTH_NAMES[rhsMonth.getMonth()],
                  " ",
                  rhsMonth.getFullYear()
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-0.5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    "data-calendar-nav": "true",
                    onClick: (e2) => {
                      e2.stopPropagation();
                      e2.nativeEvent.stopImmediatePropagation();
                      const newDate = new Date(rhsMonth);
                      newDate.setMonth(newDate.getMonth() - 1);
                      setRhsMonth(newDate);
                    },
                    onMouseDown: (e2) => {
                      e2.stopPropagation();
                      e2.nativeEvent.stopImmediatePropagation();
                    },
                    className: cn(
                      "p-1.5 rounded-md transition-colors",
                      "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                    ),
                    style: { color: palette.accent },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-lg", children: "chevron_left" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    "data-calendar-nav": "true",
                    onClick: (e2) => {
                      e2.stopPropagation();
                      e2.nativeEvent.stopImmediatePropagation();
                      const newDate = new Date(rhsMonth);
                      newDate.setMonth(newDate.getMonth() + 1);
                      setRhsMonth(newDate);
                    },
                    onMouseDown: (e2) => {
                      e2.stopPropagation();
                      e2.nativeEvent.stopImmediatePropagation();
                    },
                    className: cn(
                      "p-1.5 rounded-md transition-colors",
                      "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                    ),
                    style: { color: palette.accent },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-lg", children: "chevron_right" })
                  }
                )
              ] })
            ] }),
            navigation === "modern" && showRhsMonthPicker && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                ref: rhsMonthPickerRef,
                "data-calendar-nav": "true",
                onClick: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                onMouseDown: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                className: "calendar-month-picker absolute z-50 mt-1 p-3 bg-bg-secondary dark:bg-dark-bg-secondary rounded-lg shadow-lg border border-border-color dark:border-dark-border-color",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-2", children: MONTH_NAMES.map((month, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    "data-calendar-nav": "true",
                    onClick: (e2) => {
                      e2.stopPropagation();
                      e2.preventDefault();
                      e2.nativeEvent.stopImmediatePropagation();
                      requestAnimationFrame(() => handleRhsMonthSelect(i2));
                    },
                    onMouseDown: (e2) => {
                      e2.stopPropagation();
                      e2.preventDefault();
                      e2.nativeEvent.stopImmediatePropagation();
                    },
                    className: cn(
                      "px-3 py-2 text-sm rounded-md transition-colors",
                      rhsMonth.getMonth() === i2 ? "font-semibold" : "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                    ),
                    style: {
                      backgroundColor: rhsMonth.getMonth() === i2 ? palette.accent : void 0,
                      color: rhsMonth.getMonth() === i2 ? "white" : palette.accent
                    },
                    children: size2 === "xs" || size2 === "sm" ? ui_i18n[contextLanguage]?.monthsthreeletterformat[month.toLowerCase()] : ui_i18n[contextLanguage]?.months[month.toLowerCase()]
                  },
                  month
                )) })
              }
            ),
            navigation === "modern" && showRhsYearPicker && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                ref: rhsYearPickerRef,
                "data-calendar-nav": "true",
                onClick: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                onMouseDown: (e2) => {
                  e2.stopPropagation();
                  e2.nativeEvent.stopImmediatePropagation();
                },
                className: "calendar-year-picker absolute z-50 mt-1 p-3 bg-bg-secondary dark:bg-dark-bg-secondary rounded-lg shadow-lg border border-border-color dark:border-dark-border-color",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        "data-calendar-nav": "true",
                        onClick: (e2) => {
                          e2.stopPropagation();
                          e2.nativeEvent.stopImmediatePropagation();
                          setRhsYearRangeStart(rhsYearRangeStart - 12);
                        },
                        onMouseDown: (e2) => {
                          e2.stopPropagation();
                          e2.nativeEvent.stopImmediatePropagation();
                        },
                        className: "p-1 rounded hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
                        style: { color: palette.accent },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: "chevron_left" })
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm font-medium", style: { color: palette.accent }, children: [
                      rhsYearRangeStart,
                      " - ",
                      rhsYearRangeStart + 11
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        "data-calendar-nav": "true",
                        onClick: (e2) => {
                          e2.stopPropagation();
                          e2.nativeEvent.stopImmediatePropagation();
                          setRhsYearRangeStart(rhsYearRangeStart + 12);
                        },
                        onMouseDown: (e2) => {
                          e2.stopPropagation();
                          e2.nativeEvent.stopImmediatePropagation();
                        },
                        className: "p-1 rounded hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
                        style: { color: palette.accent },
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: "chevron_right" })
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-4 gap-2", children: Array.from({ length: 12 }, (_2, i2) => rhsYearRangeStart + i2).map((year) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      "data-calendar-nav": "true",
                      onClick: (e2) => {
                        e2.stopPropagation();
                        e2.preventDefault();
                        e2.nativeEvent.stopImmediatePropagation();
                        requestAnimationFrame(() => handleRhsYearSelect(year));
                      },
                      onMouseDown: (e2) => {
                        e2.stopPropagation();
                        e2.preventDefault();
                        e2.nativeEvent.stopImmediatePropagation();
                      },
                      className: cn(
                        "px-2 py-2 text-sm rounded-md transition-colors",
                        rhsMonth.getFullYear() === year ? "font-semibold" : "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
                      ),
                      style: {
                        backgroundColor: rhsMonth.getFullYear() === year ? palette.accent : void 0,
                        color: rhsMonth.getFullYear() === year ? "white" : palette.accent
                      },
                      children: year
                    },
                    year
                  )) })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              DayPicker,
              {
                mode,
                locale: locales[contextLanguage],
                selected: mode === "single" ? finalValue : mode === "range" ? rangeValue : multiValue,
                onSelect: mode === "single" ? onDateSelect : mode === "range" ? (_newRange, selectedDay) => {
                  if (!selectedDay) return;
                  if (justFinishedDragging.current) {
                    return;
                  }
                  handleRangeSelection(selectedDay);
                } : onMultiSelect,
                onDayMouseEnter: mode === "range" ? (day) => {
                  if (getRangeSelectionState() === 1) {
                    setHoveredDate(day);
                  }
                } : void 0,
                onDayMouseLeave: mode === "range" ? () => setHoveredDate(void 0) : void 0,
                modifiers: mode === "range" ? {
                  "range-preview": getHoverPreviewDates(),
                  "range-preview-end": hoveredDate && getRangeSelectionState() === 1 ? [hoveredDate] : []
                } : void 0,
                modifiersClassNames: mode === "range" ? {
                  "range-preview": "range-preview",
                  "range-preview-end": "range-preview-end"
                } : void 0,
                month: rhsMonth,
                onMonthChange: setRhsMonth,
                numberOfMonths: 1,
                components: {
                  Chevron: ({ orientation }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronIcon, { orientation })
                },
                captionLayout: "label",
                hideNavigation: true,
                startMonth: fromDate || new Date(startYear, 0),
                endMonth: toDate2 || new Date(endYear, 11),
                showOutsideDays,
                disabled: getDisabledMatcher(),
                weekStartsOn,
                showWeekNumber
              }
            )
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          mode === "single" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            DayPicker,
            {
              mode: "single",
              locale: locales[contextLanguage],
              selected: finalValue,
              onSelect: onDateSelect,
              month: finalMonth,
              onMonthChange: finalOnMonthChange,
              numberOfMonths,
              components: {
                Chevron: ({ orientation }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronIcon, { orientation })
              },
              captionLayout: navigation === "buttons" ? "label" : navigation === "dropdown" && showHeader || numberOfMonths > 1 ? "dropdown" : "label",
              hideNavigation: (navigation === "modern" || navigation === "buttons") && numberOfMonths === 1,
              startMonth: fromDate || new Date(startYear, 0),
              endMonth: toDate2 || new Date(endYear, 11),
              showOutsideDays,
              disabled: getDisabledMatcher(),
              weekStartsOn,
              showWeekNumber
            }
          ),
          mode === "range" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            DayPicker,
            {
              mode: "range",
              locale: locales[contextLanguage],
              selected: rangeValue,
              onSelect: (_newRange, selectedDay) => {
                if (!selectedDay) return;
                if (justFinishedDragging.current) {
                  return;
                }
                handleRangeSelection(selectedDay);
              },
              onDayMouseEnter: (day) => {
                if (getRangeSelectionState() === 1) {
                  setHoveredDate(day);
                }
              },
              onDayMouseLeave: () => setHoveredDate(void 0),
              modifiers: {
                "range-preview": getHoverPreviewDates(),
                "range-preview-end": hoveredDate && getRangeSelectionState() === 1 ? [hoveredDate] : []
              },
              modifiersClassNames: {
                "range-preview": "range-preview",
                "range-preview-end": "range-preview-end"
              },
              month: finalMonth,
              onMonthChange: finalOnMonthChange,
              numberOfMonths,
              components: {
                Chevron: ({ orientation }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronIcon, { orientation })
              },
              captionLayout: navigation === "buttons" ? "label" : navigation === "dropdown" && showHeader || numberOfMonths > 1 ? "dropdown" : "label",
              hideNavigation: (navigation === "modern" || navigation === "buttons") && numberOfMonths === 1,
              startMonth: fromDate || new Date(startYear, 0),
              endMonth: toDate2 || new Date(endYear, 11),
              showOutsideDays,
              disabled: getDisabledMatcher(),
              weekStartsOn,
              showWeekNumber,
              min: min2,
              max: max2
            }
          ),
          mode === "multiple" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            DayPicker,
            {
              mode: "multiple",
              locale: locales[contextLanguage],
              selected: multiValue,
              onSelect: onMultiSelect,
              month: finalMonth,
              onMonthChange: finalOnMonthChange,
              numberOfMonths,
              components: {
                Chevron: ({ orientation }) => /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronIcon, { orientation })
              },
              captionLayout: navigation === "buttons" ? "label" : navigation === "dropdown" && showHeader || numberOfMonths > 1 ? "dropdown" : "label",
              hideNavigation: (navigation === "modern" || navigation === "buttons") && numberOfMonths === 1,
              startMonth: fromDate || new Date(startYear, 0),
              endMonth: toDate2 || new Date(endYear, 11),
              showOutsideDays,
              disabled: getDisabledMatcher(),
              weekStartsOn,
              showWeekNumber,
              min: min2,
              max: max2
            }
          )
        ] })
      ]
    }
  );
};
const CardRoot = ({
  children,
  containerClassName = "",
  className,
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  backgroundColor = "none",
  textColor = "auto",
  gradient = "none",
  gradientColors = [],
  animation = "none",
  animationDelay = 0,
  animationDuration = 300,
  loading = false,
  imageSrc,
  imageAlt,
  imagePosition = "top",
  imageSize = "md",
  disabled = false,
  isFeatured = false,
  isInteractive = false,
  as,
  featuredText = "Featured",
  isBordered = false,
  hasShadow = true,
  isRounded = true,
  fullWidth = false,
  hasPadding = true,
  overflowVisible = true,
  // NEW: Industry standard props
  ariaLabel,
  ariaDescribedBy,
  role,
  tabIndex,
  onClick,
  onKeyDown,
  onFocus,
  onBlur,
  ...props
}) => {
  const Component2 = as || "div";
  const sizeClasses2 = {
    xs: "p-2 rounded-md",
    sm: "p-4 rounded-lg",
    md: "p-6 rounded-xl",
    lg: "p-8 rounded-2xl",
    xl: "p-10 rounded-3xl",
    "2xl": "p-12 rounded-3xl",
    full: "p-6 rounded-xl"
  };
  const variantClasses2 = {
    default: backgroundColor === "none" ? "bg-white dark:bg-dark-bg-tertiary shadow-sm border-0" : "shadow-sm border-0",
    minimal: "bg-transparent border-none shadow-none",
    elevated: backgroundColor === "none" ? "bg-white dark:bg-dark-bg-tertiary shadow-xl border-0" : "shadow-xl border-0",
    bordered: backgroundColor === "none" ? "bg-white dark:bg-dark-bg-tertiary border-2 shadow-sm" : "border-2 shadow-sm",
    filled: backgroundColor === "none" ? "bg-bg-tertiary dark:bg-dark-bg-tertiary border" : "border",
    outlined: "bg-transparent border-2",
    ghost: "bg-transparent hover:bg-bg-secondary dark:hover:bg-dark-bg-secondary border border-transparent",
    card: backgroundColor === "none" ? "bg-white dark:bg-dark-bg-tertiary shadow-lg border" : "shadow-lg border",
    panel: backgroundColor === "none" ? "bg-bg-tertiary dark:bg-dark-bg-tertiary border shadow-sm" : "border shadow-sm"
  };
  const colorClasses2 = {
    primary: "border-brand-orange dark:border-dark-brand-orange",
    success: "border-system-success",
    warning: "border-system-warning",
    danger: "border-system-error",
    info: "border-system-info",
    neutral: "border-border-color dark:border-dark-border-color"
  };
  const hoverColorClasses = {
    primary: "hover:border-brand-orange/70 dark:hover:border-dark-brand-orange/70",
    success: "hover:border-system-success/70",
    warning: "hover:border-system-warning/70",
    danger: "hover:border-system-error/70",
    info: "hover:border-system-info/70",
    neutral: "hover:border-border-color/70 dark:hover:border-dark-border-color/70"
  };
  const backgroundColorClasses = {
    primary: "bg-brand-orange dark:bg-dark-brand-orange text-white dark:text-white",
    success: "bg-system-success text-white",
    warning: "bg-system-warning text-white",
    danger: "bg-system-error text-white",
    info: "bg-system-info text-white",
    neutral: "bg-bg-tertiary dark:bg-dark-bg-tertiary text-text-primary dark:text-dark-text-primary",
    "brand-orange": "bg-brand-orange text-white",
    "brand-navy": "bg-brand-navy text-white",
    none: ""
  };
  const textColorClasses = {
    primary: "text-text-primary dark:text-dark-text-primary",
    secondary: "text-text-secondary dark:text-dark-text-secondary",
    success: "text-system-success",
    warning: "text-system-warning",
    danger: "text-system-error",
    info: "text-system-info",
    neutral: "text-text-primary dark:text-dark-text-primary",
    "brand-orange": "text-brand-orange dark:text-dark-brand-orange",
    "brand-navy": "text-brand-navy",
    white: "text-white",
    black: "text-black",
    auto: ""
    // Will be overridden by backgroundColor if needed
  };
  const getTextColorClasses = () => {
    if (textColor !== "auto") {
      return textColorClasses[textColor];
    }
    if (backgroundColor !== "none") {
      return backgroundColorClasses[backgroundColor].split(" ").filter((cls) => cls.startsWith("text-")).join(" ");
    }
    return textColorClasses.primary;
  };
  const finalTextColorClasses = getTextColorClasses();
  const gradientClasses = {
    "primary-to-secondary": "bg-gradient-to-r from-brand-orange to-brand-navy",
    "success-to-info": "bg-gradient-to-r from-system-success to-system-info",
    "warning-to-danger": "bg-gradient-to-r from-system-warning to-system-error",
    "brand-orange-to-brand-navy": "bg-gradient-to-r from-brand-orange to-brand-navy",
    "rainbow": "bg-gradient-to-r from-red-500 via-yellow-500 via-green-500 via-blue-500 to-purple-500",
    "custom": "",
    // Custom gradients use inline styles (see customGradientStyle below)
    "none": ""
  };
  const customGradientStyle = gradient === "custom" && gradientColors && gradientColors.length >= 2 ? {
    backgroundImage: `linear-gradient(to right, ${gradientColors.join(", ")})`
  } : void 0;
  const animationClasses = {
    "fadeIn": "animate-fade-in",
    "slideUp": "animate-slide-up",
    "slideDown": "animate-slide-down",
    "slideLeft": "animate-slide-left",
    "slideRight": "animate-slide-right",
    "scale": "animate-scale",
    "none": ""
  };
  const accessibilityProps = {
    ...ariaLabel && { "aria-label": ariaLabel },
    ...ariaDescribedBy && { "aria-describedby": ariaDescribedBy },
    ...role && { role },
    ...isInteractive && { tabIndex: tabIndex ?? 0 },
    ...isInteractive && onClick && { onClick },
    ...isInteractive && onKeyDown && { onKeyDown },
    ...onFocus && { onFocus },
    ...onBlur && { onBlur },
    ...disabled && { "aria-disabled": true }
  };
  const handleKeyDown = (event) => {
    if (isInteractive && !disabled) {
      if (event.key === "Enter" || event.key === " ") {
        event.preventDefault();
        onClick?.(event);
      }
    }
    onKeyDown?.(event);
  };
  if (loading) {
    const overflowClass2 = overflowVisible ? "overflow-visible" : "overflow-hidden";
    const loadingClasses = `group relative bg-bg-secondary dark:bg-dark-bg-tertiary border transition-all duration-300 ${overflowClass2} animate-pulse`;
    const shadowClass2 = hasShadow ? "shadow-md" : "";
    const roundedClass2 = isRounded ? sizeClasses2[size2] : "p-0";
    const widthClass2 = fullWidth ? "w-full" : "w-auto";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Component2,
      {
        className: `${loadingClasses} ${roundedClass2} ${shadowClass2} ${widthClass2} ${className}`,
        style,
        ...accessibilityProps,
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-4 bg-bg-tertiary dark:bg-dark-bg-primary rounded animate-pulse" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 bg-bg-tertiary dark:bg-dark-bg-primary rounded animate-pulse w-3/4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-3 bg-bg-tertiary dark:bg-dark-bg-primary rounded animate-pulse w-1/2" })
        ] })
      }
    );
  }
  if (disabled) {
    const overflowClass2 = overflowVisible ? "overflow-visible" : "overflow-hidden";
    const disabledClasses = `group relative bg-bg-secondary dark:bg-dark-bg-tertiary border-2 transition-all duration-300 ${overflowClass2} border-transparent cursor-not-allowed opacity-60`;
    const shadowClass2 = hasShadow ? "shadow-md" : "";
    const roundedClass2 = isRounded ? sizeClasses2[size2] : "p-0";
    const borderClass = isBordered ? "border-2" : "border-0";
    const widthClass2 = fullWidth ? "w-full" : "w-auto";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Component2,
      {
        className: `${disabledClasses} ${roundedClass2} ${shadowClass2} ${borderClass} ${widthClass2} ${className}`,
        style,
        ...accessibilityProps,
        ...props,
        children: [
          isFeatured && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 -mt-px left-6 z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative h-6 px-3 flex items-center justify-center bg-brand-orange rounded-b-md text-white font-bold text-xs uppercase tracking-wider", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-white !text-sm mr-1.5", children: "star" }),
            featuredText
          ] }) }),
          children
        ]
      }
    );
  }
  if (isFeatured) {
    const overflowClass2 = overflowVisible ? "overflow-visible" : "overflow-hidden";
    const interactionClasses2 = isInteractive ? "motion-safe:hover:shadow-2xl motion-safe:hover:-translate-y-1 cursor-pointer" : "";
    const shadowClass2 = hasShadow ? "shadow-xl" : "";
    const roundedClass2 = isRounded ? sizeClasses2[size2] : "p-0";
    const widthClass2 = fullWidth ? "w-full" : "w-auto";
    const combinedClasses2 = [
      "group relative shadow-xl transition-all duration-300",
      overflowClass2,
      "bg-gradient-to-br from-system-info via-brand-orange to-dark-brand-orange-hover",
      "motion-safe:animate-gradient-pan [background-size:200%_200%]",
      roundedClass2,
      shadowClass2,
      widthClass2,
      interactionClasses2,
      className
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Component2,
      {
        className: combinedClasses2,
        ...accessibilityProps,
        ...props,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `relative w-full h-full bg-bg-secondary dark:bg-dark-bg-tertiary rounded-[10px] ${overflowVisible ? "overflow-visible" : "overflow-hidden"}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 -mt-px left-6 z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative h-6 px-3 flex items-center justify-center bg-brand-orange rounded-b-md text-white font-bold text-xs uppercase tracking-wider motion-safe:animate-badge-pulse", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-white !text-sm mr-1.5", children: "star" }),
            featuredText,
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: " (Featured)" })
          ] }) }),
          children
        ] })
      }
    );
  }
  const overflowClass = overflowVisible ? "overflow-visible" : "overflow-hidden";
  const baseClasses = `group relative transition-all duration-300 ${overflowClass}`;
  const shadowClass = hasShadow ? "shadow-md" : "";
  const roundedClass = isRounded ? sizeClasses2[size2] : "p-0";
  const widthClass = fullWidth ? "w-full" : "w-auto";
  const paddingClass = hasPadding ? roundedClass : "p-0";
  const interactionClasses = isInteractive ? "cursor-pointer hover:shadow-xl motion-safe:hover:-translate-y-1 outline-none focus-visible:ring-2 focus-visible:ring-brand-orange focus-visible:ring-offset-2 dark:focus-visible:ring-dark-brand-orange" : "";
  const hoverClasses = isInteractive ? hoverColorClasses[color2] : "";
  const gradientClass = gradient !== "custom" && gradient !== "none" ? gradientClasses[gradient] : void 0;
  const combinedClasses = [
    baseClasses,
    sizeClasses2[size2],
    variantClasses2[variant],
    backgroundColorClasses[backgroundColor],
    gradientClass,
    // Only use Tailwind classes for standard gradients
    finalTextColorClasses,
    colorClasses2[color2],
    hoverClasses,
    shadowClass,
    interactionClasses,
    paddingClass,
    widthClass,
    animationClasses[animation],
    containerClassName,
    className
  ].filter(Boolean).join(" ");
  const mergedStyle = {
    ...customGradientStyle,
    ...style
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Component2,
    {
      className: combinedClasses,
      style: Object.keys(mergedStyle).length > 0 ? mergedStyle : void 0,
      ...accessibilityProps,
      ...isInteractive && { onKeyDown: handleKeyDown },
      ...props,
      children: [
        imageSrc && imagePosition === "top" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CardImage,
          {
            src: imageSrc,
            alt: imageAlt || "",
            size: imageSize,
            className: "rounded-t-lg"
          }
        ),
        imageSrc && imagePosition === "left" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CardImage,
            {
              src: imageSrc,
              alt: imageAlt || "",
              size: imageSize,
              className: "rounded-l-lg flex-shrink-0"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children })
        ] }),
        imageSrc && imagePosition === "right" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CardImage,
            {
              src: imageSrc,
              alt: imageAlt || "",
              size: imageSize,
              className: "rounded-r-lg flex-shrink-0"
            }
          )
        ] }),
        (!imageSrc || imagePosition === "top" || imagePosition === "bottom") && children,
        imageSrc && imagePosition === "bottom" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CardImage,
          {
            src: imageSrc,
            alt: imageAlt || "",
            size: imageSize,
            className: "rounded-b-lg"
          }
        )
      ]
    }
  );
};
const CardImage = ({
  className,
  isAspectRatioMaintained = true,
  isRounded = true,
  size: size2 = "md",
  alt,
  ...props
}) => {
  const sizeClasses2 = {
    xs: "h-24",
    sm: "h-32",
    md: "h-48",
    lg: "h-64",
    xl: "h-80",
    "2xl": "h-96",
    full: "h-full"
  };
  const aspectClass = isAspectRatioMaintained ? "object-cover" : "object-contain";
  const roundedClass = isRounded ? "rounded-t-lg" : "";
  const combinedClasses = `w-full ${sizeClasses2[size2]} ${aspectClass} ${roundedClass} ${className || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: combinedClasses, alt, ...props });
};
CardImage.displayName = "Card.Image";
const CardHeader = ({
  children,
  className,
  isBordered = true,
  hasPadding = true
}) => {
  const borderClass = isBordered ? "border-b border-border-color dark:border-dark-border-subtle" : "";
  const paddingClass = hasPadding ? "p-6" : "";
  const combinedClasses = `${paddingClass} ${borderClass} ${className || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: combinedClasses, children });
};
CardHeader.displayName = "Card.Header";
const CardBody = ({
  children,
  className,
  hasPadding = true,
  isScrollable = false,
  maxHeight
}) => {
  const paddingClass = hasPadding ? "p-6" : "";
  const scrollClass = isScrollable ? "overflow-y-auto" : "";
  const combinedClasses = `${paddingClass} ${scrollClass} ${className || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: combinedClasses, style: maxHeight ? { maxHeight } : void 0, children });
};
CardBody.displayName = "Card.Body";
const CardFooter = ({
  children,
  className,
  hasPadding = true,
  alignment = "right"
}) => {
  const paddingClass = hasPadding ? "px-6 pb-6 pt-4" : "";
  const alignmentClasses = {
    left: "justify-start",
    center: "justify-center",
    right: "justify-end",
    "space-between": "justify-between"
  };
  const defaultFooterClasses = `flex items-center gap-4 ${alignmentClasses[alignment]}`;
  const combinedClasses = `${paddingClass} ${defaultFooterClasses} ${className || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("footer", { className: combinedClasses, children });
};
CardFooter.displayName = "Card.Footer";
const CardTitle = ({
  children,
  className,
  level = 3,
  hasDivider = false
}) => {
  const HeadingTag = `h${level}`;
  const dividerClass = hasDivider ? "border-b border-border-color dark:border-dark-border-subtle pb-3 mb-3" : "";
  const combinedClasses = `text-lg font-semibold text-text-primary dark:text-dark-text-primary ${dividerClass} ${className || ""}`;
  return React__default.createElement(HeadingTag, { className: combinedClasses }, children);
};
CardTitle.displayName = "Card.Title";
const CardDescription = ({
  children,
  className,
  hasDivider = false
}) => {
  const dividerClass = hasDivider ? "border-t border-border-color dark:border-dark-border-subtle pt-3 mt-3" : "";
  const combinedClasses = `text-sm text-text-secondary dark:text-dark-text-secondary ${dividerClass} ${className || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: combinedClasses, children });
};
CardDescription.displayName = "Card.Description";
const CardActions = ({
  children,
  className,
  alignment = "right",
  hasDivider = true
}) => {
  const alignmentClasses = {
    left: "justify-start",
    center: "justify-center",
    right: "justify-end",
    "space-between": "justify-between"
  };
  const dividerClass = hasDivider ? "border-t border-border-color dark:border-dark-border-subtle pt-4 mt-4" : "";
  const combinedClasses = `flex items-center gap-2 ${alignmentClasses[alignment]} ${dividerClass} ${className || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: combinedClasses, children });
};
CardActions.displayName = "Card.Actions";
const CardContent = ({
  children,
  className,
  hasPadding = true
}) => {
  const paddingClass = hasPadding ? "p-6" : "";
  const combinedClasses = `${paddingClass} ${className || ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: combinedClasses, children });
};
CardContent.displayName = "Card.Content";
const CardGroup = ({
  children,
  direction = "horizontal",
  gap = "md",
  columns = 3,
  className = ""
}) => {
  const gapClasses = {
    xs: "gap-1",
    sm: "gap-2",
    md: "gap-4",
    lg: "gap-6",
    xl: "gap-8"
  };
  const directionClasses = {
    horizontal: "flex flex-row",
    vertical: "flex flex-col",
    grid: `grid grid-cols-${columns}`
  };
  const combinedClasses = `${directionClasses[direction]} ${gapClasses[gap]} ${className}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: combinedClasses, children });
};
CardGroup.displayName = "Card.Group";
const Card = Object.assign(CardRoot, {
  Image: CardImage,
  Header: CardHeader,
  Body: CardBody,
  Footer: CardFooter,
  // NEW: Industry standard sub-components
  Title: CardTitle,
  Description: CardDescription,
  Actions: CardActions,
  Content: CardContent,
  // NEW: Card Group component
  Group: CardGroup
});
const lineChartColorConfig = {
  "brand-orange": {
    stroke: "#f97316",
    gradientFrom: "#f97316",
    gradientTo: "#fed7aa"
  },
  "blue": {
    stroke: "#3b82f6",
    gradientFrom: "#3b82f6",
    gradientTo: "#dbeafe"
  },
  "green": {
    stroke: "#10b981",
    gradientFrom: "#10b981",
    gradientTo: "#d1fae5"
  },
  "red": {
    stroke: "#ef4444",
    gradientFrom: "#ef4444",
    gradientTo: "#fecaca"
  },
  "purple": {
    stroke: "#8b5cf6",
    gradientFrom: "#8b5cf6",
    gradientTo: "#e9d5ff"
  }
};
const LineChart = ({
  data = [],
  className = "",
  color: color2 = "brand-orange"
}) => {
  const safeData = Array.isArray(data) ? data : [];
  const { stroke } = lineChartColorConfig[color2];
  const width = 500;
  const height = 200;
  const padding = 20;
  if (safeData.length <= 1) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-52 flex items-center justify-center text-text-secondary dark:text-dark-text-secondary", children: "Not enough data for chart." });
  }
  const maxValue = Math.max(...data.map((p2) => p2.value), 0);
  const getX = (index2) => padding + index2 / (data.length - 1) * (width - padding * 2);
  const getY = (value) => height - padding - (maxValue > 0 ? value / maxValue * (height - padding * 2) : 0);
  const path = data.map((p2, i2) => `${i2 === 0 ? "M" : "L"} ${getX(i2)} ${getY(p2.value)}`).join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-full ${className}`, role: "img", "aria-label": "Line chart", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: `0 0 ${width} ${height}`, className: "w-full h-auto", children: [
    Array.from({ length: 5 }).map((_2, i2) => {
      const y2 = padding + i2 / 4 * (height - padding * 2);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: padding,
          y1: y2,
          x2: width - padding,
          y2,
          stroke: "currentColor",
          className: "text-border-color dark:text-dark-border-color opacity-20",
          strokeWidth: "1"
        },
        i2
      );
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        x1: padding,
        y1: padding,
        x2: padding,
        y2: height - padding,
        stroke: "currentColor",
        className: "text-border-color dark:text-dark-border-color",
        strokeWidth: "2"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "line",
      {
        x1: padding,
        y1: height - padding,
        x2: width - padding,
        y2: height - padding,
        stroke: "currentColor",
        className: "text-border-color dark:text-dark-border-color",
        strokeWidth: "2"
      }
    ),
    Array.from({ length: 5 }).map((_2, i2) => {
      const value = maxValue / 4 * (4 - i2);
      const y2 = padding + i2 / 4 * (height - padding * 2);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "text",
        {
          x: padding - 8,
          y: y2,
          textAnchor: "end",
          alignmentBaseline: "middle",
          className: "text-xs fill-current text-text-secondary dark:text-dark-text-secondary",
          children: value.toFixed(0)
        },
        i2
      );
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: path,
        fill: "none",
        stroke,
        strokeWidth: "3",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    safeData.map((p2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "cursor-pointer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: `${p2.label}: ${p2.value}` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "circle",
        {
          cx: getX(i2),
          cy: getY(p2.value),
          r: "4",
          fill: "white",
          stroke,
          strokeWidth: "2",
          className: "hover:r-6 transition-all"
        }
      )
    ] }, i2)),
    safeData.map((p2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "text",
      {
        x: getX(i2),
        y: height - padding + 16,
        textAnchor: "middle",
        className: "text-xs fill-current text-text-secondary dark:text-dark-text-secondary",
        children: p2.label.length > 8 ? `${p2.label.substring(0, 8)}...` : p2.label
      },
      i2
    ))
  ] }) });
};
const BarChart = ({
  data = [],
  className = "",
  color: color2 = "brand-orange"
}) => {
  const safeData = Array.isArray(data) ? data : [];
  const { stroke } = lineChartColorConfig[color2];
  const width = 500;
  const height = 300;
  const padding = 40;
  if (safeData.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-52 flex items-center justify-center text-text-secondary dark:text-dark-text-secondary", children: "No data available for chart." });
  }
  const maxValue = Math.max(...safeData.map((d2) => d2.value), 0);
  const barWidth = (width - padding * 2) / safeData.length * 0.8;
  const barSpacing = (width - padding * 2) / safeData.length * 0.2;
  const getX = (index2) => padding + index2 * (barWidth + barSpacing) + barSpacing / 2;
  const getY = (value) => height - padding - (maxValue > 0 ? value / maxValue * (height - padding * 2) : 0);
  const getBarHeight = (value) => maxValue > 0 ? value / maxValue * (height - padding * 2) : 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-full ${className}`, role: "img", "aria-label": "Bar chart", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: `0 0 ${width} ${height}`, className: "w-full h-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: padding, y1: padding, x2: padding, y2: height - padding, stroke: "currentColor", className: "text-border-color dark:text-dark-border-color", strokeWidth: "2" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: padding, y1: height - padding, x2: width - padding, y2: height - padding, stroke: "currentColor", className: "text-border-color dark:text-dark-border-color", strokeWidth: "2" }),
    Array.from({ length: 5 }).map((_2, i2) => {
      const value = maxValue / 4 * i2;
      const y2 = height - padding - i2 / 4 * (height - padding * 2);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("text", { x: padding - 8, y: y2, textAnchor: "end", alignmentBaseline: "middle", className: "text-xs fill-current text-text-secondary dark:text-dark-text-secondary", children: value.toFixed(0) }, i2);
    }),
    safeData.map((item, index2) => {
      const x2 = getX(index2);
      const y2 = getY(item.value);
      const barHeight = getBarHeight(item.value);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "cursor-pointer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: `${item.label}: ${item.value}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: x2, y: y2, width: barWidth, height: barHeight, fill: stroke, className: "opacity-80 hover:opacity-100 transition-opacity", rx: "4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("text", { x: x2 + barWidth / 2, y: height - padding + 16, textAnchor: "middle", className: "text-xs fill-current text-text-secondary dark:text-dark-text-secondary", children: item.label.length > 8 ? `${item.label.substring(0, 8)}...` : item.label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("text", { x: x2 + barWidth / 2, y: y2 - 5, textAnchor: "middle", className: "text-xs font-medium fill-current text-text-primary dark:text-dark-text-primary", children: item.value })
      ] }, index2);
    })
  ] }) });
};
const AreaChart = ({ data = [], className = "", color: color2 = "brand-orange" }) => {
  const safeData = Array.isArray(data) ? data : [];
  const { stroke, gradientFrom, gradientTo } = lineChartColorConfig[color2];
  const width = 500;
  const height = 200;
  const padding = 20;
  if (safeData.length <= 1) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full h-52 flex items-center justify-center text-text-secondary dark:text-dark-text-secondary", children: "Not enough data for chart." });
  }
  const maxValue = Math.max(...safeData.map((p2) => p2.value), 0);
  const getX = (index2) => padding + index2 / (safeData.length - 1) * (width - padding * 2);
  const getY = (value) => height - padding - (maxValue > 0 ? value / maxValue * (height - padding * 2) : 0);
  const path = safeData.map((p2, i2) => `${i2 === 0 ? "M" : "L"} ${getX(i2)} ${getY(p2.value)}`).join(" ");
  const areaPath = `${path} L ${getX(safeData.length - 1)} ${height - padding} L ${getX(0)} ${height - padding} Z`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-full ${className}`, role: "img", "aria-label": "Area chart", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: `0 0 ${width} ${height}`, className: "w-full h-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("linearGradient", { id: `areaGradient-${color2}`, x1: "0", y1: "0", x2: "0", y2: "1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0%", stopColor: gradientFrom }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "100%", stopColor: gradientTo })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: areaPath, fill: `url(#areaGradient-${color2})` }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: path, fill: "none", stroke, strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round" }),
    safeData.map((p2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "cursor-pointer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: `${p2.label}: ${p2.value}` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "circle",
        {
          cx: getX(i2),
          cy: getY(p2.value),
          r: "5",
          fill: "white",
          stroke,
          strokeWidth: "3"
        }
      )
    ] }, i2))
  ] }) });
};
const ScatterPlot = ({ data = [], className = "", color: color2 = "brand-orange" }) => {
  const safeData = Array.isArray(data) ? data : [];
  const { stroke } = lineChartColorConfig[color2];
  const width = 500;
  const height = 300;
  const padding = 30;
  const maxX = Math.max(...safeData.map((p2) => p2.x), 0);
  const maxY = Math.max(...safeData.map((p2) => p2.y), 0);
  const getX = (value) => padding + (maxX > 0 ? value / maxX * (width - padding * 2) : 0);
  const getY = (value) => height - padding - (maxY > 0 ? value / maxY * (height - padding * 2) : 0);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `w-full ${className}`, role: "img", "aria-label": "Scatter plot", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { viewBox: `0 0 ${width} ${height}`, className: "w-full h-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: padding, y1: height - padding, x2: width - padding, y2: height - padding, stroke: "currentColor", className: "text-border-color dark:text-dark-border-color", strokeWidth: "2" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: padding, y1: padding, x2: padding, y2: height - padding, stroke: "currentColor", className: "text-border-color dark:text-dark-border-color", strokeWidth: "2" }),
    Array.from({ length: 5 }).map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("text", { x: padding - 8, y: getY(maxY / 4 * i2), textAnchor: "end", alignmentBaseline: "middle", className: "text-xs fill-current text-text-secondary dark:text-dark-text-secondary", children: (maxY / 4 * i2).toFixed(0) }, i2)),
    Array.from({ length: 5 }).map((_2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx("text", { x: getX(maxX / 4 * i2), y: height - padding + 16, textAnchor: "middle", className: "text-xs fill-current text-text-secondary dark:text-dark-text-secondary", children: (maxX / 4 * i2).toFixed(0) }, i2)),
    safeData.map((p2, i2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: `(${p2.x}, ${p2.y})` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: getX(p2.x), cy: getY(p2.y), r: "5", fill: stroke, className: "opacity-70 hover:opacity-100 transition-opacity cursor-pointer" })
    ] }, i2))
  ] }) });
};
const getPieWedgePath = (cx, cy, radius, startAngle, endAngle) => {
  const start = {
    x: cx + radius * Math.cos(startAngle),
    y: cy + radius * Math.sin(startAngle)
  };
  const end = {
    x: cx + radius * Math.cos(endAngle),
    y: cy + radius * Math.sin(endAngle)
  };
  const largeArcFlag = endAngle - startAngle <= Math.PI ? "0" : "1";
  return `M ${start.x},${start.y} A ${radius},${radius} 0 ${largeArcFlag} 1 ${end.x},${end.y} L ${cx},${cy} Z`;
};
const PieChart = ({ data = [], className = "", size: size2 = 150 }) => {
  const total = data.reduce((acc, item) => acc + item.value, 0);
  let startAngle = -Math.PI / 2;
  const defaultColors = [
    "bg-brand-orange",
    "bg-blue-500",
    "bg-green-500",
    "bg-yellow-500",
    "bg-red-500",
    "bg-purple-500",
    "bg-pink-500",
    "bg-indigo-500"
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-wrap items-center justify-center gap-x-8 gap-y-4 ${className}`, role: "img", "aria-label": "Pie chart", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative shrink-0", style: { width: size2, height: size2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: `0 0 ${size2} ${size2}`, children: data.map((item, index2) => {
      if (item.value === 0) return null;
      const percentage = total > 0 ? item.value / total : 0;
      const angle = percentage * 2 * Math.PI;
      const endAngle = startAngle + angle;
      const pathData = getPieWedgePath(size2 / 2, size2 / 2, size2 / 2, startAngle, endAngle - 1e-4);
      startAngle = endAngle;
      const colorClass = item.colorClass || defaultColors[index2 % defaultColors.length];
      const fillClass = colorClass.replace("bg-", "fill-");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { className: "cursor-pointer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: `${item.label}: ${item.value.toLocaleString()}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: pathData, className: `${fillClass} transition-opacity hover:opacity-80` })
      ] }, item.id || index2);
    }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: data.map((item, index2) => {
      const colorClass = item.colorClass || defaultColors[index2 % defaultColors.length];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `w-3 h-3 rounded-full mr-3 shrink-0 ${colorClass}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap items-baseline gap-x-2 gap-y-1 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-text-primary dark:text-dark-text-primary", children: [
            item.label,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-text-secondary dark:text-dark-text-secondary font-medium", children: [
            item.value.toLocaleString(),
            " (",
            ~~(total > 0 ? item.value / total * 100 : 0),
            "%)"
          ] })
        ] })
      ] }, item.id || index2);
    }) })
  ] });
};
const DonutChart = ({
  data: initialData = [],
  className = "",
  size: size2 = 150,
  strokeWidth = 20
}) => {
  const data = initialData instanceof Array ? initialData : [];
  const total = data.reduce((acc, item) => acc + item.value, 0);
  const radius = (size2 - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  let accumulatedOffset = 0;
  const defaultColors = [
    "bg-brand-orange",
    "bg-blue-500",
    "bg-green-500",
    "bg-yellow-500",
    "bg-red-500",
    "bg-purple-500",
    "bg-pink-500",
    "bg-indigo-500"
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-wrap items-center justify-center gap-x-8 gap-y-4 ${className}`, role: "img", "aria-label": "Donut chart", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative shrink-0", style: { width: size2, height: size2 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: `0 0 ${size2} ${size2}`, className: "transform -rotate-90", children: data.map((item, index2) => {
        if (item.value === 0) return null;
        const percentage = total > 0 ? item.value / total : 0;
        const dasharray = percentage * circumference;
        const dashoffset = accumulatedOffset * circumference;
        accumulatedOffset += percentage;
        const colorClass = item.colorClass || defaultColors[index2 % defaultColors.length];
        const strokeClass = colorClass.replace("bg-", "stroke-");
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            cx: size2 / 2,
            cy: size2 / 2,
            r: radius,
            fill: "none",
            strokeWidth,
            strokeDasharray: `${dasharray} ${circumference - dasharray}`,
            strokeDashoffset: -dashoffset,
            className: strokeClass
          },
          item.id || index2
        );
      }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute inset-0 flex flex-col items-center justify-center text-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-3xl font-bold text-text-primary dark:text-dark-text-primary", children: total.toLocaleString() }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: "Total" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-3", children: data.map((item, index2) => {
      const colorClass = item.colorClass || defaultColors[index2 % defaultColors.length];
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `w-3 h-3 rounded-full mr-3 shrink-0 ${colorClass}` }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap items-baseline gap-x-2 gap-y-1 text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-bold text-text-primary dark:text-dark-text-primary", children: [
            item.label,
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-text-secondary dark:text-dark-text-secondary font-medium", children: [
            item.value.toLocaleString(),
            " (",
            ~~(total > 0 ? item.value / total * 100 : 0),
            "%)"
          ] })
        ] })
      ] }, item.id || index2);
    }) })
  ] });
};
const RawCheckbox = React__default.forwardRef(
  ({
    className = "",
    checkboxClassName = "",
    isIndeterminate = false,
    isDisabled = false,
    isRequired = false,
    isLoading = false,
    isReadOnly = false,
    hasBorder = true,
    hasRoundedCorners = true,
    hasFocusRing = true,
    hasShadow = false,
    hasBackground = true,
    size: size2 = "md",
    variant = "primary",
    color: color2 = "primary",
    align = "left",
    onChange,
    ...props
  }, ref) => {
    const defaultRef = useRef(null);
    const resolvedRef = ref || defaultRef;
    useEffect(() => {
      if (typeof resolvedRef === "object" && resolvedRef.current) {
        resolvedRef.current.indeterminate = !!isIndeterminate;
      }
    }, [resolvedRef, isIndeterminate]);
    const sizeClasses2 = {
      xs: "h-3 w-3",
      sm: "h-4 w-4",
      md: "h-5 w-5",
      lg: "h-6 w-6",
      xl: "h-7 w-7"
    };
    const variantClasses2 = {
      primary: "bg-bg-secondary dark:bg-dark-bg-secondary text-brand-orange",
      secondary: "bg-bg-tertiary dark:bg-dark-bg-primary text-brand-navy",
      outline: "bg-transparent border-2 text-brand-orange",
      ghost: "bg-transparent text-brand-orange",
      filled: "bg-bg-primary dark:bg-dark-bg-primary text-brand-orange"
    };
    const colorClasses2 = {
      primary: "border-brand-orange dark:border-dark-brand-orange text-brand-orange dark:text-dark-brand-orange",
      secondary: "border-border-color dark:border-dark-border-color text-text-secondary dark:text-dark-text-secondary",
      success: "border-system-success dark:border-system-success text-system-success dark:text-system-success",
      warning: "border-system-warning-dark dark:border-system-warning text-system-warning-dark dark:text-system-warning-light-text",
      danger: "border-system-error dark:border-system-error text-system-error dark:text-system-error",
      info: "border-system-info dark:border-system-info text-system-info dark:text-system-info"
    };
    const baseClasses = `${sizeClasses2[size2]} shrink-0 transition-all duration-200`;
    const backgroundClasses = hasBackground ? variantClasses2[variant] : "bg-transparent";
    const colorClass = colorClasses2[color2] ?? colorClasses2.primary;
    const borderPart = colorClass.split(" ").filter((c2) => c2.startsWith("border-") || c2.startsWith("dark:border-")).join(" ");
    const colorTextPart = colorClass.split(" ").filter((c2) => c2.startsWith("text-") || c2.startsWith("dark:text-")).join(" ");
    const borderClasses = hasBorder ? `border ${borderPart}` : "border-0";
    const roundedClasses = hasRoundedCorners ? "rounded-md" : "rounded-none";
    const focusRingByColor = {
      primary: "focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange",
      secondary: "focus-visible:ring-border-color dark:focus-visible:ring-dark-border-color",
      success: "focus-visible:ring-system-success dark:focus-visible:ring-system-success",
      warning: "focus-visible:ring-system-warning dark:focus-visible:ring-system-warning",
      danger: "focus-visible:ring-system-error dark:focus-visible:ring-system-error",
      info: "focus-visible:ring-system-info dark:focus-visible:ring-system-info"
    };
    const focusClasses = hasFocusRing ? `outline-none focus-visible:ring-2 focus-visible:ring-offset-2 ${focusRingByColor[color2]}` : "";
    const shadowClasses = hasShadow ? "shadow-md" : "";
    const stateClasses = isDisabled || isLoading ? "opacity-60 cursor-not-allowed" : "cursor-pointer";
    const loadingClasses = isLoading ? "animate-pulse" : "";
    const readOnlyClasses = isReadOnly ? "opacity-80 cursor-default" : "";
    const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
    const combinedClasses = `${baseClasses} ${backgroundClasses} ${borderClasses} ${colorTextPart} ${roundedClasses} ${focusClasses} ${shadowClasses} ${stateClasses} ${loadingClasses} ${readOnlyClasses} ${alignmentClass} ${checkboxClassName} ${className}`;
    const handleChange = (e2) => {
      if (onChange) {
        onChange(e2);
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        ref: resolvedRef,
        className: combinedClasses,
        disabled: isDisabled || isLoading,
        required: isRequired,
        readOnly: isReadOnly,
        onChange: handleChange,
        ...(() => {
          const { isSuccess, isWarning, loading, ...restProps } = props;
          return restProps;
        })()
      }
    );
  }
);
RawCheckbox.displayName = "RawCheckbox";
const Checkbox = ({
  label,
  id: id2,
  className = "",
  containerClassName = "",
  labelClassName = "",
  checkboxClassName = "",
  isDisabled = false,
  isRequired = false,
  isLoading = false,
  isIndeterminate = false,
  isReadOnly = false,
  hasBorder = true,
  hasRoundedCorners = true,
  hasFocusRing = true,
  hasShadow = false,
  hasBackground = true,
  showLabel = true,
  showHelperText = true,
  showErrorText = true,
  showRequiredIndicator = true,
  showDescription = false,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  align = "left",
  isLabelLeft = false,
  helperText,
  error: error2,
  isFullWidth = false,
  description,
  ...props
}) => {
  const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
  const labelContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "label",
      {
        htmlFor: id2,
        className: `text-sm font-medium text-text-primary dark:text-dark-text-primary ${isDisabled ? "opacity-60" : ""} ${alignmentClass} ${labelClassName}`,
        children: [
          label,
          isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
        ]
      }
    ),
    showDescription && description && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-text-secondary dark:text-dark-text-secondary mt-1", children: description })
  ] });
  const checkboxContent = /* @__PURE__ */ jsxRuntimeExports.jsx(
    RawCheckbox,
    {
      id: id2,
      className,
      checkboxClassName,
      isDisabled,
      isRequired,
      isLoading,
      isIndeterminate,
      isReadOnly,
      hasBorder,
      hasRoundedCorners,
      hasFocusRing,
      hasShadow,
      hasBackground,
      size: size2,
      variant,
      color: color2,
      align,
      ...props
    }
  );
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-start gap-3 ${widthClass} ${containerClassName}`, children: [
    isLabelLeft && labelContent,
    checkboxContent,
    !isLabelLeft && labelContent,
    (helperText || error2) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-8 mt-1", children: [
      showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
      showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
    ] })
  ] });
};
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e2.indexOf(n2)) continue;
    t2[n2] = r2[n2];
  }
  return t2;
}
function _objectWithoutProperties(e2, t2) {
  if (null == e2) return {};
  var o4, r2, i2 = _objectWithoutPropertiesLoose(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    for (r2 = 0; r2 < n2.length; r2++) o4 = n2[r2], -1 === t2.indexOf(o4) && {}.propertyIsEnumerable.call(e2, o4) && (i2[o4] = e2[o4]);
  }
  return i2;
}
function _arrayLikeToArray$1(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e2 = 0, n2 = Array(a3); e2 < a3; e2++) n2[e2] = r2[e2];
  return n2;
}
function _arrayWithoutHoles$1(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray$1(r2);
}
function _iterableToArray$1(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _unsupportedIterableToArray$1(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray$1(r2, a3);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray$1(r2, a3) : void 0;
  }
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray$1(r2) {
  return _arrayWithoutHoles$1(r2) || _iterableToArray$1(r2) || _unsupportedIterableToArray$1(r2) || _nonIterableSpread$1();
}
function _typeof(o4) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof(o4);
}
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i2 = toPrimitive(t2, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _defineProperty$1(e2, r2, t2) {
  return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
function ownKeys$2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e2);
    r2 && (o4 = o4.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o4);
  }
  return t2;
}
function _objectSpread$1(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$2(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1) return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames) {
  if (classNames.length === 0 || classNames.length === 1) return classNames;
  var key = classNames.join(".");
  if (!classNameCombinations[key]) {
    classNameCombinations[key] = powerSetPermutations(classNames);
  }
  return classNameCombinations[key];
}
function createStyleObject(classNames) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread$1(_objectSpread$1({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames) {
  return classNames.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i2) {
      return createElement({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i2)
      });
    });
  };
}
function createElement(_ref) {
  var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
  var properties = node.properties, type = node.type, TagName = node.tagName, value = node.value;
  if (type === "text") {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;
    if (!useInlineStyles) {
      props = _objectSpread$1(_objectSpread$1({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2)) classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread$1(_objectSpread$1({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
      });
    }
    var children = childrenCreator(node.children);
    return /* @__PURE__ */ React__default.createElement(TagName, _extends({
      key
    }, props), children);
  }
}
const checkForListedLanguage = (function(astGenerator, language) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language) !== -1;
});
var _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys$1(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e2);
    r2 && (o4 = o4.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o4);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
      _defineProperty$1(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var newLineRegex = /\n/g;
function getNewLines(str) {
  return str.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
  return lines.map(function(_2, i2) {
    var number2 = i2 + startingLineNumber;
    return /* @__PURE__ */ React__default.createElement("span", {
      key: "line-".concat(i2),
      className: "react-syntax-highlighter-line-number",
      style: typeof style === "function" ? style(number2) : style
    }, "".concat(number2, "\n"));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return /* @__PURE__ */ React__default.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread(_objectSpread({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines, _ref3$wrapLines = _ref3.wrapLines, wrapLines = _ref3$wrapLines === void 0 ? false : _ref3$wrapLines;
  var properties = wrapLines ? _objectSpread({}, typeof lineProps === "function" ? lineProps(lineNumber) : lineProps) : {};
  properties["className"] = properties["className"] ? [].concat(_toConsumableArray$1(properties["className"].trim().split(/\s+/)), _toConsumableArray$1(className)) : className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread({
      display: "flex"
    }, properties.style);
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i2 = 0; i2 < tree.length; i2++) {
    var node = tree[i2];
    if (node.type === "text") {
      newTree.push(createLineElement({
        children: [node],
        className: _toConsumableArray$1(new Set(className))
      }));
    } else if (node.children) {
      var classNames = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames).forEach(function(i3) {
        return newTree.push(i3);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index2 = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines,
      wrapLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node = tree[index2];
    var value = node.children[0].value;
    var newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split("\n");
      splitValue.forEach(function(text, i2) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text, "\n")
        };
        if (i2 === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index2).concat(createLineElement({
            children: [newChild],
            className: node.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i2 === splitValue.length - 1) {
          var stringChild = tree[index2 + 1] && tree[index2 + 1].children && tree[index2 + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node.properties.className
            });
            tree.splice(index2 + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index2;
    }
    index2++;
  };
  while (index2 < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node, i2) {
    return createElement({
      node,
      stylesheet,
      useInlineStyles,
      key: "code-segment-".concat(i2)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage(astGenerator, language);
    if (language === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code);
    } else {
      return astGenerator.highlightAuto(code);
    }
  }
  try {
    return language && language !== "text" ? {
      value: astGenerator.highlight(code, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e2) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight(defaultAstGenerator, defaultStyle2) {
  return function SyntaxHighlighter(_ref7) {
    var _code$match$length, _code$match;
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle2 : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : void 0,
      style: _objectSpread(_objectSpread({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = _objectWithoutProperties(_ref7, _excluded);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? /* @__PURE__ */ React__default.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code
    }) : null;
    var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest, {
      className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread({
        whiteSpace: "pre-wrap"
      }, codeTagProps.style);
    } else {
      codeTagProps.style = _objectSpread({
        whiteSpace: "pre"
      }, codeTagProps.style);
    }
    if (!astGenerator) {
      return /* @__PURE__ */ React__default.createElement(PreTag, preProps, allLineNumbers, /* @__PURE__ */ React__default.createElement(CodeTag, codeTagProps, code));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines) wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language,
      code,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var lineBreakCount = (_code$match$length = (_code$match = code.match(/\n/g)) === null || _code$match === void 0 ? void 0 : _code$match.length) !== null && _code$match$length !== void 0 ? _code$match$length : 0;
    var largestLineNumber = startingLineNumber + lineBreakCount;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return /* @__PURE__ */ React__default.createElement(PreTag, preProps, /* @__PURE__ */ React__default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style,
      useInlineStyles
    })));
  };
}
const supportedLanguages = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "bash", "basic", "batch", "bbcode", "bicep", "birb", "bison", "bnf", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "matlab", "maxscript", "mel", "mermaid", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stylus", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"];
var immutable;
var hasRequiredImmutable;
function requireImmutable() {
  if (hasRequiredImmutable) return immutable;
  hasRequiredImmutable = 1;
  immutable = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend() {
    var target = {};
    for (var i2 = 0; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  return immutable;
}
var schema;
var hasRequiredSchema;
function requireSchema() {
  if (hasRequiredSchema) return schema;
  hasRequiredSchema = 1;
  schema = Schema;
  var proto = Schema.prototype;
  proto.space = null;
  proto.normal = {};
  proto.property = {};
  function Schema(property, normal, space) {
    this.property = property;
    this.normal = normal;
    if (space) {
      this.space = space;
    }
  }
  return schema;
}
var merge_1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge_1;
  hasRequiredMerge = 1;
  var xtend = requireImmutable();
  var Schema = requireSchema();
  merge_1 = merge;
  function merge(definitions) {
    var length = definitions.length;
    var property = [];
    var normal = [];
    var index2 = -1;
    var info2;
    var space;
    while (++index2 < length) {
      info2 = definitions[index2];
      property.push(info2.property);
      normal.push(info2.normal);
      space = info2.space;
    }
    return new Schema(
      xtend.apply(null, property),
      xtend.apply(null, normal),
      space
    );
  }
  return merge_1;
}
var normalize_1;
var hasRequiredNormalize;
function requireNormalize() {
  if (hasRequiredNormalize) return normalize_1;
  hasRequiredNormalize = 1;
  normalize_1 = normalize;
  function normalize(value) {
    return value.toLowerCase();
  }
  return normalize_1;
}
var info;
var hasRequiredInfo;
function requireInfo() {
  if (hasRequiredInfo) return info;
  hasRequiredInfo = 1;
  info = Info;
  var proto = Info.prototype;
  proto.space = null;
  proto.attribute = null;
  proto.property = null;
  proto.boolean = false;
  proto.booleanish = false;
  proto.overloadedBoolean = false;
  proto.number = false;
  proto.commaSeparated = false;
  proto.spaceSeparated = false;
  proto.commaOrSpaceSeparated = false;
  proto.mustUseProperty = false;
  proto.defined = false;
  function Info(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
  return info;
}
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  var powers = 0;
  types.boolean = increment();
  types.booleanish = increment();
  types.overloadedBoolean = increment();
  types.number = increment();
  types.spaceSeparated = increment();
  types.commaSeparated = increment();
  types.commaOrSpaceSeparated = increment();
  function increment() {
    return Math.pow(2, ++powers);
  }
  return types;
}
var definedInfo;
var hasRequiredDefinedInfo;
function requireDefinedInfo() {
  if (hasRequiredDefinedInfo) return definedInfo;
  hasRequiredDefinedInfo = 1;
  var Info = requireInfo();
  var types2 = requireTypes();
  definedInfo = DefinedInfo;
  DefinedInfo.prototype = new Info();
  DefinedInfo.prototype.defined = true;
  var checks = [
    "boolean",
    "booleanish",
    "overloadedBoolean",
    "number",
    "commaSeparated",
    "spaceSeparated",
    "commaOrSpaceSeparated"
  ];
  var checksLength = checks.length;
  function DefinedInfo(property, attribute, mask, space) {
    var index2 = -1;
    var check;
    mark(this, "space", space);
    Info.call(this, property, attribute);
    while (++index2 < checksLength) {
      check = checks[index2];
      mark(this, check, (mask & types2[check]) === types2[check]);
    }
  }
  function mark(values, key, value) {
    if (value) {
      values[key] = value;
    }
  }
  return definedInfo;
}
var create_1;
var hasRequiredCreate;
function requireCreate() {
  if (hasRequiredCreate) return create_1;
  hasRequiredCreate = 1;
  var normalize = requireNormalize();
  var Schema = requireSchema();
  var DefinedInfo = requireDefinedInfo();
  create_1 = create;
  function create(definition) {
    var space = definition.space;
    var mustUseProperty = definition.mustUseProperty || [];
    var attributes = definition.attributes || {};
    var props = definition.properties;
    var transform = definition.transform;
    var property = {};
    var normal = {};
    var prop;
    var info2;
    for (prop in props) {
      info2 = new DefinedInfo(
        prop,
        transform(attributes, prop),
        props[prop],
        space
      );
      if (mustUseProperty.indexOf(prop) !== -1) {
        info2.mustUseProperty = true;
      }
      property[prop] = info2;
      normal[normalize(prop)] = prop;
      normal[normalize(info2.attribute)] = prop;
    }
    return new Schema(property, normal, space);
  }
  return create_1;
}
var xlink;
var hasRequiredXlink;
function requireXlink() {
  if (hasRequiredXlink) return xlink;
  hasRequiredXlink = 1;
  var create = requireCreate();
  xlink = create({
    space: "xlink",
    transform: xlinkTransform,
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    }
  });
  function xlinkTransform(_2, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  }
  return xlink;
}
var xml;
var hasRequiredXml;
function requireXml() {
  if (hasRequiredXml) return xml;
  hasRequiredXml = 1;
  var create = requireCreate();
  xml = create({
    space: "xml",
    transform: xmlTransform,
    properties: {
      xmlLang: null,
      xmlBase: null,
      xmlSpace: null
    }
  });
  function xmlTransform(_2, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  }
  return xml;
}
var caseSensitiveTransform_1;
var hasRequiredCaseSensitiveTransform;
function requireCaseSensitiveTransform() {
  if (hasRequiredCaseSensitiveTransform) return caseSensitiveTransform_1;
  hasRequiredCaseSensitiveTransform = 1;
  caseSensitiveTransform_1 = caseSensitiveTransform;
  function caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
  }
  return caseSensitiveTransform_1;
}
var caseInsensitiveTransform_1;
var hasRequiredCaseInsensitiveTransform;
function requireCaseInsensitiveTransform() {
  if (hasRequiredCaseInsensitiveTransform) return caseInsensitiveTransform_1;
  hasRequiredCaseInsensitiveTransform = 1;
  var caseSensitiveTransform = requireCaseSensitiveTransform();
  caseInsensitiveTransform_1 = caseInsensitiveTransform;
  function caseInsensitiveTransform(attributes, property) {
    return caseSensitiveTransform(attributes, property.toLowerCase());
  }
  return caseInsensitiveTransform_1;
}
var xmlns;
var hasRequiredXmlns;
function requireXmlns() {
  if (hasRequiredXmlns) return xmlns;
  hasRequiredXmlns = 1;
  var create = requireCreate();
  var caseInsensitiveTransform = requireCaseInsensitiveTransform();
  xmlns = create({
    space: "xmlns",
    attributes: {
      xmlnsxlink: "xmlns:xlink"
    },
    transform: caseInsensitiveTransform,
    properties: {
      xmlns: null,
      xmlnsXLink: null
    }
  });
  return xmlns;
}
var aria;
var hasRequiredAria;
function requireAria() {
  if (hasRequiredAria) return aria;
  hasRequiredAria = 1;
  var types2 = requireTypes();
  var create = requireCreate();
  var booleanish = types2.booleanish;
  var number2 = types2.number;
  var spaceSeparated = types2.spaceSeparated;
  aria = create({
    transform: ariaTransform,
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: booleanish,
      ariaAutoComplete: null,
      ariaBusy: booleanish,
      ariaChecked: booleanish,
      ariaColCount: number2,
      ariaColIndex: number2,
      ariaColSpan: number2,
      ariaControls: spaceSeparated,
      ariaCurrent: null,
      ariaDescribedBy: spaceSeparated,
      ariaDetails: null,
      ariaDisabled: booleanish,
      ariaDropEffect: spaceSeparated,
      ariaErrorMessage: null,
      ariaExpanded: booleanish,
      ariaFlowTo: spaceSeparated,
      ariaGrabbed: booleanish,
      ariaHasPopup: null,
      ariaHidden: booleanish,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: spaceSeparated,
      ariaLevel: number2,
      ariaLive: null,
      ariaModal: booleanish,
      ariaMultiLine: booleanish,
      ariaMultiSelectable: booleanish,
      ariaOrientation: null,
      ariaOwns: spaceSeparated,
      ariaPlaceholder: null,
      ariaPosInSet: number2,
      ariaPressed: booleanish,
      ariaReadOnly: booleanish,
      ariaRelevant: null,
      ariaRequired: booleanish,
      ariaRoleDescription: spaceSeparated,
      ariaRowCount: number2,
      ariaRowIndex: number2,
      ariaRowSpan: number2,
      ariaSelected: booleanish,
      ariaSetSize: number2,
      ariaSort: null,
      ariaValueMax: number2,
      ariaValueMin: number2,
      ariaValueNow: number2,
      ariaValueText: null,
      role: null
    }
  });
  function ariaTransform(_2, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  }
  return aria;
}
var html;
var hasRequiredHtml$2;
function requireHtml$2() {
  if (hasRequiredHtml$2) return html;
  hasRequiredHtml$2 = 1;
  var types2 = requireTypes();
  var create = requireCreate();
  var caseInsensitiveTransform = requireCaseInsensitiveTransform();
  var boolean = types2.boolean;
  var overloadedBoolean = types2.overloadedBoolean;
  var booleanish = types2.booleanish;
  var number2 = types2.number;
  var spaceSeparated = types2.spaceSeparated;
  var commaSeparated = types2.commaSeparated;
  html = create({
    space: "html",
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    transform: caseInsensitiveTransform,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: commaSeparated,
      acceptCharset: spaceSeparated,
      accessKey: spaceSeparated,
      action: null,
      allow: null,
      allowFullScreen: boolean,
      allowPaymentRequest: boolean,
      allowUserMedia: boolean,
      alt: null,
      as: null,
      async: boolean,
      autoCapitalize: null,
      autoComplete: spaceSeparated,
      autoFocus: boolean,
      autoPlay: boolean,
      capture: boolean,
      charSet: null,
      checked: boolean,
      cite: null,
      className: spaceSeparated,
      cols: number2,
      colSpan: null,
      content: null,
      contentEditable: booleanish,
      controls: boolean,
      controlsList: spaceSeparated,
      coords: number2 | commaSeparated,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: boolean,
      defer: boolean,
      dir: null,
      dirName: null,
      disabled: boolean,
      download: overloadedBoolean,
      draggable: booleanish,
      encType: null,
      enterKeyHint: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: boolean,
      formTarget: null,
      headers: spaceSeparated,
      height: number2,
      hidden: boolean,
      high: number2,
      href: null,
      hrefLang: null,
      htmlFor: spaceSeparated,
      httpEquiv: spaceSeparated,
      id: null,
      imageSizes: null,
      imageSrcSet: commaSeparated,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: boolean,
      itemId: null,
      itemProp: spaceSeparated,
      itemRef: spaceSeparated,
      itemScope: boolean,
      itemType: spaceSeparated,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: boolean,
      low: number2,
      manifest: null,
      max: null,
      maxLength: number2,
      media: null,
      method: null,
      min: null,
      minLength: number2,
      multiple: boolean,
      muted: boolean,
      name: null,
      nonce: null,
      noModule: boolean,
      noValidate: boolean,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforePrint: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextMenu: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: boolean,
      optimum: number2,
      pattern: null,
      ping: spaceSeparated,
      placeholder: null,
      playsInline: boolean,
      poster: null,
      preload: null,
      readOnly: boolean,
      referrerPolicy: null,
      rel: spaceSeparated,
      required: boolean,
      reversed: boolean,
      rows: number2,
      rowSpan: number2,
      sandbox: spaceSeparated,
      scope: null,
      scoped: boolean,
      seamless: boolean,
      selected: boolean,
      shape: null,
      size: number2,
      sizes: null,
      slot: null,
      span: number2,
      spellCheck: booleanish,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: commaSeparated,
      start: number2,
      step: null,
      style: null,
      tabIndex: number2,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: boolean,
      useMap: null,
      value: booleanish,
      width: number2,
      wrap: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: spaceSeparated,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: number2,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: number2,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: boolean,
      // Lists. Use CSS to reduce space between items instead
      declare: boolean,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: number2,
      // `<img>` and `<object>`
      leftMargin: number2,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: number2,
      // `<body>`
      marginWidth: number2,
      // `<body>`
      noResize: boolean,
      // `<frame>`
      noHref: boolean,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: boolean,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: boolean,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: number2,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: booleanish,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: number2,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: number2,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: boolean,
      disableRemotePlayback: boolean,
      prefix: null,
      property: null,
      results: number2,
      security: null,
      unselectable: null
    }
  });
  return html;
}
var html_1$1;
var hasRequiredHtml$1;
function requireHtml$1() {
  if (hasRequiredHtml$1) return html_1$1;
  hasRequiredHtml$1 = 1;
  var merge = requireMerge();
  var xlink2 = requireXlink();
  var xml2 = requireXml();
  var xmlns2 = requireXmlns();
  var aria2 = requireAria();
  var html2 = requireHtml$2();
  html_1$1 = merge([xml2, xlink2, xmlns2, aria2, html2]);
  return html_1$1;
}
var find_1;
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind) return find_1;
  hasRequiredFind = 1;
  var normalize = requireNormalize();
  var DefinedInfo = requireDefinedInfo();
  var Info = requireInfo();
  var data = "data";
  find_1 = find;
  var valid = /^data[-\w.:]+$/i;
  var dash = /-[a-z]/g;
  var cap = /[A-Z]/g;
  function find(schema2, value) {
    var normal = normalize(value);
    var prop = value;
    var Type = Info;
    if (normal in schema2.normal) {
      return schema2.property[schema2.normal[normal]];
    }
    if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
      if (value.charAt(4) === "-") {
        prop = datasetToProperty(value);
      } else {
        value = datasetToAttribute(value);
      }
      Type = DefinedInfo;
    }
    return new Type(prop, value);
  }
  function datasetToProperty(attribute) {
    var value = attribute.slice(5).replace(dash, camelcase);
    return data + value.charAt(0).toUpperCase() + value.slice(1);
  }
  function datasetToAttribute(property) {
    var value = property.slice(4);
    if (dash.test(value)) {
      return property;
    }
    value = value.replace(cap, kebab);
    if (value.charAt(0) !== "-") {
      value = "-" + value;
    }
    return data + value;
  }
  function kebab($0) {
    return "-" + $0.toLowerCase();
  }
  function camelcase($0) {
    return $0.charAt(1).toUpperCase();
  }
  return find_1;
}
var hastUtilParseSelector;
var hasRequiredHastUtilParseSelector;
function requireHastUtilParseSelector() {
  if (hasRequiredHastUtilParseSelector) return hastUtilParseSelector;
  hasRequiredHastUtilParseSelector = 1;
  hastUtilParseSelector = parse2;
  var search = /[#.]/g;
  function parse2(selector, defaultTagName) {
    var value = selector || "";
    var name = defaultTagName || "div";
    var props = {};
    var start = 0;
    var subvalue;
    var previous;
    var match2;
    while (start < value.length) {
      search.lastIndex = start;
      match2 = search.exec(value);
      subvalue = value.slice(start, match2 ? match2.index : value.length);
      if (subvalue) {
        if (!previous) {
          name = subvalue;
        } else if (previous === "#") {
          props.id = subvalue;
        } else if (props.className) {
          props.className.push(subvalue);
        } else {
          props.className = [subvalue];
        }
        start += subvalue.length;
      }
      if (match2) {
        previous = match2[0];
        start++;
      }
    }
    return { type: "element", tagName: name, properties: props, children: [] };
  }
  return hastUtilParseSelector;
}
var spaceSeparatedTokens = {};
var hasRequiredSpaceSeparatedTokens;
function requireSpaceSeparatedTokens() {
  if (hasRequiredSpaceSeparatedTokens) return spaceSeparatedTokens;
  hasRequiredSpaceSeparatedTokens = 1;
  spaceSeparatedTokens.parse = parse2;
  spaceSeparatedTokens.stringify = stringify;
  var empty = "";
  var space = " ";
  var whiteSpace = /[ \t\n\r\f]+/g;
  function parse2(value) {
    var input = String(value || empty).trim();
    return input === empty ? [] : input.split(whiteSpace);
  }
  function stringify(values) {
    return values.join(space).trim();
  }
  return spaceSeparatedTokens;
}
var commaSeparatedTokens = {};
var hasRequiredCommaSeparatedTokens;
function requireCommaSeparatedTokens() {
  if (hasRequiredCommaSeparatedTokens) return commaSeparatedTokens;
  hasRequiredCommaSeparatedTokens = 1;
  commaSeparatedTokens.parse = parse2;
  commaSeparatedTokens.stringify = stringify;
  var comma = ",";
  var space = " ";
  var empty = "";
  function parse2(value) {
    var values = [];
    var input = String(value || empty);
    var index2 = input.indexOf(comma);
    var lastIndex = 0;
    var end = false;
    var val;
    while (!end) {
      if (index2 === -1) {
        index2 = input.length;
        end = true;
      }
      val = input.slice(lastIndex, index2).trim();
      if (val || !end) {
        values.push(val);
      }
      lastIndex = index2 + 1;
      index2 = input.indexOf(comma, lastIndex);
    }
    return values;
  }
  function stringify(values, options) {
    var settings = options || {};
    var left = settings.padLeft === false ? empty : space;
    var right = settings.padRight ? space : empty;
    if (values[values.length - 1] === empty) {
      values = values.concat(empty);
    }
    return values.join(right + comma + left).trim();
  }
  return commaSeparatedTokens;
}
var factory_1;
var hasRequiredFactory;
function requireFactory() {
  if (hasRequiredFactory) return factory_1;
  hasRequiredFactory = 1;
  var find = requireFind();
  var normalize = requireNormalize();
  var parseSelector = requireHastUtilParseSelector();
  var spaces = requireSpaceSeparatedTokens().parse;
  var commas = requireCommaSeparatedTokens().parse;
  factory_1 = factory;
  var own = {}.hasOwnProperty;
  function factory(schema2, defaultTagName, caseSensitive) {
    var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;
    return h2;
    function h2(selector, properties) {
      var node = parseSelector(selector, defaultTagName);
      var children = Array.prototype.slice.call(arguments, 2);
      var name = node.tagName.toLowerCase();
      var property;
      node.tagName = adjust && own.call(adjust, name) ? adjust[name] : name;
      if (properties && isChildren(properties, node)) {
        children.unshift(properties);
        properties = null;
      }
      if (properties) {
        for (property in properties) {
          addProperty(node.properties, property, properties[property]);
        }
      }
      addChild(node.children, children);
      if (node.tagName === "template") {
        node.content = { type: "root", children: node.children };
        node.children = [];
      }
      return node;
    }
    function addProperty(properties, key, value) {
      var info2;
      var property;
      var result;
      if (value === null || value === void 0 || value !== value) {
        return;
      }
      info2 = find(schema2, key);
      property = info2.property;
      result = value;
      if (typeof result === "string") {
        if (info2.spaceSeparated) {
          result = spaces(result);
        } else if (info2.commaSeparated) {
          result = commas(result);
        } else if (info2.commaOrSpaceSeparated) {
          result = spaces(commas(result).join(" "));
        }
      }
      if (property === "style" && typeof value !== "string") {
        result = style(result);
      }
      if (property === "className" && properties.className) {
        result = properties.className.concat(result);
      }
      properties[property] = parsePrimitives(info2, property, result);
    }
  }
  function isChildren(value, node) {
    return typeof value === "string" || "length" in value || isNode2(node.tagName, value);
  }
  function isNode2(tagName, value) {
    var type = value.type;
    if (tagName === "input" || !type || typeof type !== "string") {
      return false;
    }
    if (typeof value.children === "object" && "length" in value.children) {
      return true;
    }
    type = type.toLowerCase();
    if (tagName === "button") {
      return type !== "menu" && type !== "submit" && type !== "reset" && type !== "button";
    }
    return "value" in value;
  }
  function addChild(nodes, value) {
    var index2;
    var length;
    if (typeof value === "string" || typeof value === "number") {
      nodes.push({ type: "text", value: String(value) });
      return;
    }
    if (typeof value === "object" && "length" in value) {
      index2 = -1;
      length = value.length;
      while (++index2 < length) {
        addChild(nodes, value[index2]);
      }
      return;
    }
    if (typeof value !== "object" || !("type" in value)) {
      throw new Error("Expected node, nodes, or string, got `" + value + "`");
    }
    nodes.push(value);
  }
  function parsePrimitives(info2, name, value) {
    var index2;
    var length;
    var result;
    if (typeof value !== "object" || !("length" in value)) {
      return parsePrimitive(info2, name, value);
    }
    length = value.length;
    index2 = -1;
    result = [];
    while (++index2 < length) {
      result[index2] = parsePrimitive(info2, name, value[index2]);
    }
    return result;
  }
  function parsePrimitive(info2, name, value) {
    var result = value;
    if (info2.number || info2.positiveNumber) {
      if (!isNaN(result) && result !== "") {
        result = Number(result);
      }
    } else if (info2.boolean || info2.overloadedBoolean) {
      if (typeof result === "string" && (result === "" || normalize(value) === normalize(name))) {
        result = true;
      }
    }
    return result;
  }
  function style(value) {
    var result = [];
    var key;
    for (key in value) {
      result.push([key, value[key]].join(": "));
    }
    return result.join("; ");
  }
  function createAdjustMap(values) {
    var length = values.length;
    var index2 = -1;
    var result = {};
    var value;
    while (++index2 < length) {
      value = values[index2];
      result[value.toLowerCase()] = value;
    }
    return result;
  }
  return factory_1;
}
var html_1;
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html_1;
  hasRequiredHtml = 1;
  var schema2 = requireHtml$1();
  var factory = requireFactory();
  var html2 = factory(schema2, "div");
  html2.displayName = "html";
  html_1 = html2;
  return html_1;
}
var hastscript;
var hasRequiredHastscript;
function requireHastscript() {
  if (hasRequiredHastscript) return hastscript;
  hasRequiredHastscript = 1;
  hastscript = requireHtml();
  return hastscript;
}
const AElig = "Æ";
const AMP = "&";
const Aacute = "Á";
const Acirc = "Â";
const Agrave = "À";
const Aring = "Å";
const Atilde = "Ã";
const Auml = "Ä";
const COPY = "©";
const Ccedil = "Ç";
const ETH = "Ð";
const Eacute = "É";
const Ecirc = "Ê";
const Egrave = "È";
const Euml = "Ë";
const GT = ">";
const Iacute = "Í";
const Icirc = "Î";
const Igrave = "Ì";
const Iuml = "Ï";
const LT = "<";
const Ntilde = "Ñ";
const Oacute = "Ó";
const Ocirc = "Ô";
const Ograve = "Ò";
const Oslash = "Ø";
const Otilde = "Õ";
const Ouml = "Ö";
const QUOT = '"';
const REG = "®";
const THORN = "Þ";
const Uacute = "Ú";
const Ucirc = "Û";
const Ugrave = "Ù";
const Uuml = "Ü";
const Yacute = "Ý";
const aacute = "á";
const acirc = "â";
const acute = "´";
const aelig = "æ";
const agrave = "à";
const amp = "&";
const aring = "å";
const atilde = "ã";
const auml = "ä";
const brvbar = "¦";
const ccedil = "ç";
const cedil = "¸";
const cent = "¢";
const copy = "©";
const curren = "¤";
const deg = "°";
const divide = "÷";
const eacute = "é";
const ecirc = "ê";
const egrave = "è";
const eth = "ð";
const euml = "ë";
const frac12 = "½";
const frac14 = "¼";
const frac34 = "¾";
const gt = ">";
const iacute = "í";
const icirc = "î";
const iexcl = "¡";
const igrave = "ì";
const iquest = "¿";
const iuml = "ï";
const laquo = "«";
const lt = "<";
const macr = "¯";
const micro = "µ";
const middot = "·";
const nbsp = " ";
const not = "¬";
const ntilde = "ñ";
const oacute = "ó";
const ocirc = "ô";
const ograve = "ò";
const ordf = "ª";
const ordm = "º";
const oslash = "ø";
const otilde = "õ";
const ouml = "ö";
const para = "¶";
const plusmn = "±";
const pound = "£";
const quot = '"';
const raquo = "»";
const reg = "®";
const sect = "§";
const shy = "­";
const sup1 = "¹";
const sup2 = "²";
const sup3 = "³";
const szlig = "ß";
const thorn = "þ";
const times = "×";
const uacute = "ú";
const ucirc = "û";
const ugrave = "ù";
const uml = "¨";
const uuml = "ü";
const yacute = "ý";
const yen = "¥";
const yuml = "ÿ";
const require$$0 = {
  AElig,
  AMP,
  Aacute,
  Acirc,
  Agrave,
  Aring,
  Atilde,
  Auml,
  COPY,
  Ccedil,
  ETH,
  Eacute,
  Ecirc,
  Egrave,
  Euml,
  GT,
  Iacute,
  Icirc,
  Igrave,
  Iuml,
  LT,
  Ntilde,
  Oacute,
  Ocirc,
  Ograve,
  Oslash,
  Otilde,
  Ouml,
  QUOT,
  REG,
  THORN,
  Uacute,
  Ucirc,
  Ugrave,
  Uuml,
  Yacute,
  aacute,
  acirc,
  acute,
  aelig,
  agrave,
  amp,
  aring,
  atilde,
  auml,
  brvbar,
  ccedil,
  cedil,
  cent,
  copy,
  curren,
  deg,
  divide,
  eacute,
  ecirc,
  egrave,
  eth,
  euml,
  frac12,
  frac14,
  frac34,
  gt,
  iacute,
  icirc,
  iexcl,
  igrave,
  iquest,
  iuml,
  laquo,
  lt,
  macr,
  micro,
  middot,
  nbsp,
  not,
  ntilde,
  oacute,
  ocirc,
  ograve,
  ordf,
  ordm,
  oslash,
  otilde,
  ouml,
  para,
  plusmn,
  pound,
  quot,
  raquo,
  reg,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  thorn,
  times,
  uacute,
  ucirc,
  ugrave,
  uml,
  uuml,
  yacute,
  yen,
  yuml
};
const require$$1$1 = {
  "0": "�",
  "128": "€",
  "130": "‚",
  "131": "ƒ",
  "132": "„",
  "133": "…",
  "134": "†",
  "135": "‡",
  "136": "ˆ",
  "137": "‰",
  "138": "Š",
  "139": "‹",
  "140": "Œ",
  "142": "Ž",
  "145": "‘",
  "146": "’",
  "147": "“",
  "148": "”",
  "149": "•",
  "150": "–",
  "151": "—",
  "152": "˜",
  "153": "™",
  "154": "š",
  "155": "›",
  "156": "œ",
  "158": "ž",
  "159": "Ÿ"
};
var isDecimal;
var hasRequiredIsDecimal;
function requireIsDecimal() {
  if (hasRequiredIsDecimal) return isDecimal;
  hasRequiredIsDecimal = 1;
  isDecimal = decimal;
  function decimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 48 && code <= 57;
  }
  return isDecimal;
}
var isHexadecimal;
var hasRequiredIsHexadecimal;
function requireIsHexadecimal() {
  if (hasRequiredIsHexadecimal) return isHexadecimal;
  hasRequiredIsHexadecimal = 1;
  isHexadecimal = hexadecimal;
  function hexadecimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
  }
  return isHexadecimal;
}
var isAlphabetical;
var hasRequiredIsAlphabetical;
function requireIsAlphabetical() {
  if (hasRequiredIsAlphabetical) return isAlphabetical;
  hasRequiredIsAlphabetical = 1;
  isAlphabetical = alphabetical;
  function alphabetical(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
  }
  return isAlphabetical;
}
var isAlphanumerical;
var hasRequiredIsAlphanumerical;
function requireIsAlphanumerical() {
  if (hasRequiredIsAlphanumerical) return isAlphanumerical;
  hasRequiredIsAlphanumerical = 1;
  var alphabetical = requireIsAlphabetical();
  var decimal = requireIsDecimal();
  isAlphanumerical = alphanumerical;
  function alphanumerical(character) {
    return alphabetical(character) || decimal(character);
  }
  return isAlphanumerical;
}
var decodeEntity_browser;
var hasRequiredDecodeEntity_browser;
function requireDecodeEntity_browser() {
  if (hasRequiredDecodeEntity_browser) return decodeEntity_browser;
  hasRequiredDecodeEntity_browser = 1;
  var el;
  var semicolon = 59;
  decodeEntity_browser = decodeEntity;
  function decodeEntity(characters) {
    var entity = "&" + characters + ";";
    var char;
    el = el || document.createElement("i");
    el.innerHTML = entity;
    char = el.textContent;
    if (char.charCodeAt(char.length - 1) === semicolon && characters !== "semi") {
      return false;
    }
    return char === entity ? false : char;
  }
  return decodeEntity_browser;
}
var parseEntities_1;
var hasRequiredParseEntities;
function requireParseEntities() {
  if (hasRequiredParseEntities) return parseEntities_1;
  hasRequiredParseEntities = 1;
  var legacy = require$$0;
  var invalid = require$$1$1;
  var decimal = requireIsDecimal();
  var hexadecimal = requireIsHexadecimal();
  var alphanumerical = requireIsAlphanumerical();
  var decodeEntity = requireDecodeEntity_browser();
  parseEntities_1 = parseEntities;
  var own = {}.hasOwnProperty;
  var fromCharCode = String.fromCharCode;
  var noop3 = Function.prototype;
  var defaults = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: false,
    nonTerminated: true
  };
  var tab = 9;
  var lineFeed = 10;
  var formFeed = 12;
  var space = 32;
  var ampersand = 38;
  var semicolon = 59;
  var lessThan = 60;
  var equalsTo = 61;
  var numberSign = 35;
  var uppercaseX = 88;
  var lowercaseX = 120;
  var replacementCharacter = 65533;
  var name = "named";
  var hexa = "hexadecimal";
  var deci = "decimal";
  var bases = {};
  bases[hexa] = 16;
  bases[deci] = 10;
  var tests = {};
  tests[name] = alphanumerical;
  tests[deci] = decimal;
  tests[hexa] = hexadecimal;
  var namedNotTerminated = 1;
  var numericNotTerminated = 2;
  var namedEmpty = 3;
  var numericEmpty = 4;
  var namedUnknown = 5;
  var numericDisallowed = 6;
  var numericProhibited = 7;
  var messages = {};
  messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
  messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
  messages[namedEmpty] = "Named character references cannot be empty";
  messages[numericEmpty] = "Numeric character references cannot be empty";
  messages[namedUnknown] = "Named character references must be known";
  messages[numericDisallowed] = "Numeric character references cannot be disallowed";
  messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
  function parseEntities(value, options) {
    var settings = {};
    var option;
    var key;
    if (!options) {
      options = {};
    }
    for (key in defaults) {
      option = options[key];
      settings[key] = option === null || option === void 0 ? defaults[key] : option;
    }
    if (settings.position.indent || settings.position.start) {
      settings.indent = settings.position.indent || [];
      settings.position = settings.position.start;
    }
    return parse2(value, settings);
  }
  function parse2(value, settings) {
    var additional = settings.additional;
    var nonTerminated = settings.nonTerminated;
    var handleText = settings.text;
    var handleReference = settings.reference;
    var handleWarning = settings.warning;
    var textContext = settings.textContext;
    var referenceContext = settings.referenceContext;
    var warningContext = settings.warningContext;
    var pos = settings.position;
    var indent = settings.indent || [];
    var length = value.length;
    var index2 = 0;
    var lines = -1;
    var column = pos.column || 1;
    var line = pos.line || 1;
    var queue = "";
    var result = [];
    var entityCharacters;
    var namedEntity;
    var terminated;
    var characters;
    var character;
    var reference;
    var following;
    var warning2;
    var reason;
    var output;
    var entity;
    var begin;
    var start;
    var type;
    var test2;
    var prev;
    var next;
    var diff;
    var end;
    if (typeof additional === "string") {
      additional = additional.charCodeAt(0);
    }
    prev = now2();
    warning2 = handleWarning ? parseError : noop3;
    index2--;
    length++;
    while (++index2 < length) {
      if (character === lineFeed) {
        column = indent[lines] || 1;
      }
      character = value.charCodeAt(index2);
      if (character === ampersand) {
        following = value.charCodeAt(index2 + 1);
        if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
          queue += fromCharCode(character);
          column++;
          continue;
        }
        start = index2 + 1;
        begin = start;
        end = start;
        if (following === numberSign) {
          end = ++begin;
          following = value.charCodeAt(end);
          if (following === uppercaseX || following === lowercaseX) {
            type = hexa;
            end = ++begin;
          } else {
            type = deci;
          }
        } else {
          type = name;
        }
        entityCharacters = "";
        entity = "";
        characters = "";
        test2 = tests[type];
        end--;
        while (++end < length) {
          following = value.charCodeAt(end);
          if (!test2(following)) {
            break;
          }
          characters += fromCharCode(following);
          if (type === name && own.call(legacy, characters)) {
            entityCharacters = characters;
            entity = legacy[characters];
          }
        }
        terminated = value.charCodeAt(end) === semicolon;
        if (terminated) {
          end++;
          namedEntity = type === name ? decodeEntity(characters) : false;
          if (namedEntity) {
            entityCharacters = characters;
            entity = namedEntity;
          }
        }
        diff = 1 + end - start;
        if (!terminated && !nonTerminated) ;
        else if (!characters) {
          if (type !== name) {
            warning2(numericEmpty, diff);
          }
        } else if (type === name) {
          if (terminated && !entity) {
            warning2(namedUnknown, 1);
          } else {
            if (entityCharacters !== characters) {
              end = begin + entityCharacters.length;
              diff = 1 + end - begin;
              terminated = false;
            }
            if (!terminated) {
              reason = entityCharacters ? namedNotTerminated : namedEmpty;
              if (settings.attribute) {
                following = value.charCodeAt(end);
                if (following === equalsTo) {
                  warning2(reason, diff);
                  entity = null;
                } else if (alphanumerical(following)) {
                  entity = null;
                } else {
                  warning2(reason, diff);
                }
              } else {
                warning2(reason, diff);
              }
            }
          }
          reference = entity;
        } else {
          if (!terminated) {
            warning2(numericNotTerminated, diff);
          }
          reference = parseInt(characters, bases[type]);
          if (prohibited(reference)) {
            warning2(numericProhibited, diff);
            reference = fromCharCode(replacementCharacter);
          } else if (reference in invalid) {
            warning2(numericDisallowed, diff);
            reference = invalid[reference];
          } else {
            output = "";
            if (disallowed(reference)) {
              warning2(numericDisallowed, diff);
            }
            if (reference > 65535) {
              reference -= 65536;
              output += fromCharCode(reference >>> (10 & 1023) | 55296);
              reference = 56320 | reference & 1023;
            }
            reference = output + fromCharCode(reference);
          }
        }
        if (reference) {
          flush();
          prev = now2();
          index2 = end - 1;
          column += end - start + 1;
          result.push(reference);
          next = now2();
          next.offset++;
          if (handleReference) {
            handleReference.call(
              referenceContext,
              reference,
              { start: prev, end: next },
              value.slice(start - 1, end)
            );
          }
          prev = next;
        } else {
          characters = value.slice(start - 1, end);
          queue += characters;
          column += characters.length;
          index2 = end - 1;
        }
      } else {
        if (character === 10) {
          line++;
          lines++;
          column = 0;
        }
        if (character === character) {
          queue += fromCharCode(character);
          column++;
        } else {
          flush();
        }
      }
    }
    return result.join("");
    function now2() {
      return {
        line,
        column,
        offset: index2 + (pos.offset || 0)
      };
    }
    function parseError(code, offset2) {
      var position = now2();
      position.column += offset2;
      position.offset += offset2;
      handleWarning.call(warningContext, messages[code], position, code);
    }
    function flush() {
      if (queue) {
        result.push(queue);
        if (handleText) {
          handleText.call(textContext, queue, { start: prev, end: now2() });
        }
        queue = "";
      }
    }
  }
  function prohibited(code) {
    return code >= 55296 && code <= 57343 || code > 1114111;
  }
  function disallowed(code) {
    return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
  }
  return parseEntities_1;
}
var prismCore = { exports: {} };
var hasRequiredPrismCore;
function requirePrismCore() {
  if (hasRequiredPrismCore) return prismCore.exports;
  hasRequiredPrismCore = 1;
  (function(module) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    /**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     */
    var Prism = (function(_self2) {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _2 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o4) {
            return Object.prototype.toString.call(o4).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o4, visited) {
            visited = visited || {};
            var clone;
            var id2;
            switch (_2.util.type(o4)) {
              case "Object":
                id2 = _2.util.objId(o4);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id2] = clone;
                for (var key in o4) {
                  if (o4.hasOwnProperty(key)) {
                    clone[key] = deepClone(o4[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id2 = _2.util.objId(o4);
                if (visited[id2]) {
                  return visited[id2];
                }
                clone = [];
                visited[id2] = clone;
                /** @type {Array} */
                /** @type {any} */
                o4.forEach(function(v2, i2) {
                  clone[i2] = deepClone(v2, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o4;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m2 = lang.exec(element.className);
              if (m2) {
                return m2[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i2 in scripts) {
                  if (scripts[i2].src == src) {
                    return scripts[i2];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id2, redef) {
            var lang2 = _2.util.clone(_2.languages[id2]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _2.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _2.languages.DFS(_2.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o4, callback, type, visited) {
            visited = visited || {};
            var objId = _2.util.objId;
            for (var i2 in o4) {
              if (o4.hasOwnProperty(i2)) {
                callback.call(o4, i2, o4[i2], type || i2);
                var property = o4[i2];
                var propertyType = _2.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i2, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _2.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _2.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _2.hooks.run("before-all-elements-highlight", env);
          for (var i2 = 0, element; element = env.elements[i2++]; ) {
            _2.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _2.util.getLanguage(element);
          var grammar = _2.languages[language];
          _2.util.setLanguage(element, language);
          var parent = element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre") {
            _2.util.setLanguage(parent, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _2.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _2.hooks.run("after-highlight", env);
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _2.hooks.run("before-sanity-check", env);
          parent = env.element.parentElement;
          if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
            parent.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _2.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _2.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_2.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_2.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _2.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _2.tokenize(env.code, env.grammar);
          _2.hooks.run("after-tokenize", env);
          return Token.stringify(_2.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks = _2.hooks.all;
            hooks[name] = hooks[name] || [];
            hooks[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env) {
            var callbacks = _2.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i2 = 0, callback; callback = callbacks[i2++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      _self2.Prism = _2;
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o4, language) {
        if (typeof o4 == "string") {
          return o4;
        }
        if (Array.isArray(o4)) {
          var s2 = "";
          o4.forEach(function(e2) {
            s2 += stringify(e2, language);
          });
          return s2;
        }
        var env = {
          type: o4.type,
          content: stringify(o4.content, language),
          tag: "span",
          classes: ["token", o4.type],
          attributes: {},
          language
        };
        var aliases = o4.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _2.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match2 = pattern.exec(text);
        if (match2 && lookbehind && match2[1]) {
          var lookbehindLength = match2[1].length;
          match2.index += lookbehindLength;
          match2[0] = match2[0].slice(lookbehindLength);
        }
        return match2;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j2 = 0; j2 < patterns.length; ++j2) {
            if (rematch && rematch.cause == token + "," + j2) {
              return;
            }
            var patternObj = patterns[j2];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match2;
              if (greedy) {
                match2 = matchPattern(pattern, pos, text, lookbehind);
                if (!match2 || match2.index >= text.length) {
                  break;
                }
                var from = match2.index;
                var to = match2.index + match2[0].length;
                var p2 = pos;
                p2 += currentNode.value.length;
                while (from >= p2) {
                  currentNode = currentNode.next;
                  p2 += currentNode.value.length;
                }
                p2 -= currentNode.value.length;
                pos = p2;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to || typeof k2.value === "string"); k2 = k2.next) {
                  removeCount++;
                  p2 += k2.value.length;
                }
                removeCount--;
                str = text.slice(pos, p2);
                match2.index -= pos;
              } else {
                match2 = matchPattern(pattern, 0, str, lookbehind);
                if (!match2) {
                  continue;
                }
              }
              var from = match2.index;
              var matchStr = match2[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _2.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j2,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count2) {
        var next = node.next;
        for (var i2 = 0; i2 < count2 && next !== list.tail; i2++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i2;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _2;
        }
        if (!_2.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message2 = JSON.parse(evt.data);
            var lang2 = message2.language;
            var code = message2.code;
            var immediateClose = message2.immediateClose;
            _self2.postMessage(_2.highlight(code, _2.languages[lang2], lang2));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _2;
      }
      var script = _2.util.currentScript();
      if (script) {
        _2.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _2.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_2.manual) {
          _2.highlightAll();
        }
      }
      if (!_2.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _2;
    })(_self);
    if (module.exports) {
      module.exports = Prism;
    }
    if (typeof commonjsGlobal !== "undefined") {
      commonjsGlobal.Prism = Prism;
    }
  })(prismCore);
  return prismCore.exports;
}
var markup_1;
var hasRequiredMarkup;
function requireMarkup() {
  if (hasRequiredMarkup) return markup_1;
  hasRequiredMarkup = 1;
  markup_1 = markup;
  markup.displayName = "markup";
  markup.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
  function markup(Prism) {
    Prism.languages.markup = {
      comment: {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      prolog: {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      doctype: {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          string: {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          punctuation: /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          name: /[^\s<>'"]+/
        }
      },
      cdata: {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      tag: {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          tag: {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              punctuation: /^<\/?/,
              namespace: /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          },
          punctuation: /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              namespace: /^[^\s>\/:]+:/
            }
          }
        }
      },
      entity: [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
    Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
    Prism.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.value.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang] = {
          pattern: /[\s\S]+/,
          inside: Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(
            /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
              /__/g,
              function() {
                return tagName;
              }
            ),
            "i"
          ),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang) {
        Prism.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                value: {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang, "language-" + lang],
                  inside: Prism.languages[lang]
                },
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism.languages.html = Prism.languages.markup;
    Prism.languages.mathml = Prism.languages.markup;
    Prism.languages.svg = Prism.languages.markup;
    Prism.languages.xml = Prism.languages.extend("markup", {});
    Prism.languages.ssml = Prism.languages.xml;
    Prism.languages.atom = Prism.languages.xml;
    Prism.languages.rss = Prism.languages.xml;
  }
  return markup_1;
}
var css_1;
var hasRequiredCss;
function requireCss() {
  if (hasRequiredCss) return css_1;
  hasRequiredCss = 1;
  css_1 = css;
  css.displayName = "css";
  css.aliases = [];
  function css(Prism) {
    (function(Prism2) {
      var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism2.languages.css = {
        comment: /\/\*[\s\S]*?\*\//,
        atrule: {
          pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
          inside: {
            rule: /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            keyword: {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        url: {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp(
            "\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
            "i"
          ),
          greedy: true,
          inside: {
            function: /^url/i,
            punctuation: /^\(|\)$/,
            string: {
              pattern: RegExp("^" + string.source + "$"),
              alias: "url"
            }
          }
        },
        selector: {
          pattern: RegExp(
            `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"
          ),
          lookbehind: true
        },
        string: {
          pattern: string,
          greedy: true
        },
        property: {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        important: /!important\b/i,
        function: {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        punctuation: /[(){};:,]/
      };
      Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
      var markup = Prism2.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism);
  }
  return css_1;
}
var clike_1;
var hasRequiredClike;
function requireClike() {
  if (hasRequiredClike) return clike_1;
  hasRequiredClike = 1;
  clike_1 = clike;
  clike.displayName = "clike";
  clike.aliases = [];
  function clike(Prism) {
    Prism.languages.clike = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          punctuation: /[.\\]/
        }
      },
      keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b\w+(?=\()/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return clike_1;
}
var javascript_1;
var hasRequiredJavascript;
function requireJavascript() {
  if (hasRequiredJavascript) return javascript_1;
  hasRequiredJavascript = 1;
  javascript_1 = javascript;
  javascript.displayName = "javascript";
  javascript.aliases = ["js"];
  function javascript(Prism) {
    Prism.languages.javascript = Prism.languages.extend("clike", {
      "class-name": [
        Prism.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      keyword: [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      number: {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism.languages.insertBefore("javascript", "keyword", {
      regex: {
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      parameter: [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism.languages.javascript
        }
      ],
      constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism.languages.insertBefore("javascript", "string", {
      hashbang: {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism.languages.javascript
            }
          },
          string: /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism.languages.markup) {
      Prism.languages.markup.tag.addInlined("script", "javascript");
      Prism.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism.languages.js = Prism.languages.javascript;
  }
  return javascript_1;
}
var core;
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  var ctx = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof commonjsGlobal === "object" ? commonjsGlobal : {};
  var restore = capture();
  ctx.Prism = { manual: true, disableWorkerMessageHandler: true };
  var h2 = requireHastscript();
  var decode = requireParseEntities();
  var Prism = requirePrismCore();
  var markup = requireMarkup();
  var css = requireCss();
  var clike = requireClike();
  var js = requireJavascript();
  restore();
  var own = {}.hasOwnProperty;
  function Refractor() {
  }
  Refractor.prototype = Prism;
  var refract = new Refractor();
  core = refract;
  refract.highlight = highlight2;
  refract.register = register;
  refract.alias = alias;
  refract.registered = registered;
  refract.listLanguages = listLanguages;
  register(markup);
  register(css);
  register(clike);
  register(js);
  refract.util.encode = encode;
  refract.Token.stringify = stringify;
  function register(grammar) {
    if (typeof grammar !== "function" || !grammar.displayName) {
      throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
    }
    if (refract.languages[grammar.displayName] === void 0) {
      grammar(refract);
    }
  }
  function alias(name, alias2) {
    var languages = refract.languages;
    var map = name;
    var key;
    var list;
    var length;
    var index2;
    if (alias2) {
      map = {};
      map[name] = alias2;
    }
    for (key in map) {
      list = map[key];
      list = typeof list === "string" ? [list] : list;
      length = list.length;
      index2 = -1;
      while (++index2 < length) {
        languages[list[index2]] = languages[key];
      }
    }
  }
  function highlight2(value, name) {
    var sup = Prism.highlight;
    var grammar;
    if (typeof value !== "string") {
      throw new Error("Expected `string` for `value`, got `" + value + "`");
    }
    if (refract.util.type(name) === "Object") {
      grammar = name;
      name = null;
    } else {
      if (typeof name !== "string") {
        throw new Error("Expected `string` for `name`, got `" + name + "`");
      }
      if (own.call(refract.languages, name)) {
        grammar = refract.languages[name];
      } else {
        throw new Error("Unknown language: `" + name + "` is not registered");
      }
    }
    return sup.call(this, value, grammar, name);
  }
  function registered(language) {
    if (typeof language !== "string") {
      throw new Error("Expected `string` for `language`, got `" + language + "`");
    }
    return own.call(refract.languages, language);
  }
  function listLanguages() {
    var languages = refract.languages;
    var list = [];
    var language;
    for (language in languages) {
      if (own.call(languages, language) && typeof languages[language] === "object") {
        list.push(language);
      }
    }
    return list;
  }
  function stringify(value, language, parent) {
    var env;
    if (typeof value === "string") {
      return { type: "text", value };
    }
    if (refract.util.type(value) === "Array") {
      return stringifyAll(value, language);
    }
    env = {
      type: value.type,
      content: refract.Token.stringify(value.content, language, parent),
      tag: "span",
      classes: ["token", value.type],
      attributes: {},
      language,
      parent
    };
    if (value.alias) {
      env.classes = env.classes.concat(value.alias);
    }
    refract.hooks.run("wrap", env);
    return h2(
      env.tag + "." + env.classes.join("."),
      attributes(env.attributes),
      env.content
    );
  }
  function stringifyAll(values, language) {
    var result = [];
    var length = values.length;
    var index2 = -1;
    var value;
    while (++index2 < length) {
      value = values[index2];
      if (value !== "" && value !== null && value !== void 0) {
        result.push(value);
      }
    }
    index2 = -1;
    length = result.length;
    while (++index2 < length) {
      value = result[index2];
      result[index2] = refract.Token.stringify(value, language, result);
    }
    return result;
  }
  function encode(tokens) {
    return tokens;
  }
  function attributes(attrs) {
    var key;
    for (key in attrs) {
      attrs[key] = decode(attrs[key]);
    }
    return attrs;
  }
  function capture() {
    var defined = "Prism" in ctx;
    var current = defined ? ctx.Prism : void 0;
    return restore2;
    function restore2() {
      if (defined) {
        ctx.Prism = current;
      } else {
        delete ctx.Prism;
      }
      defined = void 0;
      current = void 0;
    }
  }
  return core;
}
const defaultStyle = {
  'code[class*="language-"]': {
    "color": "black",
    "background": "none",
    "textShadow": "0 1px white",
    "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    "fontSize": "1em",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "wordWrap": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none"
  },
  'pre[class*="language-"]': {
    "color": "black",
    "background": "#f5f2f0",
    "textShadow": "0 1px white",
    "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
    "fontSize": "1em",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "wordWrap": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none",
    "padding": "1em",
    "margin": ".5em 0",
    "overflow": "auto"
  },
  'pre[class*="language-"]::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"] ::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"]::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"] ::-moz-selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"]::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'pre[class*="language-"] ::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"]::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  'code[class*="language-"] ::selection': {
    "textShadow": "none",
    "background": "#b3d4fc"
  },
  ':not(pre) > code[class*="language-"]': {
    "background": "#f5f2f0",
    "padding": ".1em",
    "borderRadius": ".3em",
    "whiteSpace": "normal"
  },
  "comment": {
    "color": "slategray"
  },
  "prolog": {
    "color": "slategray"
  },
  "doctype": {
    "color": "slategray"
  },
  "cdata": {
    "color": "slategray"
  },
  "punctuation": {
    "color": "#999"
  },
  "namespace": {
    "Opacity": ".7"
  },
  "property": {
    "color": "#905"
  },
  "tag": {
    "color": "#905"
  },
  "boolean": {
    "color": "#905"
  },
  "number": {
    "color": "#905"
  },
  "constant": {
    "color": "#905"
  },
  "symbol": {
    "color": "#905"
  },
  "deleted": {
    "color": "#905"
  },
  "selector": {
    "color": "#690"
  },
  "attr-name": {
    "color": "#690"
  },
  "string": {
    "color": "#690"
  },
  "char": {
    "color": "#690"
  },
  "builtin": {
    "color": "#690"
  },
  "inserted": {
    "color": "#690"
  },
  "operator": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  "entity": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)",
    "cursor": "help"
  },
  "url": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  ".language-css .token.string": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  ".style .token.string": {
    "color": "#9a6e3a",
    "background": "hsla(0, 0%, 100%, .5)"
  },
  "atrule": {
    "color": "#07a"
  },
  "attr-value": {
    "color": "#07a"
  },
  "keyword": {
    "color": "#07a"
  },
  "function": {
    "color": "#DD4A68"
  },
  "class-name": {
    "color": "#DD4A68"
  },
  "regex": {
    "color": "#e90"
  },
  "important": {
    "color": "#e90",
    "fontWeight": "bold"
  },
  "variable": {
    "color": "#e90"
  },
  "bold": {
    "fontWeight": "bold"
  },
  "italic": {
    "fontStyle": "italic"
  }
};
var abap_1;
var hasRequiredAbap;
function requireAbap() {
  if (hasRequiredAbap) return abap_1;
  hasRequiredAbap = 1;
  abap_1 = abap;
  abap.displayName = "abap";
  abap.aliases = [];
  function abap(Prism) {
    Prism.languages.abap = {
      comment: /^\*.*/m,
      string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      "string-template": {
        pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
        lookbehind: true,
        alias: "string"
      },
      /* End Of Line comments should not interfere with strings when the
      quote character occurs within them. We assume a string being highlighted
      inside an EOL comment is more acceptable than the opposite.
      */
      "eol-comment": {
        pattern: /(^|\s)".*/m,
        lookbehind: true,
        alias: "comment"
      },
      keyword: {
        pattern: /(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,
        lookbehind: true
      },
      /* Numbers can be only integers. Decimal or Hex appear only as strings */
      number: /\b\d+\b/,
      /* Operators must always be surrounded by whitespace, they cannot be put
      adjacent to operands.
      */
      operator: {
        pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
        lookbehind: true
      },
      "string-operator": {
        pattern: /(\s)&&?(?=\s)/,
        lookbehind: true,
        /* The official editor highlights */
        alias: "keyword"
      },
      "token-operator": [
        {
          /* Special operators used to access structure components, class methods/attributes, etc. */
          pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
          lookbehind: true,
          alias: "punctuation"
        },
        {
          /* Special tokens used do delimit string templates */
          pattern: /[|{}]/,
          alias: "punctuation"
        }
      ],
      punctuation: /[,.:()]/
    };
  }
  return abap_1;
}
var abnf_1;
var hasRequiredAbnf;
function requireAbnf() {
  if (hasRequiredAbnf) return abnf_1;
  hasRequiredAbnf = 1;
  abnf_1 = abnf;
  abnf.displayName = "abnf";
  abnf.aliases = [];
  function abnf(Prism) {
    (function(Prism2) {
      var coreRules = "(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)";
      Prism2.languages.abnf = {
        comment: /;.*/,
        string: {
          pattern: /(?:%[is])?"[^"\n\r]*"/,
          greedy: true,
          inside: {
            punctuation: /^%[is]/
          }
        },
        range: {
          pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
          alias: "number"
        },
        terminal: {
          pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
          alias: "number"
        },
        repetition: {
          pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
          lookbehind: true,
          alias: "operator"
        },
        definition: {
          pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
          lookbehind: true,
          alias: "keyword",
          inside: {
            punctuation: /<|>/
          }
        },
        "core-rule": {
          pattern: RegExp(
            "(?:(^|[^<\\w-])" + coreRules + "|<" + coreRules + ">)(?![\\w-])",
            "i"
          ),
          lookbehind: true,
          alias: ["rule", "constant"],
          inside: {
            punctuation: /<|>/
          }
        },
        rule: {
          pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
          lookbehind: true,
          inside: {
            punctuation: /<|>/
          }
        },
        operator: /=\/?|\//,
        punctuation: /[()\[\]]/
      };
    })(Prism);
  }
  return abnf_1;
}
var actionscript_1;
var hasRequiredActionscript;
function requireActionscript() {
  if (hasRequiredActionscript) return actionscript_1;
  hasRequiredActionscript = 1;
  actionscript_1 = actionscript;
  actionscript.displayName = "actionscript";
  actionscript.aliases = [];
  function actionscript(Prism) {
    Prism.languages.actionscript = Prism.languages.extend("javascript", {
      keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
      operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
    });
    Prism.languages.actionscript["class-name"].alias = "function";
    delete Prism.languages.actionscript["parameter"];
    delete Prism.languages.actionscript["literal-property"];
    if (Prism.languages.markup) {
      Prism.languages.insertBefore("actionscript", "string", {
        xml: {
          pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
          lookbehind: true,
          inside: Prism.languages.markup
        }
      });
    }
  }
  return actionscript_1;
}
var ada_1;
var hasRequiredAda;
function requireAda() {
  if (hasRequiredAda) return ada_1;
  hasRequiredAda = 1;
  ada_1 = ada;
  ada.displayName = "ada";
  ada.aliases = [];
  function ada(Prism) {
    Prism.languages.ada = {
      comment: /--.*/,
      string: /"(?:""|[^"\r\f\n])*"/,
      number: [
        {
          pattern: /\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
        },
        {
          pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
        }
      ],
      "attr-name": /\b'\w+/,
      keyword: /\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
      boolean: /\b(?:false|true)\b/i,
      operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
      punctuation: /\.\.?|[,;():]/,
      char: /'.'/,
      variable: /\b[a-z](?:\w)*\b/i
    };
  }
  return ada_1;
}
var agda_1;
var hasRequiredAgda;
function requireAgda() {
  if (hasRequiredAgda) return agda_1;
  hasRequiredAgda = 1;
  agda_1 = agda;
  agda.displayName = "agda";
  agda.aliases = [];
  function agda(Prism) {
    (function(Prism2) {
      Prism2.languages.agda = {
        comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
        string: {
          pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
          greedy: true
        },
        punctuation: /[(){}⦃⦄.;@]/,
        "class-name": {
          pattern: /((?:data|record) +)\S+/,
          lookbehind: true
        },
        function: {
          pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
          lookbehind: true
        },
        operator: {
          pattern: /(^\s*|\s)(?:[=|:∀→λ\\?_]|->)(?=\s)/,
          lookbehind: true
        },
        keyword: /\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
      };
    })(Prism);
  }
  return agda_1;
}
var al_1;
var hasRequiredAl;
function requireAl() {
  if (hasRequiredAl) return al_1;
  hasRequiredAl = 1;
  al_1 = al;
  al.displayName = "al";
  al.aliases = [];
  function al(Prism) {
    Prism.languages.al = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
        greedy: true
      },
      function: {
        pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
        lookbehind: true
      },
      keyword: [
        // keywords
        /\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i,
        // objects and metadata that are used like keywords
        /\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
      ],
      number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
      boolean: /\b(?:false|true)\b/i,
      variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
      "class-name": /\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
      operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
      punctuation: /[()\[\]{}:.;,]/
    };
  }
  return al_1;
}
var antlr4_1;
var hasRequiredAntlr4;
function requireAntlr4() {
  if (hasRequiredAntlr4) return antlr4_1;
  hasRequiredAntlr4 = 1;
  antlr4_1 = antlr4;
  antlr4.displayName = "antlr4";
  antlr4.aliases = ["g4"];
  function antlr4(Prism) {
    Prism.languages.antlr4 = {
      comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      string: {
        pattern: /'(?:\\.|[^\\'\r\n])*'/,
        greedy: true
      },
      "character-class": {
        pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
        greedy: true,
        alias: "regex",
        inside: {
          range: {
            pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
            lookbehind: true,
            alias: "punctuation"
          },
          escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
          punctuation: /[\[\]]/
        }
      },
      action: {
        pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
        greedy: true,
        inside: {
          content: {
            // this might be C, C++, Python, Java, C#, or any other language ANTLR4 compiles to
            pattern: /(\{)[\s\S]+(?=\})/,
            lookbehind: true
          },
          punctuation: /[{}]/
        }
      },
      command: {
        pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
        lookbehind: true,
        inside: {
          function: /\b\w+(?=\s*(?:[,(]|$))/,
          punctuation: /[,()]/
        }
      },
      annotation: {
        pattern: /@\w+(?:::\w+)*/,
        alias: "keyword"
      },
      label: {
        pattern: /#[ \t]*\w+/,
        alias: "punctuation"
      },
      keyword: /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
      definition: [
        {
          pattern: /\b[a-z]\w*(?=\s*:)/,
          alias: ["rule", "class-name"]
        },
        {
          pattern: /\b[A-Z]\w*(?=\s*:)/,
          alias: ["token", "constant"]
        }
      ],
      constant: /\b[A-Z][A-Z_]*\b/,
      operator: /\.\.|->|[|~]|[*+?]\??/,
      punctuation: /[;:()=]/
    };
    Prism.languages.g4 = Prism.languages.antlr4;
  }
  return antlr4_1;
}
var apacheconf_1;
var hasRequiredApacheconf;
function requireApacheconf() {
  if (hasRequiredApacheconf) return apacheconf_1;
  hasRequiredApacheconf = 1;
  apacheconf_1 = apacheconf;
  apacheconf.displayName = "apacheconf";
  apacheconf.aliases = [];
  function apacheconf(Prism) {
    Prism.languages.apacheconf = {
      comment: /#.*/,
      "directive-inline": {
        pattern: /(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
        lookbehind: true,
        alias: "property"
      },
      "directive-block": {
        pattern: /<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
        inside: {
          "directive-block": {
            pattern: /^<\/?\w+/,
            inside: {
              punctuation: /^<\/?/
            },
            alias: "tag"
          },
          "directive-block-parameter": {
            pattern: /.*[^>]/,
            inside: {
              punctuation: /:/,
              string: {
                pattern: /("|').*\1/,
                inside: {
                  variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
                }
              }
            },
            alias: "attr-value"
          },
          punctuation: />/
        },
        alias: "tag"
      },
      "directive-flags": {
        pattern: /\[(?:[\w=],?)+\]/,
        alias: "keyword"
      },
      string: {
        pattern: /("|').*\1/,
        inside: {
          variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
        }
      },
      variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
      regex: /\^?.*\$|\^.*\$?/
    };
  }
  return apacheconf_1;
}
var sql_1;
var hasRequiredSql;
function requireSql() {
  if (hasRequiredSql) return sql_1;
  hasRequiredSql = 1;
  sql_1 = sql;
  sql.displayName = "sql";
  sql.aliases = [];
  function sql(Prism) {
    Prism.languages.sql = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
        lookbehind: true
      },
      variable: [
        {
          pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
          greedy: true
        },
        /@[\w.$]+/
      ],
      string: {
        pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
        greedy: true,
        lookbehind: true
      },
      identifier: {
        pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
        greedy: true,
        lookbehind: true,
        inside: {
          punctuation: /^`|`$/
        }
      },
      function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
      // Should we highlight user defined functions too?
      keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
      boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
      number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
      operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
      punctuation: /[;[\]()`,.]/
    };
  }
  return sql_1;
}
var apex_1;
var hasRequiredApex;
function requireApex() {
  if (hasRequiredApex) return apex_1;
  hasRequiredApex = 1;
  var refractorSql = requireSql();
  apex_1 = apex;
  apex.displayName = "apex";
  apex.aliases = [];
  function apex(Prism) {
    Prism.register(refractorSql);
    (function(Prism2) {
      var keywords = /\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i;
      var className = /\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(
        /<keyword>/g,
        function() {
          return keywords.source;
        }
      );
      function insertClassName(pattern) {
        return RegExp(
          pattern.replace(/<CLASS-NAME>/g, function() {
            return className;
          }),
          "i"
        );
      }
      var classNameInside = {
        keyword: keywords,
        punctuation: /[()\[\]{};,:.<>]/
      };
      Prism2.languages.apex = {
        comment: Prism2.languages.clike.comment,
        string: Prism2.languages.clike.string,
        sql: {
          pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
          lookbehind: true,
          greedy: true,
          alias: "language-sql",
          inside: Prism2.languages.sql
        },
        annotation: {
          pattern: /@\w+\b/,
          alias: "punctuation"
        },
        "class-name": [
          {
            pattern: insertClassName(
              /(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/.source
            ),
            lookbehind: true,
            inside: classNameInside
          },
          {
            // cast
            pattern: insertClassName(
              /(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source
            ),
            lookbehind: true,
            inside: classNameInside
          },
          {
            // variable/parameter declaration and return types
            pattern: insertClassName(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
            inside: classNameInside
          }
        ],
        trigger: {
          pattern: /(\btrigger\s+)\w+\b/i,
          lookbehind: true,
          alias: "class-name"
        },
        keyword: keywords,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        boolean: /\b(?:false|true)\b/i,
        number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
        operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
        punctuation: /[()\[\]{};,.]/
      };
    })(Prism);
  }
  return apex_1;
}
var apl_1;
var hasRequiredApl;
function requireApl() {
  if (hasRequiredApl) return apl_1;
  hasRequiredApl = 1;
  apl_1 = apl;
  apl.displayName = "apl";
  apl.aliases = [];
  function apl(Prism) {
    Prism.languages.apl = {
      comment: /(?:⍝|#[! ]).*$/m,
      string: {
        pattern: /'(?:[^'\r\n]|'')*'/,
        greedy: true
      },
      number: /¯?(?:\d*\.?\b\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+¯]?\d+)?|¯|∞))?/i,
      statement: /:[A-Z][a-z][A-Za-z]*\b/,
      "system-function": {
        pattern: /⎕[A-Z]+/i,
        alias: "function"
      },
      constant: /[⍬⌾#⎕⍞]/,
      function: /[-+×÷⌈⌊∣|⍳⍸?*⍟○!⌹<≤=>≥≠≡≢∊⍷∪∩~∨∧⍱⍲⍴,⍪⌽⊖⍉↑↓⊂⊃⊆⊇⌷⍋⍒⊤⊥⍕⍎⊣⊢⍁⍂≈⍯↗¤→]/,
      "monadic-operator": {
        pattern: /[\\\/⌿⍀¨⍨⌶&∥]/,
        alias: "operator"
      },
      "dyadic-operator": {
        pattern: /[.⍣⍠⍤∘⌸@⌺⍥]/,
        alias: "operator"
      },
      assignment: {
        pattern: /←/,
        alias: "keyword"
      },
      punctuation: /[\[;\]()◇⋄]/,
      dfn: {
        pattern: /[{}⍺⍵⍶⍹∇⍫:]/,
        alias: "builtin"
      }
    };
  }
  return apl_1;
}
var applescript_1;
var hasRequiredApplescript;
function requireApplescript() {
  if (hasRequiredApplescript) return applescript_1;
  hasRequiredApplescript = 1;
  applescript_1 = applescript;
  applescript.displayName = "applescript";
  applescript.aliases = [];
  function applescript(Prism) {
    Prism.languages.applescript = {
      comment: [
        // Allow one level of nesting
        /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
        /--.+/,
        /#.+/
      ],
      string: /"(?:\\.|[^"\\\r\n])*"/,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
      operator: [
        /[&=≠≤≥*+\-\/÷^]|[<>]=?/,
        /\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/
      ],
      keyword: /\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
      "class-name": /\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
      punctuation: /[{}():,¬«»《》]/
    };
  }
  return applescript_1;
}
var aql_1;
var hasRequiredAql;
function requireAql() {
  if (hasRequiredAql) return aql_1;
  hasRequiredAql = 1;
  aql_1 = aql;
  aql.displayName = "aql";
  aql.aliases = [];
  function aql(Prism) {
    Prism.languages.aql = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      property: {
        pattern: /([{,]\s*)(?:(?!\d)\w+|(["'´`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
        lookbehind: true,
        greedy: true
      },
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
        greedy: true
      },
      identifier: {
        pattern: /([´`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
        greedy: true
      },
      variable: /@@?\w+/,
      keyword: [
        {
          pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
          lookbehind: true
        },
        /\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
        // pseudo keywords get a lookbehind to avoid false positives
        {
          pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
          lookbehind: true
        },
        {
          pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
          lookbehind: true
        },
        {
          pattern: /\bOPTIONS(?=\s*\{)/i
        }
      ],
      function: /\b(?!\d)\w+(?=\s*\()/,
      boolean: /\b(?:false|true)\b/i,
      range: {
        pattern: /\.\./,
        alias: "operator"
      },
      number: [
        /\b0b[01]+/i,
        /\b0x[0-9a-f]+/i,
        /(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
      ],
      operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
      punctuation: /::|[?.:,;()[\]{}]/
    };
  }
  return aql_1;
}
var c_1;
var hasRequiredC;
function requireC() {
  if (hasRequiredC) return c_1;
  hasRequiredC = 1;
  c_1 = c2;
  c2.displayName = "c";
  c2.aliases = [];
  function c2(Prism) {
    Prism.languages.c = Prism.languages.extend("clike", {
      comment: {
        pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: true
      },
      string: {
        // https://en.cppreference.com/w/c/language/string_literal
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: true
      },
      keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
      operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
    });
    Prism.languages.insertBefore("c", "string", {
      char: {
        // https://en.cppreference.com/w/c/language/character_constant
        pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
        greedy: true
      }
    });
    Prism.languages.insertBefore("c", "string", {
      macro: {
        // allow for multiline macro definitions
        // spaces after the # character compile fine with gcc
        pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: true,
        greedy: true,
        alias: "property",
        inside: {
          string: [
            {
              // highlight the path of the include statement as a string
              pattern: /^(#\s*include\s*)<[^>]+>/,
              lookbehind: true
            },
            Prism.languages.c["string"]
          ],
          char: Prism.languages.c["char"],
          comment: Prism.languages.c["comment"],
          "macro-name": [
            {
              pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
              lookbehind: true
            },
            {
              pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
              lookbehind: true,
              alias: "function"
            }
          ],
          // highlight macro directives as keywords
          directive: {
            pattern: /^(#\s*)[a-z]+/,
            lookbehind: true,
            alias: "keyword"
          },
          "directive-hash": /^#/,
          punctuation: /##|\\(?=[\r\n])/,
          expression: {
            pattern: /\S[\s\S]*/,
            inside: Prism.languages.c
          }
        }
      }
    });
    Prism.languages.insertBefore("c", "function", {
      // highlight predefined macros as constants
      constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
    });
    delete Prism.languages.c["boolean"];
  }
  return c_1;
}
var cpp_1;
var hasRequiredCpp;
function requireCpp() {
  if (hasRequiredCpp) return cpp_1;
  hasRequiredCpp = 1;
  var refractorC = requireC();
  cpp_1 = cpp;
  cpp.displayName = "cpp";
  cpp.aliases = [];
  function cpp(Prism) {
    Prism.register(refractorC);
    (function(Prism2) {
      var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
      var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
        /<keyword>/g,
        function() {
          return keyword.source;
        }
      );
      Prism2.languages.cpp = Prism2.languages.extend("c", {
        "class-name": [
          {
            pattern: RegExp(
              /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
                /<keyword>/g,
                function() {
                  return keyword.source;
                }
              )
            ),
            lookbehind: true
          },
          // This is intended to capture the class name of method implementations like:
          //   void foo::bar() const {}
          // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
          // it starts with an uppercase letter. This approximation should give decent results.
          /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
          // This will capture the class name before destructors like:
          //   Foo::~Foo() {}
          /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
          // This also intends to capture the class name of method implementations but here the class has template
          // parameters, so it can't be a namespace (until C++ adds generic namespaces).
          /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
        ],
        keyword,
        number: {
          pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
          greedy: true
        },
        operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
        boolean: /\b(?:false|true)\b/
      });
      Prism2.languages.insertBefore("cpp", "string", {
        module: {
          // https://en.cppreference.com/w/cpp/language/modules
          pattern: RegExp(
            /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
            /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
            /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
              /<mod-name>/g,
              function() {
                return modName;
              }
            ) + ")"
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            string: /^[<"][\s\S]+/,
            operator: /:/,
            punctuation: /\./
          }
        },
        "raw-string": {
          pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
          alias: "string",
          greedy: true
        }
      });
      Prism2.languages.insertBefore("cpp", "keyword", {
        "generic-function": {
          pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
          inside: {
            function: /^\w+/,
            generic: {
              pattern: /<[\s\S]+/,
              alias: "class-name",
              inside: Prism2.languages.cpp
            }
          }
        }
      });
      Prism2.languages.insertBefore("cpp", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      });
      Prism2.languages.insertBefore("cpp", "class-name", {
        // the base clause is an optional list of parent classes
        // https://en.cppreference.com/w/cpp/language/class
        "base-clause": {
          pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.extend("cpp", {})
        }
      });
      Prism2.languages.insertBefore(
        "inside",
        "double-colon",
        {
          // All untokenized words that are not namespaces should be class names
          "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
        },
        Prism2.languages.cpp["base-clause"]
      );
    })(Prism);
  }
  return cpp_1;
}
var arduino_1;
var hasRequiredArduino;
function requireArduino() {
  if (hasRequiredArduino) return arduino_1;
  hasRequiredArduino = 1;
  var refractorCpp = requireCpp();
  arduino_1 = arduino;
  arduino.displayName = "arduino";
  arduino.aliases = ["ino"];
  function arduino(Prism) {
    Prism.register(refractorCpp);
    Prism.languages.arduino = Prism.languages.extend("cpp", {
      keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
      constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
      builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
    });
    Prism.languages.ino = Prism.languages.arduino;
  }
  return arduino_1;
}
var arff_1;
var hasRequiredArff;
function requireArff() {
  if (hasRequiredArff) return arff_1;
  hasRequiredArff = 1;
  arff_1 = arff;
  arff.displayName = "arff";
  arff.aliases = [];
  function arff(Prism) {
    Prism.languages.arff = {
      comment: /%.*/,
      string: {
        pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      keyword: /@(?:attribute|data|end|relation)\b/i,
      number: /\b\d+(?:\.\d+)?\b/,
      punctuation: /[{},]/
    };
  }
  return arff_1;
}
var asciidoc_1;
var hasRequiredAsciidoc;
function requireAsciidoc() {
  if (hasRequiredAsciidoc) return asciidoc_1;
  hasRequiredAsciidoc = 1;
  asciidoc_1 = asciidoc;
  asciidoc.displayName = "asciidoc";
  asciidoc.aliases = ["adoc"];
  function asciidoc(Prism) {
    (function(Prism2) {
      var attributes = {
        pattern: /(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
        lookbehind: true,
        inside: {
          quoted: {
            pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
            inside: {
              punctuation: /^[$`]|[$`]$/
            }
          },
          interpreted: {
            pattern: /'(?:[^'\\]|\\.)*'/,
            inside: {
              punctuation: /^'|'$/
              // See rest below
            }
          },
          string: /"(?:[^"\\]|\\.)*"/,
          variable: /\w+(?==)/,
          punctuation: /^\[|\]$|,/,
          operator: /=/,
          // The negative look-ahead prevents blank matches
          "attr-value": /(?!^\s+$).+/
        }
      };
      var asciidoc2 = Prism2.languages.asciidoc = {
        "comment-block": {
          pattern: /^(\/{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1/m,
          alias: "comment"
        },
        table: {
          pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
          inside: {
            specifiers: {
              pattern: /(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
              alias: "attr-value"
            },
            punctuation: {
              pattern: /(^|[^\\])[|!]=*/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "passthrough-block": {
          pattern: /^(\+{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^\++|\++$/
            // See rest below
          }
        },
        // Literal blocks and listing blocks
        "literal-block": {
          pattern: /^(-{4,}|\.{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/
            // See rest below
          }
        },
        // Sidebar blocks, quote blocks, example blocks and open blocks
        "other-block": {
          pattern: /^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
          inside: {
            punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/
            // See rest below
          }
        },
        // list-punctuation and list-label must appear before indented-block
        "list-punctuation": {
          pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
          lookbehind: true,
          alias: "punctuation"
        },
        "list-label": {
          pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
          lookbehind: true,
          alias: "symbol"
        },
        "indented-block": {
          pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
          lookbehind: true
        },
        comment: /^\/\/.*/m,
        title: {
          pattern: /^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
          alias: "important",
          inside: {
            punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/
            // See rest below
          }
        },
        "attribute-entry": {
          pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
          alias: "tag"
        },
        attributes,
        hr: {
          pattern: /^'{3,}$/m,
          alias: "punctuation"
        },
        "page-break": {
          pattern: /^<{3,}$/m,
          alias: "punctuation"
        },
        admonition: {
          pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
          alias: "keyword"
        },
        callout: [
          {
            pattern: /(^[ \t]*)<?\d*>/m,
            lookbehind: true,
            alias: "symbol"
          },
          {
            pattern: /<\d+>/,
            alias: "symbol"
          }
        ],
        macro: {
          pattern: /\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
          inside: {
            function: /^[a-z\d-]+(?=:)/,
            punctuation: /^::?/,
            attributes: {
              pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
              inside: attributes.inside
            }
          }
        },
        inline: {
          /*
          The initial look-behind prevents the highlighting of escaped quoted text.
          Quoted text can be multi-line but cannot span an empty line.
          All quoted text can have attributes before [foobar, 'foobar', baz="bar"].
          First, we handle the constrained quotes.
          Those must be bounded by non-word chars and cannot have spaces between the delimiter and the first char.
          They are, in order: _emphasis_, ``double quotes'', `single quotes', `monospace`, 'emphasis', *strong*, +monospace+ and #unquoted#
          Then we handle the unconstrained quotes.
          Those do not have the restrictions of the constrained quotes.
          They are, in order: __emphasis__, **strong**, ++monospace++, +++passthrough+++, ##unquoted##, $$passthrough$$, ~subscript~, ^superscript^, {attribute-reference}, [[anchor]], [[[bibliography anchor]]], <<xref>>, (((indexes))) and ((indexes))
          */
          pattern: /(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
          lookbehind: true,
          inside: {
            attributes,
            url: {
              pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
              inside: {
                punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
              }
            },
            "attribute-ref": {
              pattern: /^\{.+\}$/,
              inside: {
                variable: {
                  pattern: /(^\{)[a-z\d,+_-]+/,
                  lookbehind: true
                },
                operator: /^[=?!#%@$]|!(?=[:}])/,
                punctuation: /^\{|\}$|::?/
              }
            },
            italic: {
              pattern: /^(['_])[\s\S]+\1$/,
              inside: {
                punctuation: /^(?:''?|__?)|(?:''?|__?)$/
              }
            },
            bold: {
              pattern: /^\*[\s\S]+\*$/,
              inside: {
                punctuation: /^\*\*?|\*\*?$/
              }
            },
            punctuation: /^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
          }
        },
        replacement: {
          pattern: /\((?:C|R|TM)\)/,
          alias: "builtin"
        },
        entity: /&#?[\da-z]{1,8};/i,
        "line-continuation": {
          pattern: /(^| )\+$/m,
          lookbehind: true,
          alias: "punctuation"
        }
      };
      function copyFromAsciiDoc(keys) {
        keys = keys.split(" ");
        var o4 = {};
        for (var i2 = 0, l2 = keys.length; i2 < l2; i2++) {
          o4[keys[i2]] = asciidoc2[keys[i2]];
        }
        return o4;
      }
      attributes.inside["interpreted"].inside.rest = copyFromAsciiDoc(
        "macro inline replacement entity"
      );
      asciidoc2["passthrough-block"].inside.rest = copyFromAsciiDoc("macro");
      asciidoc2["literal-block"].inside.rest = copyFromAsciiDoc("callout");
      asciidoc2["table"].inside.rest = copyFromAsciiDoc(
        "comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation"
      );
      asciidoc2["other-block"].inside.rest = copyFromAsciiDoc(
        "table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation"
      );
      asciidoc2["title"].inside.rest = copyFromAsciiDoc(
        "macro inline replacement entity"
      );
      Prism2.hooks.add("wrap", function(env) {
        if (env.type === "entity") {
          env.attributes["title"] = env.content.value.replace(/&amp;/, "&");
        }
      });
      Prism2.languages.adoc = Prism2.languages.asciidoc;
    })(Prism);
  }
  return asciidoc_1;
}
var asm6502_1;
var hasRequiredAsm6502;
function requireAsm6502() {
  if (hasRequiredAsm6502) return asm6502_1;
  hasRequiredAsm6502 = 1;
  asm6502_1 = asm6502;
  asm6502.displayName = "asm6502";
  asm6502.aliases = [];
  function asm6502(Prism) {
    Prism.languages.asm6502 = {
      comment: /;.*/,
      directive: {
        pattern: /\.\w+(?= )/,
        alias: "property"
      },
      string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      "op-code": {
        pattern: /\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
        alias: "keyword"
      },
      "hex-number": {
        pattern: /#?\$[\da-f]{1,4}\b/i,
        alias: "number"
      },
      "binary-number": {
        pattern: /#?%[01]+\b/,
        alias: "number"
      },
      "decimal-number": {
        pattern: /#?\b\d+\b/,
        alias: "number"
      },
      register: {
        pattern: /\b[xya]\b/i,
        alias: "variable"
      },
      punctuation: /[(),:]/
    };
  }
  return asm6502_1;
}
var asmatmel_1;
var hasRequiredAsmatmel;
function requireAsmatmel() {
  if (hasRequiredAsmatmel) return asmatmel_1;
  hasRequiredAsmatmel = 1;
  asmatmel_1 = asmatmel;
  asmatmel.displayName = "asmatmel";
  asmatmel.aliases = [];
  function asmatmel(Prism) {
    Prism.languages.asmatmel = {
      comment: {
        pattern: /;.*/,
        greedy: true
      },
      string: {
        pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
      directive: {
        pattern: /\.\w+(?= )/,
        alias: "property"
      },
      "r-register": {
        pattern: /\br(?:\d|[12]\d|3[01])\b/,
        alias: "variable"
      },
      "op-code": {
        pattern: /\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
        alias: "keyword"
      },
      "hex-number": {
        pattern: /#?\$[\da-f]{2,4}\b/i,
        alias: "number"
      },
      "binary-number": {
        pattern: /#?%[01]+\b/,
        alias: "number"
      },
      "decimal-number": {
        pattern: /#?\b\d+\b/,
        alias: "number"
      },
      register: {
        pattern: /\b[acznvshtixy]\b/i,
        alias: "variable"
      },
      operator: />>=?|<<=?|&&?|\|\|?|[-+*/%&|^!=<>?]=?/,
      punctuation: /[(),:]/
    };
  }
  return asmatmel_1;
}
var csharp_1;
var hasRequiredCsharp;
function requireCsharp() {
  if (hasRequiredCsharp) return csharp_1;
  hasRequiredCsharp = 1;
  csharp_1 = csharp;
  csharp.displayName = "csharp";
  csharp.aliases = ["dotnet", "cs"];
  function csharp(Prism) {
    (function(Prism2) {
      function replace(pattern, replacements) {
        return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
          return "(?:" + replacements[+index2] + ")";
        });
      }
      function re2(pattern, replacements, flags) {
        return RegExp(replace(pattern, replacements), "");
      }
      function nested(pattern, depthLog2) {
        for (var i2 = 0; i2 < depthLog2; i2++) {
          pattern = pattern.replace(/<<self>>/g, function() {
            return "(?:" + pattern + ")";
          });
        }
        return pattern.replace(/<<self>>/g, "[^\\s\\S]");
      }
      var keywordKinds = {
        // keywords which represent a return or variable type
        type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
        // keywords which are used to declare a type
        typeDeclaration: "class enum interface record struct",
        // contextual keywords
        // ("var" and "dynamic" are missing because they are used like types)
        contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
        // all other keywords
        other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
      };
      function keywordsToPattern(words) {
        return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
      }
      var typeDeclarationKeywords = keywordsToPattern(
        keywordKinds.typeDeclaration
      );
      var keywords = RegExp(
        keywordsToPattern(
          keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other
        )
      );
      var nonTypeKeywords = keywordsToPattern(
        keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other
      );
      var nonContextualKeywords = keywordsToPattern(
        keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other
      );
      var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
      var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
      var name = /@?\b[A-Za-z_]\w*\b/.source;
      var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name, generic]);
      var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
        nonTypeKeywords,
        genericName
      ]);
      var array = /\[\s*(?:,\s*)*\]/.source;
      var typeExpressionWithoutTuple = replace(
        /<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source,
        [identifier, array]
      );
      var tupleElement = replace(
        /[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source,
        [generic, nestedRound, array]
      );
      var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
      var typeExpression = replace(
        /(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source,
        [tuple, identifier, array]
      );
      var typeInside = {
        keyword: keywords,
        punctuation: /[<>()?,.:[\]]/
      };
      var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
      var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
      var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
      Prism2.languages.csharp = Prism2.languages.extend("clike", {
        string: [
          {
            pattern: re2(/(^|[^$\\])<<0>>/.source, [verbatimString]),
            lookbehind: true,
            greedy: true
          },
          {
            pattern: re2(/(^|[^@$\\])<<0>>/.source, [regularString]),
            lookbehind: true,
            greedy: true
          }
        ],
        "class-name": [
          {
            // Using static
            // using static System.Math;
            pattern: re2(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [
              identifier
            ]),
            lookbehind: true,
            inside: typeInside
          },
          {
            // Using alias (type)
            // using Project = PC.MyCompany.Project;
            pattern: re2(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
              name,
              typeExpression
            ]),
            lookbehind: true,
            inside: typeInside
          },
          {
            // Using alias (alias)
            // using Project = PC.MyCompany.Project;
            pattern: re2(/(\busing\s+)<<0>>(?=\s*=)/.source, [name]),
            lookbehind: true
          },
          {
            // Type declarations
            // class Foo<A, B>
            // interface Foo<out A, B>
            pattern: re2(/(\b<<0>>\s+)<<1>>/.source, [
              typeDeclarationKeywords,
              genericName
            ]),
            lookbehind: true,
            inside: typeInside
          },
          {
            // Single catch exception declaration
            // catch(Foo)
            // (things like catch(Foo e) is covered by variable declaration)
            pattern: re2(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
            lookbehind: true,
            inside: typeInside
          },
          {
            // Name of the type parameter of generic constraints
            // where Foo : class
            pattern: re2(/(\bwhere\s+)<<0>>/.source, [name]),
            lookbehind: true
          },
          {
            // Casts and checks via as and is.
            // as Foo<A>, is Bar<B>
            // (things like if(a is Foo b) is covered by variable declaration)
            pattern: re2(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [
              typeExpressionWithoutTuple
            ]),
            lookbehind: true,
            inside: typeInside
          },
          {
            // Variable, field and parameter declaration
            // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
            pattern: re2(
              /\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source,
              [typeExpression, nonContextualKeywords, name]
            ),
            inside: typeInside
          }
        ],
        keyword: keywords,
        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
        number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
        operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
        punctuation: /\?\.?|::|[{}[\];(),.:]/
      });
      Prism2.languages.insertBefore("csharp", "number", {
        range: {
          pattern: /\.\./,
          alias: "operator"
        }
      });
      Prism2.languages.insertBefore("csharp", "punctuation", {
        "named-parameter": {
          pattern: re2(/([(,]\s*)<<0>>(?=\s*:)/.source, [name]),
          lookbehind: true,
          alias: "punctuation"
        }
      });
      Prism2.languages.insertBefore("csharp", "class-name", {
        namespace: {
          // namespace Foo.Bar {}
          // using Foo.Bar;
          pattern: re2(
            /(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source,
            [name]
          ),
          lookbehind: true,
          inside: {
            punctuation: /\./
          }
        },
        "type-expression": {
          // default(Foo), typeof(Foo<Bar>), sizeof(int)
          pattern: re2(
            /(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source,
            [nestedRound]
          ),
          lookbehind: true,
          alias: "class-name",
          inside: typeInside
        },
        "return-type": {
          // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
          // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
          // int Foo => 0; int Foo { get; set } = 0;
          pattern: re2(
            /<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source,
            [typeExpression, identifier]
          ),
          inside: typeInside,
          alias: "class-name"
        },
        "constructor-invocation": {
          // new List<Foo<Bar[]>> { }
          pattern: re2(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
          lookbehind: true,
          inside: typeInside,
          alias: "class-name"
        },
        /*'explicit-implementation': {
        // int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
        pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
        inside: classNameInside,
        alias: 'class-name'
        },*/
        "generic-method": {
          // foo<Bar>()
          pattern: re2(/<<0>>\s*<<1>>(?=\s*\()/.source, [name, generic]),
          inside: {
            function: re2(/^<<0>>/.source, [name]),
            generic: {
              pattern: RegExp(generic),
              alias: "class-name",
              inside: typeInside
            }
          }
        },
        "type-list": {
          // The list of types inherited or of generic constraints
          // class Foo<F> : Bar, IList<FooBar>
          // where F : Bar, IList<int>
          pattern: re2(
            /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
            [
              typeDeclarationKeywords,
              genericName,
              name,
              typeExpression,
              keywords.source,
              nestedRound,
              /\bnew\s*\(\s*\)/.source
            ]
          ),
          lookbehind: true,
          inside: {
            "record-arguments": {
              pattern: re2(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
                genericName,
                nestedRound
              ]),
              lookbehind: true,
              greedy: true,
              inside: Prism2.languages.csharp
            },
            keyword: keywords,
            "class-name": {
              pattern: RegExp(typeExpression),
              greedy: true,
              inside: typeInside
            },
            punctuation: /[,()]/
          }
        },
        preprocessor: {
          pattern: /(^[\t ]*)#.*/m,
          lookbehind: true,
          alias: "property",
          inside: {
            // highlight preprocessor directives as keywords
            directive: {
              pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
              lookbehind: true,
              alias: "keyword"
            }
          }
        }
      });
      var regularStringOrCharacter = regularString + "|" + character;
      var regularStringCharacterOrComment = replace(
        /\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,
        [regularStringOrCharacter]
      );
      var roundExpression = nested(
        replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
          regularStringCharacterOrComment
        ]),
        2
      );
      var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
      var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
        identifier,
        roundExpression
      ]);
      Prism2.languages.insertBefore("csharp", "class-name", {
        attribute: {
          // Attributes
          // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
          pattern: re2(
            /((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source,
            [attrTarget, attr]
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            target: {
              pattern: re2(/^<<0>>(?=\s*:)/.source, [attrTarget]),
              alias: "keyword"
            },
            "attribute-arguments": {
              pattern: re2(/\(<<0>>*\)/.source, [roundExpression]),
              inside: Prism2.languages.csharp
            },
            "class-name": {
              pattern: RegExp(identifier),
              inside: {
                punctuation: /\./
              }
            },
            punctuation: /[:,]/
          }
        }
      });
      var formatString2 = /:[^}\r\n]+/.source;
      var mInterpolationRound = nested(
        replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
          regularStringCharacterOrComment
        ]),
        2
      );
      var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
        mInterpolationRound,
        formatString2
      ]);
      var sInterpolationRound = nested(
        replace(
          /[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source,
          [regularStringOrCharacter]
        ),
        2
      );
      var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
        sInterpolationRound,
        formatString2
      ]);
      function createInterpolationInside(interpolation, interpolationRound) {
        return {
          interpolation: {
            pattern: re2(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
            lookbehind: true,
            inside: {
              "format-string": {
                pattern: re2(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
                  interpolationRound,
                  formatString2
                ]),
                lookbehind: true,
                inside: {
                  punctuation: /^:/
                }
              },
              punctuation: /^\{|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                alias: "language-csharp",
                inside: Prism2.languages.csharp
              }
            }
          },
          string: /[\s\S]+/
        };
      }
      Prism2.languages.insertBefore("csharp", "string", {
        "interpolation-string": [
          {
            pattern: re2(
              /(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source,
              [mInterpolation]
            ),
            lookbehind: true,
            greedy: true,
            inside: createInterpolationInside(mInterpolation, mInterpolationRound)
          },
          {
            pattern: re2(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
              sInterpolation
            ]),
            lookbehind: true,
            greedy: true,
            inside: createInterpolationInside(sInterpolation, sInterpolationRound)
          }
        ],
        char: {
          pattern: RegExp(character),
          greedy: true
        }
      });
      Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
    })(Prism);
  }
  return csharp_1;
}
var aspnet_1;
var hasRequiredAspnet;
function requireAspnet() {
  if (hasRequiredAspnet) return aspnet_1;
  hasRequiredAspnet = 1;
  var refractorCsharp = requireCsharp();
  aspnet_1 = aspnet;
  aspnet.displayName = "aspnet";
  aspnet.aliases = [];
  function aspnet(Prism) {
    Prism.register(refractorCsharp);
    Prism.languages.aspnet = Prism.languages.extend("markup", {
      "page-directive": {
        pattern: /<%\s*@.*%>/,
        alias: "tag",
        inside: {
          "page-directive": {
            pattern: /<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
            alias: "tag"
          },
          rest: Prism.languages.markup.tag.inside
        }
      },
      directive: {
        pattern: /<%.*%>/,
        alias: "tag",
        inside: {
          directive: {
            pattern: /<%\s*?[$=%#:]{0,2}|%>/,
            alias: "tag"
          },
          rest: Prism.languages.csharp
        }
      }
    });
    Prism.languages.aspnet.tag.pattern = /<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
    Prism.languages.insertBefore(
      "inside",
      "punctuation",
      {
        directive: Prism.languages.aspnet["directive"]
      },
      Prism.languages.aspnet.tag.inside["attr-value"]
    );
    Prism.languages.insertBefore("aspnet", "comment", {
      "asp-comment": {
        pattern: /<%--[\s\S]*?--%>/,
        alias: ["asp", "comment"]
      }
    });
    Prism.languages.insertBefore(
      "aspnet",
      Prism.languages.javascript ? "script" : "tag",
      {
        "asp-script": {
          pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
          lookbehind: true,
          alias: ["asp", "script"],
          inside: Prism.languages.csharp || {}
        }
      }
    );
  }
  return aspnet_1;
}
var autohotkey_1;
var hasRequiredAutohotkey;
function requireAutohotkey() {
  if (hasRequiredAutohotkey) return autohotkey_1;
  hasRequiredAutohotkey = 1;
  autohotkey_1 = autohotkey;
  autohotkey.displayName = "autohotkey";
  autohotkey.aliases = [];
  function autohotkey(Prism) {
    Prism.languages.autohotkey = {
      comment: [
        {
          pattern: /(^|\s);.*/,
          lookbehind: true
        },
        {
          pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
          lookbehind: true,
          greedy: true
        }
      ],
      tag: {
        // labels
        pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
        lookbehind: true
      },
      string: /"(?:[^"\n\r]|"")*"/,
      variable: /%\w+%/,
      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
      operator: /\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
      boolean: /\b(?:false|true)\b/,
      selector: /\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
      constant: /\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
      builtin: /\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
      symbol: /\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
      important: /#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|DerefChar|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|If|IfTimeout|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InputLevel|InstallKeybdHook|InstallMouseHook|KeyHistory|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|MenuMaskKey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|Warn|WinActivateForce)\b/i,
      keyword: /\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
      function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
      punctuation: /[{}[\]():,]/
    };
  }
  return autohotkey_1;
}
var autoit_1;
var hasRequiredAutoit;
function requireAutoit() {
  if (hasRequiredAutoit) return autoit_1;
  hasRequiredAutoit = 1;
  autoit_1 = autoit;
  autoit.displayName = "autoit";
  autoit.aliases = [];
  function autoit(Prism) {
    Prism.languages.autoit = {
      comment: [
        /;.*/,
        {
          // The multi-line comments delimiters can actually be commented out with ";"
          pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
          lookbehind: true
        }
      ],
      url: {
        pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
        lookbehind: true
      },
      string: {
        pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
        greedy: true,
        inside: {
          variable: /([%$@])\w+\1/
        }
      },
      directive: {
        pattern: /(^[\t ]*)#[\w-]+/m,
        lookbehind: true,
        alias: "keyword"
      },
      function: /\b\w+(?=\()/,
      // Variables and macros
      variable: /[$@]\w+/,
      keyword: /\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
      boolean: /\b(?:False|True)\b/i,
      operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
      punctuation: /[\[\]().,:]/
    };
  }
  return autoit_1;
}
var avisynth_1;
var hasRequiredAvisynth;
function requireAvisynth() {
  if (hasRequiredAvisynth) return avisynth_1;
  hasRequiredAvisynth = 1;
  avisynth_1 = avisynth;
  avisynth.displayName = "avisynth";
  avisynth.aliases = ["avs"];
  function avisynth(Prism) {
    (function(Prism2) {
      function replace(pattern, replacements) {
        return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
          return replacements[+index2];
        });
      }
      function re2(pattern, replacements, flags) {
        return RegExp(replace(pattern, replacements), flags);
      }
      var types2 = /bool|clip|float|int|string|val/.source;
      var internals = [
        // bools
        /is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
        // control
        /apply|assert|default|eval|import|nop|select|undefined/.source,
        // global
        /opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/.source,
        // conv
        /hex(?:value)?|value/.source,
        // numeric
        /abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/.source,
        // trig
        /a?sinh?|a?cosh?|a?tan[2h]?/.source,
        // bit
        /(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/.source,
        // runtime
        /average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/.source,
        // script
        /getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/.source,
        // string
        /chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/.source,
        // version
        /isversionorgreater|version(?:number|string)/.source,
        // helper
        /buildpixeltype|colorspacenametopixeltype/.source,
        // avsplus
        /addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
      ].join("|");
      var properties = [
        // content
        /has(?:audio|video)/.source,
        // resolution
        /height|width/.source,
        // framerate
        /frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
        // interlacing
        /getparity|is(?:field|frame)based/.source,
        // color format
        /bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/.source,
        // audio
        /audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
      ].join("|");
      var filters = [
        // source
        /avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/.source,
        // color
        /coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/.source,
        // overlay
        /(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
        // geometry
        /addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/.source,
        // pixel
        /blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/.source,
        // timeline
        /trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/.source,
        // interlace
        /assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/.source,
        // audio
        /amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/.source,
        // conditional
        /animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/.source,
        // export
        /imagewriter/.source,
        // debug
        /blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/.source
      ].join("|");
      var allinternals = [internals, properties, filters].join("|");
      Prism2.languages.avisynth = {
        comment: [
          {
            // Matches [* *] nestable block comments, but only supports 1 level of nested comments
            // /\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|<self>)*\*\]/
            pattern: /(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
            lookbehind: true,
            greedy: true
          },
          {
            // Matches /* */ block comments
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            // Matches # comments
            pattern: /(^|[^\\$])#.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        // Handle before strings because optional arguments are surrounded by double quotes
        argument: {
          pattern: re2(/\b(?:<<0>>)\s+("?)\w+\1/.source, [types2], "i"),
          inside: {
            keyword: /^\w+/
          }
        },
        // Optional argument assignment
        "argument-label": {
          pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
          lookbehind: true,
          inside: {
            "argument-name": {
              pattern: /^\w+/,
              alias: "punctuation"
            },
            punctuation: /=$/
          }
        },
        string: [
          {
            // triple double-quoted
            pattern: /"""[\s\S]*?"""/,
            greedy: true
          },
          {
            // single double-quoted
            pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
            greedy: true,
            inside: {
              constant: {
                // These *are* case-sensitive!
                pattern: /\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
              }
            }
          }
        ],
        // The special "last" variable that takes the value of the last implicitly returned clip
        variable: /\b(?:last)\b/i,
        boolean: /\b(?:false|no|true|yes)\b/i,
        keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
        constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
        // AviSynth's internal functions, filters, and properties
        "builtin-function": {
          pattern: re2(/\b(?:<<0>>)\b/.source, [allinternals], "i"),
          alias: "function"
        },
        "type-cast": {
          pattern: re2(/\b(?:<<0>>)(?=\s*\()/.source, [types2], "i"),
          alias: "keyword"
        },
        // External/user-defined filters
        function: {
          pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
          lookbehind: true
        },
        // Matches a \ as the first or last character on a line
        "line-continuation": {
          pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
          lookbehind: true,
          alias: "punctuation"
        },
        number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
        operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
        punctuation: /[{}\[\]();,.]/
      };
      Prism2.languages.avs = Prism2.languages.avisynth;
    })(Prism);
  }
  return avisynth_1;
}
var avroIdl_1;
var hasRequiredAvroIdl;
function requireAvroIdl() {
  if (hasRequiredAvroIdl) return avroIdl_1;
  hasRequiredAvroIdl = 1;
  avroIdl_1 = avroIdl;
  avroIdl.displayName = "avroIdl";
  avroIdl.aliases = [];
  function avroIdl(Prism) {
    Prism.languages["avro-idl"] = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: true
      },
      string: {
        pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
        lookbehind: true,
        greedy: true
      },
      annotation: {
        pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
        greedy: true,
        alias: "function"
      },
      "function-identifier": {
        pattern: /`[^\r\n`]+`(?=\s*\()/,
        greedy: true,
        alias: "function"
      },
      identifier: {
        pattern: /`[^\r\n`]+`/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
        lookbehind: true,
        greedy: true
      },
      keyword: /\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: [
        {
          pattern: /(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
          lookbehind: true
        },
        /-?\b(?:Infinity|NaN)\b/
      ],
      operator: /=/,
      punctuation: /[()\[\]{}<>.:,;-]/
    };
    Prism.languages.avdl = Prism.languages["avro-idl"];
  }
  return avroIdl_1;
}
var bash_1;
var hasRequiredBash;
function requireBash() {
  if (hasRequiredBash) return bash_1;
  hasRequiredBash = 1;
  bash_1 = bash;
  bash.displayName = "bash";
  bash.aliases = ["shell"];
  function bash(Prism) {
    (function(Prism2) {
      var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
      var commandAfterHeredoc = {
        pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
        lookbehind: true,
        alias: "punctuation",
        // this looks reasonably well in all themes
        inside: null
        // see below
      };
      var insideString = {
        bash: commandAfterHeredoc,
        environment: {
          pattern: RegExp("\\$" + envVars),
          alias: "constant"
        },
        variable: [
          // [0]: Arithmetic Environment
          {
            pattern: /\$?\(\([\s\S]+?\)\)/,
            greedy: true,
            inside: {
              // If there is a $ sign at the beginning highlight $(( and )) as variable
              variable: [
                {
                  pattern: /(^\$\(\([\s\S]+)\)\)/,
                  lookbehind: true
                },
                /^\$\(\(/
              ],
              number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
              // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
              operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
              // If there is no $ sign at the beginning highlight (( and )) as punctuation
              punctuation: /\(\(?|\)\)?|,|;/
            }
          },
          // [1]: Command Substitution
          {
            pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
            greedy: true,
            inside: {
              variable: /^\$\(|^`|\)$|`$/
            }
          },
          // [2]: Brace expansion
          {
            pattern: /\$\{[^}]+\}/,
            greedy: true,
            inside: {
              operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
              punctuation: /[\[\]]/,
              environment: {
                pattern: RegExp("(\\{)" + envVars),
                lookbehind: true,
                alias: "constant"
              }
            }
          },
          /\$(?:\w+|[#?*!@$])/
        ],
        // Escape sequences from echo and printf's manuals, and escaped quotes.
        entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
      };
      Prism2.languages.bash = {
        shebang: {
          pattern: /^#!\s*\/.*/,
          alias: "important"
        },
        comment: {
          pattern: /(^|[^"{\\$])#.*/,
          lookbehind: true
        },
        "function-name": [
          // a) function foo {
          // b) foo() {
          // c) function foo() {
          // but not “foo {”
          {
            // a) and c)
            pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
            lookbehind: true,
            alias: "function"
          },
          {
            // b)
            pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
            alias: "function"
          }
        ],
        // Highlight variable names as variables in for and select beginnings.
        "for-or-select": {
          pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
          alias: "variable",
          lookbehind: true
        },
        // Highlight variable names as variables in the left-hand part
        // of assignments (“=” and “+=”).
        "assign-left": {
          pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
          inside: {
            environment: {
              pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
              lookbehind: true,
              alias: "constant"
            }
          },
          alias: "variable",
          lookbehind: true
        },
        string: [
          // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
          {
            pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
            lookbehind: true,
            greedy: true,
            inside: insideString
          },
          // Here-document with quotes around the tag
          // → No expansion (so no “inside”).
          {
            pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
            lookbehind: true,
            greedy: true,
            inside: {
              bash: commandAfterHeredoc
            }
          },
          // “Normal” string
          {
            // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
            pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
            lookbehind: true,
            greedy: true,
            inside: insideString
          },
          {
            // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
            pattern: /(^|[^$\\])'[^']*'/,
            lookbehind: true,
            greedy: true
          },
          {
            // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
            pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
            greedy: true,
            inside: {
              entity: insideString.entity
            }
          }
        ],
        environment: {
          pattern: RegExp("\\$?" + envVars),
          alias: "constant"
        },
        variable: insideString.variable,
        function: {
          pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
          lookbehind: true
        },
        keyword: {
          pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
          lookbehind: true
        },
        // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
        builtin: {
          pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
          lookbehind: true,
          // Alias added to make those easier to distinguish from strings.
          alias: "class-name"
        },
        boolean: {
          pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
          lookbehind: true
        },
        "file-descriptor": {
          pattern: /\B&\d\b/,
          alias: "important"
        },
        operator: {
          // Lots of redirections here, but not just that.
          pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
          inside: {
            "file-descriptor": {
              pattern: /^\d/,
              alias: "important"
            }
          }
        },
        punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
        number: {
          pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
          lookbehind: true
        }
      };
      commandAfterHeredoc.inside = Prism2.languages.bash;
      var toBeCopied = [
        "comment",
        "function-name",
        "for-or-select",
        "assign-left",
        "string",
        "environment",
        "function",
        "keyword",
        "builtin",
        "boolean",
        "file-descriptor",
        "operator",
        "punctuation",
        "number"
      ];
      var inside = insideString.variable[1].inside;
      for (var i2 = 0; i2 < toBeCopied.length; i2++) {
        inside[toBeCopied[i2]] = Prism2.languages.bash[toBeCopied[i2]];
      }
      Prism2.languages.shell = Prism2.languages.bash;
    })(Prism);
  }
  return bash_1;
}
var basic_1;
var hasRequiredBasic;
function requireBasic() {
  if (hasRequiredBasic) return basic_1;
  hasRequiredBasic = 1;
  basic_1 = basic;
  basic.displayName = "basic";
  basic.aliases = [];
  function basic(Prism) {
    Prism.languages.basic = {
      comment: {
        pattern: /(?:!|REM\b).+/i,
        inside: {
          keyword: /^REM/i
        }
      },
      string: {
        pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
        greedy: true
      },
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
      function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
      operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
      punctuation: /[,;:()]/
    };
  }
  return basic_1;
}
var batch_1;
var hasRequiredBatch;
function requireBatch() {
  if (hasRequiredBatch) return batch_1;
  hasRequiredBatch = 1;
  batch_1 = batch;
  batch.displayName = "batch";
  batch.aliases = [];
  function batch(Prism) {
    (function(Prism2) {
      var variable = /%%?[~:\w]+%?|!\S+!/;
      var parameter = {
        pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
        alias: "attr-name",
        inside: {
          punctuation: /:/
        }
      };
      var string = /"(?:[\\"]"|[^"])*"(?!")/;
      var number2 = /(?:\b|-)\d+\b/;
      Prism2.languages.batch = {
        comment: [
          /^::.*/m,
          {
            pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
            lookbehind: true
          }
        ],
        label: {
          pattern: /^:.*/m,
          alias: "property"
        },
        command: [
          {
            // FOR command
            pattern: /((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
            lookbehind: true,
            inside: {
              keyword: /\b(?:do|in)\b|^for\b/i,
              string,
              parameter,
              variable,
              number: number2,
              punctuation: /[()',]/
            }
          },
          {
            // IF command
            pattern: /((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
            lookbehind: true,
            inside: {
              keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
              string,
              parameter,
              variable,
              number: number2,
              operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
            }
          },
          {
            // ELSE command
            pattern: /((?:^|[&()])[ \t]*)else\b/im,
            lookbehind: true,
            inside: {
              keyword: /^else\b/i
            }
          },
          {
            // SET command
            pattern: /((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
            lookbehind: true,
            inside: {
              keyword: /^set\b/i,
              string,
              parameter,
              variable: [variable, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
              number: number2,
              operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
              punctuation: /[()',]/
            }
          },
          {
            // Other commands
            pattern: /((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
            lookbehind: true,
            inside: {
              keyword: /^\w+\b/,
              string,
              parameter,
              label: {
                pattern: /(^\s*):\S+/m,
                lookbehind: true,
                alias: "property"
              },
              variable,
              number: number2,
              operator: /\^/
            }
          }
        ],
        operator: /[&@]/,
        punctuation: /[()']/
      };
    })(Prism);
  }
  return batch_1;
}
var bbcode_1;
var hasRequiredBbcode;
function requireBbcode() {
  if (hasRequiredBbcode) return bbcode_1;
  hasRequiredBbcode = 1;
  bbcode_1 = bbcode;
  bbcode.displayName = "bbcode";
  bbcode.aliases = ["shortcode"];
  function bbcode(Prism) {
    Prism.languages.bbcode = {
      tag: {
        pattern: /\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
        inside: {
          tag: {
            pattern: /^\[\/?[^\s=\]]+/,
            inside: {
              punctuation: /^\[\/?/
            }
          },
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
            inside: {
              punctuation: [
                /^=/,
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          punctuation: /\]/,
          "attr-name": /[^\s=\]]+/
        }
      }
    };
    Prism.languages.shortcode = Prism.languages.bbcode;
  }
  return bbcode_1;
}
var bicep_1;
var hasRequiredBicep;
function requireBicep() {
  if (hasRequiredBicep) return bicep_1;
  hasRequiredBicep = 1;
  bicep_1 = bicep;
  bicep.displayName = "bicep";
  bicep.aliases = [];
  function bicep(Prism) {
    Prism.languages.bicep = {
      comment: [
        {
          // multiline comments eg /* ASDF */
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          // singleline comments eg // ASDF
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      property: [
        {
          pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
          lookbehind: true
        },
        {
          pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: [
        {
          pattern: /'''[^'][\s\S]*?'''/,
          greedy: true
        },
        {
          pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
          lookbehind: true,
          greedy: true
        }
      ],
      "interpolated-string": {
        pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
        lookbehind: true,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /\$\{[^{}\r\n]*\}/,
            inside: {
              expression: {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: true
              },
              punctuation: /^\$\{|\}$/
            }
          },
          string: /[\s\S]+/
        }
      },
      datatype: {
        pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
        lookbehind: true,
        alias: "class-name"
      },
      boolean: /\b(?:false|true)\b/,
      // https://github.com/Azure/bicep/blob/114a3251b4e6e30082a58729f19a8cc4e374ffa6/src/textmate/bicep.tmlanguage#L184
      keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
      decorator: /@\w+\b/,
      function: /\b[a-z_]\w*(?=[ \t]*\()/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
      punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.bicep["interpolated-string"].inside["interpolation"].inside["expression"].inside = Prism.languages.bicep;
  }
  return bicep_1;
}
var birb_1;
var hasRequiredBirb;
function requireBirb() {
  if (hasRequiredBirb) return birb_1;
  hasRequiredBirb = 1;
  birb_1 = birb;
  birb.displayName = "birb";
  birb.aliases = [];
  function birb(Prism) {
    Prism.languages.birb = Prism.languages.extend("clike", {
      string: {
        pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
        greedy: true
      },
      "class-name": [
        /\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/,
        // matches variable and function return types (parameters as well).
        /\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
      ],
      keyword: /\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
      operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
      variable: /\b[a-z_]\w*\b/
    });
    Prism.languages.insertBefore("birb", "function", {
      metadata: {
        pattern: /<\w+>/,
        greedy: true,
        alias: "symbol"
      }
    });
  }
  return birb_1;
}
var bison_1;
var hasRequiredBison;
function requireBison() {
  if (hasRequiredBison) return bison_1;
  hasRequiredBison = 1;
  var refractorC = requireC();
  bison_1 = bison;
  bison.displayName = "bison";
  bison.aliases = [];
  function bison(Prism) {
    Prism.register(refractorC);
    Prism.languages.bison = Prism.languages.extend("c", {});
    Prism.languages.insertBefore("bison", "comment", {
      bison: {
        // This should match all the beginning of the file
        // including the prologue(s), the bison declarations and
        // the grammar rules.
        pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
        inside: {
          c: {
            // Allow for one level of nested braces
            pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
            inside: {
              delimiter: {
                pattern: /^%?\{|%?\}$/,
                alias: "punctuation"
              },
              "bison-variable": {
                pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
                alias: "variable",
                inside: {
                  punctuation: /<|>/
                }
              },
              rest: Prism.languages.c
            }
          },
          comment: Prism.languages.c.comment,
          string: Prism.languages.c.string,
          property: /\S+(?=:)/,
          keyword: /%\w+/,
          number: {
            pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
            lookbehind: true
          },
          punctuation: /%[%?]|[|:;\[\]<>]/
        }
      }
    });
  }
  return bison_1;
}
var bnf_1;
var hasRequiredBnf;
function requireBnf() {
  if (hasRequiredBnf) return bnf_1;
  hasRequiredBnf = 1;
  bnf_1 = bnf;
  bnf.displayName = "bnf";
  bnf.aliases = ["rbnf"];
  function bnf(Prism) {
    Prism.languages.bnf = {
      string: {
        pattern: /"[^\r\n"]*"|'[^\r\n']*'/
      },
      definition: {
        pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
        alias: ["rule", "keyword"],
        inside: {
          punctuation: /^<|>$/
        }
      },
      rule: {
        pattern: /<[^<>\r\n\t]+>/,
        inside: {
          punctuation: /^<|>$/
        }
      },
      operator: /::=|[|()[\]{}*+?]|\.{3}/
    };
    Prism.languages.rbnf = Prism.languages.bnf;
  }
  return bnf_1;
}
var brainfuck_1;
var hasRequiredBrainfuck;
function requireBrainfuck() {
  if (hasRequiredBrainfuck) return brainfuck_1;
  hasRequiredBrainfuck = 1;
  brainfuck_1 = brainfuck;
  brainfuck.displayName = "brainfuck";
  brainfuck.aliases = [];
  function brainfuck(Prism) {
    Prism.languages.brainfuck = {
      pointer: {
        pattern: /<|>/,
        alias: "keyword"
      },
      increment: {
        pattern: /\+/,
        alias: "inserted"
      },
      decrement: {
        pattern: /-/,
        alias: "deleted"
      },
      branching: {
        pattern: /\[|\]/,
        alias: "important"
      },
      operator: /[.,]/,
      comment: /\S+/
    };
  }
  return brainfuck_1;
}
var brightscript_1;
var hasRequiredBrightscript;
function requireBrightscript() {
  if (hasRequiredBrightscript) return brightscript_1;
  hasRequiredBrightscript = 1;
  brightscript_1 = brightscript;
  brightscript.displayName = "brightscript";
  brightscript.aliases = [];
  function brightscript(Prism) {
    Prism.languages.brightscript = {
      comment: /(?:\brem|').*/i,
      "directive-statement": {
        pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
        lookbehind: true,
        alias: "property",
        inside: {
          "error-message": {
            pattern: /(^#error).+/,
            lookbehind: true
          },
          directive: {
            pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
            alias: "keyword"
          },
          expression: {
            pattern: /[\s\S]+/,
            inside: null
            // see below
          }
        }
      },
      property: {
        pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
        lookbehind: true,
        greedy: true
      },
      string: {
        pattern: /"(?:[^"\r\n]|"")*"(?!")/,
        greedy: true
      },
      "class-name": {
        pattern: /(\bAs[\t ]+)\w+/i,
        lookbehind: true
      },
      keyword: /\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\b(?!\d)\w+(?=[\t ]*\()/,
      number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
      operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
      punctuation: /[.,;()[\]{}]/,
      constant: /\b(?:LINE_NUM)\b/i
    };
    Prism.languages.brightscript["directive-statement"].inside.expression.inside = Prism.languages.brightscript;
  }
  return brightscript_1;
}
var bro_1;
var hasRequiredBro;
function requireBro() {
  if (hasRequiredBro) return bro_1;
  hasRequiredBro = 1;
  bro_1 = bro;
  bro.displayName = "bro";
  bro.aliases = [];
  function bro(Prism) {
    Prism.languages.bro = {
      comment: {
        pattern: /(^|[^\\$])#.*/,
        lookbehind: true,
        inside: {
          italic: /\b(?:FIXME|TODO|XXX)\b/
        }
      },
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      boolean: /\b[TF]\b/,
      function: {
        pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
        lookbehind: true
      },
      builtin: /(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
      constant: {
        pattern: /(\bconst[ \t]+)\w+/i,
        lookbehind: true
      },
      keyword: /\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
      operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return bro_1;
}
var bsl_1;
var hasRequiredBsl;
function requireBsl() {
  if (hasRequiredBsl) return bsl_1;
  hasRequiredBsl = 1;
  bsl_1 = bsl;
  bsl.displayName = "bsl";
  bsl.aliases = [];
  function bsl(Prism) {
    Prism.languages.bsl = {
      comment: /\/\/.*/,
      string: [
        // Строки
        // Strings
        {
          pattern: /"(?:[^"]|"")*"(?!")/,
          greedy: true
        },
        // Дата и время
        // Date & time
        {
          pattern: /'(?:[^'\r\n\\]|\\.)*'/
        }
      ],
      keyword: [
        {
          // RU
          pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:пока|для|новый|прервать|попытка|исключение|вызватьисключение|иначе|конецпопытки|неопределено|функция|перем|возврат|конецфункции|если|иначеесли|процедура|конецпроцедуры|тогда|знач|экспорт|конецесли|из|каждого|истина|ложь|по|цикл|конеццикла|выполнить)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
          lookbehind: true
        },
        {
          // EN
          pattern: /\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
        }
      ],
      number: {
        pattern: /(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
        lookbehind: true
      },
      operator: [
        /[<>+\-*/]=?|[%=]/,
        // RU
        {
          pattern: /(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:и|или|не)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
          lookbehind: true
        },
        // EN
        {
          pattern: /\b(?:and|not|or)\b/i
        }
      ],
      punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
      directive: [
        // Теги препроцессора вида &Клиент, &Сервер, ...
        // Preprocessor tags of the type &Client, &Server, ...
        {
          pattern: /^([ \t]*)&.*/m,
          lookbehind: true,
          greedy: true,
          alias: "important"
        },
        // Инструкции препроцессора вида:
        // #Если Сервер Тогда
        // ...
        // #КонецЕсли
        // Preprocessor instructions of the form:
        // #If Server Then
        // ...
        // #EndIf
        {
          pattern: /^([ \t]*)#.*/gm,
          lookbehind: true,
          greedy: true,
          alias: "important"
        }
      ]
    };
    Prism.languages.oscript = Prism.languages["bsl"];
  }
  return bsl_1;
}
var cfscript_1;
var hasRequiredCfscript;
function requireCfscript() {
  if (hasRequiredCfscript) return cfscript_1;
  hasRequiredCfscript = 1;
  cfscript_1 = cfscript;
  cfscript.displayName = "cfscript";
  cfscript.aliases = [];
  function cfscript(Prism) {
    Prism.languages.cfscript = Prism.languages.extend("clike", {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          inside: {
            annotation: {
              pattern: /(?:^|[^.])@[\w\.]+/,
              alias: "punctuation"
            }
          }
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      keyword: /\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
      operator: [
        /\+\+|--|&&|\|\||::|=>|[!=]==|<=?|>=?|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|[?:]/,
        /\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
      ],
      scope: {
        pattern: /\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
        alias: "global"
      },
      type: {
        pattern: /\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
        alias: "builtin"
      }
    });
    Prism.languages.insertBefore("cfscript", "keyword", {
      // This must be declared before keyword because we use "function" inside the lookahead
      "function-variable": {
        pattern: /[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      }
    });
    delete Prism.languages.cfscript["class-name"];
    Prism.languages.cfc = Prism.languages["cfscript"];
  }
  return cfscript_1;
}
var chaiscript_1;
var hasRequiredChaiscript;
function requireChaiscript() {
  if (hasRequiredChaiscript) return chaiscript_1;
  hasRequiredChaiscript = 1;
  var refractorCpp = requireCpp();
  chaiscript_1 = chaiscript;
  chaiscript.displayName = "chaiscript";
  chaiscript.aliases = [];
  function chaiscript(Prism) {
    Prism.register(refractorCpp);
    Prism.languages.chaiscript = Prism.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
        lookbehind: true,
        greedy: true
      },
      "class-name": [
        {
          // e.g. class Rectangle { ... }
          pattern: /(\bclass\s+)\w+/,
          lookbehind: true
        },
        {
          // e.g. attr Rectangle::height, def Rectangle::area() { ... }
          pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
          lookbehind: true
        }
      ],
      keyword: /\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
      number: [Prism.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
      operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
    });
    Prism.languages.insertBefore("chaiscript", "operator", {
      "parameter-type": {
        // e.g. def foo(int x, Vector y) {...}
        pattern: /([,(]\s*)\w+(?=\s+\w)/,
        lookbehind: true,
        alias: "class-name"
      }
    });
    Prism.languages.insertBefore("chaiscript", "string", {
      "string-interpolation": {
        pattern: /(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
        lookbehind: true,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
            lookbehind: true,
            inside: {
              "interpolation-expression": {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: true,
                inside: Prism.languages.chaiscript
              },
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    });
  }
  return chaiscript_1;
}
var cil_1;
var hasRequiredCil;
function requireCil() {
  if (hasRequiredCil) return cil_1;
  hasRequiredCil = 1;
  cil_1 = cil;
  cil.displayName = "cil";
  cil.aliases = [];
  function cil(Prism) {
    Prism.languages.cil = {
      comment: /\/\/.*/,
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      directive: {
        pattern: /(^|\W)\.[a-z]+(?=\s)/,
        lookbehind: true,
        alias: "class-name"
      },
      // Actually an assembly reference
      variable: /\[[\w\.]+\]/,
      keyword: /\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
      function: /\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
      punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
    };
  }
  return cil_1;
}
var clojure_1;
var hasRequiredClojure;
function requireClojure() {
  if (hasRequiredClojure) return clojure_1;
  hasRequiredClojure = 1;
  clojure_1 = clojure;
  clojure.displayName = "clojure";
  clojure.aliases = [];
  function clojure(Prism) {
    Prism.languages.clojure = {
      comment: {
        pattern: /;.*/,
        greedy: true
      },
      string: {
        pattern: /"(?:[^"\\]|\\.)*"/,
        greedy: true
      },
      char: /\\\w+/,
      symbol: {
        pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
        lookbehind: true
      },
      keyword: {
        pattern: /(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
        lookbehind: true
      },
      boolean: /\b(?:false|nil|true)\b/,
      number: {
        pattern: /(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
        lookbehind: true
      },
      function: {
        pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
        lookbehind: true
      },
      operator: /[#@^`~]/,
      punctuation: /[{}\[\](),]/
    };
  }
  return clojure_1;
}
var cmake_1;
var hasRequiredCmake;
function requireCmake() {
  if (hasRequiredCmake) return cmake_1;
  hasRequiredCmake = 1;
  cmake_1 = cmake;
  cmake.displayName = "cmake";
  cmake.aliases = [];
  function cmake(Prism) {
    Prism.languages.cmake = {
      comment: /#.*/,
      string: {
        pattern: /"(?:[^\\"]|\\.)*"/,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
            inside: {
              punctuation: /\$\{|\}/,
              variable: /\w+/
            }
          }
        }
      },
      variable: /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_(?:BINARY_DIR|DESCRIPTION|HOMEPAGE_URL|NAME|SOURCE_DIR|VERSION|VERSION_(?:MAJOR|MINOR|PATCH|TWEAK))|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE|XCODE_VERSION))\b/,
      property: /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|GLOBAL_KEYWORD|GLOBAL_PROJECT_TYPES|GLOBAL_ROOTNAMESPACE|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
      keyword: /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
      boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
      namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
      operator: /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
      inserted: {
        pattern: /\b\w+::\w+\b/,
        alias: "class-name"
      },
      number: /\b\d+(?:\.\d+)*\b/,
      function: /\b[a-z_]\w*(?=\s*\()\b/i,
      punctuation: /[()>}]|\$[<{]/
    };
  }
  return cmake_1;
}
var cobol_1;
var hasRequiredCobol;
function requireCobol() {
  if (hasRequiredCobol) return cobol_1;
  hasRequiredCobol = 1;
  cobol_1 = cobol;
  cobol.displayName = "cobol";
  cobol.aliases = [];
  function cobol(Prism) {
    Prism.languages.cobol = {
      comment: {
        pattern: /\*>.*|(^[ \t]*)\*.*/m,
        lookbehind: true,
        greedy: true
      },
      string: {
        pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
        greedy: true
      },
      level: {
        pattern: /(^[ \t]*)\d+\b/m,
        lookbehind: true,
        greedy: true,
        alias: "number"
      },
      "class-name": {
        // https://github.com/antlr/grammars-v4/blob/42edd5b687d183b5fa679e858a82297bd27141e7/cobol85/Cobol85.g4#L1015
        pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
        lookbehind: true,
        inside: {
          number: {
            pattern: /(\()\d+/,
            lookbehind: true
          },
          punctuation: /[()]/
        }
      },
      keyword: {
        pattern: /(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
        lookbehind: true
      },
      boolean: {
        pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
        lookbehind: true
      },
      number: {
        pattern: /(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
        lookbehind: true
      },
      operator: [
        /<>|[<>]=?|[=+*/&]/,
        {
          pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
          lookbehind: true
        }
      ],
      punctuation: /[.:,()]/
    };
  }
  return cobol_1;
}
var coffeescript_1;
var hasRequiredCoffeescript;
function requireCoffeescript() {
  if (hasRequiredCoffeescript) return coffeescript_1;
  hasRequiredCoffeescript = 1;
  coffeescript_1 = coffeescript;
  coffeescript.displayName = "coffeescript";
  coffeescript.aliases = ["coffee"];
  function coffeescript(Prism) {
    (function(Prism2) {
      var comment = /#(?!\{).+/;
      var interpolation = {
        pattern: /#\{[^}]+\}/,
        alias: "variable"
      };
      Prism2.languages.coffeescript = Prism2.languages.extend("javascript", {
        comment,
        string: [
          // Strings are multiline
          {
            pattern: /'(?:\\[\s\S]|[^\\'])*'/,
            greedy: true
          },
          {
            // Strings are multiline
            pattern: /"(?:\\[\s\S]|[^\\"])*"/,
            greedy: true,
            inside: {
              interpolation
            }
          }
        ],
        keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
        "class-member": {
          pattern: /@(?!\d)\w+/,
          alias: "variable"
        }
      });
      Prism2.languages.insertBefore("coffeescript", "comment", {
        "multiline-comment": {
          pattern: /###[\s\S]+?###/,
          alias: "comment"
        },
        // Block regexp can contain comments and interpolation
        "block-regex": {
          pattern: /\/{3}[\s\S]*?\/{3}/,
          alias: "regex",
          inside: {
            comment,
            interpolation
          }
        }
      });
      Prism2.languages.insertBefore("coffeescript", "string", {
        "inline-javascript": {
          pattern: /`(?:\\[\s\S]|[^\\`])*`/,
          inside: {
            delimiter: {
              pattern: /^`|`$/,
              alias: "punctuation"
            },
            script: {
              pattern: /[\s\S]+/,
              alias: "language-javascript",
              inside: Prism2.languages.javascript
            }
          }
        },
        // Block strings
        "multiline-string": [
          {
            pattern: /'''[\s\S]*?'''/,
            greedy: true,
            alias: "string"
          },
          {
            pattern: /"""[\s\S]*?"""/,
            greedy: true,
            alias: "string",
            inside: {
              interpolation
            }
          }
        ]
      });
      Prism2.languages.insertBefore("coffeescript", "keyword", {
        // Object property
        property: /(?!\d)\w+(?=\s*:(?!:))/
      });
      delete Prism2.languages.coffeescript["template-string"];
      Prism2.languages.coffee = Prism2.languages.coffeescript;
    })(Prism);
  }
  return coffeescript_1;
}
var concurnas_1;
var hasRequiredConcurnas;
function requireConcurnas() {
  if (hasRequiredConcurnas) return concurnas_1;
  hasRequiredConcurnas = 1;
  concurnas_1 = concurnas;
  concurnas.displayName = "concurnas";
  concurnas.aliases = ["conc"];
  function concurnas(Prism) {
    Prism.languages.concurnas = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
        lookbehind: true,
        greedy: true
      },
      langext: {
        pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
        greedy: true,
        inside: {
          "class-name": /^\w+/,
          string: {
            pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
            lookbehind: true
          },
          punctuation: /\|\|/
        }
      },
      function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
        lookbehind: true
      },
      keyword: /\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
      punctuation: /[{}[\];(),.:]/,
      operator: /<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
      annotation: {
        pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
        alias: "builtin"
      }
    };
    Prism.languages.insertBefore("concurnas", "langext", {
      "regex-literal": {
        pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: Prism.languages.concurnas
          },
          regex: /[\s\S]+/
        }
      },
      "string-literal": {
        pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: Prism.languages.concurnas
          },
          string: /[\s\S]+/
        }
      }
    });
    Prism.languages.conc = Prism.languages.concurnas;
  }
  return concurnas_1;
}
var coq_1;
var hasRequiredCoq;
function requireCoq() {
  if (hasRequiredCoq) return coq_1;
  hasRequiredCoq = 1;
  coq_1 = coq;
  coq.displayName = "coq";
  coq.aliases = [];
  function coq(Prism) {
    (function(Prism2) {
      var commentSource = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source;
      for (var i2 = 0; i2 < 2; i2++) {
        commentSource = commentSource.replace(/<self>/g, function() {
          return commentSource;
        });
      }
      commentSource = commentSource.replace(/<self>/g, "[]");
      Prism2.languages.coq = {
        comment: RegExp(commentSource),
        string: {
          pattern: /"(?:[^"]|"")*"(?!")/,
          greedy: true
        },
        attribute: [
          {
            pattern: RegExp(
              /#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(
                /<comment>/g,
                function() {
                  return commentSource;
                }
              )
            ),
            greedy: true,
            alias: "attr-name",
            inside: {
              comment: RegExp(commentSource),
              string: {
                pattern: /"(?:[^"]|"")*"(?!")/,
                greedy: true
              },
              operator: /=/,
              punctuation: /^#\[|\]$|[,()]/
            }
          },
          {
            pattern: /\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
            alias: "attr-name"
          }
        ],
        keyword: /\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
        number: /\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
        punct: {
          pattern: /@\{|\{\||\[=|:>/,
          alias: "punctuation"
        },
        operator: /\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
        punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
      };
    })(Prism);
  }
  return coq_1;
}
var ruby_1;
var hasRequiredRuby;
function requireRuby() {
  if (hasRequiredRuby) return ruby_1;
  hasRequiredRuby = 1;
  ruby_1 = ruby;
  ruby.displayName = "ruby";
  ruby.aliases = ["rb"];
  function ruby(Prism) {
    (function(Prism2) {
      Prism2.languages.ruby = Prism2.languages.extend("clike", {
        comment: {
          pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
          lookbehind: true,
          inside: {
            punctuation: /[.\\]/
          }
        },
        keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
        operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
        punctuation: /[(){}[\].,;]/
      });
      Prism2.languages.insertBefore("ruby", "operator", {
        "double-colon": {
          pattern: /::/,
          alias: "punctuation"
        }
      });
      var interpolation = {
        pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
        lookbehind: true,
        inside: {
          content: {
            pattern: /^(#\{)[\s\S]+(?=\}$)/,
            lookbehind: true,
            inside: Prism2.languages.ruby
          },
          delimiter: {
            pattern: /^#\{|\}$/,
            alias: "punctuation"
          }
        }
      };
      delete Prism2.languages.ruby.function;
      var percentExpression = "(?:" + [
        /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
        /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
        /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
        /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
        /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
      ].join("|") + ")";
      var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
      Prism2.languages.insertBefore("ruby", "keyword", {
        "regex-literal": [
          {
            pattern: RegExp(
              /%r/.source + percentExpression + /[egimnosux]{0,6}/.source
            ),
            greedy: true,
            inside: {
              interpolation,
              regex: /[\s\S]+/
            }
          },
          {
            pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
            lookbehind: true,
            greedy: true,
            inside: {
              interpolation,
              regex: /[\s\S]+/
            }
          }
        ],
        variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
        symbol: [
          {
            pattern: RegExp(/(^|[^:]):/.source + symbolName),
            lookbehind: true,
            greedy: true
          },
          {
            pattern: RegExp(
              /([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source
            ),
            lookbehind: true,
            greedy: true
          }
        ],
        "method-definition": {
          pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
          lookbehind: true,
          inside: {
            function: /\b\w+$/,
            keyword: /^self\b/,
            "class-name": /^\w+/,
            punctuation: /\./
          }
        }
      });
      Prism2.languages.insertBefore("ruby", "string", {
        "string-literal": [
          {
            pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
            greedy: true,
            inside: {
              interpolation,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
            greedy: true,
            inside: {
              interpolation,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
            alias: "heredoc-string",
            greedy: true,
            inside: {
              delimiter: {
                pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
                inside: {
                  symbol: /\b\w+/,
                  punctuation: /^<<[-~]?/
                }
              },
              interpolation,
              string: /[\s\S]+/
            }
          },
          {
            pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
            alias: "heredoc-string",
            greedy: true,
            inside: {
              delimiter: {
                pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
                inside: {
                  symbol: /\b\w+/,
                  punctuation: /^<<[-~]?'|'$/
                }
              },
              string: /[\s\S]+/
            }
          }
        ],
        "command-literal": [
          {
            pattern: RegExp(/%x/.source + percentExpression),
            greedy: true,
            inside: {
              interpolation,
              command: {
                pattern: /[\s\S]+/,
                alias: "string"
              }
            }
          },
          {
            pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
            greedy: true,
            inside: {
              interpolation,
              command: {
                pattern: /[\s\S]+/,
                alias: "string"
              }
            }
          }
        ]
      });
      delete Prism2.languages.ruby.string;
      Prism2.languages.insertBefore("ruby", "number", {
        builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
        constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
      });
      Prism2.languages.rb = Prism2.languages.ruby;
    })(Prism);
  }
  return ruby_1;
}
var crystal_1;
var hasRequiredCrystal;
function requireCrystal() {
  if (hasRequiredCrystal) return crystal_1;
  hasRequiredCrystal = 1;
  var refractorRuby = requireRuby();
  crystal_1 = crystal;
  crystal.displayName = "crystal";
  crystal.aliases = [];
  function crystal(Prism) {
    Prism.register(refractorRuby);
    (function(Prism2) {
      Prism2.languages.crystal = Prism2.languages.extend("ruby", {
        keyword: [
          /\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
          {
            pattern: /(\.\s*)(?:is_a|responds_to)\?/,
            lookbehind: true
          }
        ],
        number: /\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
        operator: [/->/, Prism2.languages.ruby.operator],
        punctuation: /[(){}[\].,;\\]/
      });
      Prism2.languages.insertBefore("crystal", "string-literal", {
        attribute: {
          pattern: /@\[.*?\]/,
          inside: {
            delimiter: {
              pattern: /^@\[|\]$/,
              alias: "punctuation"
            },
            attribute: {
              pattern: /^(\s*)\w+/,
              lookbehind: true,
              alias: "class-name"
            },
            args: {
              pattern: /\S(?:[\s\S]*\S)?/,
              inside: Prism2.languages.crystal
            }
          }
        },
        expansion: {
          pattern: /\{(?:\{.*?\}|%.*?%)\}/,
          inside: {
            content: {
              pattern: /^(\{.)[\s\S]+(?=.\}$)/,
              lookbehind: true,
              inside: Prism2.languages.crystal
            },
            delimiter: {
              pattern: /^\{[\{%]|[\}%]\}$/,
              alias: "operator"
            }
          }
        },
        char: {
          pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
          greedy: true
        }
      });
    })(Prism);
  }
  return crystal_1;
}
var cshtml_1;
var hasRequiredCshtml;
function requireCshtml() {
  if (hasRequiredCshtml) return cshtml_1;
  hasRequiredCshtml = 1;
  var refractorCsharp = requireCsharp();
  cshtml_1 = cshtml;
  cshtml.displayName = "cshtml";
  cshtml.aliases = ["razor"];
  function cshtml(Prism) {
    Prism.register(refractorCsharp);
    (function(Prism2) {
      var commentLike = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source;
      var stringLike = /@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source + "|" + /'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
      function nested(pattern, depthLog2) {
        for (var i2 = 0; i2 < depthLog2; i2++) {
          pattern = pattern.replace(/<self>/g, function() {
            return "(?:" + pattern + ")";
          });
        }
        return pattern.replace(/<self>/g, "[^\\s\\S]").replace(/<str>/g, "(?:" + stringLike + ")").replace(/<comment>/g, "(?:" + commentLike + ")");
      }
      var round2 = nested(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2);
      var square = nested(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 2);
      var curly = nested(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2);
      var angle = nested(/<(?:[^<>'"@/]|<str>|<comment>|<self>)*>/.source, 2);
      var tagAttrs = /(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?/.source;
      var tagContent = /(?!\d)[^\s>\/=$<%]+/.source + tagAttrs + /\s*\/?>/.source;
      var tagRegion = /\B@?/.source + "(?:" + /<([a-zA-Z][\w:]*)/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
      // eslint-disable-next-line regexp/strict
      /<\/?(?!\1\b)/.source + tagContent + "|" + // nested start tag
      nested(
        // eslint-disable-next-line regexp/strict
        /<\1/.source + tagAttrs + /\s*>/.source + "(?:" + (/[^<]/.source + "|" + // all tags that are not the start tag
        // eslint-disable-next-line regexp/strict
        /<\/?(?!\1\b)/.source + tagContent + "|<self>") + ")*" + // eslint-disable-next-line regexp/strict
        /<\/\1\s*>/.source,
        2
      )) + ")*" + // eslint-disable-next-line regexp/strict
      /<\/\1\s*>/.source + "|" + /</.source + tagContent + ")";
      Prism2.languages.cshtml = Prism2.languages.extend("markup", {});
      var csharpWithHtml = Prism2.languages.insertBefore(
        "csharp",
        "string",
        {
          html: {
            pattern: RegExp(tagRegion),
            greedy: true,
            inside: Prism2.languages.cshtml
          }
        },
        {
          csharp: Prism2.languages.extend("csharp", {})
        }
      );
      var cs = {
        pattern: /\S[\s\S]*/,
        alias: "language-csharp",
        inside: csharpWithHtml
      };
      Prism2.languages.insertBefore("cshtml", "prolog", {
        "razor-comment": {
          pattern: /@\*[\s\S]*?\*@/,
          greedy: true,
          alias: "comment"
        },
        block: {
          pattern: RegExp(
            /(^|[^@])@/.source + "(?:" + [
              // @{ ... }
              curly,
              // @code{ ... }
              /(?:code|functions)\s*/.source + curly,
              // @for (...) { ... }
              /(?:for|foreach|lock|switch|using|while)\s*/.source + round2 + /\s*/.source + curly,
              // @do { ... } while (...);
              /do\s*/.source + curly + /\s*while\s*/.source + round2 + /(?:\s*;)?/.source,
              // @try { ... } catch (...) { ... } finally { ... }
              /try\s*/.source + curly + /\s*catch\s*/.source + round2 + /\s*/.source + curly + /\s*finally\s*/.source + curly,
              // @if (...) {...} else if (...) {...} else {...}
              /if\s*/.source + round2 + /\s*/.source + curly + "(?:" + /\s*else/.source + "(?:" + /\s+if\s*/.source + round2 + ")?" + /\s*/.source + curly + ")*"
            ].join("|") + ")"
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            keyword: /^@\w*/,
            csharp: cs
          }
        },
        directive: {
          pattern: /^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
          lookbehind: true,
          greedy: true,
          inside: {
            keyword: /^@\w+/,
            csharp: cs
          }
        },
        value: {
          pattern: RegExp(
            /(^|[^@])@/.source + /(?:await\b\s*)?/.source + "(?:" + /\w+\b/.source + "|" + round2 + ")(?:" + /[?!]?\.\w+\b/.source + "|" + round2 + "|" + square + "|" + angle + round2 + ")*"
          ),
          lookbehind: true,
          greedy: true,
          alias: "variable",
          inside: {
            keyword: /^@/,
            csharp: cs
          }
        },
        "delegate-operator": {
          pattern: /(^|[^@])@(?=<)/,
          lookbehind: true,
          alias: "operator"
        }
      });
      Prism2.languages.razor = Prism2.languages.cshtml;
    })(Prism);
  }
  return cshtml_1;
}
var csp_1;
var hasRequiredCsp;
function requireCsp() {
  if (hasRequiredCsp) return csp_1;
  hasRequiredCsp = 1;
  csp_1 = csp;
  csp.displayName = "csp";
  csp.aliases = [];
  function csp(Prism) {
    (function(Prism2) {
      function value(source) {
        return RegExp(
          /([ \t])/.source + "(?:" + source + ")" + /(?=[\s;]|$)/.source,
          "i"
        );
      }
      Prism2.languages.csp = {
        directive: {
          pattern: /(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
          lookbehind: true,
          alias: "property"
        },
        scheme: {
          pattern: value(/[a-z][a-z0-9.+-]*:/.source),
          lookbehind: true
        },
        none: {
          pattern: value(/'none'/.source),
          lookbehind: true,
          alias: "keyword"
        },
        nonce: {
          pattern: value(/'nonce-[-+/\w=]+'/.source),
          lookbehind: true,
          alias: "number"
        },
        hash: {
          pattern: value(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
          lookbehind: true,
          alias: "number"
        },
        host: {
          pattern: value(
            /[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source + "|" + /\*[^\s;,']*/.source + "|" + /[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source
          ),
          lookbehind: true,
          alias: "url",
          inside: {
            important: /\*/
          }
        },
        keyword: [
          {
            pattern: value(/'unsafe-[a-z-]+'/.source),
            lookbehind: true,
            alias: "unsafe"
          },
          {
            pattern: value(/'[a-z-]+'/.source),
            lookbehind: true,
            alias: "safe"
          }
        ],
        punctuation: /;/
      };
    })(Prism);
  }
  return csp_1;
}
var cssExtras_1;
var hasRequiredCssExtras;
function requireCssExtras() {
  if (hasRequiredCssExtras) return cssExtras_1;
  hasRequiredCssExtras = 1;
  cssExtras_1 = cssExtras;
  cssExtras.displayName = "cssExtras";
  cssExtras.aliases = [];
  function cssExtras(Prism) {
    (function(Prism2) {
      var string = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
      var selectorInside;
      Prism2.languages.css.selector = {
        pattern: Prism2.languages.css.selector.pattern,
        lookbehind: true,
        inside: selectorInside = {
          "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
          "pseudo-class": /:[-\w]+/,
          class: /\.[-\w]+/,
          id: /#[-\w]+/,
          attribute: {
            pattern: RegExp(`\\[(?:[^[\\]"']|` + string.source + ")*\\]"),
            greedy: true,
            inside: {
              punctuation: /^\[|\]$/,
              "case-sensitivity": {
                pattern: /(\s)[si]$/i,
                lookbehind: true,
                alias: "keyword"
              },
              namespace: {
                pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
                lookbehind: true,
                inside: {
                  punctuation: /\|$/
                }
              },
              "attr-name": {
                pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
                lookbehind: true
              },
              "attr-value": [
                string,
                {
                  pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
                  lookbehind: true
                }
              ],
              operator: /[|~*^$]?=/
            }
          },
          "n-th": [
            {
              pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
              lookbehind: true,
              inside: {
                number: /[\dn]+/,
                operator: /[+-]/
              }
            },
            {
              pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
              lookbehind: true
            }
          ],
          combinator: />|\+|~|\|\|/,
          // the `tag` token has been existed and removed.
          // because we can't find a perfect tokenize to match it.
          // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.
          punctuation: /[(),]/
        }
      };
      Prism2.languages.css["atrule"].inside["selector-function-argument"].inside = selectorInside;
      Prism2.languages.insertBefore("css", "property", {
        variable: {
          pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
          lookbehind: true
        }
      });
      var unit = {
        pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
        lookbehind: true
      };
      var number2 = {
        pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
        lookbehind: true
      };
      Prism2.languages.insertBefore("css", "function", {
        operator: {
          pattern: /(\s)[+\-*\/](?=\s)/,
          lookbehind: true
        },
        // CAREFUL!
        // Previewers and Inline color use hexcode and color.
        hexcode: {
          pattern: /\B#[\da-f]{3,8}\b/i,
          alias: "color"
        },
        color: [
          {
            pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
            lookbehind: true
          },
          {
            pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
            inside: {
              unit,
              number: number2,
              function: /[\w-]+(?=\()/,
              punctuation: /[(),]/
            }
          }
        ],
        // it's important that there is no boundary assertion after the hex digits
        entity: /\\[\da-f]{1,8}/i,
        unit,
        number: number2
      });
    })(Prism);
  }
  return cssExtras_1;
}
var csv_1;
var hasRequiredCsv;
function requireCsv() {
  if (hasRequiredCsv) return csv_1;
  hasRequiredCsv = 1;
  csv_1 = csv;
  csv.displayName = "csv";
  csv.aliases = [];
  function csv(Prism) {
    Prism.languages.csv = {
      value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
      punctuation: /,/
    };
  }
  return csv_1;
}
var cypher_1;
var hasRequiredCypher;
function requireCypher() {
  if (hasRequiredCypher) return cypher_1;
  hasRequiredCypher = 1;
  cypher_1 = cypher;
  cypher.displayName = "cypher";
  cypher.aliases = [];
  function cypher(Prism) {
    Prism.languages.cypher = {
      // https://neo4j.com/docs/cypher-manual/current/syntax/comments/
      comment: /\/\/.*/,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
        greedy: true
      },
      "class-name": {
        pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
        lookbehind: true,
        greedy: true
      },
      relationship: {
        pattern: /(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
        lookbehind: true,
        greedy: true,
        alias: "property"
      },
      identifier: {
        pattern: /`(?:[^`\\\r\n])*`/,
        greedy: true
      },
      variable: /\$\w+/,
      // https://neo4j.com/docs/cypher-manual/current/syntax/reserved/
      keyword: /\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
      function: /\b\w+\b(?=\s*\()/,
      boolean: /\b(?:false|null|true)\b/i,
      number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
      // https://neo4j.com/docs/cypher-manual/current/syntax/operators/
      operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
      punctuation: /[()[\]{},;.]/
    };
  }
  return cypher_1;
}
var d_1;
var hasRequiredD;
function requireD() {
  if (hasRequiredD) return d_1;
  hasRequiredD = 1;
  d_1 = d2;
  d2.displayName = "d";
  d2.aliases = [];
  function d2(Prism) {
    Prism.languages.d = Prism.languages.extend("clike", {
      comment: [
        {
          // Shebang
          pattern: /^\s*#!.+/,
          greedy: true
        },
        {
          pattern: RegExp(
            /(^|[^\\])/.source + "(?:" + [
              // /+ comment +/
              // Allow one level of nesting
              /\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
              // // comment
              /\/\/.*/.source,
              // /* comment */
              /\/\*[\s\S]*?\*\//.source
            ].join("|") + ")"
          ),
          lookbehind: true,
          greedy: true
        }
      ],
      string: [
        {
          pattern: RegExp(
            [
              // r"", x""
              /\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
              // q"[]", q"()", q"<>", q"{}"
              /\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
              // q"IDENT
              // ...
              // IDENT"
              /\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
              // q"//", q"||", etc.
              // eslint-disable-next-line regexp/strict
              /\bq"(.)[\s\S]*?\2"/.source,
              // eslint-disable-next-line regexp/strict
              /(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
            ].join("|"),
            "m"
          ),
          greedy: true
        },
        {
          pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
          greedy: true,
          alias: "token-string"
        }
      ],
      // In order: $, keywords and special tokens, globally defined symbols
      keyword: /\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
      number: [
        // The lookbehind and the negative look-ahead try to prevent bad highlighting of the .. operator
        // Hexadecimal numbers must be handled separately to avoid problems with exponent "e"
        /\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
        {
          pattern: /((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
          lookbehind: true
        }
      ],
      operator: /\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
    });
    Prism.languages.insertBefore("d", "string", {
      // Characters
      // 'a', '\\', '\n', '\xFF', '\377', '\uFFFF', '\U0010FFFF', '\quot'
      char: /'(?:\\(?:\W|\w+)|[^\\])'/
    });
    Prism.languages.insertBefore("d", "keyword", {
      property: /\B@\w*/
    });
    Prism.languages.insertBefore("d", "function", {
      register: {
        // Iasm registers
        pattern: /\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
        alias: "variable"
      }
    });
  }
  return d_1;
}
var dart_1;
var hasRequiredDart;
function requireDart() {
  if (hasRequiredDart) return dart_1;
  hasRequiredDart = 1;
  dart_1 = dart;
  dart.displayName = "dart";
  dart.aliases = [];
  function dart(Prism) {
    (function(Prism2) {
      var keywords = [
        /\b(?:async|sync|yield)\*/,
        /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
      ];
      var packagePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
      var className = {
        pattern: RegExp(packagePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: true,
        inside: {
          namespace: {
            pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
            inside: {
              punctuation: /\./
            }
          }
        }
      };
      Prism2.languages.dart = Prism2.languages.extend("clike", {
        "class-name": [
          className,
          {
            // variables and parameters
            // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
            pattern: RegExp(
              packagePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
            ),
            lookbehind: true,
            inside: className.inside
          }
        ],
        keyword: keywords,
        operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
      });
      Prism2.languages.insertBefore("dart", "string", {
        "string-literal": {
          pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
          greedy: true,
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
              lookbehind: true,
              inside: {
                punctuation: /^\$\{?|\}$/,
                expression: {
                  pattern: /[\s\S]+/,
                  inside: Prism2.languages.dart
                }
              }
            },
            string: /[\s\S]+/
          }
        },
        string: void 0
      });
      Prism2.languages.insertBefore("dart", "class-name", {
        metadata: {
          pattern: /@\w+/,
          alias: "function"
        }
      });
      Prism2.languages.insertBefore("dart", "class-name", {
        generics: {
          pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
          inside: {
            "class-name": className,
            keyword: keywords,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
          }
        }
      });
    })(Prism);
  }
  return dart_1;
}
var dataweave_1;
var hasRequiredDataweave;
function requireDataweave() {
  if (hasRequiredDataweave) return dataweave_1;
  hasRequiredDataweave = 1;
  dataweave_1 = dataweave;
  dataweave.displayName = "dataweave";
  dataweave.aliases = [];
  function dataweave(Prism) {
    (function(Prism2) {
      Prism2.languages.dataweave = {
        url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
        property: {
          pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
          greedy: true
        },
        string: {
          pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
          greedy: true
        },
        "mime-type": /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
        date: {
          pattern: /\|[\w:+-]+\|/,
          greedy: true
        },
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        regex: {
          pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
          greedy: true
        },
        keyword: /\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
        function: /\b[A-Z_]\w*(?=\s*\()/i,
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        punctuation: /[{}[\];(),.:@]/,
        operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
        boolean: /\b(?:false|true)\b/
      };
    })(Prism);
  }
  return dataweave_1;
}
var dax_1;
var hasRequiredDax;
function requireDax() {
  if (hasRequiredDax) return dax_1;
  hasRequiredDax = 1;
  dax_1 = dax;
  dax.displayName = "dax";
  dax.aliases = [];
  function dax(Prism) {
    Prism.languages.dax = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
        lookbehind: true
      },
      "data-field": {
        pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
        alias: "symbol"
      },
      measure: {
        pattern: /\[[ \w\xA0-\uFFFF]+\]/,
        alias: "constant"
      },
      string: {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: true
      },
      function: /\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
      keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
      boolean: {
        pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
        alias: "constant"
      },
      number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
      operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
      punctuation: /[;\[\](){}`,.]/
    };
  }
  return dax_1;
}
var dhall_1;
var hasRequiredDhall;
function requireDhall() {
  if (hasRequiredDhall) return dhall_1;
  hasRequiredDhall = 1;
  dhall_1 = dhall;
  dhall.displayName = "dhall";
  dhall.aliases = [];
  function dhall(Prism) {
    Prism.languages.dhall = {
      // Multi-line comments can be nested. E.g. {- foo {- bar -} -}
      // The multi-line pattern is essentially this:
      //   \{-(?:[^-{]|-(?!\})|\{(?!-)|<SELF>)*-\}
      comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
      string: {
        pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /\$\{[^{}]*\}/,
            inside: {
              expression: {
                pattern: /(^\$\{)[\s\S]+(?=\}$)/,
                lookbehind: true,
                alias: "language-dhall",
                inside: null
                // see blow
              },
              punctuation: /\$\{|\}/
            }
          }
        }
      },
      label: {
        pattern: /`[^`]*`/,
        greedy: true
      },
      url: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L596
        pattern: /\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
        greedy: true
      },
      env: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L661
        pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
        greedy: true,
        inside: {
          function: /^env/,
          operator: /^:/,
          variable: /[\s\S]+/
        }
      },
      hash: {
        // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L725
        pattern: /\bsha256:[\da-fA-F]{64}\b/,
        inside: {
          function: /sha256/,
          operator: /:/,
          number: /[\da-fA-F]{64}/
        }
      },
      // https://github.com/dhall-lang/dhall-lang/blob/5fde8ef1bead6fb4e999d3c1ffe7044cd019d63a/standard/dhall.abnf#L359
      keyword: /\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
      builtin: /\b(?:None|Some)\b/,
      boolean: /\b(?:False|True)\b/,
      number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
      operator: /\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
      punctuation: /\.\.|[{}\[\](),./]/,
      // we'll just assume that every capital word left is a type name
      "class-name": /\b[A-Z]\w*\b/
    };
    Prism.languages.dhall.string.inside.interpolation.inside.expression.inside = Prism.languages.dhall;
  }
  return dhall_1;
}
var diff_1;
var hasRequiredDiff;
function requireDiff() {
  if (hasRequiredDiff) return diff_1;
  hasRequiredDiff = 1;
  diff_1 = diff;
  diff.displayName = "diff";
  diff.aliases = [];
  function diff(Prism) {
    (function(Prism2) {
      Prism2.languages.diff = {
        coord: [
          // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
          /^(?:\*{3}|-{3}|\+{3}).*$/m,
          // Match "@@ ... @@" coord lines in unified diff.
          /^@@.*@@$/m,
          // Match coord lines in normal diff (starts with a number).
          /^\d.*$/m
        ]
        // deleted, inserted, unchanged, diff
      };
      var PREFIXES = {
        "deleted-sign": "-",
        "deleted-arrow": "<",
        "inserted-sign": "+",
        "inserted-arrow": ">",
        unchanged: " ",
        diff: "!"
      };
      Object.keys(PREFIXES).forEach(function(name) {
        var prefix = PREFIXES[name];
        var alias = [];
        if (!/^\w+$/.test(name)) {
          alias.push(/\w+/.exec(name)[0]);
        }
        if (name === "diff") {
          alias.push("bold");
        }
        Prism2.languages.diff[name] = {
          pattern: RegExp(
            "^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+",
            "m"
          ),
          alias,
          inside: {
            line: {
              pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
              lookbehind: true
            },
            prefix: {
              pattern: /[\s\S]/,
              alias: /\w+/.exec(name)[0]
            }
          }
        };
      });
      Object.defineProperty(Prism2.languages.diff, "PREFIXES", {
        value: PREFIXES
      });
    })(Prism);
  }
  return diff_1;
}
var markupTemplating_1;
var hasRequiredMarkupTemplating;
function requireMarkupTemplating() {
  if (hasRequiredMarkupTemplating) return markupTemplating_1;
  hasRequiredMarkupTemplating = 1;
  markupTemplating_1 = markupTemplating;
  markupTemplating.displayName = "markupTemplating";
  markupTemplating.aliases = [];
  function markupTemplating(Prism) {
    (function(Prism2) {
      function getPlaceholder(language, index2) {
        return "___" + language.toUpperCase() + index2 + "___";
      }
      Object.defineProperties(Prism2.languages["markup-templating"] = {}, {
        buildPlaceholders: {
          /**
           * Tokenize all inline templating expressions matching `placeholderPattern`.
           *
           * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
           * `true` will be replaced.
           *
           * @param {object} env The environment of the `before-tokenize` hook.
           * @param {string} language The language id.
           * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
           * @param {(match: string) => boolean} [replaceFilter]
           */
          value: function(env, language, placeholderPattern, replaceFilter) {
            if (env.language !== language) {
              return;
            }
            var tokenStack = env.tokenStack = [];
            env.code = env.code.replace(placeholderPattern, function(match2) {
              if (typeof replaceFilter === "function" && !replaceFilter(match2)) {
                return match2;
              }
              var i2 = tokenStack.length;
              var placeholder;
              while (env.code.indexOf(placeholder = getPlaceholder(language, i2)) !== -1) {
                ++i2;
              }
              tokenStack[i2] = match2;
              return placeholder;
            });
            env.grammar = Prism2.languages.markup;
          }
        },
        tokenizePlaceholders: {
          /**
           * Replace placeholders with proper tokens after tokenizing.
           *
           * @param {object} env The environment of the `after-tokenize` hook.
           * @param {string} language The language id.
           */
          value: function(env, language) {
            if (env.language !== language || !env.tokenStack) {
              return;
            }
            env.grammar = Prism2.languages[language];
            var j2 = 0;
            var keys = Object.keys(env.tokenStack);
            function walkTokens(tokens) {
              for (var i2 = 0; i2 < tokens.length; i2++) {
                if (j2 >= keys.length) {
                  break;
                }
                var token = tokens[i2];
                if (typeof token === "string" || token.content && typeof token.content === "string") {
                  var k2 = keys[j2];
                  var t2 = env.tokenStack[k2];
                  var s2 = typeof token === "string" ? token : token.content;
                  var placeholder = getPlaceholder(language, k2);
                  var index2 = s2.indexOf(placeholder);
                  if (index2 > -1) {
                    ++j2;
                    var before = s2.substring(0, index2);
                    var middle = new Prism2.Token(
                      language,
                      Prism2.tokenize(t2, env.grammar),
                      "language-" + language,
                      t2
                    );
                    var after = s2.substring(index2 + placeholder.length);
                    var replacement = [];
                    if (before) {
                      replacement.push.apply(replacement, walkTokens([before]));
                    }
                    replacement.push(middle);
                    if (after) {
                      replacement.push.apply(replacement, walkTokens([after]));
                    }
                    if (typeof token === "string") {
                      tokens.splice.apply(tokens, [i2, 1].concat(replacement));
                    } else {
                      token.content = replacement;
                    }
                  }
                } else if (token.content) {
                  walkTokens(token.content);
                }
              }
              return tokens;
            }
            walkTokens(env.tokens);
          }
        }
      });
    })(Prism);
  }
  return markupTemplating_1;
}
var django_1;
var hasRequiredDjango;
function requireDjango() {
  if (hasRequiredDjango) return django_1;
  hasRequiredDjango = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  django_1 = django;
  django.displayName = "django";
  django.aliases = ["jinja2"];
  function django(Prism) {
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      Prism2.languages.django = {
        comment: /^\{#[\s\S]*?#\}$/,
        tag: {
          pattern: /(^\{%[+-]?\s*)\w+/,
          lookbehind: true,
          alias: "keyword"
        },
        delimiter: {
          pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
          alias: "punctuation"
        },
        string: {
          pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        filter: {
          pattern: /(\|)\w+/,
          lookbehind: true,
          alias: "function"
        },
        test: {
          pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
          lookbehind: true,
          alias: "function"
        },
        function: /\b[a-z_]\w+(?=\s*\()/i,
        keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
        operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
        number: /\b\d+(?:\.\d+)?\b/,
        boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
        variable: /\b\w+\b/,
        punctuation: /[{}[\](),.:;]/
      };
      var pattern = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g;
      var markupTemplating = Prism2.languages["markup-templating"];
      Prism2.hooks.add("before-tokenize", function(env) {
        markupTemplating.buildPlaceholders(env, "django", pattern);
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        markupTemplating.tokenizePlaceholders(env, "django");
      });
      Prism2.languages.jinja2 = Prism2.languages.django;
      Prism2.hooks.add("before-tokenize", function(env) {
        markupTemplating.buildPlaceholders(env, "jinja2", pattern);
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        markupTemplating.tokenizePlaceholders(env, "jinja2");
      });
    })(Prism);
  }
  return django_1;
}
var dnsZoneFile_1;
var hasRequiredDnsZoneFile;
function requireDnsZoneFile() {
  if (hasRequiredDnsZoneFile) return dnsZoneFile_1;
  hasRequiredDnsZoneFile = 1;
  dnsZoneFile_1 = dnsZoneFile;
  dnsZoneFile.displayName = "dnsZoneFile";
  dnsZoneFile.aliases = [];
  function dnsZoneFile(Prism) {
    Prism.languages["dns-zone-file"] = {
      comment: /;.*/,
      string: {
        pattern: /"(?:\\.|[^"\\\r\n])*"/,
        greedy: true
      },
      variable: [
        {
          pattern: /(^\$ORIGIN[ \t]+)\S+/m,
          lookbehind: true
        },
        {
          pattern: /(^|\s)@(?=\s|$)/,
          lookbehind: true
        }
      ],
      keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
      class: {
        // https://tools.ietf.org/html/rfc1035#page-13
        pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
        lookbehind: true,
        alias: "keyword"
      },
      type: {
        // https://en.wikipedia.org/wiki/List_of_DNS_record_types
        pattern: /(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
        lookbehind: true,
        alias: "keyword"
      },
      punctuation: /[()]/
    };
    Prism.languages["dns-zone"] = Prism.languages["dns-zone-file"];
  }
  return dnsZoneFile_1;
}
var docker_1;
var hasRequiredDocker;
function requireDocker() {
  if (hasRequiredDocker) return docker_1;
  hasRequiredDocker = 1;
  docker_1 = docker;
  docker.displayName = "docker";
  docker.aliases = ["dockerfile"];
  function docker(Prism) {
    (function(Prism2) {
      var spaceAfterBackSlash = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source;
      var space = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(
        /<SP_BS>/g,
        function() {
          return spaceAfterBackSlash;
        }
      );
      var string = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source;
      var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(
        /<STR>/g,
        function() {
          return string;
        }
      );
      var stringRule = {
        pattern: RegExp(string),
        greedy: true
      };
      var commentRule = {
        pattern: /(^[ \t]*)#.*/m,
        lookbehind: true,
        greedy: true
      };
      function re2(source, flags) {
        source = source.replace(/<OPT>/g, function() {
          return option;
        }).replace(/<SP>/g, function() {
          return space;
        });
        return RegExp(source, flags);
      }
      Prism2.languages.docker = {
        instruction: {
          pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
          lookbehind: true,
          greedy: true,
          inside: {
            options: {
              pattern: re2(
                /(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source,
                "i"
              ),
              lookbehind: true,
              greedy: true,
              inside: {
                property: {
                  pattern: /(^|\s)--[\w-]+/,
                  lookbehind: true
                },
                string: [
                  stringRule,
                  {
                    pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
                    lookbehind: true
                  }
                ],
                operator: /\\$/m,
                punctuation: /=/
              }
            },
            keyword: [
              {
                // https://docs.docker.com/engine/reference/builder/#healthcheck
                pattern: re2(
                  /(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source,
                  "i"
                ),
                lookbehind: true,
                greedy: true
              },
              {
                // https://docs.docker.com/engine/reference/builder/#from
                pattern: re2(
                  /(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source,
                  "i"
                ),
                lookbehind: true,
                greedy: true
              },
              {
                // https://docs.docker.com/engine/reference/builder/#onbuild
                pattern: re2(/(^ONBUILD<SP>)\w+/.source, "i"),
                lookbehind: true,
                greedy: true
              },
              {
                pattern: /^\w+/,
                greedy: true
              }
            ],
            comment: commentRule,
            string: stringRule,
            variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
            operator: /\\$/m
          }
        },
        comment: commentRule
      };
      Prism2.languages.dockerfile = Prism2.languages.docker;
    })(Prism);
  }
  return docker_1;
}
var dot_1;
var hasRequiredDot;
function requireDot() {
  if (hasRequiredDot) return dot_1;
  hasRequiredDot = 1;
  dot_1 = dot;
  dot.displayName = "dot";
  dot.aliases = ["gv"];
  function dot(Prism) {
    (function(Prism2) {
      var ID = "(?:" + [
        // an identifier
        /[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
        // a number
        /-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
        // a double-quoted string
        /"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
        // HTML-like string
        /<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
      ].join("|") + ")";
      var IDInside = {
        markup: {
          pattern: /(^<)[\s\S]+(?=>$)/,
          lookbehind: true,
          alias: ["language-markup", "language-html", "language-xml"],
          inside: Prism2.languages.markup
        }
      };
      function withID(source, flags) {
        return RegExp(
          source.replace(/<ID>/g, function() {
            return ID;
          }),
          flags
        );
      }
      Prism2.languages.dot = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
          greedy: true
        },
        "graph-name": {
          pattern: withID(
            /(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source,
            "i"
          ),
          lookbehind: true,
          greedy: true,
          alias: "class-name",
          inside: IDInside
        },
        "attr-value": {
          pattern: withID(/(=[ \t\r\n]*)<ID>/.source),
          lookbehind: true,
          greedy: true,
          inside: IDInside
        },
        "attr-name": {
          pattern: withID(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
          lookbehind: true,
          greedy: true,
          inside: IDInside
        },
        keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
        "compass-point": {
          pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
          lookbehind: true,
          alias: "builtin"
        },
        node: {
          pattern: withID(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
          lookbehind: true,
          greedy: true,
          inside: IDInside
        },
        operator: /[=:]|-[->]/,
        punctuation: /[\[\]{};,]/
      };
      Prism2.languages.gv = Prism2.languages.dot;
    })(Prism);
  }
  return dot_1;
}
var ebnf_1;
var hasRequiredEbnf;
function requireEbnf() {
  if (hasRequiredEbnf) return ebnf_1;
  hasRequiredEbnf = 1;
  ebnf_1 = ebnf;
  ebnf.displayName = "ebnf";
  ebnf.aliases = [];
  function ebnf(Prism) {
    Prism.languages.ebnf = {
      comment: /\(\*[\s\S]*?\*\)/,
      string: {
        pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
        greedy: true
      },
      special: {
        pattern: /\?[^?\r\n]*\?/,
        greedy: true,
        alias: "class-name"
      },
      definition: {
        pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
        lookbehind: true,
        alias: ["rule", "keyword"]
      },
      rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
      punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
      operator: /[-=|*/!]/
    };
  }
  return ebnf_1;
}
var editorconfig_1;
var hasRequiredEditorconfig;
function requireEditorconfig() {
  if (hasRequiredEditorconfig) return editorconfig_1;
  hasRequiredEditorconfig = 1;
  editorconfig_1 = editorconfig;
  editorconfig.displayName = "editorconfig";
  editorconfig.aliases = [];
  function editorconfig(Prism) {
    Prism.languages.editorconfig = {
      // https://editorconfig-specification.readthedocs.io
      comment: /[;#].*/,
      section: {
        pattern: /(^[ \t]*)\[.+\]/m,
        lookbehind: true,
        alias: "selector",
        inside: {
          regex: /\\\\[\[\]{},!?.*]/,
          // Escape special characters with '\\'
          operator: /[!?]|\.\.|\*{1,2}/,
          punctuation: /[\[\]{},]/
        }
      },
      key: {
        pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
        lookbehind: true,
        alias: "attr-name"
      },
      value: {
        pattern: /=.*/,
        alias: "attr-value",
        inside: {
          punctuation: /^=/
        }
      }
    };
  }
  return editorconfig_1;
}
var eiffel_1;
var hasRequiredEiffel;
function requireEiffel() {
  if (hasRequiredEiffel) return eiffel_1;
  hasRequiredEiffel = 1;
  eiffel_1 = eiffel;
  eiffel.displayName = "eiffel";
  eiffel.aliases = [];
  function eiffel(Prism) {
    Prism.languages.eiffel = {
      comment: /--.*/,
      string: [
        // Aligned-verbatim-strings
        {
          pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
          greedy: true
        },
        // Non-aligned-verbatim-strings
        {
          pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
          greedy: true
        },
        // Single-line string
        {
          pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
          greedy: true
        }
      ],
      // normal char | special char | char code
      char: /'(?:%.|[^%'\r\n])+'/,
      keyword: /\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
      boolean: /\b(?:False|True)\b/i,
      // Convention: class-names are always all upper-case characters
      "class-name": /\b[A-Z][\dA-Z_]*\b/,
      number: [
        // hexa | octal | bin
        /\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
        // Decimal
        /(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
      ],
      punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
      operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
    };
  }
  return eiffel_1;
}
var ejs_1;
var hasRequiredEjs;
function requireEjs() {
  if (hasRequiredEjs) return ejs_1;
  hasRequiredEjs = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  ejs_1 = ejs;
  ejs.displayName = "ejs";
  ejs.aliases = ["eta"];
  function ejs(Prism) {
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      Prism2.languages.ejs = {
        delimiter: {
          pattern: /^<%[-_=]?|[-_]?%>$/,
          alias: "punctuation"
        },
        comment: /^#[\s\S]*/,
        "language-javascript": {
          pattern: /[\s\S]+/,
          inside: Prism2.languages.javascript
        }
      };
      Prism2.hooks.add("before-tokenize", function(env) {
        var ejsPattern = /<%(?!%)[\s\S]+?%>/g;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "ejs",
          ejsPattern
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "ejs");
      });
      Prism2.languages.eta = Prism2.languages.ejs;
    })(Prism);
  }
  return ejs_1;
}
var elixir_1;
var hasRequiredElixir;
function requireElixir() {
  if (hasRequiredElixir) return elixir_1;
  hasRequiredElixir = 1;
  elixir_1 = elixir;
  elixir.displayName = "elixir";
  elixir.aliases = [];
  function elixir(Prism) {
    Prism.languages.elixir = {
      doc: {
        pattern: /@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
        inside: {
          attribute: /^@\w+/,
          string: /['"][\s\S]+/
        }
      },
      comment: {
        pattern: /#.*/,
        greedy: true
      },
      // ~r"""foo""" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r"foo", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>
      regex: {
        pattern: /~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
        greedy: true
      },
      string: [
        {
          // ~s"""foo""" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s"foo", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>
          pattern: /~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
          greedy: true,
          inside: {
            // See interpolation below
          }
        },
        {
          pattern: /("""|''')[\s\S]*?\1/,
          greedy: true,
          inside: {
            // See interpolation below
          }
        },
        {
          // Multi-line strings are allowed
          pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true,
          inside: {
            // See interpolation below
          }
        }
      ],
      atom: {
        // Look-behind prevents bad highlighting of the :: operator
        pattern: /(^|[^:]):\w+/,
        lookbehind: true,
        alias: "symbol"
      },
      module: {
        pattern: /\b[A-Z]\w*\b/,
        alias: "class-name"
      },
      // Look-ahead prevents bad highlighting of the :: operator
      "attr-name": /\b\w+\??:(?!:)/,
      argument: {
        // Look-behind prevents bad highlighting of the && operator
        pattern: /(^|[^&])&\d+/,
        lookbehind: true,
        alias: "variable"
      },
      attribute: {
        pattern: /@\w+/,
        alias: "variable"
      },
      function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
      number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
      keyword: /\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
      boolean: /\b(?:false|nil|true)\b/,
      operator: [
        /\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
        {
          // We don't want to match <<
          pattern: /([^<])<(?!<)/,
          lookbehind: true
        },
        {
          // We don't want to match >>
          pattern: /([^>])>(?!>)/,
          lookbehind: true
        }
      ],
      punctuation: /<<|>>|[.,%\[\]{}()]/
    };
    Prism.languages.elixir.string.forEach(function(o4) {
      o4.inside = {
        interpolation: {
          pattern: /#\{[^}]+\}/,
          inside: {
            delimiter: {
              pattern: /^#\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism.languages.elixir
          }
        }
      };
    });
  }
  return elixir_1;
}
var elm_1;
var hasRequiredElm;
function requireElm() {
  if (hasRequiredElm) return elm_1;
  hasRequiredElm = 1;
  elm_1 = elm;
  elm.displayName = "elm";
  elm.aliases = [];
  function elm(Prism) {
    Prism.languages.elm = {
      comment: /--.*|\{-[\s\S]*?-\}/,
      char: {
        pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
        greedy: true
      },
      string: [
        {
          // Multiline strings are wrapped in triple ". Quotes may appear unescaped.
          pattern: /"""[\s\S]*?"""/,
          greedy: true
        },
        {
          pattern: /"(?:[^\\"\r\n]|\\.)*"/,
          greedy: true
        }
      ],
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
        lookbehind: true,
        inside: {
          keyword: /\b(?:as|exposing|import)\b/
        }
      },
      keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
      // These are builtin variables only. Constructors are highlighted later as a constant.
      builtin: /\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
      // decimal integers and floating point numbers | hexadecimal integers
      number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
      // Most of this is needed because of the meaning of a single '.'.
      // If it stands alone freely, it is the function composition.
      // It may also be a separator between a module name and an identifier => no
      // operator. If it comes together with other special characters it is an
      // operator too.
      // Valid operator characters in 0.18: +-/*=.$<>:&|^?%#@~!
      // Ref: https://groups.google.com/forum/#!msg/elm-dev/0AHSnDdkSkQ/E0SVU70JEQAJ
      operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
      // In Elm, nearly everything is a variable, do not highlight these.
      hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
      constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
      punctuation: /[{}[\]|(),.:]/
    };
  }
  return elm_1;
}
var erb_1;
var hasRequiredErb;
function requireErb() {
  if (hasRequiredErb) return erb_1;
  hasRequiredErb = 1;
  var refractorRuby = requireRuby();
  var refractorMarkupTemplating = requireMarkupTemplating();
  erb_1 = erb;
  erb.displayName = "erb";
  erb.aliases = [];
  function erb(Prism) {
    Prism.register(refractorRuby);
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      Prism2.languages.erb = {
        delimiter: {
          pattern: /^(\s*)<%=?|%>(?=\s*$)/,
          lookbehind: true,
          alias: "punctuation"
        },
        ruby: {
          pattern: /\s*\S[\s\S]*/,
          alias: "language-ruby",
          inside: Prism2.languages.ruby
        }
      };
      Prism2.hooks.add("before-tokenize", function(env) {
        var erbPattern = /<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "erb",
          erbPattern
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "erb");
      });
    })(Prism);
  }
  return erb_1;
}
var erlang_1;
var hasRequiredErlang;
function requireErlang() {
  if (hasRequiredErlang) return erlang_1;
  hasRequiredErlang = 1;
  erlang_1 = erlang;
  erlang.displayName = "erlang";
  erlang.aliases = [];
  function erlang(Prism) {
    Prism.languages.erlang = {
      comment: /%.+/,
      string: {
        pattern: /"(?:\\.|[^\\"\r\n])*"/,
        greedy: true
      },
      "quoted-function": {
        pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
        alias: "function"
      },
      "quoted-atom": {
        pattern: /'(?:\\.|[^\\'\r\n])+'/,
        alias: "atom"
      },
      boolean: /\b(?:false|true)\b/,
      keyword: /\b(?:after|case|catch|end|fun|if|of|receive|try|when)\b/,
      number: [
        /\$\\?./,
        /\b\d+#[a-z0-9]+/i,
        /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
      ],
      function: /\b[a-z][\w@]*(?=\()/,
      variable: {
        // Look-behind is used to prevent wrong highlighting of atoms containing "@"
        pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
        lookbehind: true
      },
      operator: [
        /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
        {
          // We don't want to match <<
          pattern: /(^|[^<])<(?!<)/,
          lookbehind: true
        },
        {
          // We don't want to match >>
          pattern: /(^|[^>])>(?!>)/,
          lookbehind: true
        }
      ],
      atom: /\b[a-z][\w@]*/,
      punctuation: /[()[\]{}:;,.#|]|<<|>>/
    };
  }
  return erlang_1;
}
var lua_1;
var hasRequiredLua;
function requireLua() {
  if (hasRequiredLua) return lua_1;
  hasRequiredLua = 1;
  lua_1 = lua;
  lua.displayName = "lua";
  lua.aliases = [];
  function lua(Prism) {
    Prism.languages.lua = {
      comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
      // \z may be used to skip the following space
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
        greedy: true
      },
      number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
      keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
      function: /(?!\d)\w+(?=\s*(?:[({]))/,
      operator: [
        /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
        {
          // Match ".." but don't break "..."
          pattern: /(^|[^.])\.\.(?!\.)/,
          lookbehind: true
        }
      ],
      punctuation: /[\[\](){},;]|\.+|:+/
    };
  }
  return lua_1;
}
var etlua_1;
var hasRequiredEtlua;
function requireEtlua() {
  if (hasRequiredEtlua) return etlua_1;
  hasRequiredEtlua = 1;
  var refractorLua = requireLua();
  var refractorMarkupTemplating = requireMarkupTemplating();
  etlua_1 = etlua;
  etlua.displayName = "etlua";
  etlua.aliases = [];
  function etlua(Prism) {
    Prism.register(refractorLua);
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      Prism2.languages.etlua = {
        delimiter: {
          pattern: /^<%[-=]?|-?%>$/,
          alias: "punctuation"
        },
        "language-lua": {
          pattern: /[\s\S]+/,
          inside: Prism2.languages.lua
        }
      };
      Prism2.hooks.add("before-tokenize", function(env) {
        var pattern = /<%[\s\S]+?%>/g;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "etlua",
          pattern
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "etlua");
      });
    })(Prism);
  }
  return etlua_1;
}
var excelFormula_1;
var hasRequiredExcelFormula;
function requireExcelFormula() {
  if (hasRequiredExcelFormula) return excelFormula_1;
  hasRequiredExcelFormula = 1;
  excelFormula_1 = excelFormula;
  excelFormula.displayName = "excelFormula";
  excelFormula.aliases = [];
  function excelFormula(Prism) {
    Prism.languages["excel-formula"] = {
      comment: {
        pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
        lookbehind: true,
        greedy: true
      },
      string: {
        pattern: /"(?:[^"]|"")*"(?!")/,
        greedy: true
      },
      reference: {
        // https://www.ablebits.com/office-addins-blog/2015/12/08/excel-reference-another-sheet-workbook/
        // Sales!B2
        // 'Winter sales'!B2
        // [Sales.xlsx]Jan!B2:B5
        // D:\Reports\[Sales.xlsx]Jan!B2:B5
        // '[Sales.xlsx]Jan sales'!B2:B5
        // 'D:\Reports\[Sales.xlsx]Jan sales'!B2:B5
        pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
        greedy: true,
        alias: "string",
        inside: {
          operator: /!$/,
          punctuation: /'/,
          sheet: {
            pattern: /[^[\]]+$/,
            alias: "function"
          },
          file: {
            pattern: /\[[^[\]]+\]$/,
            inside: {
              punctuation: /[[\]]/
            }
          },
          path: /[\s\S]+/
        }
      },
      "function-name": {
        pattern: /\b[A-Z]\w*(?=\()/i,
        alias: "keyword"
      },
      range: {
        pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
        alias: "property",
        inside: {
          operator: /:/,
          cell: /\$?[A-Z]+\$?\d+/i,
          column: /\$?[A-Z]+/i,
          row: /\$?\d+/
        }
      },
      cell: {
        // Excel is case insensitive, so the string "foo1" could be either a variable or a cell.
        // To combat this, we match cells case insensitive, if the contain at least one "$", and case sensitive otherwise.
        pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
        alias: "property"
      },
      number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
      boolean: /\b(?:FALSE|TRUE)\b/i,
      operator: /[-+*/^%=&,]|<[=>]?|>=?/,
      punctuation: /[[\]();{}|]/
    };
    Prism.languages["xlsx"] = Prism.languages["xls"] = Prism.languages["excel-formula"];
  }
  return excelFormula_1;
}
var factor_1;
var hasRequiredFactor;
function requireFactor() {
  if (hasRequiredFactor) return factor_1;
  hasRequiredFactor = 1;
  factor_1 = factor;
  factor.displayName = "factor";
  factor.aliases = [];
  function factor(Prism) {
    (function(Prism2) {
      var comment_inside = {
        function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
      };
      var string_inside = {
        number: /\\[^\s']|%\w/
      };
      var factor2 = {
        comment: [
          {
            // ! single-line exclamation point comments with whitespace after/around the !
            pattern: /(^|\s)(?:! .*|!$)/,
            lookbehind: true,
            inside: comment_inside
          },
          /* from basis/multiline: */
          {
            // /* comment */, /* comment*/
            pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
            lookbehind: true,
            greedy: true,
            inside: comment_inside
          },
          {
            // ![[ comment ]] , ![===[ comment]===]
            pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
            lookbehind: true,
            greedy: true,
            inside: comment_inside
          }
        ],
        number: [
          {
            // basic base 10 integers 9, -9
            pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
            lookbehind: true
          },
          {
            // base prefix integers 0b010 0o70 0xad 0d10 0XAD -0xa9
            pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
            lookbehind: true
          },
          {
            // fractional ratios 1/5 -1/5 and the literal float approximations 1/5. -1/5.
            pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
            lookbehind: true
          },
          {
            // positive mixed numbers 23+1/5 +23+1/5
            pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
            lookbehind: true
          },
          {
            // negative mixed numbers -23-1/5
            pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
            lookbehind: true
          },
          {
            // basic decimal floats -0.01 0. .0 .1 -.1 -1. -12.13 +12.13
            // and scientific notation with base 10 exponents 3e4 3e-4 .3e-4
            pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
            lookbehind: true
          },
          {
            // NAN literal syntax NAN: 80000deadbeef, NAN: a
            pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
            lookbehind: true
          },
          {
            /*
            base prefix floats 0x1.0p3 (8.0) 0b1.010p2 (5.0) 0x1.p1 0b1.11111111p11111...
            "The normalized hex form ±0x1.MMMMMMMMMMMMM[pP]±EEEE allows any floating-point number to be specified precisely.
            The values of MMMMMMMMMMMMM and EEEE map directly to the mantissa and exponent fields of the binary IEEE 754 representation."
            <https://docs.factorcode.org/content/article-syntax-floats.html>
            */
            pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
            lookbehind: true
          }
        ],
        // R/ regexp?\/\\/
        regexp: {
          pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
          lookbehind: true,
          alias: "number",
          inside: {
            variable: /\\\S/,
            keyword: /[+?*\[\]^$(){}.|]/,
            operator: {
              pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
              lookbehind: true
            }
          }
        },
        boolean: {
          pattern: /(^|\s)[tf](?=\s|$)/,
          lookbehind: true
        },
        // SBUF" asd", URL" ://...", P" /etc/"
        "custom-string": {
          pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
          lookbehind: true,
          greedy: true,
          alias: "string",
          inside: {
            number: /\\\S|%\w|\//
          }
        },
        "multiline-string": [
          {
            // STRING: name \n content \n ; -> CONSTANT: name "content" (symbol)
            pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
            lookbehind: true,
            greedy: true,
            alias: "string",
            inside: {
              number: string_inside.number,
              // trailing semicolon on its own line
              "semicolon-or-setlocal": {
                pattern: /([\r\n][ \t]*);(?=\s|$)/,
                lookbehind: true,
                alias: "function"
              }
            }
          },
          {
            // HEREDOC: marker \n content \n marker ; -> "content" (immediate)
            pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
            lookbehind: true,
            greedy: true,
            alias: "string",
            inside: string_inside
          },
          {
            // [[ string ]], [==[ string]==]
            pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
            lookbehind: true,
            greedy: true,
            alias: "string",
            inside: string_inside
          }
        ],
        "special-using": {
          pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
          lookbehind: true,
          alias: "function",
          inside: {
            // this is essentially a regex for vocab names, which i don't want to specify
            // but the USING: gets picked up as a vocab name
            string: {
              pattern: /(\s)[^:\s]+/,
              lookbehind: true
            }
          }
        },
        /* this description of stack effect literal syntax is not complete and not as specific as theoretically possible
        trying to do better is more work and regex-computation-time than it's worth though.
        - we'd like to have the "delimiter" parts of the stack effect [ (, --, and ) ] be a different (less-important or comment-like) colour to the stack effect contents
        - we'd like if nested stack effects were treated as such rather than just appearing flat (with `inside`)
        - we'd like if the following variable name conventions were recognised specifically:
        special row variables = ..a b..
        type and stack effect annotations end with a colon = ( quot: ( a: ( -- ) -- b ) -- x ), ( x: number -- )
        word throws unconditional error = *
        any other word-like variable name = a ? q' etc
        https://docs.factorcode.org/content/article-effects.html
        these are pretty complicated to highlight properly without a real parser, and therefore out of scope
        the old pattern, which may be later useful, was: (^|\s)(?:call|execute|eval)?\((?:\s+[^"\r\n\t ]\S*)*?\s+--(?:\s+[^"\n\t ]\S*)*?\s+\)(?=\s|$)
        */
        // current solution is not great
        "stack-effect-delimiter": [
          {
            // opening parenthesis
            pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
            lookbehind: true,
            alias: "operator"
          },
          {
            // middle --
            pattern: /(\s)--(?=\s)/,
            lookbehind: true,
            alias: "operator"
          },
          {
            // closing parenthesis
            pattern: /(\s)\)(?=\s|$)/,
            lookbehind: true,
            alias: "operator"
          }
        ],
        combinators: {
          pattern: null,
          lookbehind: true,
          alias: "keyword"
        },
        "kernel-builtin": {
          pattern: null,
          lookbehind: true,
          alias: "variable"
        },
        "sequences-builtin": {
          pattern: null,
          lookbehind: true,
          alias: "variable"
        },
        "math-builtin": {
          pattern: null,
          lookbehind: true,
          alias: "variable"
        },
        "constructor-word": {
          // <array> but not <=>
          pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
          lookbehind: true,
          alias: "keyword"
        },
        "other-builtin-syntax": {
          pattern: null,
          lookbehind: true,
          alias: "operator"
        },
        /*
        full list of supported word naming conventions: (the convention appears outside of the [brackets])
        set-[x]
        change-[x]
        with-[x]
        new-[x]
        >[string]
        [base]>
        [string]>[number]
        +[symbol]+
        [boolean-word]?
        ?[of]
        [slot-reader]>>
        >>[slot-setter]
        [slot-writer]<<
        ([implementation-detail])
        [mutater]!
        [variant]*
        [prettyprint].
        $[help-markup]
        <constructors>, SYNTAX:, etc are supported by their own patterns.
        `with` and `new` from `kernel` are their own builtins.
        see <https://docs.factorcode.org/content/article-conventions.html>
        */
        "conventionally-named-word": {
          pattern: /(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
          lookbehind: true,
          alias: "keyword"
        },
        "colon-syntax": {
          pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
          lookbehind: true,
          greedy: true,
          alias: "function"
        },
        "semicolon-or-setlocal": {
          pattern: /(\s)(?:;|:>)(?=\s|$)/,
          lookbehind: true,
          alias: "function"
        },
        // do not highlight leading } or trailing X{ at the begin/end of the file as it's invalid syntax
        "curly-brace-literal-delimiter": [
          {
            // opening
            pattern: /(^|\s)[a-z]*\{(?=\s)/i,
            lookbehind: true,
            alias: "operator"
          },
          {
            // closing
            pattern: /(\s)\}(?=\s|$)/,
            lookbehind: true,
            alias: "operator"
          }
        ],
        // do not highlight leading ] or trailing [ at the begin/end of the file as it's invalid syntax
        "quotation-delimiter": [
          {
            // opening
            pattern: /(^|\s)\[(?=\s)/,
            lookbehind: true,
            alias: "operator"
          },
          {
            // closing
            pattern: /(\s)\](?=\s|$)/,
            lookbehind: true,
            alias: "operator"
          }
        ],
        "normal-word": {
          pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
          lookbehind: true
        },
        /*
        basic first-class string "a"
        with escaped double-quote "a\""
        escaped backslash "\\"
        and general escapes since Factor has so many "\N"
        syntax that works in the reference implementation that isn't fully
        supported because it's an implementation detail:
        "string 1""string 2" -> 2 strings (works anyway)
        "string"5 -> string, 5
        "string"[ ] -> string, quotation
        { "a"} -> array<string>
        the rest of those examples all properly recognise the string, but not
        the other object (number, quotation, etc)
        this is fine for a regex-only implementation.
        */
        string: {
          pattern: /"(?:\\\S|[^"\\])*"/,
          greedy: true,
          inside: string_inside
        }
      };
      var escape = function(str) {
        return (str + "").replace(/([.?*+\^$\[\]\\(){}|\-])/g, "\\$1");
      };
      var arrToWordsRegExp = function(arr) {
        return new RegExp("(^|\\s)(?:" + arr.map(escape).join("|") + ")(?=\\s|$)");
      };
      var builtins = {
        "kernel-builtin": [
          "or",
          "2nipd",
          "4drop",
          "tuck",
          "wrapper",
          "nip",
          "wrapper?",
          "callstack>array",
          "die",
          "dupd",
          "callstack",
          "callstack?",
          "3dup",
          "hashcode",
          "pick",
          "4nip",
          "build",
          ">boolean",
          "nipd",
          "clone",
          "5nip",
          "eq?",
          "?",
          "=",
          "swapd",
          "2over",
          "clear",
          "2dup",
          "get-retainstack",
          "not",
          "tuple?",
          "dup",
          "3nipd",
          "call",
          "-rotd",
          "object",
          "drop",
          "assert=",
          "assert?",
          "-rot",
          "execute",
          "boa",
          "get-callstack",
          "curried?",
          "3drop",
          "pickd",
          "overd",
          "over",
          "roll",
          "3nip",
          "swap",
          "and",
          "2nip",
          "rotd",
          "throw",
          "(clone)",
          "hashcode*",
          "spin",
          "reach",
          "4dup",
          "equal?",
          "get-datastack",
          "assert",
          "2drop",
          "<wrapper>",
          "boolean?",
          "identity-hashcode",
          "identity-tuple?",
          "null",
          "composed?",
          "new",
          "5drop",
          "rot",
          "-roll",
          "xor",
          "identity-tuple",
          "boolean"
        ],
        "other-builtin-syntax": [
          // syntax
          "=======",
          "recursive",
          "flushable",
          ">>",
          "<<<<<<",
          "M\\",
          "B",
          "PRIVATE>",
          "\\",
          "======",
          "final",
          "inline",
          "delimiter",
          "deprecated",
          "<PRIVATE",
          ">>>>>>",
          "<<<<<<<",
          "parse-complex",
          "malformed-complex",
          "read-only",
          ">>>>>>>",
          "call-next-method",
          "<<",
          "foldable",
          // literals
          "$",
          "$[",
          "${"
        ],
        "sequences-builtin": [
          "member-eq?",
          "mismatch",
          "append",
          "assert-sequence=",
          "longer",
          "repetition",
          "clone-like",
          "3sequence",
          "assert-sequence?",
          "last-index-from",
          "reversed",
          "index-from",
          "cut*",
          "pad-tail",
          "join-as",
          "remove-eq!",
          "concat-as",
          "but-last",
          "snip",
          "nths",
          "nth",
          "sequence",
          "longest",
          "slice?",
          "<slice>",
          "remove-nth",
          "tail-slice",
          "empty?",
          "tail*",
          "member?",
          "virtual-sequence?",
          "set-length",
          "drop-prefix",
          "iota",
          "unclip",
          "bounds-error?",
          "unclip-last-slice",
          "non-negative-integer-expected",
          "non-negative-integer-expected?",
          "midpoint@",
          "longer?",
          "?set-nth",
          "?first",
          "rest-slice",
          "prepend-as",
          "prepend",
          "fourth",
          "sift",
          "subseq-start",
          "new-sequence",
          "?last",
          "like",
          "first4",
          "1sequence",
          "reverse",
          "slice",
          "virtual@",
          "repetition?",
          "set-last",
          "index",
          "4sequence",
          "max-length",
          "set-second",
          "immutable-sequence",
          "first2",
          "first3",
          "supremum",
          "unclip-slice",
          "suffix!",
          "insert-nth",
          "tail",
          "3append",
          "short",
          "suffix",
          "concat",
          "flip",
          "immutable?",
          "reverse!",
          "2sequence",
          "sum",
          "delete-all",
          "indices",
          "snip-slice",
          "<iota>",
          "check-slice",
          "sequence?",
          "head",
          "append-as",
          "halves",
          "sequence=",
          "collapse-slice",
          "?second",
          "slice-error?",
          "product",
          "bounds-check?",
          "bounds-check",
          "immutable",
          "virtual-exemplar",
          "harvest",
          "remove",
          "pad-head",
          "last",
          "set-fourth",
          "cartesian-product",
          "remove-eq",
          "shorten",
          "shorter",
          "reversed?",
          "shorter?",
          "shortest",
          "head-slice",
          "pop*",
          "tail-slice*",
          "but-last-slice",
          "iota?",
          "append!",
          "cut-slice",
          "new-resizable",
          "head-slice*",
          "sequence-hashcode",
          "pop",
          "set-nth",
          "?nth",
          "second",
          "join",
          "immutable-sequence?",
          "<reversed>",
          "3append-as",
          "virtual-sequence",
          "subseq?",
          "remove-nth!",
          "length",
          "last-index",
          "lengthen",
          "assert-sequence",
          "copy",
          "move",
          "third",
          "first",
          "tail?",
          "set-first",
          "prefix",
          "bounds-error",
          "<repetition>",
          "exchange",
          "surround",
          "cut",
          "min-length",
          "set-third",
          "push-all",
          "head?",
          "subseq-start-from",
          "delete-slice",
          "rest",
          "sum-lengths",
          "head*",
          "infimum",
          "remove!",
          "glue",
          "slice-error",
          "subseq",
          "push",
          "replace-slice",
          "subseq-as",
          "unclip-last"
        ],
        "math-builtin": [
          "number=",
          "next-power-of-2",
          "?1+",
          "fp-special?",
          "imaginary-part",
          "float>bits",
          "number?",
          "fp-infinity?",
          "bignum?",
          "fp-snan?",
          "denominator",
          "gcd",
          "*",
          "+",
          "fp-bitwise=",
          "-",
          "u>=",
          "/",
          ">=",
          "bitand",
          "power-of-2?",
          "log2-expects-positive",
          "neg?",
          "<",
          "log2",
          ">",
          "integer?",
          "number",
          "bits>double",
          "2/",
          "zero?",
          "bits>float",
          "float?",
          "shift",
          "ratio?",
          "rect>",
          "even?",
          "ratio",
          "fp-sign",
          "bitnot",
          ">fixnum",
          "complex?",
          "/i",
          "integer>fixnum",
          "/f",
          "sgn",
          ">bignum",
          "next-float",
          "u<",
          "u>",
          "mod",
          "recip",
          "rational",
          ">float",
          "2^",
          "integer",
          "fixnum?",
          "neg",
          "fixnum",
          "sq",
          "bignum",
          ">rect",
          "bit?",
          "fp-qnan?",
          "simple-gcd",
          "complex",
          "<fp-nan>",
          "real",
          ">fraction",
          "double>bits",
          "bitor",
          "rem",
          "fp-nan-payload",
          "real-part",
          "log2-expects-positive?",
          "prev-float",
          "align",
          "unordered?",
          "float",
          "fp-nan?",
          "abs",
          "bitxor",
          "integer>fixnum-strict",
          "u<=",
          "odd?",
          "<=",
          "/mod",
          ">integer",
          "real?",
          "rational?",
          "numerator"
        ]
        // that's all for now
      };
      Object.keys(builtins).forEach(function(k2) {
        factor2[k2].pattern = arrToWordsRegExp(builtins[k2]);
      });
      var combinators = [
        // kernel
        "2bi",
        "while",
        "2tri",
        "bi*",
        "4dip",
        "both?",
        "same?",
        "tri@",
        "curry",
        "prepose",
        "3bi",
        "?if",
        "tri*",
        "2keep",
        "3keep",
        "curried",
        "2keepd",
        "when",
        "2bi*",
        "2tri*",
        "4keep",
        "bi@",
        "keepdd",
        "do",
        "unless*",
        "tri-curry",
        "if*",
        "loop",
        "bi-curry*",
        "when*",
        "2bi@",
        "2tri@",
        "with",
        "2with",
        "either?",
        "bi",
        "until",
        "3dip",
        "3curry",
        "tri-curry*",
        "tri-curry@",
        "bi-curry",
        "keepd",
        "compose",
        "2dip",
        "if",
        "3tri",
        "unless",
        "tuple",
        "keep",
        "2curry",
        "tri",
        "most",
        "while*",
        "dip",
        "composed",
        "bi-curry@",
        // sequences
        "find-last-from",
        "trim-head-slice",
        "map-as",
        "each-from",
        "none?",
        "trim-tail",
        "partition",
        "if-empty",
        "accumulate*",
        "reject!",
        "find-from",
        "accumulate-as",
        "collector-for-as",
        "reject",
        "map",
        "map-sum",
        "accumulate!",
        "2each-from",
        "follow",
        "supremum-by",
        "map!",
        "unless-empty",
        "collector",
        "padding",
        "reduce-index",
        "replicate-as",
        "infimum-by",
        "trim-tail-slice",
        "count",
        "find-index",
        "filter",
        "accumulate*!",
        "reject-as",
        "map-integers",
        "map-find",
        "reduce",
        "selector",
        "interleave",
        "2map",
        "filter-as",
        "binary-reduce",
        "map-index-as",
        "find",
        "produce",
        "filter!",
        "replicate",
        "cartesian-map",
        "cartesian-each",
        "find-index-from",
        "map-find-last",
        "3map-as",
        "3map",
        "find-last",
        "selector-as",
        "2map-as",
        "2map-reduce",
        "accumulate",
        "each",
        "each-index",
        "accumulate*-as",
        "when-empty",
        "all?",
        "collector-as",
        "push-either",
        "new-like",
        "collector-for",
        "2selector",
        "push-if",
        "2all?",
        "map-reduce",
        "3each",
        "any?",
        "trim-slice",
        "2reduce",
        "change-nth",
        "produce-as",
        "2each",
        "trim",
        "trim-head",
        "cartesian-find",
        "map-index",
        // math
        "if-zero",
        "each-integer",
        "unless-zero",
        "(find-integer)",
        "when-zero",
        "find-last-integer",
        "(all-integers?)",
        "times",
        "(each-integer)",
        "find-integer",
        "all-integers?",
        // math.combinators
        "unless-negative",
        "if-positive",
        "when-positive",
        "when-negative",
        "unless-positive",
        "if-negative",
        // combinators
        "case",
        "2cleave",
        "cond>quot",
        "case>quot",
        "3cleave",
        "wrong-values",
        "to-fixed-point",
        "alist>quot",
        "cond",
        "cleave",
        "call-effect",
        "recursive-hashcode",
        "spread",
        "deep-spread>quot",
        // combinators.short-circuit
        "2||",
        "0||",
        "n||",
        "0&&",
        "2&&",
        "3||",
        "1||",
        "1&&",
        "n&&",
        "3&&",
        // combinators.smart
        "smart-unless*",
        "keep-inputs",
        "reduce-outputs",
        "smart-when*",
        "cleave>array",
        "smart-with",
        "smart-apply",
        "smart-if",
        "inputs/outputs",
        "output>sequence-n",
        "map-outputs",
        "map-reduce-outputs",
        "dropping",
        "output>array",
        "smart-map-reduce",
        "smart-2map-reduce",
        "output>array-n",
        "nullary",
        "input<sequence",
        "append-outputs",
        "drop-inputs",
        "inputs",
        "smart-2reduce",
        "drop-outputs",
        "smart-reduce",
        "preserving",
        "smart-when",
        "outputs",
        "append-outputs-as",
        "smart-unless",
        "smart-if*",
        "sum-outputs",
        "input<sequence-unsafe",
        "output>sequence"
        // tafn
      ];
      factor2.combinators.pattern = arrToWordsRegExp(combinators);
      Prism2.languages.factor = factor2;
    })(Prism);
  }
  return factor_1;
}
var _false;
var hasRequired_false;
function require_false() {
  if (hasRequired_false) return _false;
  hasRequired_false = 1;
  _false = $false;
  $false.displayName = "$false";
  $false.aliases = [];
  function $false(Prism) {
    (function(Prism2) {
      Prism2.languages["false"] = {
        comment: {
          pattern: /\{[^}]*\}/
        },
        string: {
          pattern: /"[^"]*"/,
          greedy: true
        },
        "character-code": {
          pattern: /'(?:[^\r]|\r\n?)/,
          alias: "number"
        },
        "assembler-code": {
          pattern: /\d+`/,
          alias: "important"
        },
        number: /\d+/,
        operator: /[-!#$%&'*+,./:;=>?@\\^_`|~ßø]/,
        punctuation: /\[|\]/,
        variable: /[a-z]/,
        "non-standard": {
          pattern: /[()<BDO®]/,
          alias: "bold"
        }
      };
    })(Prism);
  }
  return _false;
}
var firestoreSecurityRules_1;
var hasRequiredFirestoreSecurityRules;
function requireFirestoreSecurityRules() {
  if (hasRequiredFirestoreSecurityRules) return firestoreSecurityRules_1;
  hasRequiredFirestoreSecurityRules = 1;
  firestoreSecurityRules_1 = firestoreSecurityRules;
  firestoreSecurityRules.displayName = "firestoreSecurityRules";
  firestoreSecurityRules.aliases = [];
  function firestoreSecurityRules(Prism) {
    Prism.languages["firestore-security-rules"] = Prism.languages.extend(
      "clike",
      {
        comment: /\/\/.*/,
        keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
        operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
      }
    );
    delete Prism.languages["firestore-security-rules"]["class-name"];
    Prism.languages.insertBefore("firestore-security-rules", "keyword", {
      path: {
        pattern: /(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
        lookbehind: true,
        greedy: true,
        inside: {
          variable: {
            pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
            inside: {
              operator: /=/,
              keyword: /\*\*/,
              punctuation: /[.$(){}]/
            }
          },
          punctuation: /\//
        }
      },
      method: {
        // to make the pattern shorter, the actual method names are omitted
        pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
        lookbehind: true,
        alias: "builtin",
        inside: {
          punctuation: /,/
        }
      }
    });
  }
  return firestoreSecurityRules_1;
}
var flow_1;
var hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow) return flow_1;
  hasRequiredFlow = 1;
  flow_1 = flow;
  flow.displayName = "flow";
  flow.aliases = [];
  function flow(Prism) {
    (function(Prism2) {
      Prism2.languages.flow = Prism2.languages.extend("javascript", {});
      Prism2.languages.insertBefore("flow", "keyword", {
        type: [
          {
            pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|any|mixed|null|void)\b/,
            alias: "tag"
          }
        ]
      });
      Prism2.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i;
      delete Prism2.languages.flow["parameter"];
      Prism2.languages.insertBefore("flow", "operator", {
        "flow-punctuation": {
          pattern: /\{\||\|\}/,
          alias: "punctuation"
        }
      });
      if (!Array.isArray(Prism2.languages.flow.keyword)) {
        Prism2.languages.flow.keyword = [Prism2.languages.flow.keyword];
      }
      Prism2.languages.flow.keyword.unshift(
        {
          pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
          lookbehind: true
        },
        {
          pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
          lookbehind: true
        }
      );
    })(Prism);
  }
  return flow_1;
}
var fortran_1;
var hasRequiredFortran;
function requireFortran() {
  if (hasRequiredFortran) return fortran_1;
  hasRequiredFortran = 1;
  fortran_1 = fortran;
  fortran.displayName = "fortran";
  fortran.aliases = [];
  function fortran(Prism) {
    Prism.languages.fortran = {
      "quoted-number": {
        pattern: /[BOZ](['"])[A-F0-9]+\1/i,
        alias: "number"
      },
      string: {
        pattern: /(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
        inside: {
          comment: {
            pattern: /(&(?:\r\n?|\n)\s*)!.*/,
            lookbehind: true
          }
        }
      },
      comment: {
        pattern: /!.*/,
        greedy: true
      },
      boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
      keyword: [
        // Types
        /\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
        // END statements
        /\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
        // Statements
        /\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
        // Others
        /\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
      ],
      operator: [
        /\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i,
        {
          // Use lookbehind to prevent confusion with (/ /)
          pattern: /(^|(?!\().)\/(?!\))/,
          lookbehind: true
        }
      ],
      punctuation: /\(\/|\/\)|[(),;:&]/
    };
  }
  return fortran_1;
}
var fsharp_1;
var hasRequiredFsharp;
function requireFsharp() {
  if (hasRequiredFsharp) return fsharp_1;
  hasRequiredFsharp = 1;
  fsharp_1 = fsharp;
  fsharp.displayName = "fsharp";
  fsharp.aliases = [];
  function fsharp(Prism) {
    Prism.languages.fsharp = Prism.languages.extend("clike", {
      comment: [
        {
          pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
        lookbehind: true,
        inside: {
          operator: /->|\*/,
          punctuation: /\./
        }
      },
      keyword: /\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
      number: [
        /\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
        /\b0b[01]+(?:uy|y)?\b/,
        /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
        /\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
      ],
      operator: /([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
    });
    Prism.languages.insertBefore("fsharp", "keyword", {
      preprocessor: {
        pattern: /(^[\t ]*)#.*/m,
        lookbehind: true,
        alias: "property",
        inside: {
          directive: {
            pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
            lookbehind: true,
            alias: "keyword"
          }
        }
      }
    });
    Prism.languages.insertBefore("fsharp", "punctuation", {
      "computation-expression": {
        pattern: /\b[_a-z]\w*(?=\s*\{)/i,
        alias: "keyword"
      }
    });
    Prism.languages.insertBefore("fsharp", "string", {
      annotation: {
        pattern: /\[<.+?>\]/,
        greedy: true,
        inside: {
          punctuation: /^\[<|>\]$/,
          "class-name": {
            pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
            lookbehind: true
          },
          "annotation-content": {
            pattern: /[\s\S]+/,
            inside: Prism.languages.fsharp
          }
        }
      },
      char: {
        pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
        greedy: true
      }
    });
  }
  return fsharp_1;
}
var ftl_1;
var hasRequiredFtl;
function requireFtl() {
  if (hasRequiredFtl) return ftl_1;
  hasRequiredFtl = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  ftl_1 = ftl;
  ftl.displayName = "ftl";
  ftl.aliases = [];
  function ftl(Prism) {
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      var FTL_EXPR = /[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/.source;
      for (var i2 = 0; i2 < 2; i2++) {
        FTL_EXPR = FTL_EXPR.replace(/<expr>/g, function() {
          return FTL_EXPR;
        });
      }
      FTL_EXPR = FTL_EXPR.replace(/<expr>/g, /[^\s\S]/.source);
      var ftl2 = {
        comment: /<#--[\s\S]*?-->/,
        string: [
          {
            // raw string
            pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
            greedy: true
          },
          {
            pattern: RegExp(
              /("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(
                /<expr>/g,
                function() {
                  return FTL_EXPR;
                }
              )
            ),
            greedy: true,
            inside: {
              interpolation: {
                pattern: RegExp(
                  /((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(
                    /<expr>/g,
                    function() {
                      return FTL_EXPR;
                    }
                  )
                ),
                lookbehind: true,
                inside: {
                  "interpolation-punctuation": {
                    pattern: /^\$\{|\}$/,
                    alias: "punctuation"
                  },
                  rest: null
                }
              }
            }
          }
        ],
        keyword: /\b(?:as)\b/,
        boolean: /\b(?:false|true)\b/,
        "builtin-function": {
          pattern: /((?:^|[^?])\?\s*)\w+/,
          lookbehind: true,
          alias: "function"
        },
        function: /\b\w+(?=\s*\()/,
        number: /\b\d+(?:\.\d+)?\b/,
        operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
        punctuation: /[,;.:()[\]{}]/
      };
      ftl2.string[1].inside.interpolation.inside.rest = ftl2;
      Prism2.languages.ftl = {
        "ftl-comment": {
          // the pattern is shortened to be more efficient
          pattern: /^<#--[\s\S]*/,
          alias: "comment"
        },
        "ftl-directive": {
          pattern: /^<[\s\S]+>$/,
          inside: {
            directive: {
              pattern: /(^<\/?)[#@][a-z]\w*/i,
              lookbehind: true,
              alias: "keyword"
            },
            punctuation: /^<\/?|\/?>$/,
            content: {
              pattern: /\s*\S[\s\S]*/,
              alias: "ftl",
              inside: ftl2
            }
          }
        },
        "ftl-interpolation": {
          pattern: /^\$\{[\s\S]*\}$/,
          inside: {
            punctuation: /^\$\{|\}$/,
            content: {
              pattern: /\s*\S[\s\S]*/,
              alias: "ftl",
              inside: ftl2
            }
          }
        }
      };
      Prism2.hooks.add("before-tokenize", function(env) {
        var pattern = RegExp(
          /<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(
            /<expr>/g,
            function() {
              return FTL_EXPR;
            }
          ),
          "gi"
        );
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "ftl",
          pattern
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "ftl");
      });
    })(Prism);
  }
  return ftl_1;
}
var gap_1;
var hasRequiredGap;
function requireGap() {
  if (hasRequiredGap) return gap_1;
  hasRequiredGap = 1;
  gap_1 = gap;
  gap.displayName = "gap";
  gap.aliases = [];
  function gap(Prism) {
    Prism.languages.gap = {
      shell: {
        pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
        greedy: true,
        inside: {
          gap: {
            pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
            lookbehind: true,
            inside: null
            // see below
          },
          punctuation: /^gap>/
        }
      },
      comment: {
        pattern: /#.*/,
        greedy: true
      },
      string: {
        pattern: /(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
        lookbehind: true,
        greedy: true,
        inside: {
          continuation: {
            pattern: /([\r\n])>/,
            lookbehind: true,
            alias: "punctuation"
          }
        }
      },
      keyword: /\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: {
        pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
        lookbehind: true
      },
      continuation: {
        pattern: /([\r\n])>/,
        lookbehind: true,
        alias: "punctuation"
      },
      operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
      punctuation: /[()[\]{},;.:]/
    };
    Prism.languages.gap.shell.inside.gap.inside = Prism.languages.gap;
  }
  return gap_1;
}
var gcode_1;
var hasRequiredGcode;
function requireGcode() {
  if (hasRequiredGcode) return gcode_1;
  hasRequiredGcode = 1;
  gcode_1 = gcode;
  gcode.displayName = "gcode";
  gcode.aliases = [];
  function gcode(Prism) {
    Prism.languages.gcode = {
      comment: /;.*|\B\(.*?\)\B/,
      string: {
        pattern: /"(?:""|[^"])*"/,
        greedy: true
      },
      keyword: /\b[GM]\d+(?:\.\d+)?\b/,
      property: /\b[A-Z]/,
      checksum: {
        pattern: /(\*)\d+/,
        lookbehind: true,
        alias: "number"
      },
      // T0:0:0
      punctuation: /[:*]/
    };
  }
  return gcode_1;
}
var gdscript_1;
var hasRequiredGdscript;
function requireGdscript() {
  if (hasRequiredGdscript) return gdscript_1;
  hasRequiredGdscript = 1;
  gdscript_1 = gdscript;
  gdscript.displayName = "gdscript";
  gdscript.aliases = [];
  function gdscript(Prism) {
    Prism.languages.gdscript = {
      comment: /#.*/,
      string: {
        pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
        greedy: true
      },
      "class-name": {
        // class_name Foo, extends Bar, class InnerClass
        // export(int) var baz, export(int, 0) var i
        // as Node
        // const FOO: int = 9, var bar: bool = true
        // func add(reference: Item, amount: int) -> Item:
        pattern: /(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
        lookbehind: true
      },
      keyword: /\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
      function: /\b[a-z_]\w*(?=[ \t]*\()/i,
      variable: /\$\w+/,
      number: [
        /\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/,
        /\b(?:INF|NAN|PI|TAU)\b/
      ],
      constant: /\b[A-Z][A-Z_\d]*\b/,
      boolean: /\b(?:false|true)\b/,
      operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
      punctuation: /[.:,;()[\]{}]/
    };
  }
  return gdscript_1;
}
var gedcom_1;
var hasRequiredGedcom;
function requireGedcom() {
  if (hasRequiredGedcom) return gedcom_1;
  hasRequiredGedcom = 1;
  gedcom_1 = gedcom;
  gedcom.displayName = "gedcom";
  gedcom.aliases = [];
  function gedcom(Prism) {
    Prism.languages.gedcom = {
      "line-value": {
        // Preceded by level, optional pointer, and tag
        pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
        lookbehind: true,
        inside: {
          pointer: {
            pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
            alias: "variable"
          }
        }
      },
      tag: {
        // Preceded by level and optional pointer
        pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
        lookbehind: true,
        alias: "string"
      },
      level: {
        pattern: /(^[\t ]*)\d+/m,
        lookbehind: true,
        alias: "number"
      },
      pointer: {
        pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
        alias: "variable"
      }
    };
  }
  return gedcom_1;
}
var gherkin_1;
var hasRequiredGherkin;
function requireGherkin() {
  if (hasRequiredGherkin) return gherkin_1;
  hasRequiredGherkin = 1;
  gherkin_1 = gherkin;
  gherkin.displayName = "gherkin";
  gherkin.aliases = [];
  function gherkin(Prism) {
    (function(Prism2) {
      var tableRow = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
      Prism2.languages.gherkin = {
        pystring: {
          pattern: /("""|''')[\s\S]+?\1/,
          alias: "string"
        },
        comment: {
          pattern: /(^[ \t]*)#.*/m,
          lookbehind: true
        },
        tag: {
          pattern: /(^[ \t]*)@\S*/m,
          lookbehind: true
        },
        feature: {
          pattern: /((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Característica|Egenskab|Egenskap|Eiginleiki|Feature|Fīča|Fitur|Fonctionnalité|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcţionalitate|Funcționalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitāte|Funkcionalnost|Funkcja|Funksie|Funktionalität|Funktionalitéit|Funzionalità|Hwaet|Hwæt|Jellemző|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogućnost|Moznosti|Možnosti|OH HAI|Omadus|Ominaisuus|Osobina|Özellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Požadavek|Požiadavka|Pretty much|Qap|Qu'meH 'ut|Savybė|Tính năng|Trajto|Vermoë|Vlastnosť|Właściwość|Značilnost|Δυνατότητα|Λειτουργία|Могућност|Мөмкинлек|Особина|Свойство|Үзенчәлеклелек|Функционал|Функционалност|Функция|Функціонал|תכונה|خاصية|خصوصیت|صلاحیت|کاروبار کی ضرورت|وِیژگی|रूप लेख|ਖਾਸੀਅਤ|ਨਕਸ਼ ਨੁਹਾਰ|ਮੁਹਾਂਦਰਾ|గుణము|ಹೆಚ್ಚಳ|ความต้องการทางธุรกิจ|ความสามารถ|โครงหลัก|기능|フィーチャ|功能|機能):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
          lookbehind: true,
          inside: {
            important: {
              pattern: /(:)[^\r\n]+/,
              lookbehind: true
            },
            keyword: /[^:\r\n]+:/
          }
        },
        scenario: {
          pattern: /(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|Ær|Agtergrond|All y'all|Antecedentes|Antecedents|Atburðarás|Atburðarásir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bối cảnh|Cefndir|Cenario|Cenário|Cenario de Fundo|Cenário de Fundo|Cenarios|Cenários|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dæmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineação do Cenário|Dis is what went down|Dữ liệu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenário|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatókönyv|Forgatókönyv vázlat|Fundo|Geçmiş|Grundlage|Hannergrond|ghantoH|Háttér|Heave to|Istorik|Juhtumid|Keadaan|Khung kịch bản|Khung tình huống|Kịch bản|Koncept|Konsep skenario|Kontèks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lýsing Atburðarásar|Lýsing Dæma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Náčrt Scenára|Náčrt Scénáře|Náčrt Scenáru|Oris scenarija|Örnekler|Osnova|Osnova Scenára|Osnova scénáře|Osnutek|Ozadje|Paraugs|Pavyzdžiai|Példák|Piemēri|Plan du scénario|Plan du Scénario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozadí|Pozadie|Pozadina|Príklady|Příklady|Primer|Primeri|Primjeri|Przykłady|Raamstsenaarium|Reckon it's like|Rerefons|Scenár|Scénář|Scenarie|Scenarij|Scenarijai|Scenarijaus šablonas|Scenariji|Scenārijs|Scenārijs pēc parauga|Scenarijus|Scenario|Scénario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se ðe|Se the|Se þe|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo taslağı|Shiver me timbers|Situācija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structură scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwær swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tình huống|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Założenia|Παραδείγματα|Περιγραφή Σεναρίου|Σενάρια|Σενάριο|Υπόβαθρο|Кереш|Контекст|Концепт|Мисаллар|Мисоллар|Основа|Передумова|Позадина|Предистория|Предыстория|Приклади|Пример|Примери|Примеры|Рамка на сценарий|Скица|Структура сценарија|Структура сценария|Структура сценарію|Сценарий|Сценарий структураси|Сценарийның төзелеше|Сценарији|Сценарио|Сценарій|Тарих|Үрнәкләр|דוגמאות|רקע|תבנית תרחיש|תרחיש|الخلفية|الگوی سناریو|امثلة|پس منظر|زمینه|سناریو|سيناريو|سيناريو مخطط|مثالیں|منظر نامے کا خاکہ|منظرنامہ|نمونه ها|उदाहरण|परिदृश्य|परिदृश्य रूपरेखा|पृष्ठभूमि|ਉਦਾਹਰਨਾਂ|ਪਟਕਥਾ|ਪਟਕਥਾ ਢਾਂਚਾ|ਪਟਕਥਾ ਰੂਪ ਰੇਖਾ|ਪਿਛੋਕੜ|ఉదాహరణలు|కథనం|నేపథ్యం|సన్నివేశం|ಉದಾಹರಣೆಗಳು|ಕಥಾಸಾರಾಂಶ|ವಿವರಣೆ|ಹಿನ್ನೆಲೆ|โครงสร้างของเหตุการณ์|ชุดของตัวอย่าง|ชุดของเหตุการณ์|แนวคิด|สรุปเหตุการณ์|เหตุการณ์|배경|시나리오|시나리오 개요|예|サンプル|シナリオ|シナリオアウトライン|シナリオテンプレ|シナリオテンプレート|テンプレ|例|例子|剧本|剧本大纲|劇本|劇本大綱|场景|场景大纲|場景|場景大綱|背景):[^:\r\n]*/m,
          lookbehind: true,
          inside: {
            important: {
              pattern: /(:)[^\r\n]*/,
              lookbehind: true
            },
            keyword: /[^:\r\n]+:/
          }
        },
        "table-body": {
          // Look-behind is used to skip the table head, which has the same format as any table row
          pattern: RegExp("(" + tableRow + ")(?:" + tableRow + ")+"),
          lookbehind: true,
          inside: {
            outline: {
              pattern: /<[^>]+>/,
              alias: "variable"
            },
            td: {
              pattern: /\s*[^\s|][^|]*/,
              alias: "string"
            },
            punctuation: /\|/
          }
        },
        "table-head": {
          pattern: RegExp(tableRow),
          inside: {
            th: {
              pattern: /\s*[^\s|][^|]*/,
              alias: "variable"
            },
            punctuation: /\|/
          }
        },
        atrule: {
          pattern: /(^[ \t]+)(?:'a|'ach|'ej|7|a|A také|A taktiež|A tiež|A zároveň|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Atès|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Biết|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Când|Cand|Cando|Ce|Cuando|Če|Ða ðe|Ða|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Daţi fiind|Dați fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitaĵo|Do|Dun|Duota|Ðurh|Eeldades|Ef|Eğer ki|Entao|Então|Entón|E|En|Entonces|Epi|És|Etant donnée|Etant donné|Et|Étant données|Étant donnée|Étant donné|Etant données|Etant donnés|Étant donnés|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeśli|Jeżeli|Kad|Kada|Kadar|Kai|Kaj|Když|Keď|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|Lè sa a|Lè|Logo|Lorsqu'<|Lorsque|mä|Maar|Mais|Mając|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Når|När|Nato|Nhưng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Però|Podano|Pokiaľ|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|Så|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|Şi|Și|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Thì|Thurh|Toda|Too right|Un|Und|ugeholl|Và|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za předpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakładając|Zaradi|Zatati|Þa þe|Þa|Þá|Þegar|Þurh|Αλλά|Δεδομένου|Και|Όταν|Τότε|А також|Агар|Але|Али|Аммо|А|Әгәр|Әйтик|Әмма|Бирок|Ва|Вә|Дадено|Дано|Допустим|Если|Задате|Задати|Задато|И|І|К тому же|Када|Кад|Когато|Когда|Коли|Ләкин|Лекин|Нәтиҗәдә|Нехай|Но|Онда|Припустимо, що|Припустимо|Пусть|Также|Та|Тогда|Тоді|То|Унда|Һәм|Якщо|אבל|אזי|אז|בהינתן|וגם|כאשר|آنگاه|اذاً|اگر|اما|اور|با فرض|بالفرض|بفرض|پھر|تب|ثم|جب|عندما|فرض کیا|لكن|لیکن|متى|هنگامی|و|अगर|और|कदा|किन्तु|चूंकि|जब|तथा|तदा|तब|परन्तु|पर|यदि|ਅਤੇ|ਜਦੋਂ|ਜਿਵੇਂ ਕਿ|ਜੇਕਰ|ਤਦ|ਪਰ|అప్పుడు|ఈ పరిస్థితిలో|కాని|చెప్పబడినది|మరియు|ಆದರೆ|ನಂತರ|ನೀಡಿದ|ಮತ್ತು|ಸ್ಥಿತಿಯನ್ನು|กำหนดให้|ดังนั้น|แต่|เมื่อ|และ|그러면<|그리고<|단<|만약<|만일<|먼저<|조건<|하지만<|かつ<|しかし<|ただし<|ならば<|もし<|並且<|但し<|但是<|假如<|假定<|假設<|假设<|前提<|同时<|同時<|并且<|当<|當<|而且<|那么<|那麼<)(?=[ \t])/m,
          lookbehind: true
        },
        string: {
          pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
          inside: {
            outline: {
              pattern: /<[^>]+>/,
              alias: "variable"
            }
          }
        },
        outline: {
          pattern: /<[^>]+>/,
          alias: "variable"
        }
      };
    })(Prism);
  }
  return gherkin_1;
}
var git_1;
var hasRequiredGit;
function requireGit() {
  if (hasRequiredGit) return git_1;
  hasRequiredGit = 1;
  git_1 = git;
  git.displayName = "git";
  git.aliases = [];
  function git(Prism) {
    Prism.languages.git = {
      /*
       * A simple one line comment like in a git status command
       * For instance:
       * $ git status
       * # On branch infinite-scroll
       * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
       * # and have 1 and 2 different commits each, respectively.
       * nothing to commit (working directory clean)
       */
      comment: /^#.*/m,
      /*
       * Regexp to match the changed lines in a git diff output. Check the example below.
       */
      deleted: /^[-–].*/m,
      inserted: /^\+.*/m,
      /*
       * a string (double and simple quote)
       */
      string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      /*
       * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
       * For instance:
       * $ git add file.txt
       */
      command: {
        pattern: /^.*\$ git .*$/m,
        inside: {
          /*
           * A git command can contain a parameter starting by a single or a double dash followed by a string
           * For instance:
           * $ git diff --cached
           * $ git log -p
           */
          parameter: /\s--?\w+/
        }
      },
      /*
       * Coordinates displayed in a git diff command
       * For instance:
       * $ git diff
       * diff --git file.txt file.txt
       * index 6214953..1d54a52 100644
       * --- file.txt
       * +++ file.txt
       * @@ -1 +1,2 @@
       * -Here's my tetx file
       * +Here's my text file
       * +And this is the second line
       */
      coord: /^@@.*@@$/m,
      /*
       * Match a "commit [SHA1]" line in a git log output.
       * For instance:
       * $ git log
       * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
       * Author: lgiraudel
       * Date:   Mon Feb 17 11:18:34 2014 +0100
       *
       *     Add of a new line
       */
      "commit-sha1": /^commit \w{40}$/m
    };
  }
  return git_1;
}
var glsl_1;
var hasRequiredGlsl;
function requireGlsl() {
  if (hasRequiredGlsl) return glsl_1;
  hasRequiredGlsl = 1;
  var refractorC = requireC();
  glsl_1 = glsl;
  glsl.displayName = "glsl";
  glsl.aliases = [];
  function glsl(Prism) {
    Prism.register(refractorC);
    Prism.languages.glsl = Prism.languages.extend("c", {
      keyword: /\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
    });
  }
  return glsl_1;
}
var gml_1;
var hasRequiredGml;
function requireGml() {
  if (hasRequiredGml) return gml_1;
  hasRequiredGml = 1;
  gml_1 = gml;
  gml.displayName = "gml";
  gml.aliases = [];
  function gml(Prism) {
    Prism.languages.gamemakerlanguage = Prism.languages.gml = Prism.languages.extend("clike", {
      keyword: /\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
      number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
      operator: /--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
      constant: /\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
      variable: /\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
    });
  }
  return gml_1;
}
var gn_1;
var hasRequiredGn;
function requireGn() {
  if (hasRequiredGn) return gn_1;
  hasRequiredGn = 1;
  gn_1 = gn;
  gn.displayName = "gn";
  gn.aliases = ["gni"];
  function gn(Prism) {
    Prism.languages.gn = {
      comment: {
        pattern: /#.*/,
        greedy: true
      },
      "string-literal": {
        pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
        lookbehind: true,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
            lookbehind: true,
            inside: {
              number: /^\$0x[\s\S]{2}$/,
              variable: /^\$\w+$/,
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              expression: {
                pattern: /[\s\S]+/,
                inside: null
                // see below
              }
            }
          },
          string: /[\s\S]+/
        }
      },
      keyword: /\b(?:else|if)\b/,
      boolean: /\b(?:false|true)\b/,
      "builtin-function": {
        // a few functions get special highlighting to improve readability
        pattern: /\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
        alias: "keyword"
      },
      function: /\b[a-z_]\w*(?=\s*\()/i,
      constant: /\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
      number: /-?\b\d+\b/,
      operator: /[-+!=<>]=?|&&|\|\|/,
      punctuation: /[(){}[\],.]/
    };
    Prism.languages.gn["string-literal"].inside["interpolation"].inside["expression"].inside = Prism.languages.gn;
    Prism.languages.gni = Prism.languages.gn;
  }
  return gn_1;
}
var goModule_1;
var hasRequiredGoModule;
function requireGoModule() {
  if (hasRequiredGoModule) return goModule_1;
  hasRequiredGoModule = 1;
  goModule_1 = goModule;
  goModule.displayName = "goModule";
  goModule.aliases = [];
  function goModule(Prism) {
    Prism.languages["go-mod"] = Prism.languages["go-module"] = {
      comment: {
        pattern: /\/\/.*/,
        greedy: true
      },
      version: {
        pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
        lookbehind: true,
        alias: "number"
      },
      "go-version": {
        pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
        lookbehind: true,
        alias: "number"
      },
      keyword: {
        pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
        lookbehind: true
      },
      operator: /=>/,
      punctuation: /[()[\],]/
    };
  }
  return goModule_1;
}
var go_1;
var hasRequiredGo;
function requireGo() {
  if (hasRequiredGo) return go_1;
  hasRequiredGo = 1;
  go_1 = go;
  go.displayName = "go";
  go.aliases = [];
  function go(Prism) {
    Prism.languages.go = Prism.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
        lookbehind: true,
        greedy: true
      },
      keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
      boolean: /\b(?:_|false|iota|nil|true)\b/,
      number: [
        // binary and octal integers
        /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
        // hexadecimal integers and floats
        /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
        // decimal integers and floats
        /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
      ],
      operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
      builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
    });
    Prism.languages.insertBefore("go", "string", {
      char: {
        pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
        greedy: true
      }
    });
    delete Prism.languages.go["class-name"];
  }
  return go_1;
}
var graphql_1;
var hasRequiredGraphql;
function requireGraphql() {
  if (hasRequiredGraphql) return graphql_1;
  hasRequiredGraphql = 1;
  graphql_1 = graphql;
  graphql.displayName = "graphql";
  graphql.aliases = [];
  function graphql(Prism) {
    Prism.languages.graphql = {
      comment: /#.*/,
      description: {
        pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
        greedy: true,
        alias: "string",
        inside: {
          "language-markdown": {
            pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
            lookbehind: true,
            inside: Prism.languages.markdown
          }
        }
      },
      string: {
        pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
        greedy: true
      },
      number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      boolean: /\b(?:false|true)\b/,
      variable: /\$[a-z_]\w*/i,
      directive: {
        pattern: /@[a-z_]\w*/i,
        alias: "function"
      },
      "attr-name": {
        pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
        greedy: true
      },
      "atom-input": {
        pattern: /\b[A-Z]\w*Input\b/,
        alias: "class-name"
      },
      scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
      constant: /\b[A-Z][A-Z_\d]*\b/,
      "class-name": {
        pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
        lookbehind: true
      },
      fragment: {
        pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
        lookbehind: true,
        alias: "function"
      },
      "definition-mutation": {
        pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
        lookbehind: true,
        alias: "function"
      },
      "definition-query": {
        pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
        lookbehind: true,
        alias: "function"
      },
      keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
      operator: /[!=|&]|\.{3}/,
      "property-query": /\w+(?=\s*\()/,
      object: /\w+(?=\s*\{)/,
      punctuation: /[!(){}\[\]:=,]/,
      property: /\w+/
    };
    Prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env) {
      if (env.language !== "graphql") {
        return;
      }
      var validTokens = env.tokens.filter(function(token) {
        return typeof token !== "string" && token.type !== "comment" && token.type !== "scalar";
      });
      var currentIndex = 0;
      function getToken(offset2) {
        return validTokens[currentIndex + offset2];
      }
      function isTokenType(types2, offset2) {
        offset2 = offset2 || 0;
        for (var i3 = 0; i3 < types2.length; i3++) {
          var token = getToken(i3 + offset2);
          if (!token || token.type !== types2[i3]) {
            return false;
          }
        }
        return true;
      }
      function findClosingBracket(open, close) {
        var stackHeight = 1;
        for (var i3 = currentIndex; i3 < validTokens.length; i3++) {
          var token = validTokens[i3];
          var content = token.content;
          if (token.type === "punctuation" && typeof content === "string") {
            if (open.test(content)) {
              stackHeight++;
            } else if (close.test(content)) {
              stackHeight--;
              if (stackHeight === 0) {
                return i3;
              }
            }
          }
        }
        return -1;
      }
      function addAlias(token, alias) {
        var aliases = token.alias;
        if (!aliases) {
          token.alias = aliases = [];
        } else if (!Array.isArray(aliases)) {
          token.alias = aliases = [aliases];
        }
        aliases.push(alias);
      }
      for (; currentIndex < validTokens.length; ) {
        var startToken = validTokens[currentIndex++];
        if (startToken.type === "keyword" && startToken.content === "mutation") {
          var inputVariables = [];
          if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
            currentIndex += 2;
            var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
            if (definitionEnd === -1) {
              continue;
            }
            for (; currentIndex < definitionEnd; currentIndex++) {
              var t2 = getToken(0);
              if (t2.type === "variable") {
                addAlias(t2, "variable-input");
                inputVariables.push(t2.content);
              }
            }
            currentIndex = definitionEnd + 1;
          }
          if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{") {
            currentIndex++;
            addAlias(getToken(0), "property-mutation");
            if (inputVariables.length > 0) {
              var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
              if (mutationEnd === -1) {
                continue;
              }
              for (var i2 = currentIndex; i2 < mutationEnd; i2++) {
                var varToken = validTokens[i2];
                if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) {
                  addAlias(varToken, "variable-input");
                }
              }
            }
          }
        }
      }
    });
  }
  return graphql_1;
}
var groovy_1;
var hasRequiredGroovy;
function requireGroovy() {
  if (hasRequiredGroovy) return groovy_1;
  hasRequiredGroovy = 1;
  groovy_1 = groovy;
  groovy.displayName = "groovy";
  groovy.aliases = [];
  function groovy(Prism) {
    Prism.languages.groovy = Prism.languages.extend("clike", {
      string: [
        {
          // https://groovy-lang.org/syntax.html#_dollar_slashy_string
          pattern: /("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
          greedy: true
        },
        {
          // TODO: Slash strings (e.g. /foo/) can contain line breaks but this will cause a lot of trouble with
          // simple division (see JS regex), so find a fix maybe?
          pattern: /(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        }
      ],
      keyword: /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
      number: /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
      operator: {
        pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
        lookbehind: true
      },
      punctuation: /\.+|[{}[\];(),:$]/
    });
    Prism.languages.insertBefore("groovy", "string", {
      shebang: {
        pattern: /#!.+/,
        alias: "comment"
      }
    });
    Prism.languages.insertBefore("groovy", "punctuation", {
      "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
    });
    Prism.languages.insertBefore("groovy", "function", {
      annotation: {
        pattern: /(^|[^.])@\w+/,
        lookbehind: true,
        alias: "punctuation"
      }
    });
    Prism.hooks.add("wrap", function(env) {
      if (env.language === "groovy" && env.type === "string") {
        var delimiter = env.content.value[0];
        if (delimiter != "'") {
          var pattern = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
          if (delimiter === "$") {
            pattern = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/;
          }
          env.content.value = env.content.value.replace(/&lt;/g, "<").replace(/&amp;/g, "&");
          env.content = Prism.highlight(env.content.value, {
            expression: {
              pattern,
              lookbehind: true,
              inside: Prism.languages.groovy
            }
          });
          env.classes.push(delimiter === "/" ? "regex" : "gstring");
        }
      }
    });
  }
  return groovy_1;
}
var haml_1;
var hasRequiredHaml;
function requireHaml() {
  if (hasRequiredHaml) return haml_1;
  hasRequiredHaml = 1;
  var refractorRuby = requireRuby();
  haml_1 = haml;
  haml.displayName = "haml";
  haml.aliases = [];
  function haml(Prism) {
    Prism.register(refractorRuby);
    (function(Prism2) {
      Prism2.languages.haml = {
        // Multiline stuff should appear before the rest
        "multiline-comment": {
          pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
          lookbehind: true,
          alias: "comment"
        },
        "multiline-code": [
          {
            pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
            lookbehind: true,
            inside: Prism2.languages.ruby
          },
          {
            pattern: /((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
            lookbehind: true,
            inside: Prism2.languages.ruby
          }
        ],
        // See at the end of the file for known filters
        filter: {
          pattern: /((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
          lookbehind: true,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "symbol"
            }
          }
        },
        markup: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
          lookbehind: true,
          inside: Prism2.languages.markup
        },
        doctype: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
          lookbehind: true
        },
        tag: {
          // Allows for one nested group of braces
          pattern: /((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
          lookbehind: true,
          inside: {
            attributes: [
              {
                // Lookbehind tries to prevent interpolations from breaking it all
                // Allows for one nested group of braces
                pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
                lookbehind: true,
                inside: Prism2.languages.ruby
              },
              {
                pattern: /\([^)]+\)/,
                inside: {
                  "attr-value": {
                    pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
                    lookbehind: true
                  },
                  "attr-name": /[\w:-]+(?=\s*!?=|\s*[,)])/,
                  punctuation: /[=(),]/
                }
              },
              {
                pattern: /\[[^\]]+\]/,
                inside: Prism2.languages.ruby
              }
            ],
            punctuation: /[<>]/
          }
        },
        code: {
          pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
          lookbehind: true,
          inside: Prism2.languages.ruby
        },
        // Interpolations in plain text
        interpolation: {
          pattern: /#\{[^}]+\}/,
          inside: {
            delimiter: {
              pattern: /^#\{|\}$/,
              alias: "punctuation"
            },
            ruby: {
              pattern: /[\s\S]+/,
              inside: Prism2.languages.ruby
            }
          }
        },
        punctuation: {
          pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
          lookbehind: true
        }
      };
      var filter_pattern = "((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+";
      var filters = [
        "css",
        {
          filter: "coffee",
          language: "coffeescript"
        },
        "erb",
        "javascript",
        "less",
        "markdown",
        "ruby",
        "scss",
        "textile"
      ];
      var all_filters = {};
      for (var i2 = 0, l2 = filters.length; i2 < l2; i2++) {
        var filter2 = filters[i2];
        filter2 = typeof filter2 === "string" ? {
          filter: filter2,
          language: filter2
        } : filter2;
        if (Prism2.languages[filter2.language]) {
          all_filters["filter-" + filter2.filter] = {
            pattern: RegExp(
              filter_pattern.replace("{{filter_name}}", function() {
                return filter2.filter;
              })
            ),
            lookbehind: true,
            inside: {
              "filter-name": {
                pattern: /^:[\w-]+/,
                alias: "symbol"
              },
              text: {
                pattern: /[\s\S]+/,
                alias: [filter2.language, "language-" + filter2.language],
                inside: Prism2.languages[filter2.language]
              }
            }
          };
        }
      }
      Prism2.languages.insertBefore("haml", "filter", all_filters);
    })(Prism);
  }
  return haml_1;
}
var handlebars_1;
var hasRequiredHandlebars;
function requireHandlebars() {
  if (hasRequiredHandlebars) return handlebars_1;
  hasRequiredHandlebars = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  handlebars_1 = handlebars;
  handlebars.displayName = "handlebars";
  handlebars.aliases = ["hbs"];
  function handlebars(Prism) {
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      Prism2.languages.handlebars = {
        comment: /\{\{![\s\S]*?\}\}/,
        delimiter: {
          pattern: /^\{\{\{?|\}\}\}?$/,
          alias: "punctuation"
        },
        string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
        boolean: /\b(?:false|true)\b/,
        block: {
          pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
          lookbehind: true,
          alias: "keyword"
        },
        brackets: {
          pattern: /\[[^\]]+\]/,
          inside: {
            punctuation: /\[|\]/,
            variable: /[\s\S]+/
          }
        },
        punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
        variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
      };
      Prism2.hooks.add("before-tokenize", function(env) {
        var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "handlebars",
          handlebarsPattern
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(
          env,
          "handlebars"
        );
      });
      Prism2.languages.hbs = Prism2.languages.handlebars;
    })(Prism);
  }
  return handlebars_1;
}
var haskell_1;
var hasRequiredHaskell;
function requireHaskell() {
  if (hasRequiredHaskell) return haskell_1;
  hasRequiredHaskell = 1;
  haskell_1 = haskell;
  haskell.displayName = "haskell";
  haskell.aliases = ["hs"];
  function haskell(Prism) {
    Prism.languages.haskell = {
      comment: {
        pattern: /(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
        lookbehind: true
      },
      char: {
        pattern: /'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
        alias: "string"
      },
      string: {
        pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
        greedy: true
      },
      keyword: /\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
        lookbehind: true,
        inside: {
          keyword: /\b(?:as|hiding|import|qualified)\b/,
          punctuation: /\./
        }
      },
      // These are builtin variables only. Constructors are highlighted later as a constant.
      builtin: /\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
      // decimal integers and floating point numbers | octal integers | hexadecimal integers
      number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
      operator: [
        {
          // infix operator
          pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
          greedy: true
        },
        {
          // function composition
          pattern: /(\s)\.(?=\s)/,
          lookbehind: true
        },
        // Most of this is needed because of the meaning of a single '.'.
        // If it stands alone freely, it is the function composition.
        // It may also be a separator between a module name and an identifier => no
        // operator. If it comes together with other special characters it is an
        // operator too.
        //
        // This regex means: /[-!#$%*+=?&@|~.:<>^\\\/]+/ without /\./.
        /[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
      ],
      // In Haskell, nearly everything is a variable, do not highlight these.
      hvariable: {
        pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
        inside: {
          punctuation: /\./
        }
      },
      constant: {
        pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
        inside: {
          punctuation: /\./
        }
      },
      punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.hs = Prism.languages.haskell;
  }
  return haskell_1;
}
var haxe_1;
var hasRequiredHaxe;
function requireHaxe() {
  if (hasRequiredHaxe) return haxe_1;
  hasRequiredHaxe = 1;
  haxe_1 = haxe;
  haxe.displayName = "haxe";
  haxe.aliases = [];
  function haxe(Prism) {
    Prism.languages.haxe = Prism.languages.extend("clike", {
      string: {
        // Strings can be multi-line
        pattern: /"(?:[^"\\]|\\[\s\S])*"/,
        greedy: true
      },
      "class-name": [
        {
          pattern: /(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
          lookbehind: true
        },
        // based on naming convention
        /\b[A-Z]\w*/
      ],
      // The final look-ahead prevents highlighting of keywords if expressions such as "haxe.macro.Expr"
      keyword: /\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
      function: {
        pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
        greedy: true
      },
      operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
    });
    Prism.languages.insertBefore("haxe", "string", {
      "string-interpolation": {
        pattern: /'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{?|\}$/,
                alias: "punctuation"
              },
              expression: {
                pattern: /[\s\S]+/,
                inside: Prism.languages.haxe
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    });
    Prism.languages.insertBefore("haxe", "class-name", {
      regex: {
        pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
        greedy: true,
        inside: {
          "regex-flags": /\b[a-z]+$/,
          "regex-source": {
            pattern: /^(~\/)[\s\S]+(?=\/$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism.languages.regex
          },
          "regex-delimiter": /^~\/|\/$/
        }
      }
    });
    Prism.languages.insertBefore("haxe", "keyword", {
      preprocessor: {
        pattern: /#(?:else|elseif|end|if)\b.*/,
        alias: "property"
      },
      metadata: {
        pattern: /@:?[\w.]+/,
        alias: "symbol"
      },
      reification: {
        pattern: /\$(?:\w+|(?=\{))/,
        alias: "important"
      }
    });
  }
  return haxe_1;
}
var hcl_1;
var hasRequiredHcl;
function requireHcl() {
  if (hasRequiredHcl) return hcl_1;
  hasRequiredHcl = 1;
  hcl_1 = hcl;
  hcl.displayName = "hcl";
  hcl.aliases = [];
  function hcl(Prism) {
    Prism.languages.hcl = {
      comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
      heredoc: {
        pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
        greedy: true,
        alias: "string"
      },
      keyword: [
        {
          pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
          inside: {
            type: {
              pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
              lookbehind: true,
              alias: "variable"
            }
          }
        },
        {
          pattern: /(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
          inside: {
            type: {
              pattern: /(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
              lookbehind: true,
              alias: "variable"
            }
          }
        },
        /[\w-]+(?=\s+\{)/
      ],
      property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
      string: {
        pattern: /"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
            lookbehind: true,
            inside: {
              type: {
                pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
                lookbehind: true,
                alias: "variable"
              },
              keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
              function: /\w+(?=\()/,
              string: {
                pattern: /"(?:\\[\s\S]|[^\\"])*"/,
                greedy: true
              },
              number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
              punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
            }
          }
        }
      },
      number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
      boolean: /\b(?:false|true)\b/i,
      punctuation: /[=\[\]{}]/
    };
  }
  return hcl_1;
}
var hlsl_1;
var hasRequiredHlsl;
function requireHlsl() {
  if (hasRequiredHlsl) return hlsl_1;
  hasRequiredHlsl = 1;
  var refractorC = requireC();
  hlsl_1 = hlsl;
  hlsl.displayName = "hlsl";
  hlsl.aliases = [];
  function hlsl(Prism) {
    Prism.register(refractorC);
    Prism.languages.hlsl = Prism.languages.extend("c", {
      // Regarding keywords and class names:
      // The list of all keywords was split into 'keyword' and 'class-name' tokens based on whether they are capitalized.
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-keywords
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-reserved-words
      "class-name": [
        Prism.languages.c["class-name"],
        /\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/
      ],
      keyword: [
        // HLSL keyword
        /\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/,
        // scalar, vector, and matrix types
        /\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
      ],
      // https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-appendix-grammar#floating-point-numbers
      number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
      boolean: /\b(?:false|true)\b/
    });
  }
  return hlsl_1;
}
var hoon_1;
var hasRequiredHoon;
function requireHoon() {
  if (hasRequiredHoon) return hoon_1;
  hasRequiredHoon = 1;
  hoon_1 = hoon;
  hoon.displayName = "hoon";
  hoon.aliases = [];
  function hoon(Prism) {
    Prism.languages.hoon = {
      comment: {
        pattern: /::.*/,
        greedy: true
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      constant: /%(?:\.[ny]|[\w-]+)/,
      "class-name": /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
      function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
      keyword: /\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
    };
  }
  return hoon_1;
}
var hpkp_1;
var hasRequiredHpkp;
function requireHpkp() {
  if (hasRequiredHpkp) return hpkp_1;
  hasRequiredHpkp = 1;
  hpkp_1 = hpkp;
  hpkp.displayName = "hpkp";
  hpkp.aliases = [];
  function hpkp(Prism) {
    Prism.languages.hpkp = {
      directive: {
        pattern: /\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
        alias: "property"
      },
      operator: /=/,
      punctuation: /;/
    };
  }
  return hpkp_1;
}
var hsts_1;
var hasRequiredHsts;
function requireHsts() {
  if (hasRequiredHsts) return hsts_1;
  hasRequiredHsts = 1;
  hsts_1 = hsts;
  hsts.displayName = "hsts";
  hsts.aliases = [];
  function hsts(Prism) {
    Prism.languages.hsts = {
      directive: {
        pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
        alias: "property"
      },
      operator: /=/,
      punctuation: /;/
    };
  }
  return hsts_1;
}
var http_1;
var hasRequiredHttp;
function requireHttp() {
  if (hasRequiredHttp) return http_1;
  hasRequiredHttp = 1;
  http_1 = http;
  http.displayName = "http";
  http.aliases = [];
  function http(Prism) {
    (function(Prism2) {
      function headerValueOf(name) {
        return RegExp("(^(?:" + name + "):[ 	]*(?![ 	]))[^]+", "i");
      }
      Prism2.languages.http = {
        "request-line": {
          pattern: /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
          inside: {
            // HTTP Method
            method: {
              pattern: /^[A-Z]+\b/,
              alias: "property"
            },
            // Request Target e.g. http://example.com, /path/to/file
            "request-target": {
              pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
              lookbehind: true,
              alias: "url",
              inside: Prism2.languages.uri
            },
            // HTTP Version
            "http-version": {
              pattern: /^(\s)HTTP\/[\d.]+/,
              lookbehind: true,
              alias: "property"
            }
          }
        },
        "response-status": {
          pattern: /^HTTP\/[\d.]+ \d+ .+/m,
          inside: {
            // HTTP Version
            "http-version": {
              pattern: /^HTTP\/[\d.]+/,
              alias: "property"
            },
            // Status Code
            "status-code": {
              pattern: /^(\s)\d+(?=\s)/,
              lookbehind: true,
              alias: "number"
            },
            // Reason Phrase
            "reason-phrase": {
              pattern: /^(\s).+/,
              lookbehind: true,
              alias: "string"
            }
          }
        },
        header: {
          pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
          inside: {
            "header-value": [
              {
                pattern: headerValueOf(/Content-Security-Policy/.source),
                lookbehind: true,
                alias: ["csp", "languages-csp"],
                inside: Prism2.languages.csp
              },
              {
                pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
                lookbehind: true,
                alias: ["hpkp", "languages-hpkp"],
                inside: Prism2.languages.hpkp
              },
              {
                pattern: headerValueOf(/Strict-Transport-Security/.source),
                lookbehind: true,
                alias: ["hsts", "languages-hsts"],
                inside: Prism2.languages.hsts
              },
              {
                pattern: headerValueOf(/[^:]+/.source),
                lookbehind: true
              }
            ],
            "header-name": {
              pattern: /^[^:]+/,
              alias: "keyword"
            },
            punctuation: /^:/
          }
        }
      };
      var langs = Prism2.languages;
      var httpLanguages = {
        "application/javascript": langs.javascript,
        "application/json": langs.json || langs.javascript,
        "application/xml": langs.xml,
        "text/xml": langs.xml,
        "text/html": langs.html,
        "text/css": langs.css,
        "text/plain": langs.plain
      };
      var suffixTypes = {
        "application/json": true,
        "application/xml": true
      };
      function getSuffixPattern(contentType2) {
        var suffix = contentType2.replace(/^[a-z]+\//, "");
        var suffixPattern = "\\w+/(?:[\\w.-]+\\+)+" + suffix + "(?![+\\w.-])";
        return "(?:" + contentType2 + "|" + suffixPattern + ")";
      }
      var options;
      for (var contentType in httpLanguages) {
        if (httpLanguages[contentType]) {
          options = options || {};
          var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
          options[contentType.replace(/\//g, "-")] = {
            pattern: RegExp(
              "(" + /content-type:\s*/.source + pattern + /(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source + ")" + // This is a little interesting:
              // The HTTP format spec required 1 empty line before the body to make everything unambiguous.
              // However, when writing code by hand (e.g. to display on a website) people can forget about this,
              // so we want to be liberal here. We will allow the empty line to be omitted if the first line of
              // the body does not start with a [\w-] character (as headers do).
              /[^ \t\w-][\s\S]*/.source,
              "i"
            ),
            lookbehind: true,
            inside: httpLanguages[contentType]
          };
        }
      }
      if (options) {
        Prism2.languages.insertBefore("http", "header", options);
      }
    })(Prism);
  }
  return http_1;
}
var ichigojam_1;
var hasRequiredIchigojam;
function requireIchigojam() {
  if (hasRequiredIchigojam) return ichigojam_1;
  hasRequiredIchigojam = 1;
  ichigojam_1 = ichigojam;
  ichigojam.displayName = "ichigojam";
  ichigojam.aliases = [];
  function ichigojam(Prism) {
    Prism.languages.ichigojam = {
      comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
      string: {
        pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
        greedy: true
      },
      number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
      keyword: /\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
      function: /\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
      label: /(?:\B@\S+)/,
      operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
      punctuation: /[\[,;:()\]]/
    };
  }
  return ichigojam_1;
}
var icon_1;
var hasRequiredIcon;
function requireIcon() {
  if (hasRequiredIcon) return icon_1;
  hasRequiredIcon = 1;
  icon_1 = icon;
  icon.displayName = "icon";
  icon.aliases = [];
  function icon(Prism) {
    Prism.languages.icon = {
      comment: /#.*/,
      string: {
        pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
        greedy: true
      },
      number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
      "builtin-keyword": {
        pattern: /&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
        alias: "variable"
      },
      directive: {
        pattern: /\$\w+/,
        alias: "builtin"
      },
      keyword: /\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
      function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
      operator: /[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
      punctuation: /[\[\](){},;]/
    };
  }
  return icon_1;
}
var icuMessageFormat_1;
var hasRequiredIcuMessageFormat;
function requireIcuMessageFormat() {
  if (hasRequiredIcuMessageFormat) return icuMessageFormat_1;
  hasRequiredIcuMessageFormat = 1;
  icuMessageFormat_1 = icuMessageFormat;
  icuMessageFormat.displayName = "icuMessageFormat";
  icuMessageFormat.aliases = [];
  function icuMessageFormat(Prism) {
    (function(Prism2) {
      function nested(source, level) {
        if (level <= 0) {
          return /[]/.source;
        } else {
          return source.replace(/<SELF>/g, function() {
            return nested(source, level - 1);
          });
        }
      }
      var stringPattern = /'[{}:=,](?:[^']|'')*'(?!')/;
      var escape = {
        pattern: /''/,
        greedy: true,
        alias: "operator"
      };
      var string = {
        pattern: stringPattern,
        greedy: true,
        inside: {
          escape
        }
      };
      var argumentSource = nested(
        /\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(
          /<STR>/g,
          function() {
            return stringPattern.source;
          }
        ),
        8
      );
      var nestedMessage = {
        pattern: RegExp(argumentSource),
        inside: {
          message: {
            pattern: /^(\{)[\s\S]+(?=\}$)/,
            lookbehind: true,
            inside: null
            // see below
          },
          "message-delimiter": {
            pattern: /./,
            alias: "punctuation"
          }
        }
      };
      Prism2.languages["icu-message-format"] = {
        argument: {
          pattern: RegExp(argumentSource),
          greedy: true,
          inside: {
            content: {
              pattern: /^(\{)[\s\S]+(?=\}$)/,
              lookbehind: true,
              inside: {
                "argument-name": {
                  pattern: /^(\s*)[^{}:=,\s]+/,
                  lookbehind: true
                },
                "choice-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4c/classicu_1_1ChoiceFormat.html#details
                  pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: true,
                  inside: {
                    punctuation: /\|/,
                    range: {
                      pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
                      lookbehind: true,
                      inside: {
                        operator: /[<#\u2264]/,
                        number: /\S+/
                      }
                    },
                    rest: null
                    // see below
                  }
                },
                "plural-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/PluralFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                  pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: true,
                  inside: {
                    offset: /^offset:\s*\d+/,
                    "nested-message": nestedMessage,
                    selector: {
                      pattern: /=\d+|[^{}:=,\s]+/,
                      inside: {
                        keyword: /^(?:few|many|one|other|two|zero)$/
                      }
                    }
                  }
                },
                "select-style": {
                  // https://unicode-org.github.io/icu-docs/apidoc/released/icu4j/com/ibm/icu/text/SelectFormat.html#:~:text=Patterns%20and%20Their%20Interpretation
                  pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
                  lookbehind: true,
                  inside: {
                    "nested-message": nestedMessage,
                    selector: {
                      pattern: /[^{}:=,\s]+/,
                      inside: {
                        keyword: /^other$/
                      }
                    }
                  }
                },
                keyword: /\b(?:choice|plural|select|selectordinal)\b/,
                "arg-type": {
                  pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
                  alias: "keyword"
                },
                "arg-skeleton": {
                  pattern: /(,\s*)::[^{}:=,\s]+/,
                  lookbehind: true
                },
                "arg-style": {
                  pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
                  lookbehind: true
                },
                "arg-style-text": {
                  pattern: RegExp(
                    /(^\s*,\s*(?=\S))/.source + nested(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) + "$"
                  ),
                  lookbehind: true,
                  alias: "string"
                },
                punctuation: /,/
              }
            },
            "argument-delimiter": {
              pattern: /./,
              alias: "operator"
            }
          }
        },
        escape,
        string
      };
      nestedMessage.inside.message.inside = Prism2.languages["icu-message-format"];
      Prism2.languages["icu-message-format"].argument.inside.content.inside["choice-style"].inside.rest = Prism2.languages["icu-message-format"];
    })(Prism);
  }
  return icuMessageFormat_1;
}
var idris_1;
var hasRequiredIdris;
function requireIdris() {
  if (hasRequiredIdris) return idris_1;
  hasRequiredIdris = 1;
  var refractorHaskell = requireHaskell();
  idris_1 = idris;
  idris.displayName = "idris";
  idris.aliases = ["idr"];
  function idris(Prism) {
    Prism.register(refractorHaskell);
    Prism.languages.idris = Prism.languages.extend("haskell", {
      comment: {
        pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
      },
      keyword: /\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
      builtin: void 0
    });
    Prism.languages.insertBefore("idris", "keyword", {
      "import-statement": {
        pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
        lookbehind: true,
        inside: {
          punctuation: /\./
        }
      }
    });
    Prism.languages.idr = Prism.languages.idris;
  }
  return idris_1;
}
var iecst_1;
var hasRequiredIecst;
function requireIecst() {
  if (hasRequiredIecst) return iecst_1;
  hasRequiredIecst = 1;
  iecst_1 = iecst;
  iecst.displayName = "iecst";
  iecst.aliases = [];
  function iecst(Prism) {
    Prism.languages.iecst = {
      comment: [
        {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      keyword: [
        /\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i,
        /\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/
      ],
      "class-name": /\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
      address: {
        pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
        alias: "symbol"
      },
      number: /\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      boolean: /\b(?:FALSE|NULL|TRUE)\b/,
      operator: /S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      punctuation: /[()[\].,;]/
    };
  }
  return iecst_1;
}
var ignore_1;
var hasRequiredIgnore;
function requireIgnore() {
  if (hasRequiredIgnore) return ignore_1;
  hasRequiredIgnore = 1;
  ignore_1 = ignore;
  ignore.displayName = "ignore";
  ignore.aliases = ["gitignore", "hgignore", "npmignore"];
  function ignore(Prism) {
    (function(Prism2) {
      Prism2.languages.ignore = {
        // https://git-scm.com/docs/gitignore
        comment: /^#.*/m,
        entry: {
          pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
          alias: "string",
          inside: {
            operator: /^!|\*\*?|\?/,
            regex: {
              pattern: /(^|[^\\])\[[^\[\]]*\]/,
              lookbehind: true
            },
            punctuation: /\//
          }
        }
      };
      Prism2.languages.gitignore = Prism2.languages.ignore;
      Prism2.languages.hgignore = Prism2.languages.ignore;
      Prism2.languages.npmignore = Prism2.languages.ignore;
    })(Prism);
  }
  return ignore_1;
}
var inform7_1;
var hasRequiredInform7;
function requireInform7() {
  if (hasRequiredInform7) return inform7_1;
  hasRequiredInform7 = 1;
  inform7_1 = inform7;
  inform7.displayName = "inform7";
  inform7.aliases = [];
  function inform7(Prism) {
    Prism.languages.inform7 = {
      string: {
        pattern: /"[^"]*"/,
        inside: {
          substitution: {
            pattern: /\[[^\[\]]+\]/,
            inside: {
              delimiter: {
                pattern: /\[|\]/,
                alias: "punctuation"
              }
              // See rest below
            }
          }
        }
      },
      comment: {
        pattern: /\[[^\[\]]+\]/,
        greedy: true
      },
      title: {
        pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
        alias: "important"
      },
      number: {
        pattern: /(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
        lookbehind: true
      },
      verb: {
        pattern: /(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
        lookbehind: true,
        alias: "operator"
      },
      keyword: {
        pattern: /(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
        lookbehind: true
      },
      property: {
        pattern: /(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
        lookbehind: true,
        alias: "symbol"
      },
      position: {
        pattern: /(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
        lookbehind: true,
        alias: "keyword"
      },
      type: {
        pattern: /(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
        lookbehind: true,
        alias: "variable"
      },
      punctuation: /[.,:;(){}]/
    };
    Prism.languages.inform7["string"].inside["substitution"].inside.rest = Prism.languages.inform7;
    Prism.languages.inform7["string"].inside["substitution"].inside.rest.text = {
      pattern: /\S(?:\s*\S)*/,
      alias: "comment"
    };
  }
  return inform7_1;
}
var ini_1;
var hasRequiredIni;
function requireIni() {
  if (hasRequiredIni) return ini_1;
  hasRequiredIni = 1;
  ini_1 = ini;
  ini.displayName = "ini";
  ini.aliases = [];
  function ini(Prism) {
    Prism.languages.ini = {
      /**
       * The component mimics the behavior of the Win32 API parser.
       *
       * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
       */
      comment: {
        pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
        lookbehind: true
      },
      section: {
        pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
        lookbehind: true,
        inside: {
          "section-name": {
            pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
            lookbehind: true,
            alias: "selector"
          },
          punctuation: /\[|\]/
        }
      },
      key: {
        pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
        lookbehind: true,
        alias: "attr-name"
      },
      value: {
        pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
        lookbehind: true,
        alias: "attr-value",
        inside: {
          "inner-value": {
            pattern: /^("|').+(?=\1$)/,
            lookbehind: true
          }
        }
      },
      punctuation: /=/
    };
  }
  return ini_1;
}
var io_1;
var hasRequiredIo;
function requireIo() {
  if (hasRequiredIo) return io_1;
  hasRequiredIo = 1;
  io_1 = io;
  io.displayName = "io";
  io.aliases = [];
  function io(Prism) {
    Prism.languages.io = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
        lookbehind: true,
        greedy: true
      },
      "triple-quoted-string": {
        pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
        greedy: true,
        alias: "string"
      },
      string: {
        pattern: /"(?:\\.|[^\\\r\n"])*"/,
        greedy: true
      },
      keyword: /\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
      builtin: /\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
      boolean: /\b(?:false|nil|true)\b/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
      operator: /[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return io_1;
}
var j_1;
var hasRequiredJ;
function requireJ() {
  if (hasRequiredJ) return j_1;
  hasRequiredJ = 1;
  j_1 = j2;
  j2.displayName = "j";
  j2.aliases = [];
  function j2(Prism) {
    Prism.languages.j = {
      comment: {
        pattern: /\bNB\..*/,
        greedy: true
      },
      string: {
        pattern: /'(?:''|[^'\r\n])*'/,
        greedy: true
      },
      keyword: /\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
      verb: {
        // Negative look-ahead prevents bad highlighting
        // of ^: ;. =. =: !. !:
        pattern: /(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
        alias: "keyword"
      },
      number: /\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
      adverb: {
        pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
        alias: "builtin"
      },
      operator: /[=a][.:]|_\./,
      conjunction: {
        pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
        alias: "variable"
      },
      punctuation: /[()]/
    };
  }
  return j_1;
}
var java_1;
var hasRequiredJava;
function requireJava() {
  if (hasRequiredJava) return java_1;
  hasRequiredJava = 1;
  java_1 = java;
  java.displayName = "java";
  java.aliases = [];
  function java(Prism) {
    (function(Prism2) {
      var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
      var classNamePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
      var className = {
        pattern: RegExp(classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: true,
        inside: {
          namespace: {
            pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /\./
        }
      };
      Prism2.languages.java = Prism2.languages.extend("clike", {
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
          lookbehind: true,
          greedy: true
        },
        "class-name": [
          className,
          {
            // variables and parameters
            // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
            pattern: RegExp(
              classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source
            ),
            lookbehind: true,
            inside: className.inside
          }
        ],
        keyword: keywords,
        function: [
          Prism2.languages.clike.function,
          {
            pattern: /(::\s*)[a-z_]\w*/,
            lookbehind: true
          }
        ],
        number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
        operator: {
          pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
          lookbehind: true
        }
      });
      Prism2.languages.insertBefore("java", "string", {
        "triple-quoted-string": {
          // http://openjdk.java.net/jeps/355#Description
          pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
          greedy: true,
          alias: "string"
        },
        char: {
          pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
          greedy: true
        }
      });
      Prism2.languages.insertBefore("java", "class-name", {
        annotation: {
          pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
          lookbehind: true,
          alias: "punctuation"
        },
        generics: {
          pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
          inside: {
            "class-name": className,
            keyword: keywords,
            punctuation: /[<>(),.:]/,
            operator: /[?&|]/
          }
        },
        namespace: {
          pattern: RegExp(
            /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
              /<keyword>/g,
              function() {
                return keywords.source;
              }
            )
          ),
          lookbehind: true,
          inside: {
            punctuation: /\./
          }
        }
      });
    })(Prism);
  }
  return java_1;
}
var javadoclike_1;
var hasRequiredJavadoclike;
function requireJavadoclike() {
  if (hasRequiredJavadoclike) return javadoclike_1;
  hasRequiredJavadoclike = 1;
  javadoclike_1 = javadoclike;
  javadoclike.displayName = "javadoclike";
  javadoclike.aliases = [];
  function javadoclike(Prism) {
    (function(Prism2) {
      var javaDocLike = Prism2.languages.javadoclike = {
        parameter: {
          pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
          lookbehind: true
        },
        keyword: {
          // keywords are the first word in a line preceded be an `@` or surrounded by curly braces.
          // @word, {@word}
          pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
          lookbehind: true
        },
        punctuation: /[{}]/
      };
      function docCommentSupport(lang, callback) {
        var tokenName = "doc-comment";
        var grammar = Prism2.languages[lang];
        if (!grammar) {
          return;
        }
        var token = grammar[tokenName];
        if (!token) {
          var definition = {};
          definition[tokenName] = {
            pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            alias: "comment"
          };
          grammar = Prism2.languages.insertBefore(lang, "comment", definition);
          token = grammar[tokenName];
        }
        if (token instanceof RegExp) {
          token = grammar[tokenName] = {
            pattern: token
          };
        }
        if (Array.isArray(token)) {
          for (var i2 = 0, l2 = token.length; i2 < l2; i2++) {
            if (token[i2] instanceof RegExp) {
              token[i2] = {
                pattern: token[i2]
              };
            }
            callback(token[i2]);
          }
        } else {
          callback(token);
        }
      }
      function addSupport(languages, docLanguage) {
        if (typeof languages === "string") {
          languages = [languages];
        }
        languages.forEach(function(lang) {
          docCommentSupport(lang, function(pattern) {
            if (!pattern.inside) {
              pattern.inside = {};
            }
            pattern.inside.rest = docLanguage;
          });
        });
      }
      Object.defineProperty(javaDocLike, "addSupport", {
        value: addSupport
      });
      javaDocLike.addSupport(["java", "javascript", "php"], javaDocLike);
    })(Prism);
  }
  return javadoclike_1;
}
var javadoc_1;
var hasRequiredJavadoc;
function requireJavadoc() {
  if (hasRequiredJavadoc) return javadoc_1;
  hasRequiredJavadoc = 1;
  var refractorJava = requireJava();
  var refractorJavadoclike = requireJavadoclike();
  javadoc_1 = javadoc;
  javadoc.displayName = "javadoc";
  javadoc.aliases = [];
  function javadoc(Prism) {
    Prism.register(refractorJava);
    Prism.register(refractorJavadoclike);
    (function(Prism2) {
      var codeLinePattern = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m;
      var memberReference = /#\s*\w+(?:\s*\([^()]*\))?/.source;
      var reference = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(
        /<mem>/g,
        function() {
          return memberReference;
        }
      );
      Prism2.languages.javadoc = Prism2.languages.extend("javadoclike", {});
      Prism2.languages.insertBefore("javadoc", "keyword", {
        reference: {
          pattern: RegExp(
            /(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source + "(?:" + reference + ")"
          ),
          lookbehind: true,
          inside: {
            function: {
              pattern: /(#\s*)\w+(?=\s*\()/,
              lookbehind: true
            },
            field: {
              pattern: /(#\s*)\w+/,
              lookbehind: true
            },
            namespace: {
              pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
              inside: {
                punctuation: /\./
              }
            },
            "class-name": /\b[A-Z]\w*/,
            keyword: Prism2.languages.java.keyword,
            punctuation: /[#()[\],.]/
          }
        },
        "class-name": {
          // @param <T> the first generic type parameter
          pattern: /(@param\s+)<[A-Z]\w*>/,
          lookbehind: true,
          inside: {
            punctuation: /[.<>]/
          }
        },
        "code-section": [
          {
            pattern: /(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
            lookbehind: true,
            inside: {
              code: {
                // there can't be any HTML inside of {@code} tags
                pattern: codeLinePattern,
                lookbehind: true,
                inside: Prism2.languages.java,
                alias: "language-java"
              }
            }
          },
          {
            pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
            lookbehind: true,
            inside: {
              line: {
                pattern: codeLinePattern,
                lookbehind: true,
                inside: {
                  // highlight HTML tags and entities
                  tag: Prism2.languages.markup.tag,
                  entity: Prism2.languages.markup.entity,
                  code: {
                    // everything else is Java code
                    pattern: /.+/,
                    inside: Prism2.languages.java,
                    alias: "language-java"
                  }
                }
              }
            }
          }
        ],
        tag: Prism2.languages.markup.tag,
        entity: Prism2.languages.markup.entity
      });
      Prism2.languages.javadoclike.addSupport("java", Prism2.languages.javadoc);
    })(Prism);
  }
  return javadoc_1;
}
var javastacktrace_1;
var hasRequiredJavastacktrace;
function requireJavastacktrace() {
  if (hasRequiredJavastacktrace) return javastacktrace_1;
  hasRequiredJavastacktrace = 1;
  javastacktrace_1 = javastacktrace;
  javastacktrace.displayName = "javastacktrace";
  javastacktrace.aliases = [];
  function javastacktrace(Prism) {
    Prism.languages.javastacktrace = {
      // java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
      // Caused by: java.sql.SQLException: Violation of unique constraint MY_ENTITY_UK_1: duplicate value(s) for column(s) MY_COLUMN in statement [...]
      // Caused by: com.example.myproject.MyProjectServletException
      // Caused by: MidLevelException: LowLevelException
      // Suppressed: Resource$CloseFailException: Resource ID = 0
      summary: {
        pattern: /^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
        lookbehind: true,
        inside: {
          keyword: {
            pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
            lookbehind: true
          },
          // the current thread if the summary starts with 'Exception in thread'
          string: {
            pattern: /^(\s*)"[^"]*"/,
            lookbehind: true
          },
          exceptions: {
            pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
            lookbehind: true,
            inside: {
              "class-name": /[\w$]+$/,
              namespace: /\b[a-z]\w*\b/,
              punctuation: /\./
            }
          },
          message: {
            pattern: /(:\s*)\S.*/,
            lookbehind: true,
            alias: "string"
          },
          punctuation: /:/
        }
      },
      // at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)
      // at org.hsqldb.jdbc.Util.throwError(Unknown Source) here could be some notes
      // at java.base/java.lang.Class.forName0(Native Method)
      // at Util.<init>(Unknown Source)
      // at com.foo.loader/foo@9.0/com.foo.Main.run(Main.java:101)
      // at com.foo.loader//com.foo.bar.App.run(App.java:12)
      // at acme@2.1/org.acme.Lib.test(Lib.java:80)
      // at MyClass.mash(MyClass.java:9)
      //
      // More information:
      // https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/StackTraceElement.html#toString()
      //
      // A valid Java module name is defined as:
      //   "A module name consists of one or more Java identifiers (§3.8) separated by "." tokens."
      // https://docs.oracle.com/javase/specs/jls/se9/html/jls-6.html#jls-ModuleName
      //
      // A Java module version is defined by this class:
      // https://docs.oracle.com/javase/9/docs/api/java/lang/module/ModuleDescriptor.Version.html
      // This is the implementation of the `parse` method in JDK13:
      // https://github.com/matcdac/jdk/blob/2305df71d1b7710266ae0956d73927a225132c0f/src/java.base/share/classes/java/lang/module/ModuleDescriptor.java#L1108
      // However, to keep this simple, a version will be matched by the pattern /@[\w$.+-]*/.
      "stack-frame": {
        pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
        lookbehind: true,
        inside: {
          keyword: {
            pattern: /^(\s*)at(?= )/,
            lookbehind: true
          },
          source: [
            // (Main.java:15)
            // (Main.scala:15)
            {
              pattern: /(\()\w+\.\w+:\d+(?=\))/,
              lookbehind: true,
              inside: {
                file: /^\w+\.\w+/,
                punctuation: /:/,
                "line-number": {
                  pattern: /\b\d+\b/,
                  alias: "number"
                }
              }
            },
            // (Unknown Source)
            // (Native Method)
            // (...something...)
            {
              pattern: /(\()[^()]*(?=\))/,
              lookbehind: true,
              inside: {
                keyword: /^(?:Native Method|Unknown Source)$/
              }
            }
          ],
          "class-name": /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
          function: /(?:<init>|[\w$]+)(?=\()/,
          "class-loader": {
            pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
            lookbehind: true,
            alias: "namespace",
            inside: {
              punctuation: /\./
            }
          },
          module: {
            pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
            lookbehind: true,
            inside: {
              version: {
                pattern: /(@)[\s\S]+/,
                lookbehind: true,
                alias: "number"
              },
              punctuation: /[@.]/
            }
          },
          namespace: {
            pattern: /(?:\b[a-z]\w*\.)+/,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[()/.]/
        }
      },
      // ... 32 more
      // ... 32 common frames omitted
      more: {
        pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
        lookbehind: true,
        inside: {
          punctuation: /\.{3}/,
          number: /\d+/,
          keyword: /\b[a-z]+(?: [a-z]+)*\b/
        }
      }
    };
  }
  return javastacktrace_1;
}
var jexl_1;
var hasRequiredJexl;
function requireJexl() {
  if (hasRequiredJexl) return jexl_1;
  hasRequiredJexl = 1;
  jexl_1 = jexl;
  jexl.displayName = "jexl";
  jexl.aliases = [];
  function jexl(Prism) {
    Prism.languages.jexl = {
      string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
      transform: {
        pattern: /(\|\s*)[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
        alias: "function",
        lookbehind: true
      },
      function: /[a-zA-Zа-яА-Я_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\wа-яА-Я\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
      number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
      operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
      boolean: /\b(?:false|true)\b/,
      keyword: /\bin\b/,
      punctuation: /[{}[\](),.]/
    };
  }
  return jexl_1;
}
var jolie_1;
var hasRequiredJolie;
function requireJolie() {
  if (hasRequiredJolie) return jolie_1;
  hasRequiredJolie = 1;
  jolie_1 = jolie;
  jolie.displayName = "jolie";
  jolie.aliases = [];
  function jolie(Prism) {
    Prism.languages.jolie = Prism.languages.extend("clike", {
      string: {
        pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
        lookbehind: true,
        greedy: true
      },
      "class-name": {
        pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
        lookbehind: true
      },
      keyword: /\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
      function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
      operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
      punctuation: /[()[\]{},;.:]/,
      builtin: /\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
    });
    Prism.languages.insertBefore("jolie", "keyword", {
      aggregates: {
        pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
        lookbehind: true,
        inside: {
          keyword: /\bwith\b/,
          "class-name": /\w+/,
          punctuation: /,/
        }
      },
      redirects: {
        pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
        lookbehind: true,
        inside: {
          punctuation: /,/,
          "class-name": /\w+/,
          operator: /=>/
        }
      },
      property: {
        pattern: /\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
      }
    });
  }
  return jolie_1;
}
var jq_1;
var hasRequiredJq;
function requireJq() {
  if (hasRequiredJq) return jq_1;
  hasRequiredJq = 1;
  jq_1 = jq;
  jq.displayName = "jq";
  jq.aliases = [];
  function jq(Prism) {
    (function(Prism2) {
      var interpolation = /\\\((?:[^()]|\([^()]*\))*\)/.source;
      var string = RegExp(
        /(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(
          /__/g,
          function() {
            return interpolation;
          }
        )
      );
      var stringInterpolation = {
        interpolation: {
          pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + interpolation),
          lookbehind: true,
          inside: {
            content: {
              pattern: /^(\\\()[\s\S]+(?=\)$)/,
              lookbehind: true,
              inside: null
              // see below
            },
            punctuation: /^\\\(|\)$/
          }
        }
      };
      var jq2 = Prism2.languages.jq = {
        comment: /#.*/,
        property: {
          pattern: RegExp(string.source + /(?=\s*:(?!:))/.source),
          lookbehind: true,
          greedy: true,
          inside: stringInterpolation
        },
        string: {
          pattern: string,
          lookbehind: true,
          greedy: true,
          inside: stringInterpolation
        },
        function: {
          pattern: /(\bdef\s+)[a-z_]\w+/i,
          lookbehind: true
        },
        variable: /\B\$\w+/,
        "property-literal": {
          pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
          alias: "property"
        },
        keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
        boolean: /\b(?:false|true)\b/,
        number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
        operator: [
          {
            pattern: /\|=?/,
            alias: "pipe"
          },
          /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/
        ],
        "c-style-function": {
          pattern: /\b[a-z_]\w*(?=\s*\()/i,
          alias: "function"
        },
        punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
        dot: {
          pattern: /\./,
          alias: "important"
        }
      };
      stringInterpolation.interpolation.inside.content.inside = jq2;
    })(Prism);
  }
  return jq_1;
}
var jsExtras_1;
var hasRequiredJsExtras;
function requireJsExtras() {
  if (hasRequiredJsExtras) return jsExtras_1;
  hasRequiredJsExtras = 1;
  jsExtras_1 = jsExtras;
  jsExtras.displayName = "jsExtras";
  jsExtras.aliases = [];
  function jsExtras(Prism) {
    (function(Prism2) {
      Prism2.languages.insertBefore("javascript", "function-variable", {
        "method-variable": {
          pattern: RegExp(
            "(\\.\\s*)" + Prism2.languages.javascript["function-variable"].pattern.source
          ),
          lookbehind: true,
          alias: ["function-variable", "method", "function", "property-access"]
        }
      });
      Prism2.languages.insertBefore("javascript", "function", {
        method: {
          pattern: RegExp(
            "(\\.\\s*)" + Prism2.languages.javascript["function"].source
          ),
          lookbehind: true,
          alias: ["function", "property-access"]
        }
      });
      Prism2.languages.insertBefore("javascript", "constant", {
        "known-class-name": [
          {
            // standard built-ins
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
            pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
            alias: "class-name"
          },
          {
            // errors
            pattern: /\b(?:[A-Z]\w*)Error\b/,
            alias: "class-name"
          }
        ]
      });
      function withId(source, flags) {
        return RegExp(
          source.replace(/<ID>/g, function() {
            return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
          }),
          flags
        );
      }
      Prism2.languages.insertBefore("javascript", "keyword", {
        imports: {
          // https://tc39.es/ecma262/#sec-imports
          pattern: withId(
            /(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source
          ),
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        exports: {
          // https://tc39.es/ecma262/#sec-exports
          pattern: withId(
            /(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source
          ),
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      });
      Prism2.languages.javascript["keyword"].unshift(
        {
          pattern: /\b(?:as|default|export|from|import)\b/,
          alias: "module"
        },
        {
          pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
          alias: "control-flow"
        },
        {
          pattern: /\bnull\b/,
          alias: ["null", "nil"]
        },
        {
          pattern: /\bundefined\b/,
          alias: "nil"
        }
      );
      Prism2.languages.insertBefore("javascript", "operator", {
        spread: {
          pattern: /\.{3}/,
          alias: "operator"
        },
        arrow: {
          pattern: /=>/,
          alias: "operator"
        }
      });
      Prism2.languages.insertBefore("javascript", "punctuation", {
        "property-access": {
          pattern: withId(/(\.\s*)#?<ID>/.source),
          lookbehind: true
        },
        "maybe-class-name": {
          pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
          lookbehind: true
        },
        dom: {
          // this contains only a few commonly used DOM variables
          pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
          alias: "variable"
        },
        console: {
          pattern: /\bconsole(?=\s*\.)/,
          alias: "class-name"
        }
      });
      var maybeClassNameTokens = [
        "function",
        "function-variable",
        "method",
        "method-variable",
        "property-access"
      ];
      for (var i2 = 0; i2 < maybeClassNameTokens.length; i2++) {
        var token = maybeClassNameTokens[i2];
        var value = Prism2.languages.javascript[token];
        if (Prism2.util.type(value) === "RegExp") {
          value = Prism2.languages.javascript[token] = {
            pattern: value
          };
        }
        var inside = value.inside || {};
        value.inside = inside;
        inside["maybe-class-name"] = /^[A-Z][\s\S]*/;
      }
    })(Prism);
  }
  return jsExtras_1;
}
var jsTemplates_1;
var hasRequiredJsTemplates;
function requireJsTemplates() {
  if (hasRequiredJsTemplates) return jsTemplates_1;
  hasRequiredJsTemplates = 1;
  jsTemplates_1 = jsTemplates;
  jsTemplates.displayName = "jsTemplates";
  jsTemplates.aliases = [];
  function jsTemplates(Prism) {
    (function(Prism2) {
      var templateString = Prism2.languages.javascript["template-string"];
      var templateLiteralPattern = templateString.pattern.source;
      var interpolationObject = templateString.inside["interpolation"];
      var interpolationPunctuationObject = interpolationObject.inside["interpolation-punctuation"];
      var interpolationPattern = interpolationObject.pattern.source;
      function createTemplate(language, tag) {
        if (!Prism2.languages[language]) {
          return void 0;
        }
        return {
          pattern: RegExp("((?:" + tag + ")\\s*)" + templateLiteralPattern),
          lookbehind: true,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            "embedded-code": {
              pattern: /[\s\S]+/,
              alias: language
            }
          }
        };
      }
      Prism2.languages.javascript["template-string"] = [
        // styled-jsx:
        //   css`a { color: #25F; }`
        // styled-components:
        //   styled.h1`color: red;`
        createTemplate(
          "css",
          /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source
        ),
        // html`<p></p>`
        // div.innerHTML = `<p></p>`
        createTemplate("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
        // svg`<path fill="#fff" d="M55.37 ..."/>`
        createTemplate("svg", /\bsvg/.source),
        // md`# h1`, markdown`## h2`
        createTemplate("markdown", /\b(?:markdown|md)/.source),
        // gql`...`, graphql`...`, graphql.experimental`...`
        createTemplate(
          "graphql",
          /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source
        ),
        // sql`...`
        createTemplate("sql", /\bsql/.source),
        // vanilla template string
        templateString
      ].filter(Boolean);
      function getPlaceholder(counter, language) {
        return "___" + language.toUpperCase() + "_" + counter + "___";
      }
      function tokenizeWithHooks(code, grammar, language) {
        var env = {
          code,
          grammar,
          language
        };
        Prism2.hooks.run("before-tokenize", env);
        env.tokens = Prism2.tokenize(env.code, env.grammar);
        Prism2.hooks.run("after-tokenize", env);
        return env.tokens;
      }
      function tokenizeInterpolationExpression(expression) {
        var tempGrammar = {};
        tempGrammar["interpolation-punctuation"] = interpolationPunctuationObject;
        var tokens = Prism2.tokenize(expression, tempGrammar);
        if (tokens.length === 3) {
          var args = [1, 1];
          args.push.apply(
            args,
            tokenizeWithHooks(tokens[1], Prism2.languages.javascript, "javascript")
          );
          tokens.splice.apply(tokens, args);
        }
        return new Prism2.Token(
          "interpolation",
          tokens,
          interpolationObject.alias,
          expression
        );
      }
      function tokenizeEmbedded(code, grammar, language) {
        var _tokens = Prism2.tokenize(code, {
          interpolation: {
            pattern: RegExp(interpolationPattern),
            lookbehind: true
          }
        });
        var placeholderCounter = 0;
        var placeholderMap = {};
        var embeddedCode = _tokens.map(function(token) {
          if (typeof token === "string") {
            return token;
          } else {
            var interpolationExpression = token.content;
            var placeholder;
            while (code.indexOf(
              placeholder = getPlaceholder(placeholderCounter++, language)
            ) !== -1) {
            }
            placeholderMap[placeholder] = interpolationExpression;
            return placeholder;
          }
        }).join("");
        var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);
        var placeholders = Object.keys(placeholderMap);
        placeholderCounter = 0;
        function walkTokens(tokens) {
          for (var i2 = 0; i2 < tokens.length; i2++) {
            if (placeholderCounter >= placeholders.length) {
              return;
            }
            var token = tokens[i2];
            if (typeof token === "string" || typeof token.content === "string") {
              var placeholder = placeholders[placeholderCounter];
              var s2 = typeof token === "string" ? token : (
                /** @type {string} */
                token.content
              );
              var index2 = s2.indexOf(placeholder);
              if (index2 !== -1) {
                ++placeholderCounter;
                var before = s2.substring(0, index2);
                var middle = tokenizeInterpolationExpression(
                  placeholderMap[placeholder]
                );
                var after = s2.substring(index2 + placeholder.length);
                var replacement = [];
                if (before) {
                  replacement.push(before);
                }
                replacement.push(middle);
                if (after) {
                  var afterTokens = [after];
                  walkTokens(afterTokens);
                  replacement.push.apply(replacement, afterTokens);
                }
                if (typeof token === "string") {
                  tokens.splice.apply(tokens, [i2, 1].concat(replacement));
                  i2 += replacement.length - 1;
                } else {
                  token.content = replacement;
                }
              }
            } else {
              var content = token.content;
              if (Array.isArray(content)) {
                walkTokens(content);
              } else {
                walkTokens([content]);
              }
            }
          }
        }
        walkTokens(embeddedTokens);
        return new Prism2.Token(
          language,
          embeddedTokens,
          "language-" + language,
          code
        );
      }
      var supportedLanguages2 = {
        javascript: true,
        js: true,
        typescript: true,
        ts: true,
        jsx: true,
        tsx: true
      };
      Prism2.hooks.add("after-tokenize", function(env) {
        if (!(env.language in supportedLanguages2)) {
          return;
        }
        function findTemplateStrings(tokens) {
          for (var i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
            var token = tokens[i2];
            if (typeof token === "string") {
              continue;
            }
            var content = token.content;
            if (!Array.isArray(content)) {
              if (typeof content !== "string") {
                findTemplateStrings([content]);
              }
              continue;
            }
            if (token.type === "template-string") {
              var embedded = content[1];
              if (content.length === 3 && typeof embedded !== "string" && embedded.type === "embedded-code") {
                var code = stringContent(embedded);
                var alias = embedded.alias;
                var language = Array.isArray(alias) ? alias[0] : alias;
                var grammar = Prism2.languages[language];
                if (!grammar) {
                  continue;
                }
                content[1] = tokenizeEmbedded(code, grammar, language);
              }
            } else {
              findTemplateStrings(content);
            }
          }
        }
        findTemplateStrings(env.tokens);
      });
      function stringContent(value) {
        if (typeof value === "string") {
          return value;
        } else if (Array.isArray(value)) {
          return value.map(stringContent).join("");
        } else {
          return stringContent(value.content);
        }
      }
    })(Prism);
  }
  return jsTemplates_1;
}
var typescript_1;
var hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript) return typescript_1;
  hasRequiredTypescript = 1;
  typescript_1 = typescript;
  typescript.displayName = "typescript";
  typescript.aliases = ["ts"];
  function typescript(Prism) {
    (function(Prism2) {
      Prism2.languages.typescript = Prism2.languages.extend("javascript", {
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
      });
      Prism2.languages.typescript.keyword.push(
        /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
        // keywords that have to be followed by an identifier
        /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
        // This is for `import type *, {}`
        /\btype\b(?=\s*(?:[\{*]|$))/
      );
      delete Prism2.languages.typescript["parameter"];
      delete Prism2.languages.typescript["literal-property"];
      var typeInside = Prism2.languages.extend("typescript", {});
      delete typeInside["class-name"];
      Prism2.languages.typescript["class-name"].inside = typeInside;
      Prism2.languages.insertBefore("typescript", "function", {
        decorator: {
          pattern: /@[$\w\xA0-\uFFFF]+/,
          inside: {
            at: {
              pattern: /^@/,
              alias: "operator"
            },
            function: /^[\s\S]+/
          }
        },
        "generic-function": {
          // e.g. foo<T extends "bar" | "baz">( ...
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
          greedy: true,
          inside: {
            function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
            generic: {
              pattern: /<[\s\S]+/,
              // everything after the first <
              alias: "class-name",
              inside: typeInside
            }
          }
        }
      });
      Prism2.languages.ts = Prism2.languages.typescript;
    })(Prism);
  }
  return typescript_1;
}
var jsdoc_1;
var hasRequiredJsdoc;
function requireJsdoc() {
  if (hasRequiredJsdoc) return jsdoc_1;
  hasRequiredJsdoc = 1;
  var refractorJavadoclike = requireJavadoclike();
  var refractorTypescript = requireTypescript();
  jsdoc_1 = jsdoc;
  jsdoc.displayName = "jsdoc";
  jsdoc.aliases = [];
  function jsdoc(Prism) {
    Prism.register(refractorJavadoclike);
    Prism.register(refractorTypescript);
    (function(Prism2) {
      var javascript = Prism2.languages.javascript;
      var type = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source;
      var parameterPrefix = "(@(?:arg|argument|param|property)\\s+(?:" + type + "\\s+)?)";
      Prism2.languages.jsdoc = Prism2.languages.extend("javadoclike", {
        parameter: {
          // @param {string} foo - foo bar
          pattern: RegExp(
            parameterPrefix + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source
          ),
          lookbehind: true,
          inside: {
            punctuation: /\./
          }
        }
      });
      Prism2.languages.insertBefore("jsdoc", "keyword", {
        "optional-parameter": {
          // @param {string} [baz.foo="bar"] foo bar
          pattern: RegExp(
            parameterPrefix + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source
          ),
          lookbehind: true,
          inside: {
            parameter: {
              pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
              lookbehind: true,
              inside: {
                punctuation: /\./
              }
            },
            code: {
              pattern: /(=)[\s\S]*(?=\]$)/,
              lookbehind: true,
              inside: javascript,
              alias: "language-javascript"
            },
            punctuation: /[=[\]]/
          }
        },
        "class-name": [
          {
            pattern: RegExp(
              /(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(
                /<TYPE>/g,
                function() {
                  return type;
                }
              )
            ),
            lookbehind: true,
            inside: {
              punctuation: /\./
            }
          },
          {
            pattern: RegExp("(@[a-z]+\\s+)" + type),
            lookbehind: true,
            inside: {
              string: javascript.string,
              number: javascript.number,
              boolean: javascript.boolean,
              keyword: Prism2.languages.typescript.keyword,
              operator: /=>|\.\.\.|[&|?:*]/,
              punctuation: /[.,;=<>{}()[\]]/
            }
          }
        ],
        example: {
          pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
          lookbehind: true,
          inside: {
            code: {
              pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
              lookbehind: true,
              inside: javascript,
              alias: "language-javascript"
            }
          }
        }
      });
      Prism2.languages.javadoclike.addSupport("javascript", Prism2.languages.jsdoc);
    })(Prism);
  }
  return jsdoc_1;
}
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json_1;
  hasRequiredJson = 1;
  json_1 = json;
  json.displayName = "json";
  json.aliases = ["webmanifest"];
  function json(Prism) {
    Prism.languages.json = {
      property: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
        lookbehind: true,
        greedy: true
      },
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
        lookbehind: true,
        greedy: true
      },
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: true
      },
      number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      punctuation: /[{}[\],]/,
      operator: /:/,
      boolean: /\b(?:false|true)\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      }
    };
    Prism.languages.webmanifest = Prism.languages.json;
  }
  return json_1;
}
var json5_1;
var hasRequiredJson5;
function requireJson5() {
  if (hasRequiredJson5) return json5_1;
  hasRequiredJson5 = 1;
  var refractorJson = requireJson();
  json5_1 = json5;
  json5.displayName = "json5";
  json5.aliases = [];
  function json5(Prism) {
    Prism.register(refractorJson);
    (function(Prism2) {
      var string = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
      Prism2.languages.json5 = Prism2.languages.extend("json", {
        property: [
          {
            pattern: RegExp(string.source + "(?=\\s*:)"),
            greedy: true
          },
          {
            pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
            alias: "unquoted"
          }
        ],
        string: {
          pattern: string,
          greedy: true
        },
        number: /[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
      });
    })(Prism);
  }
  return json5_1;
}
var jsonp_1;
var hasRequiredJsonp;
function requireJsonp() {
  if (hasRequiredJsonp) return jsonp_1;
  hasRequiredJsonp = 1;
  var refractorJson = requireJson();
  jsonp_1 = jsonp;
  jsonp.displayName = "jsonp";
  jsonp.aliases = [];
  function jsonp(Prism) {
    Prism.register(refractorJson);
    Prism.languages.jsonp = Prism.languages.extend("json", {
      punctuation: /[{}[\]();,.]/
    });
    Prism.languages.insertBefore("jsonp", "punctuation", {
      function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
    });
  }
  return jsonp_1;
}
var jsstacktrace_1;
var hasRequiredJsstacktrace;
function requireJsstacktrace() {
  if (hasRequiredJsstacktrace) return jsstacktrace_1;
  hasRequiredJsstacktrace = 1;
  jsstacktrace_1 = jsstacktrace;
  jsstacktrace.displayName = "jsstacktrace";
  jsstacktrace.aliases = [];
  function jsstacktrace(Prism) {
    Prism.languages.jsstacktrace = {
      "error-message": {
        pattern: /^\S.*/m,
        alias: "string"
      },
      "stack-frame": {
        pattern: /(^[ \t]+)at[ \t].*/m,
        lookbehind: true,
        inside: {
          "not-my-code": {
            pattern: /^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
            alias: "comment"
          },
          filename: {
            pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
            lookbehind: true,
            alias: "url"
          },
          function: {
            pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
            lookbehind: true,
            inside: {
              punctuation: /\./
            }
          },
          punctuation: /[()]/,
          keyword: /\b(?:at|new)\b/,
          alias: {
            pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
            alias: "variable"
          },
          "line-number": {
            pattern: /:\d+(?::\d+)?\b/,
            alias: "number",
            inside: {
              punctuation: /:/
            }
          }
        }
      }
    };
  }
  return jsstacktrace_1;
}
var jsx_1;
var hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx) return jsx_1;
  hasRequiredJsx = 1;
  jsx_1 = jsx;
  jsx.displayName = "jsx";
  jsx.aliases = [];
  function jsx(Prism) {
    (function(Prism2) {
      var javascript = Prism2.util.clone(Prism2.languages.javascript);
      var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
      var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
      var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
      function re2(source, flags) {
        source = source.replace(/<S>/g, function() {
          return space;
        }).replace(/<BRACES>/g, function() {
          return braces;
        }).replace(/<SPREAD>/g, function() {
          return spread;
        });
        return RegExp(source, flags);
      }
      spread = re2(spread).source;
      Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
      Prism2.languages.jsx.tag.pattern = re2(
        /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
      );
      Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
      Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
      Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
      Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
      Prism2.languages.insertBefore(
        "inside",
        "attr-name",
        {
          spread: {
            pattern: re2(/<SPREAD>/.source),
            inside: Prism2.languages.jsx
          }
        },
        Prism2.languages.jsx.tag
      );
      Prism2.languages.insertBefore(
        "inside",
        "special-attr",
        {
          script: {
            // Allow for two levels of nesting
            pattern: re2(/=<BRACES>/.source),
            alias: "language-javascript",
            inside: {
              "script-punctuation": {
                pattern: /^=(?=\{)/,
                alias: "punctuation"
              },
              rest: Prism2.languages.jsx
            }
          }
        },
        Prism2.languages.jsx.tag
      );
      var stringifyToken = function(token) {
        if (!token) {
          return "";
        }
        if (typeof token === "string") {
          return token;
        }
        if (typeof token.content === "string") {
          return token.content;
        }
        return token.content.map(stringifyToken).join("");
      };
      var walkTokens = function(tokens) {
        var openedTags = [];
        for (var i2 = 0; i2 < tokens.length; i2++) {
          var token = tokens[i2];
          var notTagNorBrace = false;
          if (typeof token !== "string") {
            if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
              if (token.content[0].content[0].content === "</") {
                if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
                  openedTags.pop();
                }
              } else {
                if (token.content[token.content.length - 1].content === "/>") ;
                else {
                  openedTags.push({
                    tagName: stringifyToken(token.content[0].content[1]),
                    openedBraces: 0
                  });
                }
              }
            } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
              openedTags[openedTags.length - 1].openedBraces++;
            } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
              openedTags[openedTags.length - 1].openedBraces--;
            } else {
              notTagNorBrace = true;
            }
          }
          if (notTagNorBrace || typeof token === "string") {
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
              var plainText = stringifyToken(token);
              if (i2 < tokens.length - 1 && (typeof tokens[i2 + 1] === "string" || tokens[i2 + 1].type === "plain-text")) {
                plainText += stringifyToken(tokens[i2 + 1]);
                tokens.splice(i2 + 1, 1);
              }
              if (i2 > 0 && (typeof tokens[i2 - 1] === "string" || tokens[i2 - 1].type === "plain-text")) {
                plainText = stringifyToken(tokens[i2 - 1]) + plainText;
                tokens.splice(i2 - 1, 1);
                i2--;
              }
              tokens[i2] = new Prism2.Token(
                "plain-text",
                plainText,
                null,
                plainText
              );
            }
          }
          if (token.content && typeof token.content !== "string") {
            walkTokens(token.content);
          }
        }
      };
      Prism2.hooks.add("after-tokenize", function(env) {
        if (env.language !== "jsx" && env.language !== "tsx") {
          return;
        }
        walkTokens(env.tokens);
      });
    })(Prism);
  }
  return jsx_1;
}
var julia_1;
var hasRequiredJulia;
function requireJulia() {
  if (hasRequiredJulia) return julia_1;
  hasRequiredJulia = 1;
  julia_1 = julia;
  julia.displayName = "julia";
  julia.aliases = [];
  function julia(Prism) {
    Prism.languages.julia = {
      comment: {
        // support one level of nested comments
        // https://github.com/JuliaLang/julia/pull/6128
        pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
        lookbehind: true
      },
      regex: {
        // https://docs.julialang.org/en/v1/manual/strings/#Regular-Expressions-1
        pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
        greedy: true
      },
      string: {
        // https://docs.julialang.org/en/v1/manual/strings/#String-Basics-1
        // https://docs.julialang.org/en/v1/manual/strings/#non-standard-string-literals-1
        // https://docs.julialang.org/en/v1/manual/running-external-programs/#Running-External-Programs-1
        pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
        greedy: true
      },
      char: {
        // https://docs.julialang.org/en/v1/manual/strings/#man-characters-1
        pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
        lookbehind: true,
        greedy: true
      },
      keyword: /\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
      // https://docs.julialang.org/en/v1/manual/mathematical-operations/
      // https://docs.julialang.org/en/v1/manual/mathematical-operations/#Operator-Precedence-and-Associativity-1
      operator: /&&|\|\||[-+*^%÷⊻&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~≠≤≥'√∛]/,
      punctuation: /::?|[{}[\]();,.?]/,
      // https://docs.julialang.org/en/v1/base/numbers/#Base.im
      constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[πℯ]/
    };
  }
  return julia_1;
}
var keepalived_1;
var hasRequiredKeepalived;
function requireKeepalived() {
  if (hasRequiredKeepalived) return keepalived_1;
  hasRequiredKeepalived = 1;
  keepalived_1 = keepalived;
  keepalived.displayName = "keepalived";
  keepalived.aliases = [];
  function keepalived(Prism) {
    Prism.languages.keepalived = {
      comment: {
        pattern: /[#!].*/,
        greedy: true
      },
      string: {
        pattern: /(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
        lookbehind: true,
        greedy: true
      },
      // support IPv4, IPv6, subnet mask
      ip: {
        pattern: RegExp(
          /\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(
            /<ipv4>/g,
            function() {
              return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/.source;
            }
          ),
          "i"
        ),
        alias: "number"
      },
      // support *nix / Windows, directory / file
      path: {
        pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
        lookbehind: true,
        alias: "string"
      },
      variable: /\$\{?\w+\}?/,
      email: {
        pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
        alias: "string"
      },
      "conditional-configuration": {
        pattern: /@\^?[\w-]+/,
        alias: "variable"
      },
      operator: /=/,
      property: /\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
      constant: /\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
      number: {
        pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
        lookbehind: true
      },
      boolean: /\b(?:false|no|off|on|true|yes)\b/,
      punctuation: /[\{\}]/
    };
  }
  return keepalived_1;
}
var keyman_1;
var hasRequiredKeyman;
function requireKeyman() {
  if (hasRequiredKeyman) return keyman_1;
  hasRequiredKeyman = 1;
  keyman_1 = keyman;
  keyman.displayName = "keyman";
  keyman.aliases = [];
  function keyman(Prism) {
    Prism.languages.keyman = {
      comment: {
        pattern: /\bc .*/i,
        greedy: true
      },
      string: {
        pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
        greedy: true
      },
      "virtual-key": {
        pattern: /\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
        greedy: true,
        alias: "function"
        // alias for styles
      },
      // https://help.keyman.com/developer/language/guide/headers
      "header-keyword": {
        pattern: /&\w+/,
        alias: "bold"
        // alias for styles
      },
      "header-statement": {
        pattern: /\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
        alias: "bold"
        // alias for styles
      },
      "rule-keyword": {
        pattern: /\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
        alias: "keyword"
      },
      "structural-keyword": {
        pattern: /\b(?:ansi|begin|group|match|nomatch|unicode|using keys)\b/i,
        alias: "keyword"
      },
      "compile-target": {
        pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
        alias: "property"
      },
      // U+####, x###, d### characters and numbers
      number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
      operator: /[+>\\$]|\.\./,
      punctuation: /[()=,]/
    };
  }
  return keyman_1;
}
var kotlin_1;
var hasRequiredKotlin;
function requireKotlin() {
  if (hasRequiredKotlin) return kotlin_1;
  hasRequiredKotlin = 1;
  kotlin_1 = kotlin;
  kotlin.displayName = "kotlin";
  kotlin.aliases = ["kt", "kts"];
  function kotlin(Prism) {
    (function(Prism2) {
      Prism2.languages.kotlin = Prism2.languages.extend("clike", {
        keyword: {
          // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
          pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
          lookbehind: true
        },
        function: [
          {
            pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
            greedy: true
          },
          {
            pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
            lookbehind: true,
            greedy: true
          }
        ],
        number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
        operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
      });
      delete Prism2.languages.kotlin["class-name"];
      var interpolationInside = {
        "interpolation-punctuation": {
          pattern: /^\$\{?|\}$/,
          alias: "punctuation"
        },
        expression: {
          pattern: /[\s\S]+/,
          inside: Prism2.languages.kotlin
        }
      };
      Prism2.languages.insertBefore("kotlin", "string", {
        // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
        "string-literal": [
          {
            pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
            alias: "multiline",
            inside: {
              interpolation: {
                pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                inside: interpolationInside
              },
              string: /[\s\S]+/
            }
          },
          {
            pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
            alias: "singleline",
            inside: {
              interpolation: {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                lookbehind: true,
                inside: interpolationInside
              },
              string: /[\s\S]+/
            }
          }
        ],
        char: {
          // https://kotlinlang.org/spec/expressions.html#character-literals
          pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
          greedy: true
        }
      });
      delete Prism2.languages.kotlin["string"];
      Prism2.languages.insertBefore("kotlin", "keyword", {
        annotation: {
          pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
          alias: "builtin"
        }
      });
      Prism2.languages.insertBefore("kotlin", "function", {
        label: {
          pattern: /\b\w+@|@\w+\b/,
          alias: "symbol"
        }
      });
      Prism2.languages.kt = Prism2.languages.kotlin;
      Prism2.languages.kts = Prism2.languages.kotlin;
    })(Prism);
  }
  return kotlin_1;
}
var kumir_1;
var hasRequiredKumir;
function requireKumir() {
  if (hasRequiredKumir) return kumir_1;
  hasRequiredKumir = 1;
  kumir_1 = kumir;
  kumir.displayName = "kumir";
  kumir.aliases = ["kum"];
  function kumir(Prism) {
    (function(Prism2) {
      var nonId = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
      function wrapId(pattern, flags) {
        return RegExp(pattern.replace(/<nonId>/g, nonId), flags);
      }
      Prism2.languages.kumir = {
        comment: {
          pattern: /\|.*/
        },
        prolog: {
          pattern: /#.*/,
          greedy: true
        },
        string: {
          pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
          greedy: true
        },
        boolean: {
          pattern: wrapId(/(^|[<nonId>])(?:да|нет)(?=[<nonId>]|$)/.source),
          lookbehind: true
        },
        "operator-word": {
          pattern: wrapId(/(^|[<nonId>])(?:и|или|не)(?=[<nonId>]|$)/.source),
          lookbehind: true,
          alias: "keyword"
        },
        "system-variable": {
          pattern: wrapId(/(^|[<nonId>])знач(?=[<nonId>]|$)/.source),
          lookbehind: true,
          alias: "keyword"
        },
        type: [
          {
            pattern: wrapId(
              /(^|[<nonId>])(?:вещ|лит|лог|сим|цел)(?:\x20*таб)?(?=[<nonId>]|$)/.source
            ),
            lookbehind: true,
            alias: "builtin"
          },
          {
            pattern: wrapId(
              /(^|[<nonId>])(?:компл|сканкод|файл|цвет)(?=[<nonId>]|$)/.source
            ),
            lookbehind: true,
            alias: "important"
          }
        ],
        /**
         * Should be performed after searching for type names because of "таб".
         * "таб" is a reserved word, but never used without a preceding type name.
         * "НАЗНАЧИТЬ", "Фввод", and "Фвывод" are not reserved words.
         */
        keyword: {
          pattern: wrapId(
            /(^|[<nonId>])(?:алг|арг(?:\x20*рез)?|ввод|ВКЛЮЧИТЬ|вс[её]|выбор|вывод|выход|дано|для|до|дс|если|иначе|исп|использовать|кон(?:(?:\x20+|_)исп)?|кц(?:(?:\x20+|_)при)?|надо|нач|нс|нц|от|пауза|пока|при|раза?|рез|стоп|таб|то|утв|шаг)(?=[<nonId>]|$)/.source
          ),
          lookbehind: true
        },
        /** Should be performed after searching for reserved words. */
        name: {
          // eslint-disable-next-line regexp/no-super-linear-backtracking
          pattern: wrapId(
            /(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source
          ),
          lookbehind: true
        },
        /** Should be performed after searching for names. */
        number: {
          pattern: wrapId(
            /(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/.source,
            "i"
          ),
          lookbehind: true
        },
        /** Should be performed after searching for words. */
        punctuation: /:=|[(),:;\[\]]/,
        /**
         * Should be performed after searching for
         * - numeric constants (because of "+" and "-");
         * - punctuation marks (because of ":=" and "=").
         */
        "operator-char": {
          pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
          alias: "operator"
        }
      };
      Prism2.languages.kum = Prism2.languages.kumir;
    })(Prism);
  }
  return kumir_1;
}
var kusto_1;
var hasRequiredKusto;
function requireKusto() {
  if (hasRequiredKusto) return kusto_1;
  hasRequiredKusto = 1;
  kusto_1 = kusto;
  kusto.displayName = "kusto";
  kusto.aliases = [];
  function kusto(Prism) {
    Prism.languages.kusto = {
      comment: {
        pattern: /\/\/.*/,
        greedy: true
      },
      string: {
        pattern: /```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
        greedy: true
      },
      verb: {
        pattern: /(\|\s*)[a-z][\w-]*/i,
        lookbehind: true,
        alias: "keyword"
      },
      command: {
        pattern: /\.[a-z][a-z\d-]*\b/,
        alias: "keyword"
      },
      "class-name": /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
      keyword: /\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
      boolean: /\b(?:false|null|true)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/,
      datetime: [
        {
          // RFC 822 + RFC 850
          pattern: /\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
          alias: "number"
        },
        {
          // ISO 8601
          pattern: /[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
          alias: "number"
        }
      ],
      number: /\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mnµ]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
      operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
      punctuation: /[()\[\]{},;.:]/
    };
  }
  return kusto_1;
}
var latex_1;
var hasRequiredLatex;
function requireLatex() {
  if (hasRequiredLatex) return latex_1;
  hasRequiredLatex = 1;
  latex_1 = latex;
  latex.displayName = "latex";
  latex.aliases = ["tex", "context"];
  function latex(Prism) {
    (function(Prism2) {
      var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
      var insideEqu = {
        "equation-command": {
          pattern: funcPattern,
          alias: "regex"
        }
      };
      Prism2.languages.latex = {
        comment: /%.*/,
        // the verbatim environment prints whitespace to the document
        cdata: {
          pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
          lookbehind: true
        },
        /*
         * equations can be between $$ $$ or $ $ or \( \) or \[ \]
         * (all are multiline)
         */
        equation: [
          {
            pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
            inside: insideEqu,
            alias: "string"
          },
          {
            pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
            lookbehind: true,
            inside: insideEqu,
            alias: "string"
          }
        ],
        /*
         * arguments which are keywords or references are highlighted
         * as keywords
         */
        keyword: {
          pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
          lookbehind: true
        },
        url: {
          pattern: /(\\url\{)[^}]+(?=\})/,
          lookbehind: true
        },
        /*
         * section or chapter headlines are highlighted as bold so that
         * they stand out more
         */
        headline: {
          pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
          lookbehind: true,
          alias: "class-name"
        },
        function: {
          pattern: funcPattern,
          alias: "selector"
        },
        punctuation: /[[\]{}&]/
      };
      Prism2.languages.tex = Prism2.languages.latex;
      Prism2.languages.context = Prism2.languages.latex;
    })(Prism);
  }
  return latex_1;
}
var php_1;
var hasRequiredPhp;
function requirePhp() {
  if (hasRequiredPhp) return php_1;
  hasRequiredPhp = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  php_1 = php;
  php.displayName = "php";
  php.aliases = [];
  function php(Prism) {
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
      var constant = [
        {
          pattern: /\b(?:false|true)\b/i,
          alias: "boolean"
        },
        {
          pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
          greedy: true,
          lookbehind: true
        },
        {
          pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
          greedy: true,
          lookbehind: true
        },
        /\b(?:null)\b/i,
        /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
      ];
      var number2 = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
      var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
      var punctuation = /[{}\[\](),:;]/;
      Prism2.languages.php = {
        delimiter: {
          pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
          alias: "important"
        },
        comment,
        variable: /\$+(?:\w+\b|(?=\{))/,
        package: {
          pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
          lookbehind: true,
          inside: {
            punctuation: /\\/
          }
        },
        "class-name-definition": {
          pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
          lookbehind: true,
          alias: "class-name"
        },
        "function-definition": {
          pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
          lookbehind: true,
          alias: "function"
        },
        keyword: [
          {
            pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
            alias: "type-casting",
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
            alias: "type-hint",
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string|void)\b/i,
            alias: "return-type",
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
            alias: "type-declaration",
            greedy: true
          },
          {
            pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
            alias: "type-declaration",
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /\b(?:parent|self|static)(?=\s*::)/i,
            alias: "static-context",
            greedy: true
          },
          {
            // yield from
            pattern: /(\byield\s+)from\b/i,
            lookbehind: true
          },
          // `class` is always a keyword unlike other keywords
          /\bclass\b/i,
          {
            // https://www.php.net/manual/en/reserved.keywords.php
            //
            // keywords cannot be preceded by "->"
            // the complex lookbehind means `(?<!(?:->|::)\s*)`
            pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
            lookbehind: true
          }
        ],
        "argument-name": {
          pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
          lookbehind: true
        },
        "class-name": [
          {
            pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
            greedy: true
          },
          {
            pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
            alias: "class-name-fully-qualified",
            greedy: true,
            lookbehind: true,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
            alias: "class-name-fully-qualified",
            greedy: true,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
            alias: "class-name-fully-qualified",
            greedy: true,
            lookbehind: true,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /\b[a-z_]\w*(?=\s*\$)/i,
            alias: "type-declaration",
            greedy: true
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
            alias: ["class-name-fully-qualified", "type-declaration"],
            greedy: true,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /\b[a-z_]\w*(?=\s*::)/i,
            alias: "static-context",
            greedy: true
          },
          {
            pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
            alias: ["class-name-fully-qualified", "static-context"],
            greedy: true,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
            alias: "type-hint",
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
            alias: ["class-name-fully-qualified", "type-hint"],
            greedy: true,
            lookbehind: true,
            inside: {
              punctuation: /\\/
            }
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
            alias: "return-type",
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
            alias: ["class-name-fully-qualified", "return-type"],
            greedy: true,
            lookbehind: true,
            inside: {
              punctuation: /\\/
            }
          }
        ],
        constant,
        function: {
          pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
          lookbehind: true,
          inside: {
            punctuation: /\\/
          }
        },
        property: {
          pattern: /(->\s*)\w+/,
          lookbehind: true
        },
        number: number2,
        operator,
        punctuation
      };
      var string_interpolation = {
        pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
        lookbehind: true,
        inside: Prism2.languages.php
      };
      var string = [
        {
          pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
          alias: "nowdoc-string",
          greedy: true,
          inside: {
            delimiter: {
              pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
              alias: "symbol",
              inside: {
                punctuation: /^<<<'?|[';]$/
              }
            }
          }
        },
        {
          pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
          alias: "heredoc-string",
          greedy: true,
          inside: {
            delimiter: {
              pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
              alias: "symbol",
              inside: {
                punctuation: /^<<<"?|[";]$/
              }
            },
            interpolation: string_interpolation
          }
        },
        {
          pattern: /`(?:\\[\s\S]|[^\\`])*`/,
          alias: "backtick-quoted-string",
          greedy: true
        },
        {
          pattern: /'(?:\\[\s\S]|[^\\'])*'/,
          alias: "single-quoted-string",
          greedy: true
        },
        {
          pattern: /"(?:\\[\s\S]|[^\\"])*"/,
          alias: "double-quoted-string",
          greedy: true,
          inside: {
            interpolation: string_interpolation
          }
        }
      ];
      Prism2.languages.insertBefore("php", "variable", {
        string,
        attribute: {
          pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
          greedy: true,
          inside: {
            "attribute-content": {
              pattern: /^(#\[)[\s\S]+(?=\]$)/,
              lookbehind: true,
              // inside can appear subset of php
              inside: {
                comment,
                string,
                "attribute-class-name": [
                  {
                    pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                    alias: "class-name",
                    greedy: true,
                    lookbehind: true
                  },
                  {
                    pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                    alias: ["class-name", "class-name-fully-qualified"],
                    greedy: true,
                    lookbehind: true,
                    inside: {
                      punctuation: /\\/
                    }
                  }
                ],
                constant,
                number: number2,
                operator,
                punctuation
              }
            },
            delimiter: {
              pattern: /^#\[|\]$/,
              alias: "punctuation"
            }
          }
        }
      });
      Prism2.hooks.add("before-tokenize", function(env) {
        if (!/<\?/.test(env.code)) {
          return;
        }
        var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "php",
          phpPattern
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "php");
      });
    })(Prism);
  }
  return php_1;
}
var latte_1;
var hasRequiredLatte;
function requireLatte() {
  if (hasRequiredLatte) return latte_1;
  hasRequiredLatte = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  var refractorPhp = requirePhp();
  latte_1 = latte;
  latte.displayName = "latte";
  latte.aliases = [];
  function latte(Prism) {
    Prism.register(refractorMarkupTemplating);
    Prism.register(refractorPhp);
    (function(Prism2) {
      Prism2.languages.latte = {
        comment: /^\{\*[\s\S]*/,
        "latte-tag": {
          // https://latte.nette.org/en/tags
          pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
          lookbehind: true,
          alias: "important"
        },
        delimiter: {
          pattern: /^\{\/?|\}$/,
          alias: "punctuation"
        },
        php: {
          pattern: /\S(?:[\s\S]*\S)?/,
          alias: "language-php",
          inside: Prism2.languages.php
        }
      };
      var markupLatte = Prism2.languages.extend("markup", {});
      Prism2.languages.insertBefore(
        "inside",
        "attr-value",
        {
          "n-attr": {
            pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
            inside: {
              "attr-name": {
                pattern: /^[^\s=]+/,
                alias: "important"
              },
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  punctuation: [
                    /^=/,
                    {
                      pattern: /^(\s*)["']|["']$/,
                      lookbehind: true
                    }
                  ],
                  php: {
                    pattern: /\S(?:[\s\S]*\S)?/,
                    inside: Prism2.languages.php
                  }
                }
              }
            }
          }
        },
        markupLatte.tag
      );
      Prism2.hooks.add("before-tokenize", function(env) {
        if (env.language !== "latte") {
          return;
        }
        var lattePattern = /\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "latte",
          lattePattern
        );
        env.grammar = markupLatte;
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "latte");
      });
    })(Prism);
  }
  return latte_1;
}
var less_1;
var hasRequiredLess;
function requireLess() {
  if (hasRequiredLess) return less_1;
  hasRequiredLess = 1;
  less_1 = less;
  less.displayName = "less";
  less.aliases = [];
  function less(Prism) {
    Prism.languages.less = Prism.languages.extend("css", {
      comment: [
        /\/\*[\s\S]*?\*\//,
        {
          pattern: /(^|[^\\])\/\/.*/,
          lookbehind: true
        }
      ],
      atrule: {
        pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
        inside: {
          punctuation: /[:()]/
        }
      },
      // selectors and mixins are considered the same
      selector: {
        pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
        inside: {
          // mixin parameters
          variable: /@+[\w-]+/
        }
      },
      property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
      operator: /[+\-*\/]/
    });
    Prism.languages.insertBefore("less", "property", {
      variable: [
        // Variable declaration (the colon must be consumed!)
        {
          pattern: /@[\w-]+\s*:/,
          inside: {
            punctuation: /:/
          }
        },
        // Variable usage
        /@@?[\w-]+/
      ],
      "mixin-usage": {
        pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
        lookbehind: true,
        alias: "function"
      }
    });
  }
  return less_1;
}
var scheme_1;
var hasRequiredScheme;
function requireScheme() {
  if (hasRequiredScheme) return scheme_1;
  hasRequiredScheme = 1;
  scheme_1 = scheme;
  scheme.displayName = "scheme";
  scheme.aliases = [];
  function scheme(Prism) {
    (function(Prism2) {
      Prism2.languages.scheme = {
        // this supports "normal" single-line comments:
        //   ; comment
        // and (potentially nested) multiline comments:
        //   #| comment #| nested |# still comment |#
        // (only 1 level of nesting is supported)
        comment: /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: true
        },
        symbol: {
          pattern: /'[^()\[\]#'\s]+/,
          greedy: true
        },
        char: {
          pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
          greedy: true
        },
        "lambda-parameter": [
          // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30
          {
            pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
            lookbehind: true
          },
          {
            pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
            lookbehind: true
          }
        ],
        keyword: {
          pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
          lookbehind: true
        },
        builtin: {
          // all functions of the base library of R7RS plus some of built-ins of R5Rs
          pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
          lookbehind: true
        },
        operator: {
          pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
          lookbehind: true
        },
        number: {
          // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).
          //
          // <number>      := <num 2>|<num 8>|<num 10>|<num 16>
          // <num R>       := <prefix R><complex R>
          // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>
          // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\.0)?i
          // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\.0
          // <ureal R>     := <uint R>(?:\/<uint R>)?
          //                | <decimal R>
          //
          // <decimal 10>  := (?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?
          // <uint R>      := <digit R>+
          // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>
          // <radix 2>     := #b
          // <radix 8>     := #o
          // <radix 10>    := (?:#d)?
          // <radix 16>    := #x
          // <digit 2>     := [01]
          // <digit 8>     := [0-7]
          // <digit 10>    := \d
          // <digit 16>    := [0-9a-f]
          //
          // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all
          // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)
          // pattern:
          pattern: RegExp(
            SortedBNF({
              "<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
              "<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
              "<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
              "<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
              "<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
              "<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
              "<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
              "<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
              "<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
              "<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
              "<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
            }),
            "i"
          ),
          lookbehind: true
        },
        boolean: {
          pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
          lookbehind: true
        },
        function: {
          pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
          lookbehind: true
        },
        identifier: {
          pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
          lookbehind: true,
          greedy: true
        },
        punctuation: /[()\[\]']/
      };
      function SortedBNF(grammar) {
        for (var key in grammar) {
          grammar[key] = grammar[key].replace(/<[\w\s]+>/g, function(key2) {
            return "(?:" + grammar[key2].trim() + ")";
          });
        }
        return grammar[key];
      }
    })(Prism);
  }
  return scheme_1;
}
var lilypond_1;
var hasRequiredLilypond;
function requireLilypond() {
  if (hasRequiredLilypond) return lilypond_1;
  hasRequiredLilypond = 1;
  var refractorScheme = requireScheme();
  lilypond_1 = lilypond;
  lilypond.displayName = "lilypond";
  lilypond.aliases = [];
  function lilypond(Prism) {
    Prism.register(refractorScheme);
    (function(Prism2) {
      var schemeExpression = /\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/.source;
      var recursivenessLog2 = 5;
      for (var i2 = 0; i2 < recursivenessLog2; i2++) {
        schemeExpression = schemeExpression.replace(/<expr>/g, function() {
          return schemeExpression;
        });
      }
      schemeExpression = schemeExpression.replace(/<expr>/g, /[^\s\S]/.source);
      var lilypond2 = Prism2.languages.lilypond = {
        comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
        "embedded-scheme": {
          pattern: RegExp(
            /(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(
              /<expr>/g,
              function() {
                return schemeExpression;
              }
            ),
            "m"
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            scheme: {
              pattern: /^(#)[\s\S]+$/,
              lookbehind: true,
              alias: "language-scheme",
              inside: {
                "embedded-lilypond": {
                  pattern: /#\{[\s\S]*?#\}/,
                  greedy: true,
                  inside: {
                    punctuation: /^#\{|#\}$/,
                    lilypond: {
                      pattern: /[\s\S]+/,
                      alias: "language-lilypond",
                      inside: null
                      // see below
                    }
                  }
                },
                rest: Prism2.languages.scheme
              }
            },
            punctuation: /#/
          }
        },
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: true
        },
        "class-name": {
          pattern: /(\\new\s+)[\w-]+/,
          lookbehind: true
        },
        keyword: {
          pattern: /\\[a-z][-\w]*/i,
          inside: {
            punctuation: /^\\/
          }
        },
        operator: /[=|]|<<|>>/,
        punctuation: {
          pattern: /(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
          lookbehind: true
        },
        number: /\b\d+(?:\/\d+)?\b/
      };
      lilypond2["embedded-scheme"].inside["scheme"].inside["embedded-lilypond"].inside["lilypond"].inside = lilypond2;
      Prism2.languages.ly = lilypond2;
    })(Prism);
  }
  return lilypond_1;
}
var liquid_1;
var hasRequiredLiquid;
function requireLiquid() {
  if (hasRequiredLiquid) return liquid_1;
  hasRequiredLiquid = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  liquid_1 = liquid;
  liquid.displayName = "liquid";
  liquid.aliases = [];
  function liquid(Prism) {
    Prism.register(refractorMarkupTemplating);
    Prism.languages.liquid = {
      comment: {
        pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
        lookbehind: true
      },
      delimiter: {
        pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
        alias: "punctuation"
      },
      string: {
        pattern: /"[^"]*"|'[^']*'/,
        greedy: true
      },
      keyword: /\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
      object: /\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
      function: [
        {
          pattern: /(\|\s*)\w+/,
          lookbehind: true,
          alias: "filter"
        },
        {
          // array functions
          pattern: /(\.\s*)(?:first|last|size)/,
          lookbehind: true
        }
      ],
      boolean: /\b(?:false|nil|true)\b/,
      range: {
        pattern: /\.\./,
        alias: "operator"
      },
      // https://github.com/Shopify/liquid/blob/698f5e0d967423e013f6169d9111bd969bd78337/lib/liquid/lexer.rb#L21
      number: /\b\d+(?:\.\d+)?\b/,
      operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
      punctuation: /[.,\[\]()]/,
      empty: {
        pattern: /\bempty\b/,
        alias: "keyword"
      }
    };
    Prism.hooks.add("before-tokenize", function(env) {
      var liquidPattern = /\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g;
      var insideRaw = false;
      Prism.languages["markup-templating"].buildPlaceholders(
        env,
        "liquid",
        liquidPattern,
        function(match2) {
          var tagMatch = /^\{%-?\s*(\w+)/.exec(match2);
          if (tagMatch) {
            var tag = tagMatch[1];
            if (tag === "raw" && !insideRaw) {
              insideRaw = true;
              return true;
            } else if (tag === "endraw") {
              insideRaw = false;
              return true;
            }
          }
          return !insideRaw;
        }
      );
    });
    Prism.hooks.add("after-tokenize", function(env) {
      Prism.languages["markup-templating"].tokenizePlaceholders(env, "liquid");
    });
  }
  return liquid_1;
}
var lisp_1;
var hasRequiredLisp;
function requireLisp() {
  if (hasRequiredLisp) return lisp_1;
  hasRequiredLisp = 1;
  lisp_1 = lisp;
  lisp.displayName = "lisp";
  lisp.aliases = [];
  function lisp(Prism) {
    (function(Prism2) {
      function simple_form(name) {
        return RegExp(/(\()/.source + "(?:" + name + ")" + /(?=[\s\)])/.source);
      }
      function primitive(pattern) {
        return RegExp(
          /([\s([])/.source + "(?:" + pattern + ")" + /(?=[\s)])/.source
        );
      }
      var symbol = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source;
      var marker = "&" + symbol;
      var par = "(\\()";
      var endpar = "(?=\\))";
      var space = "(?=\\s)";
      var nestedPar = /(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source;
      var language = {
        // Three or four semicolons are considered a heading.
        // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html
        heading: {
          pattern: /;;;.*/,
          alias: ["comment", "title"]
        },
        comment: /;.*/,
        string: {
          pattern: /"(?:[^"\\]|\\.)*"/,
          greedy: true,
          inside: {
            argument: /[-A-Z]+(?=[.,\s])/,
            symbol: RegExp("`" + symbol + "'")
          }
        },
        "quoted-symbol": {
          pattern: RegExp("#?'" + symbol),
          alias: ["variable", "symbol"]
        },
        "lisp-property": {
          pattern: RegExp(":" + symbol),
          alias: "property"
        },
        splice: {
          pattern: RegExp(",@?" + symbol),
          alias: ["symbol", "variable"]
        },
        keyword: [
          {
            pattern: RegExp(
              par + "(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)" + space
            ),
            lookbehind: true
          },
          {
            pattern: RegExp(
              par + "(?:append|by|collect|concat|do|finally|for|in|return)" + space
            ),
            lookbehind: true
          }
        ],
        declare: {
          pattern: simple_form(/declare/.source),
          lookbehind: true,
          alias: "keyword"
        },
        interactive: {
          pattern: simple_form(/interactive/.source),
          lookbehind: true,
          alias: "keyword"
        },
        boolean: {
          pattern: primitive(/nil|t/.source),
          lookbehind: true
        },
        number: {
          pattern: primitive(/[-+]?\d+(?:\.\d*)?/.source),
          lookbehind: true
        },
        defvar: {
          pattern: RegExp(par + "def(?:const|custom|group|var)\\s+" + symbol),
          lookbehind: true,
          inside: {
            keyword: /^def[a-z]+/,
            variable: RegExp(symbol)
          }
        },
        defun: {
          pattern: RegExp(
            par + /(?:cl-)?(?:defmacro|defun\*?)\s+/.source + symbol + /\s+\(/.source + nestedPar + /\)/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            keyword: /^(?:cl-)?def\S+/,
            // See below, this property needs to be defined later so that it can
            // reference the language object.
            arguments: null,
            function: {
              pattern: RegExp("(^\\s)" + symbol),
              lookbehind: true
            },
            punctuation: /[()]/
          }
        },
        lambda: {
          pattern: RegExp(
            par + "lambda\\s+\\(\\s*(?:&?" + symbol + "(?:\\s+&?" + symbol + ")*\\s*)?\\)"
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            keyword: /^lambda/,
            // See below, this property needs to be defined later so that it can
            // reference the language object.
            arguments: null,
            punctuation: /[()]/
          }
        },
        car: {
          pattern: RegExp(par + symbol),
          lookbehind: true
        },
        punctuation: [
          // open paren, brackets, and close paren
          /(?:['`,]?\(|[)\[\]])/,
          // cons
          {
            pattern: /(\s)\.(?=\s)/,
            lookbehind: true
          }
        ]
      };
      var arg = {
        "lisp-marker": RegExp(marker),
        varform: {
          pattern: RegExp(
            /\(/.source + symbol + /\s+(?=\S)/.source + nestedPar + /\)/.source
          ),
          inside: language
        },
        argument: {
          pattern: RegExp(/(^|[\s(])/.source + symbol),
          lookbehind: true,
          alias: "variable"
        },
        rest: language
      };
      var forms = "\\S+(?:\\s+\\S+)*";
      var arglist = {
        pattern: RegExp(par + nestedPar + endpar),
        lookbehind: true,
        inside: {
          "rest-vars": {
            pattern: RegExp("&(?:body|rest)\\s+" + forms),
            inside: arg
          },
          "other-marker-vars": {
            pattern: RegExp("&(?:aux|optional)\\s+" + forms),
            inside: arg
          },
          keys: {
            pattern: RegExp("&key\\s+" + forms + "(?:\\s+&allow-other-keys)?"),
            inside: arg
          },
          argument: {
            pattern: RegExp(symbol),
            alias: "variable"
          },
          punctuation: /[()]/
        }
      };
      language["lambda"].inside.arguments = arglist;
      language["defun"].inside.arguments = Prism2.util.clone(arglist);
      language["defun"].inside.arguments.inside.sublist = arglist;
      Prism2.languages.lisp = language;
      Prism2.languages.elisp = language;
      Prism2.languages.emacs = language;
      Prism2.languages["emacs-lisp"] = language;
    })(Prism);
  }
  return lisp_1;
}
var livescript_1;
var hasRequiredLivescript;
function requireLivescript() {
  if (hasRequiredLivescript) return livescript_1;
  hasRequiredLivescript = 1;
  livescript_1 = livescript;
  livescript.displayName = "livescript";
  livescript.aliases = [];
  function livescript(Prism) {
    Prism.languages.livescript = {
      comment: [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: true
        },
        {
          pattern: /(^|[^\\])#.*/,
          lookbehind: true
        }
      ],
      "interpolated-string": {
        /* Look-behind and look-ahead prevents wrong behavior of the greedy pattern
         * forcing it to match """-quoted string when it would otherwise match "-quoted first. */
        pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
        lookbehind: true,
        greedy: true,
        inside: {
          variable: {
            pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
            lookbehind: true
          },
          interpolation: {
            pattern: /(^|[^\\])#\{[^}]+\}/m,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^#\{|\}$/,
                alias: "variable"
              }
              // See rest below
            }
          },
          string: /[\s\S]+/
        }
      },
      string: [
        {
          pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
          greedy: true
        },
        {
          pattern: /<\[[\s\S]*?\]>/,
          greedy: true
        },
        /\\[^\s,;\])}]+/
      ],
      regex: [
        {
          pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
          greedy: true,
          inside: {
            comment: {
              pattern: /(^|[^\\])#.*/,
              lookbehind: true
            }
          }
        },
        {
          pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
          greedy: true
        }
      ],
      keyword: {
        pattern: /(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
        lookbehind: true
      },
      "keyword-operator": {
        pattern: /(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
        lookbehind: true,
        alias: "operator"
      },
      boolean: {
        pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
        lookbehind: true
      },
      argument: {
        // Don't match .&. nor &&
        pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
        lookbehind: true,
        alias: "variable"
      },
      number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
      identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
      operator: [
        // Spaced .
        {
          pattern: /( )\.(?= )/,
          lookbehind: true
        },
        // Full list, in order:
        // .= .~ .. ...
        // .&. .^. .<<. .>>. .>>>.
        // := :: ::=
        // &&
        // || |>
        // < << <<< <<<<
        // <- <-- <-! <--!
        // <~ <~~ <~! <~~!
        // <| <= <?
        // > >> >= >?
        // - -- -> -->
        // + ++
        // @ @@
        // % %%
        // * **
        // ! != !~=
        // !~> !~~>
        // !-> !-->
        // ~ ~> ~~> ~=
        // = ==
        // ^ ^^
        // / ?
        /\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
      ],
      punctuation: /[(){}\[\]|.,:;`]/
    };
    Prism.languages.livescript["interpolated-string"].inside["interpolation"].inside.rest = Prism.languages.livescript;
  }
  return livescript_1;
}
var llvm_1;
var hasRequiredLlvm;
function requireLlvm() {
  if (hasRequiredLlvm) return llvm_1;
  hasRequiredLlvm = 1;
  llvm_1 = llvm;
  llvm.displayName = "llvm";
  llvm.aliases = [];
  function llvm(Prism) {
    (function(Prism2) {
      Prism2.languages.llvm = {
        comment: /;.*/,
        string: {
          pattern: /"[^"]*"/,
          greedy: true
        },
        boolean: /\b(?:false|true)\b/,
        variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
        label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
        type: {
          pattern: /\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
          alias: "class-name"
        },
        keyword: /\b[a-z_][a-z_0-9]*\b/,
        number: /[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
        punctuation: /[{}[\];(),.!*=<>]/
      };
    })(Prism);
  }
  return llvm_1;
}
var log_1;
var hasRequiredLog;
function requireLog() {
  if (hasRequiredLog) return log_1;
  hasRequiredLog = 1;
  log_1 = log;
  log.displayName = "log";
  log.aliases = [];
  function log(Prism) {
    Prism.languages.log = {
      string: {
        // Single-quoted strings must not be confused with plain text. E.g. Can't isn't Susan's Chris' toy
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
        greedy: true
      },
      exception: {
        pattern: /(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
        lookbehind: true,
        greedy: true,
        alias: ["javastacktrace", "language-javastacktrace"],
        inside: Prism.languages["javastacktrace"] || {
          keyword: /\bat\b/,
          function: /[a-z_][\w$]*(?=\()/,
          punctuation: /[.:()]/
        }
      },
      level: [
        {
          pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
          alias: ["error", "important"]
        },
        {
          pattern: /\b(?:WARN|WARNING|WRN)\b/,
          alias: ["warning", "important"]
        },
        {
          pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
          alias: ["info", "keyword"]
        },
        {
          pattern: /\b(?:DBG|DEBUG|FINE)\b/,
          alias: ["debug", "keyword"]
        },
        {
          pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
          alias: ["trace", "comment"]
        }
      ],
      property: {
        pattern: /((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
        lookbehind: true
      },
      separator: {
        pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
        lookbehind: true,
        alias: "comment"
      },
      url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
      email: {
        pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
        lookbehind: true,
        alias: "url"
      },
      "ip-address": {
        pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
        alias: "constant"
      },
      "mac-address": {
        pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
        alias: "constant"
      },
      domain: {
        pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
        lookbehind: true,
        alias: "constant"
      },
      uuid: {
        pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
        alias: "constant"
      },
      hash: {
        pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
        alias: "constant"
      },
      "file-path": {
        pattern: /\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
        lookbehind: true,
        greedy: true,
        alias: "string"
      },
      date: {
        pattern: RegExp(
          /\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source + "|" + /\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/.source + "|" + /\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/.source,
          "i"
        ),
        alias: "number"
      },
      time: {
        pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
        alias: "number"
      },
      boolean: /\b(?:false|null|true)\b/i,
      number: {
        pattern: /(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
        lookbehind: true
      },
      operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
      punctuation: /[\[\].,]/
    };
  }
  return log_1;
}
var lolcode_1;
var hasRequiredLolcode;
function requireLolcode() {
  if (hasRequiredLolcode) return lolcode_1;
  hasRequiredLolcode = 1;
  lolcode_1 = lolcode;
  lolcode.displayName = "lolcode";
  lolcode.aliases = [];
  function lolcode(Prism) {
    Prism.languages.lolcode = {
      comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
      string: {
        pattern: /"(?::.|[^":])*"/,
        inside: {
          variable: /:\{[^}]+\}/,
          symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
        },
        greedy: true
      },
      number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
      symbol: {
        pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
        lookbehind: true,
        inside: {
          keyword: /A(?=\s)/
        }
      },
      label: {
        pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
        lookbehind: true,
        alias: "string"
      },
      function: {
        pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
        lookbehind: true
      },
      keyword: [
        {
          pattern: /(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
          lookbehind: true
        },
        /'Z(?=\s|,|$)/
      ],
      boolean: {
        pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
        lookbehind: true
      },
      variable: {
        pattern: /(^|\s)IT(?=\s|,|$)/,
        lookbehind: true
      },
      operator: {
        pattern: /(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
        lookbehind: true
      },
      punctuation: /\.{3}|…|,|!/
    };
  }
  return lolcode_1;
}
var magma_1;
var hasRequiredMagma;
function requireMagma() {
  if (hasRequiredMagma) return magma_1;
  hasRequiredMagma = 1;
  magma_1 = magma;
  magma.displayName = "magma";
  magma.aliases = [];
  function magma(Prism) {
    Prism.languages.magma = {
      output: {
        pattern: /^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
        lookbehind: true,
        greedy: true
      },
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: true
      },
      string: {
        pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
        lookbehind: true,
        greedy: true
      },
      // http://magma.maths.usyd.edu.au/magma/handbook/text/82
      keyword: /\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
      boolean: /\b(?:false|true)\b/,
      generator: {
        pattern: /\b[a-z_]\w*(?=\s*<)/i,
        alias: "class-name"
      },
      function: /\b[a-z_]\w*(?=\s*\()/i,
      number: {
        pattern: /(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
        lookbehind: true
      },
      operator: /->|[-+*/^~!|#=]|:=|\.\./,
      punctuation: /[()[\]{}<>,;.:]/
    };
  }
  return magma_1;
}
var makefile_1;
var hasRequiredMakefile;
function requireMakefile() {
  if (hasRequiredMakefile) return makefile_1;
  hasRequiredMakefile = 1;
  makefile_1 = makefile;
  makefile.displayName = "makefile";
  makefile.aliases = [];
  function makefile(Prism) {
    Prism.languages.makefile = {
      comment: {
        pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
        lookbehind: true
      },
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "builtin-target": {
        pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
        alias: "builtin"
      },
      target: {
        pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
        alias: "symbol",
        inside: {
          variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
        }
      },
      variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
      // Directives
      keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
      function: {
        pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
        lookbehind: true
      },
      operator: /(?:::|[?:+!])?=|[|@]/,
      punctuation: /[:;(){}]/
    };
  }
  return makefile_1;
}
var markdown_1;
var hasRequiredMarkdown;
function requireMarkdown() {
  if (hasRequiredMarkdown) return markdown_1;
  hasRequiredMarkdown = 1;
  markdown_1 = markdown;
  markdown.displayName = "markdown";
  markdown.aliases = ["md"];
  function markdown(Prism) {
    (function(Prism2) {
      var inner2 = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
      function createInline(pattern) {
        pattern = pattern.replace(/<inner>/g, function() {
          return inner2;
        });
        return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
      }
      var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
      var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
        /__/g,
        function() {
          return tableCell;
        }
      );
      var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
      Prism2.languages.markdown = Prism2.languages.extend("markup", {});
      Prism2.languages.insertBefore("markdown", "prolog", {
        "front-matter-block": {
          pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
          lookbehind: true,
          greedy: true,
          inside: {
            punctuation: /^---|---$/,
            "front-matter": {
              pattern: /\S+(?:\s+\S+)*/,
              alias: ["yaml", "language-yaml"],
              inside: Prism2.languages.yaml
            }
          }
        },
        blockquote: {
          // > ...
          pattern: /^>(?:[\t ]*>)*/m,
          alias: "punctuation"
        },
        table: {
          pattern: RegExp(
            "^" + tableRow + tableLine + "(?:" + tableRow + ")*",
            "m"
          ),
          inside: {
            "table-data-rows": {
              pattern: RegExp(
                "^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"
              ),
              lookbehind: true,
              inside: {
                "table-data": {
                  pattern: RegExp(tableCell),
                  inside: Prism2.languages.markdown
                },
                punctuation: /\|/
              }
            },
            "table-line": {
              pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
              lookbehind: true,
              inside: {
                punctuation: /\||:?-{3,}:?/
              }
            },
            "table-header-row": {
              pattern: RegExp("^" + tableRow + "$"),
              inside: {
                "table-header": {
                  pattern: RegExp(tableCell),
                  alias: "important",
                  inside: Prism2.languages.markdown
                },
                punctuation: /\|/
              }
            }
          }
        },
        code: [
          {
            // Prefixed by 4 spaces or 1 tab and preceded by an empty line
            pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
            lookbehind: true,
            alias: "keyword"
          },
          {
            // ```optional language
            // code block
            // ```
            pattern: /^```[\s\S]*?^```$/m,
            greedy: true,
            inside: {
              "code-block": {
                pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                lookbehind: true
              },
              "code-language": {
                pattern: /^(```).+/,
                lookbehind: true
              },
              punctuation: /```/
            }
          }
        ],
        title: [
          {
            // title 1
            // =======
            // title 2
            // -------
            pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
            alias: "important",
            inside: {
              punctuation: /==+$|--+$/
            }
          },
          {
            // # title 1
            // ###### title 6
            pattern: /(^\s*)#.+/m,
            lookbehind: true,
            alias: "important",
            inside: {
              punctuation: /^#+|#+$/
            }
          }
        ],
        hr: {
          // ***
          // ---
          // * * *
          // -----------
          pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
          lookbehind: true,
          alias: "punctuation"
        },
        list: {
          // * item
          // + item
          // - item
          // 1. item
          pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
          lookbehind: true,
          alias: "punctuation"
        },
        "url-reference": {
          // [id]: http://example.com "Optional title"
          // [id]: http://example.com 'Optional title'
          // [id]: http://example.com (Optional title)
          // [id]: <http://example.com> "Optional title"
          pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
          inside: {
            variable: {
              pattern: /^(!?\[)[^\]]+/,
              lookbehind: true
            },
            string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
            punctuation: /^[\[\]!:]|[<>]/
          },
          alias: "url"
        },
        bold: {
          // **strong**
          // __strong__
          // allow one nested instance of italic text using the same delimiter
          pattern: createInline(
            /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            content: {
              pattern: /(^..)[\s\S]+(?=..$)/,
              lookbehind: true,
              inside: {}
              // see below
            },
            punctuation: /\*\*|__/
          }
        },
        italic: {
          // *em*
          // _em_
          // allow one nested instance of bold text using the same delimiter
          pattern: createInline(
            /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            content: {
              pattern: /(^.)[\s\S]+(?=.$)/,
              lookbehind: true,
              inside: {}
              // see below
            },
            punctuation: /[*_]/
          }
        },
        strike: {
          // ~~strike through~~
          // ~strike~
          // eslint-disable-next-line regexp/strict
          pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
          lookbehind: true,
          greedy: true,
          inside: {
            content: {
              pattern: /(^~~?)[\s\S]+(?=\1$)/,
              lookbehind: true,
              inside: {}
              // see below
            },
            punctuation: /~~?/
          }
        },
        "code-snippet": {
          // `code`
          // ``code``
          pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
          lookbehind: true,
          greedy: true,
          alias: ["code", "keyword"]
        },
        url: {
          // [example](http://example.com "Optional title")
          // [example][id]
          // [example] [id]
          pattern: createInline(
            /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            operator: /^!/,
            content: {
              pattern: /(^\[)[^\]]+(?=\])/,
              lookbehind: true,
              inside: {}
              // see below
            },
            variable: {
              pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
              lookbehind: true
            },
            url: {
              pattern: /(^\]\()[^\s)]+/,
              lookbehind: true
            },
            string: {
              pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
              lookbehind: true
            }
          }
        }
      });
      ["url", "bold", "italic", "strike"].forEach(function(token) {
        ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
          if (token !== inside) {
            Prism2.languages.markdown[token].inside.content.inside[inside] = Prism2.languages.markdown[inside];
          }
        });
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        if (env.language !== "markdown" && env.language !== "md") {
          return;
        }
        function walkTokens(tokens) {
          if (!tokens || typeof tokens === "string") {
            return;
          }
          for (var i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
            var token = tokens[i2];
            if (token.type !== "code") {
              walkTokens(token.content);
              continue;
            }
            var codeLang = token.content[1];
            var codeBlock = token.content[3];
            if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
              var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
              lang = (/[a-z][\w-]*/i.exec(lang) || [""])[0].toLowerCase();
              var alias = "language-" + lang;
              if (!codeBlock.alias) {
                codeBlock.alias = [alias];
              } else if (typeof codeBlock.alias === "string") {
                codeBlock.alias = [codeBlock.alias, alias];
              } else {
                codeBlock.alias.push(alias);
              }
            }
          }
        }
        walkTokens(env.tokens);
      });
      Prism2.hooks.add("wrap", function(env) {
        if (env.type !== "code-block") {
          return;
        }
        var codeLang = "";
        for (var i2 = 0, l2 = env.classes.length; i2 < l2; i2++) {
          var cls = env.classes[i2];
          var match2 = /language-(.+)/.exec(cls);
          if (match2) {
            codeLang = match2[1];
            break;
          }
        }
        var grammar = Prism2.languages[codeLang];
        if (!grammar) {
          if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
            var id2 = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
            env.attributes["id"] = id2;
            Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
              var ele = document.getElementById(id2);
              if (ele) {
                ele.innerHTML = Prism2.highlight(
                  ele.textContent,
                  Prism2.languages[codeLang],
                  codeLang
                );
              }
            });
          }
        } else {
          env.content = Prism2.highlight(
            textContent(env.content.value),
            grammar,
            codeLang
          );
        }
      });
      var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
      var KNOWN_ENTITY_NAMES = {
        amp: "&",
        lt: "<",
        gt: ">",
        quot: '"'
      };
      var fromCodePoint = String.fromCodePoint || String.fromCharCode;
      function textContent(html2) {
        var text = html2.replace(tagPattern, "");
        text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m2, code) {
          code = code.toLowerCase();
          if (code[0] === "#") {
            var value;
            if (code[1] === "x") {
              value = parseInt(code.slice(2), 16);
            } else {
              value = Number(code.slice(1));
            }
            return fromCodePoint(value);
          } else {
            var known = KNOWN_ENTITY_NAMES[code];
            if (known) {
              return known;
            }
            return m2;
          }
        });
        return text;
      }
      Prism2.languages.md = Prism2.languages.markdown;
    })(Prism);
  }
  return markdown_1;
}
var matlab_1;
var hasRequiredMatlab;
function requireMatlab() {
  if (hasRequiredMatlab) return matlab_1;
  hasRequiredMatlab = 1;
  matlab_1 = matlab;
  matlab.displayName = "matlab";
  matlab.aliases = [];
  function matlab(Prism) {
    Prism.languages.matlab = {
      comment: [/%\{[\s\S]*?\}%/, /%.+/],
      string: {
        pattern: /\B'(?:''|[^'\r\n])*'/,
        greedy: true
      },
      // FIXME We could handle imaginary numbers as a whole
      number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
      keyword: /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
      function: /\b(?!\d)\w+(?=\s*\()/,
      operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
      punctuation: /\.{3}|[.,;\[\](){}!]/
    };
  }
  return matlab_1;
}
var maxscript_1;
var hasRequiredMaxscript;
function requireMaxscript() {
  if (hasRequiredMaxscript) return maxscript_1;
  hasRequiredMaxscript = 1;
  maxscript_1 = maxscript;
  maxscript.displayName = "maxscript";
  maxscript.aliases = [];
  function maxscript(Prism) {
    (function(Prism2) {
      var keywords = /\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
      Prism2.languages.maxscript = {
        comment: {
          pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
          greedy: true
        },
        string: {
          pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
          lookbehind: true,
          greedy: true
        },
        path: {
          pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
          greedy: true,
          alias: "string"
        },
        "function-call": {
          pattern: RegExp(
            "((?:" + // start of line
            (/^/.source + "|" + // operators and other language constructs
            /[;=<>+\-*/^({\[]/.source + "|" + // keywords as part of statements
            /\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/.source) + ")[ 	]*)(?!" + keywords.source + ")" + /[a-z_]\w*\b/.source + "(?=[ 	]*(?:" + // variable
            ("(?!" + keywords.source + ")" + /[a-z_]/.source + "|" + // number
            /\d|-\.?\d/.source + "|" + // other expressions or literals
            /[({'"$@#?]/.source) + "))",
            "im"
          ),
          lookbehind: true,
          greedy: true,
          alias: "function"
        },
        "function-definition": {
          pattern: /(\b(?:fn|function)\s+)\w+\b/i,
          lookbehind: true,
          alias: "function"
        },
        argument: {
          pattern: /\b[a-z_]\w*(?=:)/i,
          alias: "attr-name"
        },
        keyword: keywords,
        boolean: /\b(?:false|true)\b/,
        time: {
          pattern: /(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
          lookbehind: true,
          alias: "number"
        },
        number: [
          {
            pattern: /(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
            lookbehind: true
          },
          /\b(?:e|pi)\b/
        ],
        constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
        color: {
          pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
          alias: "constant"
        },
        operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
        punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
      };
    })(Prism);
  }
  return maxscript_1;
}
var mel_1;
var hasRequiredMel;
function requireMel() {
  if (hasRequiredMel) return mel_1;
  hasRequiredMel = 1;
  mel_1 = mel;
  mel.displayName = "mel";
  mel.aliases = [];
  function mel(Prism) {
    Prism.languages.mel = {
      comment: /\/\/.*/,
      code: {
        pattern: /`(?:\\.|[^\\`\r\n])*`/,
        greedy: true,
        alias: "italic",
        inside: {
          delimiter: {
            pattern: /^`|`$/,
            alias: "punctuation"
          }
          // See rest below
        }
      },
      string: {
        pattern: /"(?:\\.|[^\\"\r\n])*"/,
        greedy: true
      },
      variable: /\$\w+/,
      number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
      flag: {
        pattern: /-[^\d\W]\w*/,
        alias: "operator"
      },
      keyword: /\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
      function: /\b\w+(?=\()|\b(?:CBG|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|Mayatomr|about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,
      operator: [
        /\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/,
        {
          // We don't want to match <<
          pattern: /(^|[^<])<(?!<)/,
          lookbehind: true
        },
        {
          // We don't want to match >>
          pattern: /(^|[^>])>(?!>)/,
          lookbehind: true
        }
      ],
      punctuation: /<<|>>|[.,:;?\[\](){}]/
    };
    Prism.languages.mel["code"].inside.rest = Prism.languages.mel;
  }
  return mel_1;
}
var mermaid_1;
var hasRequiredMermaid;
function requireMermaid() {
  if (hasRequiredMermaid) return mermaid_1;
  hasRequiredMermaid = 1;
  mermaid_1 = mermaid;
  mermaid.displayName = "mermaid";
  mermaid.aliases = [];
  function mermaid(Prism) {
    Prism.languages.mermaid = {
      comment: {
        pattern: /%%.*/,
        greedy: true
      },
      style: {
        pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
        lookbehind: true,
        inside: {
          property: /\b\w[\w-]*(?=[ \t]*:)/,
          operator: /:/,
          punctuation: /,/
        }
      },
      "inter-arrow-label": {
        pattern: /([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
        lookbehind: true,
        greedy: true,
        inside: {
          arrow: {
            pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
            alias: "operator"
          },
          label: {
            pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
            lookbehind: true,
            alias: "property"
          },
          "arrow-head": {
            pattern: /^\S+/,
            alias: ["arrow", "operator"]
          }
        }
      },
      arrow: [
        // This might look complex but it really isn't.
        // There are many possible arrows (see tests) and it's impossible to fit all of them into one pattern. The
        // problem is that we only have one lookbehind per pattern. However, we cannot disallow too many arrow
        // characters in the one lookbehind because that would create too many false negatives. So we have to split the
        // arrows into different patterns.
        {
          // ER diagram
          pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
          lookbehind: true,
          alias: "operator"
        },
        {
          // flow chart
          // (?:==+|--+|-\.*-)
          pattern: /(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
          lookbehind: true,
          alias: "operator"
        },
        {
          // sequence diagram
          pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
          lookbehind: true,
          alias: "operator"
        },
        {
          // class diagram
          pattern: /(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
          lookbehind: true,
          alias: "operator"
        }
      ],
      label: {
        pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
        lookbehind: true,
        greedy: true,
        alias: "property"
      },
      text: {
        pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
        alias: "string"
      },
      string: {
        pattern: /"[^"\r\n]*"/,
        greedy: true
      },
      annotation: {
        pattern: /<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
        alias: "important"
      },
      keyword: [
        // This language has both case-sensitive and case-insensitive keywords
        {
          pattern: /(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
          lookbehind: true,
          greedy: true
        }
      ],
      entity: /#[a-z0-9]+;/,
      operator: {
        pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
        lookbehind: true
      },
      punctuation: /[(){};]/
    };
  }
  return mermaid_1;
}
var mizar_1;
var hasRequiredMizar;
function requireMizar() {
  if (hasRequiredMizar) return mizar_1;
  hasRequiredMizar = 1;
  mizar_1 = mizar;
  mizar.displayName = "mizar";
  mizar.aliases = [];
  function mizar(Prism) {
    Prism.languages.mizar = {
      comment: /::.+/,
      keyword: /@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
      parameter: {
        pattern: /\$(?:10|\d)/,
        alias: "variable"
      },
      variable: /\b\w+(?=:)/,
      number: /(?:\b|-)\d+\b/,
      operator: /\.\.\.|->|&|\.?=/,
      punctuation: /\(#|#\)|[,:;\[\](){}]/
    };
  }
  return mizar_1;
}
var mongodb_1;
var hasRequiredMongodb;
function requireMongodb() {
  if (hasRequiredMongodb) return mongodb_1;
  hasRequiredMongodb = 1;
  mongodb_1 = mongodb;
  mongodb.displayName = "mongodb";
  mongodb.aliases = [];
  function mongodb(Prism) {
    (function(Prism2) {
      var operators = [
        // query and projection
        "$eq",
        "$gt",
        "$gte",
        "$in",
        "$lt",
        "$lte",
        "$ne",
        "$nin",
        "$and",
        "$not",
        "$nor",
        "$or",
        "$exists",
        "$type",
        "$expr",
        "$jsonSchema",
        "$mod",
        "$regex",
        "$text",
        "$where",
        "$geoIntersects",
        "$geoWithin",
        "$near",
        "$nearSphere",
        "$all",
        "$elemMatch",
        "$size",
        "$bitsAllClear",
        "$bitsAllSet",
        "$bitsAnyClear",
        "$bitsAnySet",
        "$comment",
        "$elemMatch",
        "$meta",
        "$slice",
        // update
        "$currentDate",
        "$inc",
        "$min",
        "$max",
        "$mul",
        "$rename",
        "$set",
        "$setOnInsert",
        "$unset",
        "$addToSet",
        "$pop",
        "$pull",
        "$push",
        "$pullAll",
        "$each",
        "$position",
        "$slice",
        "$sort",
        "$bit",
        // aggregation pipeline stages
        "$addFields",
        "$bucket",
        "$bucketAuto",
        "$collStats",
        "$count",
        "$currentOp",
        "$facet",
        "$geoNear",
        "$graphLookup",
        "$group",
        "$indexStats",
        "$limit",
        "$listLocalSessions",
        "$listSessions",
        "$lookup",
        "$match",
        "$merge",
        "$out",
        "$planCacheStats",
        "$project",
        "$redact",
        "$replaceRoot",
        "$replaceWith",
        "$sample",
        "$set",
        "$skip",
        "$sort",
        "$sortByCount",
        "$unionWith",
        "$unset",
        "$unwind",
        "$setWindowFields",
        // aggregation pipeline operators
        "$abs",
        "$accumulator",
        "$acos",
        "$acosh",
        "$add",
        "$addToSet",
        "$allElementsTrue",
        "$and",
        "$anyElementTrue",
        "$arrayElemAt",
        "$arrayToObject",
        "$asin",
        "$asinh",
        "$atan",
        "$atan2",
        "$atanh",
        "$avg",
        "$binarySize",
        "$bsonSize",
        "$ceil",
        "$cmp",
        "$concat",
        "$concatArrays",
        "$cond",
        "$convert",
        "$cos",
        "$dateFromParts",
        "$dateToParts",
        "$dateFromString",
        "$dateToString",
        "$dayOfMonth",
        "$dayOfWeek",
        "$dayOfYear",
        "$degreesToRadians",
        "$divide",
        "$eq",
        "$exp",
        "$filter",
        "$first",
        "$floor",
        "$function",
        "$gt",
        "$gte",
        "$hour",
        "$ifNull",
        "$in",
        "$indexOfArray",
        "$indexOfBytes",
        "$indexOfCP",
        "$isArray",
        "$isNumber",
        "$isoDayOfWeek",
        "$isoWeek",
        "$isoWeekYear",
        "$last",
        "$last",
        "$let",
        "$literal",
        "$ln",
        "$log",
        "$log10",
        "$lt",
        "$lte",
        "$ltrim",
        "$map",
        "$max",
        "$mergeObjects",
        "$meta",
        "$min",
        "$millisecond",
        "$minute",
        "$mod",
        "$month",
        "$multiply",
        "$ne",
        "$not",
        "$objectToArray",
        "$or",
        "$pow",
        "$push",
        "$radiansToDegrees",
        "$range",
        "$reduce",
        "$regexFind",
        "$regexFindAll",
        "$regexMatch",
        "$replaceOne",
        "$replaceAll",
        "$reverseArray",
        "$round",
        "$rtrim",
        "$second",
        "$setDifference",
        "$setEquals",
        "$setIntersection",
        "$setIsSubset",
        "$setUnion",
        "$size",
        "$sin",
        "$slice",
        "$split",
        "$sqrt",
        "$stdDevPop",
        "$stdDevSamp",
        "$strcasecmp",
        "$strLenBytes",
        "$strLenCP",
        "$substr",
        "$substrBytes",
        "$substrCP",
        "$subtract",
        "$sum",
        "$switch",
        "$tan",
        "$toBool",
        "$toDate",
        "$toDecimal",
        "$toDouble",
        "$toInt",
        "$toLong",
        "$toObjectId",
        "$toString",
        "$toLower",
        "$toUpper",
        "$trim",
        "$trunc",
        "$type",
        "$week",
        "$year",
        "$zip",
        "$count",
        "$dateAdd",
        "$dateDiff",
        "$dateSubtract",
        "$dateTrunc",
        "$getField",
        "$rand",
        "$sampleRate",
        "$setField",
        "$unsetField",
        // aggregation pipeline query modifiers
        "$comment",
        "$explain",
        "$hint",
        "$max",
        "$maxTimeMS",
        "$min",
        "$orderby",
        "$query",
        "$returnKey",
        "$showDiskLoc",
        "$natural"
      ];
      var builtinFunctions = [
        "ObjectId",
        "Code",
        "BinData",
        "DBRef",
        "Timestamp",
        "NumberLong",
        "NumberDecimal",
        "MaxKey",
        "MinKey",
        "RegExp",
        "ISODate",
        "UUID"
      ];
      operators = operators.map(function(operator) {
        return operator.replace("$", "\\$");
      });
      var operatorsSource = "(?:" + operators.join("|") + ")\\b";
      Prism2.languages.mongodb = Prism2.languages.extend("javascript", {});
      Prism2.languages.insertBefore("mongodb", "string", {
        property: {
          pattern: /(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
          greedy: true,
          inside: {
            keyword: RegExp(`^(['"])?` + operatorsSource + "(?:\\1)?$")
          }
        }
      });
      Prism2.languages.mongodb.string.inside = {
        url: {
          // url pattern
          pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
          greedy: true
        },
        entity: {
          // ipv4
          pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
          greedy: true
        }
      };
      Prism2.languages.insertBefore("mongodb", "constant", {
        builtin: {
          pattern: RegExp("\\b(?:" + builtinFunctions.join("|") + ")\\b"),
          alias: "keyword"
        }
      });
    })(Prism);
  }
  return mongodb_1;
}
var monkey_1;
var hasRequiredMonkey;
function requireMonkey() {
  if (hasRequiredMonkey) return monkey_1;
  hasRequiredMonkey = 1;
  monkey_1 = monkey;
  monkey.displayName = "monkey";
  monkey.aliases = [];
  function monkey(Prism) {
    Prism.languages.monkey = {
      comment: {
        pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
        greedy: true
      },
      string: {
        pattern: /"[^"\r\n]*"/,
        greedy: true
      },
      preprocessor: {
        pattern: /(^[ \t]*)#.+/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      },
      function: /\b\w+(?=\()/,
      "type-char": {
        pattern: /\b[?%#$]/,
        alias: "class-name"
      },
      number: {
        pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
        lookbehind: true
      },
      keyword: /\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
      operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
      punctuation: /[.,:;()\[\]]/
    };
  }
  return monkey_1;
}
var moonscript_1;
var hasRequiredMoonscript;
function requireMoonscript() {
  if (hasRequiredMoonscript) return moonscript_1;
  hasRequiredMoonscript = 1;
  moonscript_1 = moonscript;
  moonscript.displayName = "moonscript";
  moonscript.aliases = ["moon"];
  function moonscript(Prism) {
    Prism.languages.moonscript = {
      comment: /--.*/,
      string: [
        {
          pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
          greedy: true
        },
        {
          pattern: /"[^"]*"/,
          greedy: true,
          inside: {
            interpolation: {
              pattern: /#\{[^{}]*\}/,
              inside: {
                moonscript: {
                  pattern: /(^#\{)[\s\S]+(?=\})/,
                  lookbehind: true,
                  inside: null
                  // see beow
                },
                "interpolation-punctuation": {
                  pattern: /#\{|\}/,
                  alias: "punctuation"
                }
              }
            }
          }
        }
      ],
      "class-name": [
        {
          pattern: /(\b(?:class|extends)[ \t]+)\w+/,
          lookbehind: true
        },
        // class-like names start with a capital letter
        /\b[A-Z]\w*/
      ],
      keyword: /\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
      variable: /@@?\w*/,
      property: {
        pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
        lookbehind: true
      },
      function: {
        pattern: /\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
        inside: {
          punctuation: /\./
        }
      },
      boolean: /\b(?:false|true)\b/,
      number: /(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
      operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
      punctuation: /[.,()[\]{}\\]/
    };
    Prism.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside = Prism.languages.moonscript;
    Prism.languages.moon = Prism.languages.moonscript;
  }
  return moonscript_1;
}
var n1ql_1;
var hasRequiredN1ql;
function requireN1ql() {
  if (hasRequiredN1ql) return n1ql_1;
  hasRequiredN1ql = 1;
  n1ql_1 = n1ql;
  n1ql.displayName = "n1ql";
  n1ql.aliases = [];
  function n1ql(Prism) {
    Prism.languages.n1ql = {
      comment: {
        pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
        greedy: true
      },
      string: {
        pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
        greedy: true
      },
      identifier: {
        pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
        greedy: true
      },
      parameter: /\$[\w.]+/,
      // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html#n1ql-reserved-words
      keyword: /\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      boolean: /\b(?:FALSE|TRUE)\b/i,
      number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
      operator: /[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
      punctuation: /[;[\](),.{}:]/
    };
  }
  return n1ql_1;
}
var n4js_1;
var hasRequiredN4js;
function requireN4js() {
  if (hasRequiredN4js) return n4js_1;
  hasRequiredN4js = 1;
  n4js_1 = n4js;
  n4js.displayName = "n4js";
  n4js.aliases = ["n4jsd"];
  function n4js(Prism) {
    Prism.languages.n4js = Prism.languages.extend("javascript", {
      // Keywords from N4JS language spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html
      keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
    });
    Prism.languages.insertBefore("n4js", "constant", {
      // Annotations in N4JS spec: https://numberfour.github.io/n4js/spec/N4JSSpec.html#_annotations
      annotation: {
        pattern: /@+\w+/,
        alias: "operator"
      }
    });
    Prism.languages.n4jsd = Prism.languages.n4js;
  }
  return n4js_1;
}
var nand2tetrisHdl_1;
var hasRequiredNand2tetrisHdl;
function requireNand2tetrisHdl() {
  if (hasRequiredNand2tetrisHdl) return nand2tetrisHdl_1;
  hasRequiredNand2tetrisHdl = 1;
  nand2tetrisHdl_1 = nand2tetrisHdl;
  nand2tetrisHdl.displayName = "nand2tetrisHdl";
  nand2tetrisHdl.aliases = [];
  function nand2tetrisHdl(Prism) {
    Prism.languages["nand2tetris-hdl"] = {
      comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
      boolean: /\b(?:false|true)\b/,
      function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
      number: /\b\d+\b/,
      operator: /=|\.\./,
      punctuation: /[{}[\];(),:]/
    };
  }
  return nand2tetrisHdl_1;
}
var naniscript_1;
var hasRequiredNaniscript;
function requireNaniscript() {
  if (hasRequiredNaniscript) return naniscript_1;
  hasRequiredNaniscript = 1;
  naniscript_1 = naniscript;
  naniscript.displayName = "naniscript";
  naniscript.aliases = [];
  function naniscript(Prism) {
    (function(Prism2) {
      var expressionDef = /\{[^\r\n\[\]{}]*\}/;
      var params = {
        "quoted-string": {
          pattern: /"(?:[^"\\]|\\.)*"/,
          alias: "operator"
        },
        "command-param-id": {
          pattern: /(\s)\w+:/,
          lookbehind: true,
          alias: "property"
        },
        "command-param-value": [
          {
            pattern: expressionDef,
            alias: "selector"
          },
          {
            pattern: /([\t ])\S+/,
            lookbehind: true,
            greedy: true,
            alias: "operator"
          },
          {
            pattern: /\S(?:.*\S)?/,
            alias: "operator"
          }
        ]
      };
      Prism2.languages.naniscript = {
        // ; ...
        comment: {
          pattern: /^([\t ]*);.*/m,
          lookbehind: true
        },
        // > ...
        // Define is a control line starting with '>' followed by a word, a space and a text.
        define: {
          pattern: /^>.+/m,
          alias: "tag",
          inside: {
            value: {
              pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
              lookbehind: true,
              alias: "operator"
            },
            key: {
              pattern: /(^>)\w+/,
              lookbehind: true
            }
          }
        },
        // # ...
        label: {
          pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
          lookbehind: true,
          alias: "regex"
        },
        command: {
          pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
          lookbehind: true,
          alias: "function",
          inside: {
            "command-name": /^@\w+/,
            expression: {
              pattern: expressionDef,
              greedy: true,
              alias: "selector"
            },
            "command-params": {
              pattern: /\s*\S[\s\S]*/,
              inside: params
            }
          }
        },
        // Generic is any line that doesn't start with operators: ;>#@
        "generic-text": {
          pattern: /(^[ \t]*)[^#@>;\s].*/m,
          lookbehind: true,
          alias: "punctuation",
          inside: {
            // \{ ... \} ... \[ ... \] ... \"
            "escaped-char": /\\[{}\[\]"]/,
            expression: {
              pattern: expressionDef,
              greedy: true,
              alias: "selector"
            },
            "inline-command": {
              pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
              greedy: true,
              alias: "function",
              inside: {
                "command-params": {
                  pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
                  lookbehind: true,
                  inside: params
                },
                "command-param-name": {
                  pattern: /^(\[[\t ]*)\w+/,
                  lookbehind: true,
                  alias: "name"
                },
                "start-stop-char": /[\[\]]/
              }
            }
          }
        }
      };
      Prism2.languages.nani = Prism2.languages["naniscript"];
      Prism2.hooks.add("after-tokenize", function(env) {
        var tokens = env.tokens;
        tokens.forEach(function(token) {
          if (typeof token !== "string" && token.type === "generic-text") {
            var content = getTextContent(token);
            if (!isBracketsBalanced(content)) {
              token.type = "bad-line";
              token.content = content;
            }
          }
        });
      });
      function isBracketsBalanced(input) {
        var brackets = "[]{}";
        var stack = [];
        for (var i2 = 0; i2 < input.length; i2++) {
          var bracket = input[i2];
          var bracketsIndex = brackets.indexOf(bracket);
          if (bracketsIndex !== -1) {
            if (bracketsIndex % 2 === 0) {
              stack.push(bracketsIndex + 1);
            } else if (stack.pop() !== bracketsIndex) {
              return false;
            }
          }
        }
        return stack.length === 0;
      }
      function getTextContent(token) {
        if (typeof token === "string") {
          return token;
        } else if (Array.isArray(token)) {
          return token.map(getTextContent).join("");
        } else {
          return getTextContent(token.content);
        }
      }
    })(Prism);
  }
  return naniscript_1;
}
var nasm_1;
var hasRequiredNasm;
function requireNasm() {
  if (hasRequiredNasm) return nasm_1;
  hasRequiredNasm = 1;
  nasm_1 = nasm;
  nasm.displayName = "nasm";
  nasm.aliases = [];
  function nasm(Prism) {
    Prism.languages.nasm = {
      comment: /;.*$/m,
      string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
      label: {
        pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
        lookbehind: true,
        alias: "function"
      },
      keyword: [
        /\[?BITS (?:16|32|64)\]?/,
        {
          pattern: /(^\s*)section\s*[a-z.]+:?/im,
          lookbehind: true
        },
        /(?:extern|global)[^;\r\n]*/i,
        /(?:CPU|DEFAULT|FLOAT).*$/m
      ],
      register: {
        pattern: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
        alias: "variable"
      },
      number: /(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
      operator: /[\[\]*+\-\/%<>=&|$!]/
    };
  }
  return nasm_1;
}
var neon_1;
var hasRequiredNeon;
function requireNeon() {
  if (hasRequiredNeon) return neon_1;
  hasRequiredNeon = 1;
  neon_1 = neon;
  neon.displayName = "neon";
  neon.aliases = [];
  function neon(Prism) {
    Prism.languages.neon = {
      comment: {
        pattern: /#.*/,
        greedy: true
      },
      datetime: {
        pattern: /(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
        lookbehind: true,
        alias: "number"
      },
      key: {
        pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
        lookbehind: true,
        alias: "atrule"
      },
      number: {
        pattern: /(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
        lookbehind: true
      },
      boolean: {
        pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
        lookbehind: true
      },
      null: {
        pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
        lookbehind: true,
        alias: "keyword"
      },
      string: {
        pattern: /(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
        lookbehind: true,
        greedy: true
      },
      literal: {
        pattern: /(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
        lookbehind: true,
        alias: "string"
      },
      punctuation: /[,:=[\]{}()-]/
    };
  }
  return neon_1;
}
var nevod_1;
var hasRequiredNevod;
function requireNevod() {
  if (hasRequiredNevod) return nevod_1;
  hasRequiredNevod = 1;
  nevod_1 = nevod;
  nevod.displayName = "nevod";
  nevod.aliases = [];
  function nevod(Prism) {
    Prism.languages.nevod = {
      comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
      string: {
        pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
        greedy: true,
        inside: {
          "string-attrs": /!$|!\*$|\*$/
        }
      },
      namespace: {
        pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
        lookbehind: true
      },
      pattern: {
        pattern: /(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
        lookbehind: true,
        inside: {
          "pattern-name": {
            pattern: /^#?[a-zA-Z0-9\-.]+/,
            alias: "class-name"
          },
          fields: {
            pattern: /\(.*\)/,
            inside: {
              "field-name": {
                pattern: /[a-zA-Z0-9\-.]+/,
                alias: "variable"
              },
              punctuation: /[,()]/,
              operator: {
                pattern: /~/,
                alias: "field-hidden-mark"
              }
            }
          }
        }
      },
      search: {
        pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
        alias: "function",
        lookbehind: true
      },
      keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
      "standard-pattern": {
        pattern: /\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
        inside: {
          "standard-pattern-name": {
            pattern: /^[a-zA-Z0-9\-.]+/,
            alias: "builtin"
          },
          quantifier: {
            pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
            alias: "number"
          },
          "standard-pattern-attr": {
            pattern: /[a-zA-Z0-9\-.]+/,
            alias: "builtin"
          },
          punctuation: /[,()]/
        }
      },
      quantifier: {
        pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
        alias: "number"
      },
      operator: [
        {
          pattern: /=/,
          alias: "pattern-def"
        },
        {
          pattern: /&/,
          alias: "conjunction"
        },
        {
          pattern: /~/,
          alias: "exception"
        },
        {
          pattern: /\?/,
          alias: "optionality"
        },
        {
          pattern: /[[\]]/,
          alias: "repetition"
        },
        {
          pattern: /[{}]/,
          alias: "variation"
        },
        {
          pattern: /[+_]/,
          alias: "sequence"
        },
        {
          pattern: /\.{2,3}/,
          alias: "span"
        }
      ],
      "field-capture": [
        {
          pattern: /([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
          lookbehind: true,
          inside: {
            "field-name": {
              pattern: /[a-zA-Z0-9\-.]+/,
              alias: "variable"
            },
            colon: /:/
          }
        },
        {
          pattern: /[a-zA-Z0-9\-.]+\s*:/,
          inside: {
            "field-name": {
              pattern: /[a-zA-Z0-9\-.]+/,
              alias: "variable"
            },
            colon: /:/
          }
        }
      ],
      punctuation: /[:;,()]/,
      name: /[a-zA-Z0-9\-.]+/
    };
  }
  return nevod_1;
}
var nginx_1;
var hasRequiredNginx;
function requireNginx() {
  if (hasRequiredNginx) return nginx_1;
  hasRequiredNginx = 1;
  nginx_1 = nginx;
  nginx.displayName = "nginx";
  nginx.aliases = [];
  function nginx(Prism) {
    (function(Prism2) {
      var variable = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
      Prism2.languages.nginx = {
        comment: {
          pattern: /(^|[\s{};])#.*/,
          lookbehind: true,
          greedy: true
        },
        directive: {
          pattern: /(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
          lookbehind: true,
          greedy: true,
          inside: {
            string: {
              pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
              lookbehind: true,
              greedy: true,
              inside: {
                escape: {
                  pattern: /\\["'\\nrt]/,
                  alias: "entity"
                },
                variable
              }
            },
            comment: {
              pattern: /(\s)#.*/,
              lookbehind: true,
              greedy: true
            },
            keyword: {
              pattern: /^\S+/,
              greedy: true
            },
            // other patterns
            boolean: {
              pattern: /(\s)(?:off|on)(?!\S)/,
              lookbehind: true
            },
            number: {
              pattern: /(\s)\d+[a-z]*(?!\S)/i,
              lookbehind: true
            },
            variable
          }
        },
        punctuation: /[{};]/
      };
    })(Prism);
  }
  return nginx_1;
}
var nim_1;
var hasRequiredNim;
function requireNim() {
  if (hasRequiredNim) return nim_1;
  hasRequiredNim = 1;
  nim_1 = nim;
  nim.displayName = "nim";
  nim.aliases = [];
  function nim(Prism) {
    Prism.languages.nim = {
      comment: {
        pattern: /#.*/,
        greedy: true
      },
      string: {
        // Double-quoted strings can be prefixed by an identifier (Generalized raw string literals)
        pattern: /(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
        greedy: true
      },
      char: {
        // Character literals are handled specifically to prevent issues with numeric type suffixes
        pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
        greedy: true
      },
      function: {
        pattern: /(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
        greedy: true,
        inside: {
          operator: /\*$/
        }
      },
      // We don't want to highlight operators (and anything really) inside backticks
      identifier: {
        pattern: /`[^`\r\n]+`/,
        greedy: true,
        inside: {
          punctuation: /`/
        }
      },
      // The negative look ahead prevents wrong highlighting of the .. operator
      number: /\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
      keyword: /\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
      operator: {
        // Look behind and look ahead prevent wrong highlighting of punctuations [. .] {. .} (. .)
        // but allow the slice operator .. to take precedence over them
        // One can define his own operators in Nim so all combination of operators might be an operator.
        pattern: /(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
        lookbehind: true
      },
      punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
    };
  }
  return nim_1;
}
var nix_1;
var hasRequiredNix;
function requireNix() {
  if (hasRequiredNix) return nix_1;
  hasRequiredNix = 1;
  nix_1 = nix;
  nix.displayName = "nix";
  nix.aliases = [];
  function nix(Prism) {
    Prism.languages.nix = {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|#.*/,
        greedy: true
      },
      string: {
        pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
        greedy: true,
        inside: {
          interpolation: {
            // The lookbehind ensures the ${} is not preceded by \ or ''
            pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
            lookbehind: true,
            inside: null
            // see below
          }
        }
      },
      url: [
        /\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
        {
          pattern: /([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
          lookbehind: true
        }
      ],
      antiquotation: {
        pattern: /\$(?=\{)/,
        alias: "important"
      },
      number: /\b\d+\b/,
      keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
      function: /\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
      boolean: /\b(?:false|true)\b/,
      operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
      punctuation: /[{}()[\].,:;]/
    };
    Prism.languages.nix.string.inside.interpolation.inside = Prism.languages.nix;
  }
  return nix_1;
}
var nsis_1;
var hasRequiredNsis;
function requireNsis() {
  if (hasRequiredNsis) return nsis_1;
  hasRequiredNsis = 1;
  nsis_1 = nsis;
  nsis.displayName = "nsis";
  nsis.aliases = [];
  function nsis(Prism) {
    Prism.languages.nsis = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
        lookbehind: true,
        greedy: true
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      keyword: {
        pattern: /(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
        lookbehind: true
      },
      property: /\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
      constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
      variable: /\$\w[\w\.]*/,
      number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
      operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
      punctuation: /[{}[\];(),.:]/,
      important: {
        pattern: /(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
        lookbehind: true
      }
    };
  }
  return nsis_1;
}
var objectivec_1;
var hasRequiredObjectivec;
function requireObjectivec() {
  if (hasRequiredObjectivec) return objectivec_1;
  hasRequiredObjectivec = 1;
  var refractorC = requireC();
  objectivec_1 = objectivec;
  objectivec.displayName = "objectivec";
  objectivec.aliases = ["objc"];
  function objectivec(Prism) {
    Prism.register(refractorC);
    Prism.languages.objectivec = Prism.languages.extend("c", {
      string: {
        pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: true
      },
      keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
      operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
    });
    delete Prism.languages.objectivec["class-name"];
    Prism.languages.objc = Prism.languages.objectivec;
  }
  return objectivec_1;
}
var ocaml_1;
var hasRequiredOcaml;
function requireOcaml() {
  if (hasRequiredOcaml) return ocaml_1;
  hasRequiredOcaml = 1;
  ocaml_1 = ocaml;
  ocaml.displayName = "ocaml";
  ocaml.aliases = [];
  function ocaml(Prism) {
    Prism.languages.ocaml = {
      comment: {
        pattern: /\(\*[\s\S]*?\*\)/,
        greedy: true
      },
      char: {
        pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
        greedy: true
      },
      string: [
        {
          pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
          greedy: true
        },
        {
          pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
          greedy: true
        }
      ],
      number: [
        // binary and octal
        /\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
        // hexadecimal
        /\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
        // decimal
        /\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
      ],
      directive: {
        pattern: /\B#\w+/,
        alias: "property"
      },
      label: {
        pattern: /\B~\w+/,
        alias: "property"
      },
      "type-variable": {
        pattern: /\B'\w+/,
        alias: "function"
      },
      variant: {
        pattern: /`\w+/,
        alias: "symbol"
      },
      // For the list of keywords and operators,
      // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84
      keyword: /\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
      boolean: /\b(?:false|true)\b/,
      "operator-like-punctuation": {
        pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
        alias: "punctuation"
      },
      // Custom operators are allowed
      operator: /\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
      punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
    };
  }
  return ocaml_1;
}
var opencl_1;
var hasRequiredOpencl;
function requireOpencl() {
  if (hasRequiredOpencl) return opencl_1;
  hasRequiredOpencl = 1;
  var refractorC = requireC();
  opencl_1 = opencl;
  opencl.displayName = "opencl";
  opencl.aliases = [];
  function opencl(Prism) {
    Prism.register(refractorC);
    (function(Prism2) {
      Prism2.languages.opencl = Prism2.languages.extend("c", {
        // Extracted from the official specs (2.0) and http://streamcomputing.eu/downloads/?opencl.lang (opencl-keywords, opencl-types) and http://sourceforge.net/tracker/?func=detail&aid=2957794&group_id=95717&atid=612384 (Words2, partly Words3)
        keyword: /\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
        // Extracted from http://streamcomputing.eu/downloads/?opencl.lang (opencl-const)
        // Math Constants: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/mathConstants.html
        // Macros and Limits: https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/macroLimits.html
        number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
        boolean: /\b(?:false|true)\b/,
        "constant-opencl-kernel": {
          pattern: /\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
          alias: "constant"
        }
      });
      Prism2.languages.insertBefore("opencl", "class-name", {
        // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/scalarDataTypes.html
        // https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/otherDataTypes.html
        "builtin-type": {
          pattern: /\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
          alias: "keyword"
        }
      });
      var attributes = {
        // Extracted from http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-types and opencl-host)
        "type-opencl-host": {
          pattern: /\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
          alias: "keyword"
        },
        "boolean-opencl-host": {
          pattern: /\bCL_(?:FALSE|TRUE)\b/,
          alias: "boolean"
        },
        // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-const)
        "constant-opencl-host": {
          pattern: /\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
          alias: "constant"
        },
        // Extracted from cl.h (2.0) and http://streamcomputing.eu/downloads/?opencl_host.lang (opencl-host)
        "function-opencl-host": {
          pattern: /\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
          alias: "function"
        }
      };
      Prism2.languages.insertBefore("c", "keyword", attributes);
      if (Prism2.languages.cpp) {
        attributes["type-opencl-host-cpp"] = {
          pattern: /\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
          alias: "keyword"
        };
        Prism2.languages.insertBefore("cpp", "keyword", attributes);
      }
    })(Prism);
  }
  return opencl_1;
}
var openqasm_1;
var hasRequiredOpenqasm;
function requireOpenqasm() {
  if (hasRequiredOpenqasm) return openqasm_1;
  hasRequiredOpenqasm = 1;
  openqasm_1 = openqasm;
  openqasm.displayName = "openqasm";
  openqasm.aliases = ["qasm"];
  function openqasm(Prism) {
    Prism.languages.openqasm = {
      comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
      string: {
        pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
        greedy: true
      },
      keyword: /\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
      "class-name": /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
      function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
      constant: /\b(?:euler|pi|tau)\b|π|𝜏|ℇ/,
      number: {
        pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|µs|ms|s)?/i,
        lookbehind: true
      },
      operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
      punctuation: /[(){}\[\];,:.]/
    };
    Prism.languages.qasm = Prism.languages.openqasm;
  }
  return openqasm_1;
}
var oz_1;
var hasRequiredOz;
function requireOz() {
  if (hasRequiredOz) return oz_1;
  hasRequiredOz = 1;
  oz_1 = oz;
  oz.displayName = "oz";
  oz.aliases = [];
  function oz(Prism) {
    Prism.languages.oz = {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|%.*/,
        greedy: true
      },
      string: {
        pattern: /"(?:[^"\\]|\\[\s\S])*"/,
        greedy: true
      },
      atom: {
        pattern: /'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        alias: "builtin"
      },
      keyword: /\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
      function: [
        /\b[a-z][A-Za-z\d]*(?=\()/,
        {
          pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
          lookbehind: true
        }
      ],
      number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
      variable: /`(?:[^`\\]|\\.)+`/,
      "attr-name": /\b\w+(?=[ \t]*:(?![:=]))/,
      operator: /:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
      punctuation: /[\[\](){}.:;?]/
    };
  }
  return oz_1;
}
var parigp_1;
var hasRequiredParigp;
function requireParigp() {
  if (hasRequiredParigp) return parigp_1;
  hasRequiredParigp = 1;
  parigp_1 = parigp;
  parigp.displayName = "parigp";
  parigp.aliases = [];
  function parigp(Prism) {
    Prism.languages.parigp = {
      comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"/,
        greedy: true
      },
      // PARI/GP does not care about white spaces at all
      // so let's process the keywords to build an appropriate regexp
      // (e.g. "b *r *e *a *k", etc.)
      keyword: (function() {
        var keywords = [
          "breakpoint",
          "break",
          "dbg_down",
          "dbg_err",
          "dbg_up",
          "dbg_x",
          "forcomposite",
          "fordiv",
          "forell",
          "forpart",
          "forprime",
          "forstep",
          "forsubgroup",
          "forvec",
          "for",
          "iferr",
          "if",
          "local",
          "my",
          "next",
          "return",
          "until",
          "while"
        ];
        keywords = keywords.map(function(keyword) {
          return keyword.split("").join(" *");
        }).join("|");
        return RegExp("\\b(?:" + keywords + ")\\b");
      })(),
      function: /\b\w(?:[\w ]*\w)?(?= *\()/,
      number: {
        // The lookbehind and the negative lookahead prevent from breaking the .. operator
        pattern: /((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
        lookbehind: true
      },
      operator: /\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
      punctuation: /[\[\]{}().,:;|]/
    };
  }
  return parigp_1;
}
var parser_1;
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser_1;
  hasRequiredParser = 1;
  parser_1 = parser;
  parser.displayName = "parser";
  parser.aliases = [];
  function parser(Prism) {
    (function(Prism2) {
      var parser2 = Prism2.languages.parser = Prism2.languages.extend("markup", {
        keyword: {
          pattern: /(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
          lookbehind: true
        },
        variable: {
          pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
          lookbehind: true,
          inside: {
            punctuation: /\.|:+/
          }
        },
        function: {
          pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
          lookbehind: true,
          inside: {
            keyword: {
              pattern: /(^@)(?:GET_|SET_)/,
              lookbehind: true
            },
            punctuation: /\.|:+/
          }
        },
        escape: {
          pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
          alias: "builtin"
        },
        punctuation: /[\[\](){};]/
      });
      parser2 = Prism2.languages.insertBefore("parser", "keyword", {
        "parser-comment": {
          pattern: /(\s)#.*/,
          lookbehind: true,
          alias: "comment"
        },
        expression: {
          // Allow for 3 levels of depth
          pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
          greedy: true,
          lookbehind: true,
          inside: {
            string: {
              pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
              lookbehind: true
            },
            keyword: parser2.keyword,
            variable: parser2.variable,
            function: parser2.function,
            boolean: /\b(?:false|true)\b/,
            number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
            escape: parser2.escape,
            operator: /[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
            punctuation: parser2.punctuation
          }
        }
      });
      Prism2.languages.insertBefore(
        "inside",
        "punctuation",
        {
          expression: parser2.expression,
          keyword: parser2.keyword,
          variable: parser2.variable,
          function: parser2.function,
          escape: parser2.escape,
          "parser-punctuation": {
            pattern: parser2.punctuation,
            alias: "punctuation"
          }
        },
        parser2["tag"].inside["attr-value"]
      );
    })(Prism);
  }
  return parser_1;
}
var pascal_1;
var hasRequiredPascal;
function requirePascal() {
  if (hasRequiredPascal) return pascal_1;
  hasRequiredPascal = 1;
  pascal_1 = pascal;
  pascal.displayName = "pascal";
  pascal.aliases = ["objectpascal"];
  function pascal(Prism) {
    Prism.languages.pascal = {
      directive: {
        pattern: /\{\$[\s\S]*?\}/,
        greedy: true,
        alias: ["marco", "property"]
      },
      comment: {
        pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
        greedy: true
      },
      string: {
        pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
        greedy: true
      },
      asm: {
        pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
        lookbehind: true,
        greedy: true,
        inside: null
        // see below
      },
      keyword: [
        {
          // Turbo Pascal
          pattern: /(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
          lookbehind: true
        },
        {
          // Free Pascal
          pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
          lookbehind: true
        },
        {
          // Object Pascal
          pattern: /(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
          lookbehind: true
        },
        {
          // Modifiers
          pattern: /(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
          lookbehind: true
        }
      ],
      number: [
        // Hexadecimal, octal and binary
        /(?:[&%]\d+|\$[a-f\d]+)/i,
        // Decimal
        /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i
      ],
      operator: [
        /\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/,
        {
          pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
          lookbehind: true
        }
      ],
      punctuation: /\(\.|\.\)|[()\[\]:;,.]/
    };
    Prism.languages.pascal.asm.inside = Prism.languages.extend("pascal", {
      asm: void 0,
      keyword: void 0,
      operator: void 0
    });
    Prism.languages.objectpascal = Prism.languages.pascal;
  }
  return pascal_1;
}
var pascaligo_1;
var hasRequiredPascaligo;
function requirePascaligo() {
  if (hasRequiredPascaligo) return pascaligo_1;
  hasRequiredPascaligo = 1;
  pascaligo_1 = pascaligo;
  pascaligo.displayName = "pascaligo";
  pascaligo.aliases = [];
  function pascaligo(Prism) {
    (function(Prism2) {
      var braces = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source;
      var type = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(
        /<braces>/g,
        function() {
          return braces;
        }
      );
      var pascaligo2 = Prism2.languages.pascaligo = {
        comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
        string: {
          pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
          greedy: true
        },
        "class-name": [
          {
            pattern: RegExp(
              /(\btype\s+\w+\s+is\s+)<type>/.source.replace(
                /<type>/g,
                function() {
                  return type;
                }
              ),
              "i"
            ),
            lookbehind: true,
            inside: null
            // see below
          },
          {
            pattern: RegExp(
              /<type>(?=\s+is\b)/.source.replace(/<type>/g, function() {
                return type;
              }),
              "i"
            ),
            inside: null
            // see below
          },
          {
            pattern: RegExp(
              /(:\s*)<type>/.source.replace(/<type>/g, function() {
                return type;
              })
            ),
            lookbehind: true,
            inside: null
            // see below
          }
        ],
        keyword: {
          pattern: /(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
          lookbehind: true
        },
        boolean: {
          pattern: /(^|[^&])\b(?:False|True)\b/i,
          lookbehind: true
        },
        builtin: {
          pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
          lookbehind: true
        },
        function: /\b\w+(?=\s*\()/,
        number: [
          // Hexadecimal, octal and binary
          /%[01]+|&[0-7]+|\$[a-f\d]+/i,
          // Decimal
          /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i
        ],
        operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
        punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
      };
      var classNameInside = [
        "comment",
        "keyword",
        "builtin",
        "operator",
        "punctuation"
      ].reduce(function(accum, key) {
        accum[key] = pascaligo2[key];
        return accum;
      }, {});
      pascaligo2["class-name"].forEach(function(p2) {
        p2.inside = classNameInside;
      });
    })(Prism);
  }
  return pascaligo_1;
}
var pcaxis_1;
var hasRequiredPcaxis;
function requirePcaxis() {
  if (hasRequiredPcaxis) return pcaxis_1;
  hasRequiredPcaxis = 1;
  pcaxis_1 = pcaxis;
  pcaxis.displayName = "pcaxis";
  pcaxis.aliases = ["px"];
  function pcaxis(Prism) {
    Prism.languages.pcaxis = {
      string: /"[^"]*"/,
      keyword: {
        pattern: /((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
        lookbehind: true,
        greedy: true,
        inside: {
          keyword: /^[-A-Z\d]+/,
          language: {
            pattern: /^(\s*)\[[-\w]+\]/,
            lookbehind: true,
            inside: {
              punctuation: /^\[|\]$/,
              property: /[-\w]+/
            }
          },
          "sub-key": {
            pattern: /^(\s*)\S[\s\S]*/,
            lookbehind: true,
            inside: {
              parameter: {
                pattern: /"[^"]*"/,
                alias: "property"
              },
              punctuation: /^\(|\)$|,/
            }
          }
        }
      },
      operator: /=/,
      tlist: {
        pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
        greedy: true,
        inside: {
          function: /^TLIST/,
          property: {
            pattern: /^(\s*\(\s*)\w+/,
            lookbehind: true
          },
          string: /"[^"]*"/,
          punctuation: /[(),]/,
          operator: /-/
        }
      },
      punctuation: /[;,]/,
      number: {
        pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
        lookbehind: true
      },
      boolean: /NO|YES/
    };
    Prism.languages.px = Prism.languages.pcaxis;
  }
  return pcaxis_1;
}
var peoplecode_1;
var hasRequiredPeoplecode;
function requirePeoplecode() {
  if (hasRequiredPeoplecode) return peoplecode_1;
  hasRequiredPeoplecode = 1;
  peoplecode_1 = peoplecode;
  peoplecode.displayName = "peoplecode";
  peoplecode.aliases = ["pcode"];
  function peoplecode(Prism) {
    Prism.languages.peoplecode = {
      comment: RegExp(
        [
          // C-style multiline comments
          /\/\*[\s\S]*?\*\//.source,
          // REM comments
          /\bREM[^;]*;/.source,
          // Nested <* *> comments
          /<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
          // /+ +/ comments
          /\/\+[\s\S]*?\+\//.source
        ].join("|")
      ),
      string: {
        pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
        greedy: true
      },
      variable: /%\w+/,
      "function-definition": {
        pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
        lookbehind: true,
        alias: "function"
      },
      "class-name": {
        pattern: /((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
        lookbehind: true,
        inside: {
          punctuation: /:/
        }
      },
      keyword: /\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
      "operator-keyword": {
        pattern: /\b(?:and|not|or)\b/i,
        alias: "operator"
      },
      function: /[_a-z]\w*(?=\s*\()/i,
      boolean: /\b(?:false|true)\b/i,
      number: /\b\d+(?:\.\d+)?\b/,
      operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
      punctuation: /[:.;,()[\]]/
    };
    Prism.languages.pcode = Prism.languages.peoplecode;
  }
  return peoplecode_1;
}
var perl_1;
var hasRequiredPerl;
function requirePerl() {
  if (hasRequiredPerl) return perl_1;
  hasRequiredPerl = 1;
  perl_1 = perl;
  perl.displayName = "perl";
  perl.aliases = [];
  function perl(Prism) {
    (function(Prism2) {
      var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
      Prism2.languages.perl = {
        comment: [
          {
            // POD
            pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\$])#.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        // TODO Could be nice to handle Heredoc too.
        string: [
          {
            pattern: RegExp(
              /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                // q/.../
                /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                // q a...a
                // eslint-disable-next-line regexp/strict
                /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                // q(...)
                // q{...}
                // q[...]
                // q<...>
                brackets
              ].join("|") + ")"
            ),
            greedy: true
          },
          // "...", `...`
          {
            pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
            greedy: true
          },
          // '...'
          // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
          {
            pattern: /'(?:[^'\\\r\n]|\\.)*'/,
            greedy: true
          }
        ],
        regex: [
          {
            pattern: RegExp(
              /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                // m/.../
                /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                // m a...a
                // eslint-disable-next-line regexp/strict
                /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                // m(...)
                // m{...}
                // m[...]
                // m<...>
                brackets
              ].join("|") + ")" + /[msixpodualngc]*/.source
            ),
            greedy: true
          },
          // The lookbehinds prevent -s from breaking
          {
            pattern: RegExp(
              /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                // s/.../.../
                // eslint-disable-next-line regexp/strict
                /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                // s a...a...a
                // eslint-disable-next-line regexp/strict
                /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
                // s(...)(...)
                // s{...}{...}
                // s[...][...]
                // s<...><...>
                // s(...)[...]
                brackets + /\s*/.source + brackets
              ].join("|") + ")" + /[msixpodualngcer]*/.source
            ),
            lookbehind: true,
            greedy: true
          },
          // /.../
          // The look-ahead tries to prevent two divisions on
          // the same line from being highlighted as regex.
          // This does not support multi-line regex.
          {
            pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
            greedy: true
          }
        ],
        // FIXME Not sure about the handling of ::, ', and #
        variable: [
          // ${^POSTMATCH}
          /[&*$@%]\{\^[A-Z]+\}/,
          // $^V
          /[&*$@%]\^[A-Z_]/,
          // ${...}
          /[&*$@%]#?(?=\{)/,
          // $foo
          /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
          // $1
          /[&*$@%]\d+/,
          // $_, @_, %!
          // The negative lookahead prevents from breaking the %= operator
          /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
        ],
        filehandle: {
          // <>, <FOO>, _
          pattern: /<(?![<=])\S*?>|\b_\b/,
          alias: "symbol"
        },
        "v-string": {
          // v1.2, 1.2.3
          pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
          alias: "string"
        },
        function: {
          pattern: /(\bsub[ \t]+)\w+/,
          lookbehind: true
        },
        keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
        number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
        operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
        punctuation: /[{}[\];(),:]/
      };
    })(Prism);
  }
  return perl_1;
}
var phpExtras_1;
var hasRequiredPhpExtras;
function requirePhpExtras() {
  if (hasRequiredPhpExtras) return phpExtras_1;
  hasRequiredPhpExtras = 1;
  var refractorPhp = requirePhp();
  phpExtras_1 = phpExtras;
  phpExtras.displayName = "phpExtras";
  phpExtras.aliases = [];
  function phpExtras(Prism) {
    Prism.register(refractorPhp);
    Prism.languages.insertBefore("php", "variable", {
      this: {
        pattern: /\$this\b/,
        alias: "keyword"
      },
      global: /\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
      scope: {
        pattern: /\b[\w\\]+::/,
        inside: {
          keyword: /\b(?:parent|self|static)\b/,
          punctuation: /::|\\/
        }
      }
    });
  }
  return phpExtras_1;
}
var phpdoc_1;
var hasRequiredPhpdoc;
function requirePhpdoc() {
  if (hasRequiredPhpdoc) return phpdoc_1;
  hasRequiredPhpdoc = 1;
  var refractorPhp = requirePhp();
  var refractorJavadoclike = requireJavadoclike();
  phpdoc_1 = phpdoc;
  phpdoc.displayName = "phpdoc";
  phpdoc.aliases = [];
  function phpdoc(Prism) {
    Prism.register(refractorPhp);
    Prism.register(refractorJavadoclike);
    (function(Prism2) {
      var typeExpression = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
      Prism2.languages.phpdoc = Prism2.languages.extend("javadoclike", {
        parameter: {
          pattern: RegExp(
            "(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:" + typeExpression + "\\s+)?)\\$\\w+"
          ),
          lookbehind: true
        }
      });
      Prism2.languages.insertBefore("phpdoc", "keyword", {
        "class-name": [
          {
            pattern: RegExp(
              "(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)" + typeExpression
            ),
            lookbehind: true,
            inside: {
              keyword: /\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
              punctuation: /[|\\[\]()]/
            }
          }
        ]
      });
      Prism2.languages.javadoclike.addSupport("php", Prism2.languages.phpdoc);
    })(Prism);
  }
  return phpdoc_1;
}
var plsql_1;
var hasRequiredPlsql;
function requirePlsql() {
  if (hasRequiredPlsql) return plsql_1;
  hasRequiredPlsql = 1;
  var refractorSql = requireSql();
  plsql_1 = plsql;
  plsql.displayName = "plsql";
  plsql.aliases = [];
  function plsql(Prism) {
    Prism.register(refractorSql);
    Prism.languages.plsql = Prism.languages.extend("sql", {
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|--.*/,
        greedy: true
      },
      // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-reserved-words-keywords.html
      keyword: /\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
      // https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/plsql-language-fundamentals.html#GUID-96A42F7C-7A71-4B90-8255-CA9C8BD9722E
      operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
    });
    Prism.languages.insertBefore("plsql", "operator", {
      label: {
        pattern: /<<\s*\w+\s*>>/,
        alias: "symbol"
      }
    });
  }
  return plsql_1;
}
var powerquery_1;
var hasRequiredPowerquery;
function requirePowerquery() {
  if (hasRequiredPowerquery) return powerquery_1;
  hasRequiredPowerquery = 1;
  powerquery_1 = powerquery;
  powerquery.displayName = "powerquery";
  powerquery.aliases = [];
  function powerquery(Prism) {
    Prism.languages.powerquery = {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: true,
        greedy: true
      },
      "quoted-identifier": {
        pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
        greedy: true
      },
      string: {
        pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
        greedy: true
      },
      constant: [
        /\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
        /\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
        /\bOccurrence\.(?:All|First|Last)\b/,
        /\bOrder\.(?:Ascending|Descending)\b/,
        /\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
        /\bMissingField\.(?:Error|Ignore|UseNull)\b/,
        /\bQuoteStyle\.(?:Csv|None)\b/,
        /\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
        /\bGroupKind\.(?:Global|Local)\b/,
        /\bExtraValues\.(?:Error|Ignore|List)\b/,
        /\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
        /\bJoinSide\.(?:Left|Right)\b/,
        /\bPrecision\.(?:Decimal|Double)\b/,
        /\bRelativePosition\.From(?:End|Start)\b/,
        /\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
        /\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
        /\bnull\b/
      ],
      boolean: /\b(?:false|true)\b/,
      keyword: /\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
      function: {
        pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
        lookbehind: true
      },
      "data-type": {
        pattern: /\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
        alias: "class-name"
      },
      number: {
        pattern: /\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
        lookbehind: true
      },
      operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
      punctuation: /[,;\[\](){}]/
    };
    Prism.languages.pq = Prism.languages["powerquery"];
    Prism.languages.mscript = Prism.languages["powerquery"];
  }
  return powerquery_1;
}
var powershell_1;
var hasRequiredPowershell;
function requirePowershell() {
  if (hasRequiredPowershell) return powershell_1;
  hasRequiredPowershell = 1;
  powershell_1 = powershell;
  powershell.displayName = "powershell";
  powershell.aliases = [];
  function powershell(Prism) {
    (function(Prism2) {
      var powershell2 = Prism2.languages.powershell = {
        comment: [
          {
            pattern: /(^|[^`])<#[\s\S]*?#>/,
            lookbehind: true
          },
          {
            pattern: /(^|[^`])#.*/,
            lookbehind: true
          }
        ],
        string: [
          {
            pattern: /"(?:`[\s\S]|[^`"])*"/,
            greedy: true,
            inside: null
            // see below
          },
          {
            pattern: /'(?:[^']|'')*'/,
            greedy: true
          }
        ],
        // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
        // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
        namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
        boolean: /\$(?:false|true)\b/i,
        variable: /\$\w+\b/,
        // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
        // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
        // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
        function: [
          /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
          /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
        ],
        // per http://technet.microsoft.com/en-us/library/hh847744.aspx
        keyword: /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
        operator: {
          pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
          lookbehind: true
        },
        punctuation: /[|{}[\];(),.]/
      };
      powershell2.string[0].inside = {
        function: {
          // Allow for one level of nesting
          pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
          lookbehind: true,
          inside: powershell2
        },
        boolean: powershell2.boolean,
        variable: powershell2.variable
      };
    })(Prism);
  }
  return powershell_1;
}
var processing_1;
var hasRequiredProcessing;
function requireProcessing() {
  if (hasRequiredProcessing) return processing_1;
  hasRequiredProcessing = 1;
  processing_1 = processing;
  processing.displayName = "processing";
  processing.aliases = [];
  function processing(Prism) {
    Prism.languages.processing = Prism.languages.extend("clike", {
      keyword: /\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
      // Spaces are allowed between function name and parenthesis
      function: /\b\w+(?=\s*\()/,
      operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
    });
    Prism.languages.insertBefore("processing", "number", {
      // Special case: XML is a type
      constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
      type: {
        pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
        alias: "class-name"
      }
    });
  }
  return processing_1;
}
var prolog_1;
var hasRequiredProlog;
function requireProlog() {
  if (hasRequiredProlog) return prolog_1;
  hasRequiredProlog = 1;
  prolog_1 = prolog;
  prolog.displayName = "prolog";
  prolog.aliases = [];
  function prolog(Prism) {
    Prism.languages.prolog = {
      // Syntax depends on the implementation
      comment: {
        pattern: /\/\*[\s\S]*?\*\/|%.*/,
        greedy: true
      },
      // Depending on the implementation, strings may allow escaped newlines and quote-escape
      string: {
        pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
        greedy: true
      },
      builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
      // FIXME: Should we list all null-ary predicates (not followed by a parenthesis) like halt, trace, etc.?
      function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
      number: /\b\d+(?:\.\d*)?/,
      // Custom operators are allowed
      operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
      punctuation: /[(){}\[\],]/
    };
  }
  return prolog_1;
}
var promql_1;
var hasRequiredPromql;
function requirePromql() {
  if (hasRequiredPromql) return promql_1;
  hasRequiredPromql = 1;
  promql_1 = promql;
  promql.displayName = "promql";
  promql.aliases = [];
  function promql(Prism) {
    (function(Prism2) {
      var aggregations = [
        "sum",
        "min",
        "max",
        "avg",
        "group",
        "stddev",
        "stdvar",
        "count",
        "count_values",
        "bottomk",
        "topk",
        "quantile"
      ];
      var vectorMatching = [
        "on",
        "ignoring",
        "group_right",
        "group_left",
        "by",
        "without"
      ];
      var offsetModifier = ["offset"];
      var keywords = aggregations.concat(vectorMatching, offsetModifier);
      Prism2.languages.promql = {
        comment: {
          pattern: /(^[ \t]*)#.*/m,
          lookbehind: true
        },
        "vector-match": {
          // Match the comma-separated label lists inside vector matching:
          pattern: new RegExp(
            "((?:" + vectorMatching.join("|") + ")\\s*)\\([^)]*\\)"
          ),
          lookbehind: true,
          inside: {
            "label-key": {
              pattern: /\b[^,]+\b/,
              alias: "attr-name"
            },
            punctuation: /[(),]/
          }
        },
        "context-labels": {
          pattern: /\{[^{}]*\}/,
          inside: {
            "label-key": {
              pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
              alias: "attr-name"
            },
            "label-value": {
              pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
              greedy: true,
              alias: "attr-value"
            },
            punctuation: /\{|\}|=~?|![=~]|,/
          }
        },
        "context-range": [
          {
            pattern: /\[[\w\s:]+\]/,
            // [1m]
            inside: {
              punctuation: /\[|\]|:/,
              "range-duration": {
                pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                alias: "number"
              }
            }
          },
          {
            pattern: /(\boffset\s+)\w+/,
            // offset 1m
            lookbehind: true,
            inside: {
              "range-duration": {
                pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
                alias: "number"
              }
            }
          }
        ],
        keyword: new RegExp("\\b(?:" + keywords.join("|") + ")\\b", "i"),
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: /[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
        operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
        punctuation: /[{};()`,.[\]]/
      };
    })(Prism);
  }
  return promql_1;
}
var properties_1;
var hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties_1;
  hasRequiredProperties = 1;
  properties_1 = properties;
  properties.displayName = "properties";
  properties.aliases = [];
  function properties(Prism) {
    Prism.languages.properties = {
      comment: /^[ \t]*[#!].*$/m,
      "attr-value": {
        pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
        lookbehind: true
      },
      "attr-name": /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
      punctuation: /[=:]/
    };
  }
  return properties_1;
}
var protobuf_1;
var hasRequiredProtobuf;
function requireProtobuf() {
  if (hasRequiredProtobuf) return protobuf_1;
  hasRequiredProtobuf = 1;
  protobuf_1 = protobuf;
  protobuf.displayName = "protobuf";
  protobuf.aliases = [];
  function protobuf(Prism) {
    (function(Prism2) {
      var builtinTypes = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
      Prism2.languages.protobuf = Prism2.languages.extend("clike", {
        "class-name": [
          {
            pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
            lookbehind: true
          },
          {
            pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
            lookbehind: true
          }
        ],
        keyword: /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
        function: /\b[a-z_]\w*(?=\s*\()/i
      });
      Prism2.languages.insertBefore("protobuf", "operator", {
        map: {
          pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
          alias: "class-name",
          inside: {
            punctuation: /[<>.,]/,
            builtin: builtinTypes
          }
        },
        builtin: builtinTypes,
        "positional-class-name": {
          pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
          alias: "class-name",
          inside: {
            punctuation: /\./
          }
        },
        annotation: {
          pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
          lookbehind: true
        }
      });
    })(Prism);
  }
  return protobuf_1;
}
var psl_1;
var hasRequiredPsl;
function requirePsl() {
  if (hasRequiredPsl) return psl_1;
  hasRequiredPsl = 1;
  psl_1 = psl;
  psl.displayName = "psl";
  psl.aliases = [];
  function psl(Prism) {
    Prism.languages.psl = {
      comment: {
        pattern: /#.*/,
        greedy: true
      },
      string: {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true,
        inside: {
          symbol: /\\[ntrbA-Z"\\]/
        }
      },
      "heredoc-string": {
        pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
        alias: "string",
        greedy: true
      },
      keyword: /\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
      constant: /\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
      boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
      variable: /\b(?:PslDebug|errno|exit_status)\b/,
      builtin: {
        pattern: /\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
        alias: "builtin-function"
      },
      "foreach-variable": {
        pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
        lookbehind: true,
        greedy: true
      },
      function: /\b[_a-z]\w*\b(?=\s*\()/i,
      number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
      operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
      punctuation: /[(){}\[\];,]/
    };
  }
  return psl_1;
}
var pug_1;
var hasRequiredPug;
function requirePug() {
  if (hasRequiredPug) return pug_1;
  hasRequiredPug = 1;
  pug_1 = pug;
  pug.displayName = "pug";
  pug.aliases = [];
  function pug(Prism) {
    (function(Prism2) {
      Prism2.languages.pug = {
        // Multiline stuff should appear before the rest
        // This handles both single-line and multi-line comments
        comment: {
          pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
          lookbehind: true
        },
        // All the tag-related part is in lookbehind
        // so that it can be highlighted by the "tag" pattern
        "multiline-script": {
          pattern: /(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        // See at the end of the file for known filters
        filter: {
          pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: true,
          inside: {
            "filter-name": {
              pattern: /^:[\w-]+/,
              alias: "variable"
            },
            text: /\S[\s\S]*/
          }
        },
        "multiline-plain-text": {
          pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
          lookbehind: true
        },
        markup: {
          pattern: /(^[\t ]*)<.+/m,
          lookbehind: true,
          inside: Prism2.languages.markup
        },
        doctype: {
          pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
          lookbehind: true
        },
        // This handle all conditional and loop keywords
        "flow-control": {
          pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
          lookbehind: true,
          inside: {
            each: {
              pattern: /^each .+? in\b/,
              inside: {
                keyword: /\b(?:each|in)\b/,
                punctuation: /,/
              }
            },
            branch: {
              pattern: /^(?:case|default|else|if|unless|when|while)\b/,
              alias: "keyword"
            },
            rest: Prism2.languages.javascript
          }
        },
        keyword: {
          pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
          lookbehind: true
        },
        mixin: [
          // Declaration
          {
            pattern: /(^[\t ]*)mixin .+/m,
            lookbehind: true,
            inside: {
              keyword: /^mixin/,
              function: /\w+(?=\s*\(|\s*$)/,
              punctuation: /[(),.]/
            }
          },
          // Usage
          {
            pattern: /(^[\t ]*)\+.+/m,
            lookbehind: true,
            inside: {
              name: {
                pattern: /^\+\w+/,
                alias: "function"
              },
              rest: Prism2.languages.javascript
            }
          }
        ],
        script: {
          pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        "plain-text": {
          pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
          lookbehind: true
        },
        tag: {
          pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
          lookbehind: true,
          inside: {
            attributes: [
              {
                pattern: /&[^(]+\([^)]+\)/,
                inside: Prism2.languages.javascript
              },
              {
                pattern: /\([^)]+\)/,
                inside: {
                  "attr-value": {
                    pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
                    lookbehind: true,
                    inside: Prism2.languages.javascript
                  },
                  "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
                  punctuation: /[!=(),]+/
                }
              }
            ],
            punctuation: /:/,
            "attr-id": /#[\w\-]+/,
            "attr-class": /\.[\w\-]+/
          }
        },
        code: [
          {
            pattern: /(^[\t ]*(?:-|!?=)).+/m,
            lookbehind: true,
            inside: Prism2.languages.javascript
          }
        ],
        punctuation: /[.\-!=|]+/
      };
      var filter_pattern = /(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source;
      var filters = [
        {
          filter: "atpl",
          language: "twig"
        },
        {
          filter: "coffee",
          language: "coffeescript"
        },
        "ejs",
        "handlebars",
        "less",
        "livescript",
        "markdown",
        {
          filter: "sass",
          language: "scss"
        },
        "stylus"
      ];
      var all_filters = {};
      for (var i2 = 0, l2 = filters.length; i2 < l2; i2++) {
        var filter2 = filters[i2];
        filter2 = typeof filter2 === "string" ? {
          filter: filter2,
          language: filter2
        } : filter2;
        if (Prism2.languages[filter2.language]) {
          all_filters["filter-" + filter2.filter] = {
            pattern: RegExp(
              filter_pattern.replace("<filter_name>", function() {
                return filter2.filter;
              }),
              "m"
            ),
            lookbehind: true,
            inside: {
              "filter-name": {
                pattern: /^:[\w-]+/,
                alias: "variable"
              },
              text: {
                pattern: /\S[\s\S]*/,
                alias: [filter2.language, "language-" + filter2.language],
                inside: Prism2.languages[filter2.language]
              }
            }
          };
        }
      }
      Prism2.languages.insertBefore("pug", "filter", all_filters);
    })(Prism);
  }
  return pug_1;
}
var puppet_1;
var hasRequiredPuppet;
function requirePuppet() {
  if (hasRequiredPuppet) return puppet_1;
  hasRequiredPuppet = 1;
  puppet_1 = puppet;
  puppet.displayName = "puppet";
  puppet.aliases = [];
  function puppet(Prism) {
    (function(Prism2) {
      Prism2.languages.puppet = {
        heredoc: [
          // Matches the content of a quoted heredoc string (subject to interpolation)
          {
            pattern: /(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
            lookbehind: true,
            alias: "string",
            inside: {
              // Matches the end tag
              punctuation: /(?=\S).*\S(?= *$)/
              // See interpolation below
            }
          },
          // Matches the content of an unquoted heredoc string (no interpolation)
          {
            pattern: /(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
            lookbehind: true,
            greedy: true,
            alias: "string",
            inside: {
              // Matches the end tag
              punctuation: /(?=\S).*\S(?= *$)/
            }
          },
          // Matches the start tag of heredoc strings
          {
            pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
            alias: "string",
            inside: {
              punctuation: {
                pattern: /(\().+?(?=\))/,
                lookbehind: true
              }
            }
          }
        ],
        "multiline-comment": {
          pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
          lookbehind: true,
          greedy: true,
          alias: "comment"
        },
        regex: {
          // Must be prefixed with the keyword "node" or a non-word char
          pattern: /((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
          lookbehind: true,
          greedy: true,
          inside: {
            // Extended regexes must have the x flag. They can contain single-line comments.
            "extended-regex": {
              pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
              inside: {
                comment: /#.*/
              }
            }
          }
        },
        comment: {
          pattern: /(^|[^\\])#.*/,
          lookbehind: true,
          greedy: true
        },
        string: {
          // Allow for one nested level of double quotes inside interpolation
          pattern: /(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
          greedy: true,
          inside: {
            "double-quoted": {
              pattern: /^"[\s\S]*"$/,
              inside: {
                // See interpolation below
              }
            }
          }
        },
        variable: {
          pattern: /\$(?:::)?\w+(?:::\w+)*/,
          inside: {
            punctuation: /::/
          }
        },
        "attr-name": /(?:\b\w+|\*)(?=\s*=>)/,
        function: [
          {
            pattern: /(\.)(?!\d)\w+/,
            lookbehind: true
          },
          /\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
        ],
        number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
        boolean: /\b(?:false|true)\b/,
        // Includes words reserved for future use
        keyword: /\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
        datatype: {
          pattern: /\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
          alias: "symbol"
        },
        operator: /=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
        punctuation: /[\[\]{}().,;]|:+/
      };
      var interpolation = [
        {
          // Allow for one nested level of braces inside interpolation
          pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
          lookbehind: true,
          inside: {
            "short-variable": {
              // Negative look-ahead prevent wrong highlighting of functions
              pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
              lookbehind: true,
              alias: "variable",
              inside: {
                punctuation: /::/
              }
            },
            delimiter: {
              pattern: /^\$/,
              alias: "variable"
            },
            rest: Prism2.languages.puppet
          }
        },
        {
          pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
          lookbehind: true,
          alias: "variable",
          inside: {
            punctuation: /::/
          }
        }
      ];
      Prism2.languages.puppet["heredoc"][0].inside.interpolation = interpolation;
      Prism2.languages.puppet["string"].inside["double-quoted"].inside.interpolation = interpolation;
    })(Prism);
  }
  return puppet_1;
}
var pure_1;
var hasRequiredPure;
function requirePure() {
  if (hasRequiredPure) return pure_1;
  hasRequiredPure = 1;
  pure_1 = pure;
  pure.displayName = "pure";
  pure.aliases = [];
  function pure(Prism) {
    (function(Prism2) {
      Prism2.languages.pure = {
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
            lookbehind: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true
          },
          /#!.+/
        ],
        "inline-lang": {
          pattern: /%<[\s\S]+?%>/,
          greedy: true,
          inside: {
            lang: {
              pattern: /(^%< *)-\*-.+?-\*-/,
              lookbehind: true,
              alias: "comment"
            },
            delimiter: {
              pattern: /^%<.*|%>$/,
              alias: "punctuation"
            }
          }
        },
        string: {
          pattern: /"(?:\\.|[^"\\\r\n])*"/,
          greedy: true
        },
        number: {
          // The look-behind prevents wrong highlighting of the .. operator
          pattern: /((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
          lookbehind: true
        },
        keyword: /\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
        function: /\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
        special: {
          pattern: /\b__[a-z]+__\b/i,
          alias: "builtin"
        },
        // Any combination of operator chars can be an operator
        // eslint-disable-next-line no-misleading-character-class
        operator: /(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
        // FIXME: How can we prevent | and , to be highlighted as operator when they are used alone?
        punctuation: /[(){}\[\];,|]/
      };
      var inlineLanguages = [
        "c",
        {
          lang: "c++",
          alias: "cpp"
        },
        "fortran"
      ];
      var inlineLanguageRe = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
      inlineLanguages.forEach(function(lang) {
        var alias = lang;
        if (typeof lang !== "string") {
          alias = lang.alias;
          lang = lang.lang;
        }
        if (Prism2.languages[alias]) {
          var o4 = {};
          o4["inline-lang-" + alias] = {
            pattern: RegExp(
              inlineLanguageRe.replace(
                "<lang>",
                lang.replace(/([.+*?\/\\(){}\[\]])/g, "\\$1")
              ),
              "i"
            ),
            inside: Prism2.util.clone(Prism2.languages.pure["inline-lang"].inside)
          };
          o4["inline-lang-" + alias].inside.rest = Prism2.util.clone(
            Prism2.languages[alias]
          );
          Prism2.languages.insertBefore("pure", "inline-lang", o4);
        }
      });
      if (Prism2.languages.c) {
        Prism2.languages.pure["inline-lang"].inside.rest = Prism2.util.clone(
          Prism2.languages.c
        );
      }
    })(Prism);
  }
  return pure_1;
}
var purebasic_1;
var hasRequiredPurebasic;
function requirePurebasic() {
  if (hasRequiredPurebasic) return purebasic_1;
  hasRequiredPurebasic = 1;
  purebasic_1 = purebasic;
  purebasic.displayName = "purebasic";
  purebasic.aliases = [];
  function purebasic(Prism) {
    Prism.languages.purebasic = Prism.languages.extend("clike", {
      comment: /;.*/,
      keyword: /\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
      function: /\b\w+(?:\.\w+)?\s*(?=\()/,
      number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
      operator: /(?:@\*?|\?|\*)\w+|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
    });
    Prism.languages.insertBefore("purebasic", "keyword", {
      tag: /#\w+\$?/,
      asm: {
        pattern: /(^[\t ]*)!.*/m,
        lookbehind: true,
        alias: "tag",
        inside: {
          comment: /;.*/,
          string: {
            pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
            greedy: true
          },
          // Anonymous label references, i.e.: jmp @b
          "label-reference-anonymous": {
            pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
            lookbehind: true,
            alias: "fasm-label"
          },
          // Named label reference, i.e.: jne label1
          "label-reference-addressed": {
            pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
            lookbehind: true,
            alias: "fasm-label"
          },
          keyword: [
            /\b(?:extern|global)\b[^;\r\n]*/i,
            /\b(?:CPU|DEFAULT|FLOAT)\b.*/
          ],
          function: {
            pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
            lookbehind: true
          },
          "function-inline": {
            pattern: /(:\s*)[\da-z]+(?=\s)/i,
            lookbehind: true,
            alias: "function"
          },
          label: {
            pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
            lookbehind: true,
            alias: "fasm-label"
          },
          register: /\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
          number: /(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
          operator: /[\[\]*+\-/%<>=&|$!,.:]/
        }
      }
    });
    delete Prism.languages.purebasic["class-name"];
    delete Prism.languages.purebasic["boolean"];
    Prism.languages.pbfasm = Prism.languages["purebasic"];
  }
  return purebasic_1;
}
var purescript_1;
var hasRequiredPurescript;
function requirePurescript() {
  if (hasRequiredPurescript) return purescript_1;
  hasRequiredPurescript = 1;
  var refractorHaskell = requireHaskell();
  purescript_1 = purescript;
  purescript.displayName = "purescript";
  purescript.aliases = ["purs"];
  function purescript(Prism) {
    Prism.register(refractorHaskell);
    Prism.languages.purescript = Prism.languages.extend("haskell", {
      keyword: /\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|∀/,
      "import-statement": {
        // The imported or hidden names are not included in this import
        // statement. This is because we want to highlight those exactly like
        // we do for the names in the program.
        pattern: /(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
        lookbehind: true,
        inside: {
          keyword: /\b(?:as|hiding|import)\b/,
          punctuation: /\./
        }
      },
      // These are builtin functions only. Constructors are highlighted later as a constant.
      builtin: /\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
      operator: [
        // Infix operators
        Prism.languages.haskell.operator[0],
        // ASCII operators
        Prism.languages.haskell.operator[2],
        // All UTF16 Unicode operator symbols
        // This regex is equivalent to /(?=[\x80-\uFFFF])[\p{gc=Math_Symbol}\p{gc=Currency_Symbol}\p{Modifier_Symbol}\p{Other_Symbol}]/u
        // See https://github.com/PrismJS/prism/issues/3006 for more details.
        /[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
      ]
    });
    Prism.languages.purs = Prism.languages.purescript;
  }
  return purescript_1;
}
var python_1;
var hasRequiredPython;
function requirePython() {
  if (hasRequiredPython) return python_1;
  hasRequiredPython = 1;
  python_1 = python;
  python.displayName = "python";
  python.aliases = ["py"];
  function python(Prism) {
    Prism.languages.python = {
      comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: true,
        greedy: true
      },
      "string-interpolation": {
        pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: true,
        inside: {
          interpolation: {
            // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
            pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
            lookbehind: true,
            inside: {
              "format-spec": {
                pattern: /(:)[^:(){}]+(?=\}$)/,
                lookbehind: true
              },
              "conversion-option": {
                pattern: /![sra](?=[:}]$)/,
                alias: "punctuation"
              },
              rest: null
            }
          },
          string: /[\s\S]+/
        }
      },
      "triple-quoted-string": {
        pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
        greedy: true,
        alias: "string"
      },
      string: {
        pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: true
      },
      function: {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: true
      },
      "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: true
      },
      decorator: {
        pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
        lookbehind: true,
        alias: ["annotation", "punctuation"],
        inside: {
          punctuation: /\./
        }
      },
      keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
      builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
      boolean: /\b(?:False|None|True)\b/,
      number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
      operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
    Prism.languages.py = Prism.languages.python;
  }
  return python_1;
}
var q_1;
var hasRequiredQ;
function requireQ() {
  if (hasRequiredQ) return q_1;
  hasRequiredQ = 1;
  q_1 = q2;
  q2.displayName = "q";
  q2.aliases = [];
  function q2(Prism) {
    Prism.languages.q = {
      string: /"(?:\\.|[^"\\\r\n])*"/,
      comment: [
        // From http://code.kx.com/wiki/Reference/Slash:
        // When / is following a space (or a right parenthesis, bracket, or brace), it is ignored with the rest of the line.
        {
          pattern: /([\t )\]}])\/.*/,
          lookbehind: true,
          greedy: true
        },
        // From http://code.kx.com/wiki/Reference/Slash:
        // A line which has / as its first character and contains at least one other non-whitespace character is a whole-line comment and is ignored entirely.
        // A / on a line by itself begins a multiline comment which is terminated by the next \ on a line by itself.
        // If a / is not matched by a \, the multiline comment is unterminated and continues to end of file.
        // The / and \ must be the first char on the line, but may be followed by any amount of whitespace.
        {
          pattern: /(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
          lookbehind: true,
          greedy: true
        },
        // From http://code.kx.com/wiki/Reference/Slash:
        // A \ on a line by itself with no preceding matching / will comment to end of file.
        {
          pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
          greedy: true
        },
        {
          pattern: /^#!.+/m,
          greedy: true
        }
      ],
      symbol: /`(?::\S+|[\w.]*)/,
      datetime: {
        pattern: /0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
        alias: "number"
      },
      // The negative look-ahead prevents bad highlighting
      // of verbs 0: and 1:
      number: /\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
      keyword: /\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
      adverb: {
        pattern: /['\/\\]:?|\beach\b/,
        alias: "function"
      },
      verb: {
        pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
        alias: "operator"
      },
      punctuation: /[(){}\[\];.]/
    };
  }
  return q_1;
}
var qml_1;
var hasRequiredQml;
function requireQml() {
  if (hasRequiredQml) return qml_1;
  hasRequiredQml = 1;
  qml_1 = qml;
  qml.displayName = "qml";
  qml.aliases = [];
  function qml(Prism) {
    (function(Prism2) {
      var jsString = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source;
      var jsComment = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source;
      var jsExpr = /(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source.replace(/<string>/g, function() {
        return jsString;
      }).replace(/<comment>/g, function() {
        return jsComment;
      });
      for (var i2 = 0; i2 < 2; i2++) {
        jsExpr = jsExpr.replace(/<expr>/g, function() {
          return jsExpr;
        });
      }
      jsExpr = jsExpr.replace(/<expr>/g, "[^\\s\\S]");
      Prism2.languages.qml = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
          greedy: true
        },
        "javascript-function": {
          pattern: RegExp(
            /((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(
              /<js>/g,
              function() {
                return jsExpr;
              }
            ),
            "m"
          ),
          lookbehind: true,
          greedy: true,
          alias: "language-javascript",
          inside: Prism2.languages.javascript
        },
        "class-name": {
          pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
          lookbehind: true
        },
        property: [
          {
            pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
            lookbehind: true
          },
          {
            pattern: /((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
            lookbehind: true,
            inside: {
              keyword: /^property/,
              property: /\w+(?:\.\w+)*/
            }
          }
        ],
        "javascript-expression": {
          pattern: RegExp(
            /(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(
              /<js>/g,
              function() {
                return jsExpr;
              }
            ),
            "m"
          ),
          lookbehind: true,
          greedy: true,
          alias: "language-javascript",
          inside: Prism2.languages.javascript
        },
        string: {
          pattern: /"(?:\\.|[^\\"\r\n])*"/,
          greedy: true
        },
        keyword: /\b(?:as|import|on)\b/,
        punctuation: /[{}[\]:;,]/
      };
    })(Prism);
  }
  return qml_1;
}
var qore_1;
var hasRequiredQore;
function requireQore() {
  if (hasRequiredQore) return qore_1;
  hasRequiredQore = 1;
  qore_1 = qore;
  qore.displayName = "qore";
  qore.aliases = [];
  function qore(Prism) {
    Prism.languages.qore = Prism.languages.extend("clike", {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
        lookbehind: true
      },
      // Overridden to allow unescaped multi-line strings
      string: {
        pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
        greedy: true
      },
      keyword: /\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
      boolean: /\b(?:false|true)\b/i,
      function: /\$?\b(?!\d)\w+(?=\()/,
      number: /\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
      operator: {
        pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
        lookbehind: true
      },
      variable: /\$(?!\d)\w+\b/
    });
  }
  return qore_1;
}
var qsharp_1;
var hasRequiredQsharp;
function requireQsharp() {
  if (hasRequiredQsharp) return qsharp_1;
  hasRequiredQsharp = 1;
  qsharp_1 = qsharp;
  qsharp.displayName = "qsharp";
  qsharp.aliases = ["qs"];
  function qsharp(Prism) {
    (function(Prism2) {
      function replace(pattern, replacements) {
        return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
          return "(?:" + replacements[+index2] + ")";
        });
      }
      function re2(pattern, replacements, flags) {
        return RegExp(replace(pattern, replacements), "");
      }
      function nested(pattern, depthLog2) {
        for (var i2 = 0; i2 < depthLog2; i2++) {
          pattern = pattern.replace(/<<self>>/g, function() {
            return "(?:" + pattern + ")";
          });
        }
        return pattern.replace(/<<self>>/g, "[^\\s\\S]");
      }
      var keywordKinds = {
        // keywords which represent a return or variable type
        type: "Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero",
        // all other keywords
        other: "Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within"
      };
      function keywordsToPattern(words) {
        return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
      }
      var keywords = RegExp(
        keywordsToPattern(keywordKinds.type + " " + keywordKinds.other)
      );
      var identifier = /\b[A-Za-z_]\w*\b/.source;
      var qualifiedName = replace(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [identifier]);
      var typeInside = {
        keyword: keywords,
        punctuation: /[<>()?,.:[\]]/
      };
      var regularString = /"(?:\\.|[^\\"])*"/.source;
      Prism2.languages.qsharp = Prism2.languages.extend("clike", {
        comment: /\/\/.*/,
        string: [
          {
            pattern: re2(/(^|[^$\\])<<0>>/.source, [regularString]),
            lookbehind: true,
            greedy: true
          }
        ],
        "class-name": [
          {
            // open Microsoft.Quantum.Canon;
            // open Microsoft.Quantum.Canon as CN;
            pattern: re2(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [
              qualifiedName
            ]),
            lookbehind: true,
            inside: typeInside
          },
          {
            // namespace Quantum.App1;
            pattern: re2(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [qualifiedName]),
            lookbehind: true,
            inside: typeInside
          }
        ],
        keyword: keywords,
        number: /(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
        operator: /\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
        punctuation: /::|[{}[\];(),.:]/
      });
      Prism2.languages.insertBefore("qsharp", "number", {
        range: {
          pattern: /\.\./,
          alias: "operator"
        }
      });
      var interpolationExpr = nested(
        replace(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [regularString]),
        2
      );
      Prism2.languages.insertBefore("qsharp", "string", {
        "interpolation-string": {
          pattern: re2(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [interpolationExpr]),
          greedy: true,
          inside: {
            interpolation: {
              pattern: re2(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [
                interpolationExpr
              ]),
              lookbehind: true,
              inside: {
                punctuation: /^\{|\}$/,
                expression: {
                  pattern: /[\s\S]+/,
                  alias: "language-qsharp",
                  inside: Prism2.languages.qsharp
                }
              }
            },
            string: /[\s\S]+/
          }
        }
      });
    })(Prism);
    Prism.languages.qs = Prism.languages.qsharp;
  }
  return qsharp_1;
}
var r_1;
var hasRequiredR;
function requireR() {
  if (hasRequiredR) return r_1;
  hasRequiredR = 1;
  r_1 = r2;
  r2.displayName = "r";
  r2.aliases = [];
  function r2(Prism) {
    Prism.languages.r = {
      comment: /#.*/,
      string: {
        pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "percent-operator": {
        // Includes user-defined operators
        // and %%, %*%, %/%, %in%, %o%, %x%
        pattern: /%[^%\s]*%/,
        alias: "operator"
      },
      boolean: /\b(?:FALSE|TRUE)\b/,
      ellipsis: /\.\.(?:\.|\d+)/,
      number: [
        /\b(?:Inf|NaN)\b/,
        /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
      ],
      keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
      operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
      punctuation: /[(){}\[\],;]/
    };
  }
  return r_1;
}
var racket_1;
var hasRequiredRacket;
function requireRacket() {
  if (hasRequiredRacket) return racket_1;
  hasRequiredRacket = 1;
  var refractorScheme = requireScheme();
  racket_1 = racket;
  racket.displayName = "racket";
  racket.aliases = ["rkt"];
  function racket(Prism) {
    Prism.register(refractorScheme);
    Prism.languages.racket = Prism.languages.extend("scheme", {
      "lambda-parameter": {
        // the racket lambda syntax is a lot more complex, so we won't even attempt to capture it.
        // this will just prevent false positives of the `function` pattern
        pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
        lookbehind: true
      }
    });
    Prism.languages.insertBefore("racket", "string", {
      lang: {
        pattern: /^#lang.+/m,
        greedy: true,
        alias: "keyword"
      }
    });
    Prism.languages.rkt = Prism.languages.racket;
  }
  return racket_1;
}
var reason_1;
var hasRequiredReason;
function requireReason() {
  if (hasRequiredReason) return reason_1;
  hasRequiredReason = 1;
  reason_1 = reason;
  reason.displayName = "reason";
  reason.aliases = [];
  function reason(Prism) {
    Prism.languages.reason = Prism.languages.extend("clike", {
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
        greedy: true
      },
      // 'class-name' must be matched *after* 'constructor' defined below
      "class-name": /\b[A-Z]\w*/,
      keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
      operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
    });
    Prism.languages.insertBefore("reason", "class-name", {
      char: {
        pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
        greedy: true
      },
      // Negative look-ahead prevents from matching things like String.capitalize
      constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
      label: {
        pattern: /\b[a-z]\w*(?=::)/,
        alias: "symbol"
      }
    });
    delete Prism.languages.reason.function;
  }
  return reason_1;
}
var regex_1;
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex_1;
  hasRequiredRegex = 1;
  regex_1 = regex;
  regex.displayName = "regex";
  regex.aliases = [];
  function regex(Prism) {
    (function(Prism2) {
      var specialEscape = {
        pattern: /\\[\\(){}[\]^$+*?|.]/,
        alias: "escape"
      };
      var escape = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
      var charSet = {
        pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
        alias: "class-name"
      };
      var charSetWithoutDot = {
        pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
        alias: "class-name"
      };
      var rangeChar = "(?:[^\\\\-]|" + escape.source + ")";
      var range = RegExp(rangeChar + "-" + rangeChar);
      var groupName = {
        pattern: /(<|')[^<>']+(?=[>']$)/,
        lookbehind: true,
        alias: "variable"
      };
      Prism2.languages.regex = {
        "char-class": {
          pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
          lookbehind: true,
          inside: {
            "char-class-negation": {
              pattern: /(^\[)\^/,
              lookbehind: true,
              alias: "operator"
            },
            "char-class-punctuation": {
              pattern: /^\[|\]$/,
              alias: "punctuation"
            },
            range: {
              pattern: range,
              inside: {
                escape,
                "range-punctuation": {
                  pattern: /-/,
                  alias: "operator"
                }
              }
            },
            "special-escape": specialEscape,
            "char-set": charSetWithoutDot,
            escape
          }
        },
        "special-escape": specialEscape,
        "char-set": charSet,
        backreference: [
          {
            // a backreference which is not an octal escape
            pattern: /\\(?![123][0-7]{2})[1-9]/,
            alias: "keyword"
          },
          {
            pattern: /\\k<[^<>']+>/,
            alias: "keyword",
            inside: {
              "group-name": groupName
            }
          }
        ],
        anchor: {
          pattern: /[$^]|\\[ABbGZz]/,
          alias: "function"
        },
        escape,
        group: [
          {
            // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
            // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
            // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
            pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
            alias: "punctuation",
            inside: {
              "group-name": groupName
            }
          },
          {
            pattern: /\)/,
            alias: "punctuation"
          }
        ],
        quantifier: {
          pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
          alias: "number"
        },
        alternation: {
          pattern: /\|/,
          alias: "keyword"
        }
      };
    })(Prism);
  }
  return regex_1;
}
var rego_1;
var hasRequiredRego;
function requireRego() {
  if (hasRequiredRego) return rego_1;
  hasRequiredRego = 1;
  rego_1 = rego;
  rego.displayName = "rego";
  rego.aliases = [];
  function rego(Prism) {
    Prism.languages.rego = {
      comment: /#.*/,
      property: {
        pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
        lookbehind: true,
        greedy: true
      },
      string: {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
        lookbehind: true,
        greedy: true
      },
      keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
      boolean: /\b(?:false|true)\b/,
      function: {
        pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
        inside: {
          namespace: /\b\w+\b(?=\s*\.)/,
          punctuation: /\./
        }
      },
      number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
      operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
      punctuation: /[,;.\[\]{}()]/
    };
  }
  return rego_1;
}
var renpy_1;
var hasRequiredRenpy;
function requireRenpy() {
  if (hasRequiredRenpy) return renpy_1;
  hasRequiredRenpy = 1;
  renpy_1 = renpy;
  renpy.displayName = "renpy";
  renpy.aliases = ["rpy"];
  function renpy(Prism) {
    Prism.languages.renpy = {
      comment: {
        pattern: /(^|[^\\])#.+/,
        lookbehind: true
      },
      string: {
        pattern: /("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
        greedy: true
      },
      function: /\b[a-z_]\w*(?=\()/i,
      property: /\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
      tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
      keyword: /\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
      boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
      number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
      operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
      punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.rpy = Prism.languages.renpy;
  }
  return renpy_1;
}
var rest_1;
var hasRequiredRest;
function requireRest() {
  if (hasRequiredRest) return rest_1;
  hasRequiredRest = 1;
  rest_1 = rest;
  rest.displayName = "rest";
  rest.aliases = [];
  function rest(Prism) {
    Prism.languages.rest = {
      table: [
        {
          pattern: /(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
          lookbehind: true,
          inside: {
            punctuation: /\||(?:\+[=-]+)+\+/
          }
        },
        {
          pattern: /(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
          lookbehind: true,
          inside: {
            punctuation: /[=-]+/
          }
        }
      ],
      // Directive-like patterns
      "substitution-def": {
        pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
        lookbehind: true,
        inside: {
          substitution: {
            pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
            alias: "attr-value",
            inside: {
              punctuation: /^\||\|$/
            }
          },
          directive: {
            pattern: /( )(?! )[^:]+::/,
            lookbehind: true,
            alias: "function",
            inside: {
              punctuation: /::$/
            }
          }
        }
      },
      "link-target": [
        {
          pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
          lookbehind: true,
          alias: "string",
          inside: {
            punctuation: /^\[|\]$/
          }
        },
        {
          pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
          lookbehind: true,
          alias: "string",
          inside: {
            punctuation: /^_|:$/
          }
        }
      ],
      directive: {
        pattern: /(^[\t ]*\.\. )[^:]+::/m,
        lookbehind: true,
        alias: "function",
        inside: {
          punctuation: /::$/
        }
      },
      comment: {
        // The two alternatives try to prevent highlighting of blank comments
        pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
        lookbehind: true
      },
      title: [
        // Overlined and underlined
        {
          pattern: /^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
          inside: {
            punctuation: /^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
            important: /.+/
          }
        },
        // Underlined only
        {
          pattern: /(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
          lookbehind: true,
          inside: {
            punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
            important: /.+/
          }
        }
      ],
      hr: {
        pattern: /((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
        lookbehind: true,
        alias: "punctuation"
      },
      field: {
        pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
        lookbehind: true,
        alias: "attr-name"
      },
      "command-line-option": {
        pattern: /(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
        lookbehind: true,
        alias: "symbol"
      },
      "literal-block": {
        pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
        inside: {
          "literal-block-punctuation": {
            pattern: /^::/,
            alias: "punctuation"
          }
        }
      },
      "quoted-literal-block": {
        pattern: /::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
        inside: {
          "literal-block-punctuation": {
            pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
            alias: "punctuation"
          }
        }
      },
      "list-bullet": {
        pattern: /(^[\t ]*)(?:[*+\-•‣⁃]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
        lookbehind: true,
        alias: "punctuation"
      },
      "doctest-block": {
        pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
        lookbehind: true,
        inside: {
          punctuation: /^>>>/
        }
      },
      inline: [
        {
          pattern: /(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
          lookbehind: true,
          inside: {
            bold: {
              pattern: /(^\*\*).+(?=\*\*$)/,
              lookbehind: true
            },
            italic: {
              pattern: /(^\*).+(?=\*$)/,
              lookbehind: true
            },
            "inline-literal": {
              pattern: /(^``).+(?=``$)/,
              lookbehind: true,
              alias: "symbol"
            },
            role: {
              pattern: /^:[^:]+:|:[^:]+:$/,
              alias: "function",
              inside: {
                punctuation: /^:|:$/
              }
            },
            "interpreted-text": {
              pattern: /(^`).+(?=`$)/,
              lookbehind: true,
              alias: "attr-value"
            },
            substitution: {
              pattern: /(^\|).+(?=\|$)/,
              lookbehind: true,
              alias: "attr-value"
            },
            punctuation: /\*\*?|``?|\|/
          }
        }
      ],
      link: [
        {
          pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
          alias: "string",
          inside: {
            punctuation: /^\[|\]_$/
          }
        },
        {
          pattern: /(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
          alias: "string",
          inside: {
            punctuation: /^_?`|`$|`?_?_$/
          }
        }
      ],
      // Line block start,
      // quote attribution,
      // explicit markup start,
      // and anonymous hyperlink target shortcut (__)
      punctuation: {
        pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?|—|\.\.|__)(?= )|\.\.$)/m,
        lookbehind: true
      }
    };
  }
  return rest_1;
}
var rip_1;
var hasRequiredRip;
function requireRip() {
  if (hasRequiredRip) return rip_1;
  hasRequiredRip = 1;
  rip_1 = rip;
  rip.displayName = "rip";
  rip.aliases = [];
  function rip(Prism) {
    Prism.languages.rip = {
      comment: {
        pattern: /#.*/,
        greedy: true
      },
      char: {
        pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
        greedy: true
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      regex: {
        pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
        lookbehind: true,
        greedy: true
      },
      keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
      builtin: /@|\bSystem\b/,
      boolean: /\b(?:false|true)\b/,
      date: /\b\d{4}-\d{2}-\d{2}\b/,
      time: /\b\d{2}:\d{2}:\d{2}\b/,
      datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
      symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
      number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
      punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
      reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
    };
  }
  return rip_1;
}
var roboconf_1;
var hasRequiredRoboconf;
function requireRoboconf() {
  if (hasRequiredRoboconf) return roboconf_1;
  hasRequiredRoboconf = 1;
  roboconf_1 = roboconf;
  roboconf.displayName = "roboconf";
  roboconf.aliases = [];
  function roboconf(Prism) {
    Prism.languages.roboconf = {
      comment: /#.*/,
      keyword: {
        pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
        lookbehind: true
      },
      component: {
        pattern: /[\w-]+(?=[ \t]*\{)/,
        alias: "variable"
      },
      property: /[\w.-]+(?=[ \t]*:)/,
      value: {
        pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
        lookbehind: true,
        alias: "attr-value"
      },
      optional: {
        pattern: /\(optional\)/,
        alias: "builtin"
      },
      wildcard: {
        pattern: /(\.)\*/,
        lookbehind: true,
        alias: "operator"
      },
      punctuation: /[{},.;:=]/
    };
  }
  return roboconf_1;
}
var robotframework_1;
var hasRequiredRobotframework;
function requireRobotframework() {
  if (hasRequiredRobotframework) return robotframework_1;
  hasRequiredRobotframework = 1;
  robotframework_1 = robotframework;
  robotframework.displayName = "robotframework";
  robotframework.aliases = [];
  function robotframework(Prism) {
    (function(Prism2) {
      var comment = {
        pattern: /(^[ \t]*| {2}|\t)#.*/m,
        lookbehind: true,
        greedy: true
      };
      var variable = {
        pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
        lookbehind: true,
        inside: {
          punctuation: /^[$@&%]\{|\}$/
        }
      };
      function createSection(name, inside) {
        var extendecInside = {};
        extendecInside["section-header"] = {
          pattern: /^ ?\*{3}.+?\*{3}/,
          alias: "keyword"
        };
        for (var token in inside) {
          extendecInside[token] = inside[token];
        }
        extendecInside["tag"] = {
          pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
          lookbehind: true,
          inside: {
            punctuation: /\[|\]/
          }
        };
        extendecInside["variable"] = variable;
        extendecInside["comment"] = comment;
        return {
          pattern: RegExp(
            /^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(
              /<name>/g,
              function() {
                return name;
              }
            ),
            "im"
          ),
          alias: "section",
          inside: extendecInside
        };
      }
      var docTag = {
        pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
        lookbehind: true,
        alias: "string"
      };
      var testNameLike = {
        pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
        lookbehind: true,
        alias: "function",
        inside: {
          variable
        }
      };
      var testPropertyLike = {
        pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
        lookbehind: true,
        inside: {
          variable
        }
      };
      Prism2.languages["robotframework"] = {
        settings: createSection("Settings", {
          documentation: {
            pattern: /([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
            lookbehind: true,
            alias: "string"
          },
          property: {
            pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
            lookbehind: true
          }
        }),
        variables: createSection("Variables"),
        "test-cases": createSection("Test Cases", {
          "test-name": testNameLike,
          documentation: docTag,
          property: testPropertyLike
        }),
        keywords: createSection("Keywords", {
          "keyword-name": testNameLike,
          documentation: docTag,
          property: testPropertyLike
        }),
        tasks: createSection("Tasks", {
          "task-name": testNameLike,
          documentation: docTag,
          property: testPropertyLike
        }),
        comment
      };
      Prism2.languages.robot = Prism2.languages["robotframework"];
    })(Prism);
  }
  return robotframework_1;
}
var rust_1;
var hasRequiredRust;
function requireRust() {
  if (hasRequiredRust) return rust_1;
  hasRequiredRust = 1;
  rust_1 = rust;
  rust.displayName = "rust";
  rust.aliases = [];
  function rust(Prism) {
    (function(Prism2) {
      var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
      for (var i2 = 0; i2 < 2; i2++) {
        multilineComment = multilineComment.replace(/<self>/g, function() {
          return multilineComment;
        });
      }
      multilineComment = multilineComment.replace(/<self>/g, function() {
        return /[^\s\S]/.source;
      });
      Prism2.languages.rust = {
        comment: [
          {
            pattern: RegExp(/(^|[^\\])/.source + multilineComment),
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        string: {
          pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
          greedy: true
        },
        char: {
          pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
          greedy: true
        },
        attribute: {
          pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
          greedy: true,
          alias: "attr-name",
          inside: {
            string: null
            // see below
          }
        },
        // Closure params should not be confused with bitwise OR |
        "closure-params": {
          pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
          lookbehind: true,
          greedy: true,
          inside: {
            "closure-punctuation": {
              pattern: /^\||\|$/,
              alias: "punctuation"
            },
            rest: null
            // see below
          }
        },
        "lifetime-annotation": {
          pattern: /'\w+/,
          alias: "symbol"
        },
        "fragment-specifier": {
          pattern: /(\$\w+:)[a-z]+/,
          lookbehind: true,
          alias: "punctuation"
        },
        variable: /\$\w+/,
        "function-definition": {
          pattern: /(\bfn\s+)\w+/,
          lookbehind: true,
          alias: "function"
        },
        "type-definition": {
          pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
          lookbehind: true,
          alias: "class-name"
        },
        "module-declaration": [
          {
            pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
            lookbehind: true,
            alias: "namespace"
          },
          {
            pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
            lookbehind: true,
            alias: "namespace",
            inside: {
              punctuation: /::/
            }
          }
        ],
        keyword: [
          // https://github.com/rust-lang/reference/blob/master/src/keywords.md
          /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
          // primitives and str
          // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
          /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
        ],
        // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
        // and Rust's naming conventions recommend snake_case anyway.
        // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
        function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
        macro: {
          pattern: /\b\w+!/,
          alias: "property"
        },
        constant: /\b[A-Z_][A-Z_\d]+\b/,
        "class-name": /\b[A-Z]\w*\b/,
        namespace: {
          pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
          inside: {
            punctuation: /::/
          }
        },
        // Hex, oct, bin, dec numbers with visual separators and type suffix
        number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
        boolean: /\b(?:false|true)\b/,
        punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
        operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
      };
      Prism2.languages.rust["closure-params"].inside.rest = Prism2.languages.rust;
      Prism2.languages.rust["attribute"].inside["string"] = Prism2.languages.rust["string"];
    })(Prism);
  }
  return rust_1;
}
var sas_1;
var hasRequiredSas;
function requireSas() {
  if (hasRequiredSas) return sas_1;
  hasRequiredSas = 1;
  sas_1 = sas;
  sas.displayName = "sas";
  sas.aliases = [];
  function sas(Prism) {
    (function(Prism2) {
      var stringPattern = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source;
      var number2 = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i;
      var numericConstant = {
        pattern: RegExp(stringPattern + "[bx]"),
        alias: "number"
      };
      var macroVariable = {
        pattern: /&[a-z_]\w*/i
      };
      var macroKeyword = {
        pattern: /((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
        lookbehind: true,
        alias: "keyword"
      };
      var step = {
        pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
        alias: "keyword",
        lookbehind: true
      };
      var comment = [
        /\/\*[\s\S]*?\*\//,
        {
          pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
          lookbehind: true
        }
      ];
      var string = {
        pattern: RegExp(stringPattern),
        greedy: true
      };
      var punctuation = /[$%@.(){}\[\];,\\]/;
      var func = {
        pattern: /%?\b\w+(?=\()/,
        alias: "keyword"
      };
      var args = {
        function: func,
        "arg-value": {
          pattern: /(=\s*)[A-Z\.]+/i,
          lookbehind: true
        },
        operator: /=/,
        "macro-variable": macroVariable,
        arg: {
          pattern: /[A-Z]+/i,
          alias: "keyword"
        },
        number: number2,
        "numeric-constant": numericConstant,
        punctuation,
        string
      };
      var format2 = {
        pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
        inside: {
          keyword: /^(?:format|put)(?==)/i,
          equals: /=/,
          format: {
            pattern: /(?:\w|\$\d)+\.\d?/,
            alias: "number"
          }
        }
      };
      var altformat = {
        pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
        inside: {
          keyword: /^(?:format|put)/i,
          format: {
            pattern: /[\w$]+\.\d?/,
            alias: "number"
          }
        }
      };
      var globalStatements = {
        pattern: /((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
        lookbehind: true,
        alias: "keyword"
      };
      var submitStatement = {
        pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
        lookbehind: true,
        alias: "keyword"
      };
      var actionSets = /aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/.source;
      var casActions = {
        pattern: RegExp(
          /(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(
            /<act>/g,
            function() {
              return actionSets;
            }
          ),
          "i"
        ),
        lookbehind: true,
        inside: {
          keyword: RegExp(
            /(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function() {
              return actionSets;
            }),
            "i"
          ),
          action: {
            pattern: /(?:action)/i,
            alias: "keyword"
          },
          comment,
          function: func,
          "arg-value": args["arg-value"],
          operator: args.operator,
          argument: args.arg,
          number: number2,
          "numeric-constant": numericConstant,
          punctuation,
          string
        }
      };
      var keywords = {
        pattern: /((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
        lookbehind: true
      };
      Prism2.languages.sas = {
        datalines: {
          pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
          lookbehind: true,
          alias: "string",
          inside: {
            keyword: {
              pattern: /^(?:cards|(?:data)?lines)/i
            },
            punctuation: /;/
          }
        },
        "proc-sql": {
          pattern: /(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: true,
          inside: {
            sql: {
              pattern: RegExp(
                /^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(
                  /<str>/g,
                  function() {
                    return stringPattern;
                  }
                ),
                "im"
              ),
              alias: "language-sql",
              inside: Prism2.languages.sql
            },
            "global-statements": globalStatements,
            "sql-statements": {
              pattern: /(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
              lookbehind: true,
              alias: "keyword"
            },
            number: number2,
            "numeric-constant": numericConstant,
            punctuation,
            string
          }
        },
        "proc-groovy": {
          pattern: /(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: true,
          inside: {
            comment,
            groovy: {
              pattern: RegExp(
                /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
                  /<str>/g,
                  function() {
                    return stringPattern;
                  }
                ),
                "im"
              ),
              lookbehind: true,
              alias: "language-groovy",
              inside: Prism2.languages.groovy
            },
            keyword: keywords,
            "submit-statement": submitStatement,
            "global-statements": globalStatements,
            number: number2,
            "numeric-constant": numericConstant,
            punctuation,
            string
          }
        },
        "proc-lua": {
          pattern: /(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
          lookbehind: true,
          inside: {
            comment,
            lua: {
              pattern: RegExp(
                /(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
                  /<str>/g,
                  function() {
                    return stringPattern;
                  }
                ),
                "im"
              ),
              lookbehind: true,
              alias: "language-lua",
              inside: Prism2.languages.lua
            },
            keyword: keywords,
            "submit-statement": submitStatement,
            "global-statements": globalStatements,
            number: number2,
            "numeric-constant": numericConstant,
            punctuation,
            string
          }
        },
        "proc-cas": {
          pattern: /(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
          lookbehind: true,
          inside: {
            comment,
            "statement-var": {
              pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
              lookbehind: true,
              inside: {
                statement: {
                  pattern: /^saveresult\s+\S+/i,
                  inside: {
                    keyword: /^(?:saveresult)/i
                  }
                },
                rest: args
              }
            },
            "cas-actions": casActions,
            statement: {
              pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
              lookbehind: true,
              inside: args
            },
            step,
            keyword: keywords,
            function: func,
            format: format2,
            altformat,
            "global-statements": globalStatements,
            number: number2,
            "numeric-constant": numericConstant,
            punctuation,
            string
          }
        },
        "proc-args": {
          pattern: RegExp(
            /(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(
              /<str>/g,
              function() {
                return stringPattern;
              }
            ),
            "im"
          ),
          lookbehind: true,
          inside: args
        },
        /*Special keywords within macros*/
        "macro-keyword": macroKeyword,
        "macro-variable": macroVariable,
        "macro-string-functions": {
          pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
          lookbehind: true,
          inside: {
            function: {
              pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
              alias: "keyword"
            },
            "macro-keyword": macroKeyword,
            "macro-variable": macroVariable,
            "escaped-char": {
              pattern: /%['"()<>=¬^~;,#]/
            },
            punctuation
          }
        },
        "macro-declaration": {
          pattern: /^%macro[^;]+(?=;)/im,
          inside: {
            keyword: /%macro/i
          }
        },
        "macro-end": {
          pattern: /^%mend[^;]+(?=;)/im,
          inside: {
            keyword: /%mend/i
          }
        },
        /*%_zscore(headcir, _lhc, _mhc, _shc, headcz, headcpct, _Fheadcz); */
        macro: {
          pattern: /%_\w+(?=\()/,
          alias: "keyword"
        },
        input: {
          pattern: /\binput\s[-\w\s/*.$&]+;/i,
          inside: {
            input: {
              alias: "keyword",
              pattern: /^input/i
            },
            comment,
            number: number2,
            "numeric-constant": numericConstant
          }
        },
        "options-args": {
          pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
          lookbehind: true,
          inside: args
        },
        "cas-actions": casActions,
        comment,
        function: func,
        format: format2,
        altformat,
        "numeric-constant": numericConstant,
        datetime: {
          // '1jan2013'd, '9:25:19pm't, '18jan2003:9:27:05am'dt
          pattern: RegExp(stringPattern + "(?:dt?|t)"),
          alias: "number"
        },
        string,
        step,
        keyword: keywords,
        // In SAS Studio syntax highlighting, these operators are styled like keywords
        "operator-keyword": {
          pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
          alias: "operator"
        },
        // Decimal (1.2e23), hexadecimal (0c1x)
        number: number2,
        operator: /\*\*?|\|\|?|!!?|¦¦?|<[>=]?|>[<=]?|[-+\/=&]|[~¬^]=?/,
        punctuation
      };
    })(Prism);
  }
  return sas_1;
}
var sass_1;
var hasRequiredSass;
function requireSass() {
  if (hasRequiredSass) return sass_1;
  hasRequiredSass = 1;
  sass_1 = sass;
  sass.displayName = "sass";
  sass.aliases = [];
  function sass(Prism) {
    (function(Prism2) {
      Prism2.languages.sass = Prism2.languages.extend("css", {
        // Sass comments don't need to be closed, only indented
        comment: {
          pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
          lookbehind: true,
          greedy: true
        }
      });
      Prism2.languages.insertBefore("sass", "atrule", {
        // We want to consume the whole line
        "atrule-line": {
          // Includes support for = and + shortcuts
          pattern: /^(?:[ \t]*)[@+=].+/m,
          greedy: true,
          inside: {
            atrule: /(?:@[\w-]+|[+=])/
          }
        }
      });
      delete Prism2.languages.sass.atrule;
      var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
      var operator = [
        /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
        {
          pattern: /(\s)-(?=\s)/,
          lookbehind: true
        }
      ];
      Prism2.languages.insertBefore("sass", "property", {
        // We want to consume the whole line
        "variable-line": {
          pattern: /^[ \t]*\$.+/m,
          greedy: true,
          inside: {
            punctuation: /:/,
            variable,
            operator
          }
        },
        // We want to consume the whole line
        "property-line": {
          pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
          greedy: true,
          inside: {
            property: [
              /[^:\s]+(?=\s*:)/,
              {
                pattern: /(:)[^:\s]+/,
                lookbehind: true
              }
            ],
            punctuation: /:/,
            variable,
            operator,
            important: Prism2.languages.sass.important
          }
        }
      });
      delete Prism2.languages.sass.property;
      delete Prism2.languages.sass.important;
      Prism2.languages.insertBefore("sass", "punctuation", {
        selector: {
          pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
          lookbehind: true,
          greedy: true
        }
      });
    })(Prism);
  }
  return sass_1;
}
var scala_1;
var hasRequiredScala;
function requireScala() {
  if (hasRequiredScala) return scala_1;
  hasRequiredScala = 1;
  var refractorJava = requireJava();
  scala_1 = scala;
  scala.displayName = "scala";
  scala.aliases = [];
  function scala(Prism) {
    Prism.register(refractorJava);
    Prism.languages.scala = Prism.languages.extend("java", {
      "triple-quoted-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: true,
        alias: "string"
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      keyword: /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
      number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
      builtin: /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
      symbol: /'[^\d\s\\]\w*/
    });
    Prism.languages.insertBefore("scala", "triple-quoted-string", {
      "string-interpolation": {
        pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
        greedy: true,
        inside: {
          id: {
            pattern: /^\w+/,
            greedy: true,
            alias: "function"
          },
          escape: {
            pattern: /\\\$"|\$[$"]/,
            greedy: true,
            alias: "symbol"
          },
          interpolation: {
            pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
            greedy: true,
            inside: {
              punctuation: /^\$\{?|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                inside: Prism.languages.scala
              }
            }
          },
          string: /[\s\S]+/
        }
      }
    });
    delete Prism.languages.scala["class-name"];
    delete Prism.languages.scala["function"];
  }
  return scala_1;
}
var scss_1;
var hasRequiredScss;
function requireScss() {
  if (hasRequiredScss) return scss_1;
  hasRequiredScss = 1;
  scss_1 = scss;
  scss.displayName = "scss";
  scss.aliases = [];
  function scss(Prism) {
    Prism.languages.scss = Prism.languages.extend("css", {
      comment: {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: true
      },
      atrule: {
        pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
        inside: {
          rule: /@[\w-]+/
          // See rest below
        }
      },
      // url, compassified
      url: /(?:[-a-z]+-)?url(?=\()/i,
      // CSS selector regex is not appropriate for Sass
      // since there can be lot more things (var, @ directive, nesting..)
      // a selector must start at the end of a property or after a brace (end of other rules or nesting)
      // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
      // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
      // can "pass" as a selector- e.g: proper#{$erty})
      // this one was hard to do, so please be careful if you edit this one :)
      selector: {
        // Initial look-ahead is used to prevent matching of blank selectors
        pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
        inside: {
          parent: {
            pattern: /&/,
            alias: "important"
          },
          placeholder: /%[-\w]+/,
          variable: /\$[-\w]+|#\{\$[-\w]+\}/
        }
      },
      property: {
        pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
        inside: {
          variable: /\$[-\w]+|#\{\$[-\w]+\}/
        }
      }
    });
    Prism.languages.insertBefore("scss", "atrule", {
      keyword: [
        /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
        {
          pattern: /( )(?:from|through)(?= )/,
          lookbehind: true
        }
      ]
    });
    Prism.languages.insertBefore("scss", "important", {
      // var and interpolated vars
      variable: /\$[-\w]+|#\{\$[-\w]+\}/
    });
    Prism.languages.insertBefore("scss", "function", {
      "module-modifier": {
        pattern: /\b(?:as|hide|show|with)\b/i,
        alias: "keyword"
      },
      placeholder: {
        pattern: /%[-\w]+/,
        alias: "selector"
      },
      statement: {
        pattern: /\B!(?:default|optional)\b/i,
        alias: "keyword"
      },
      boolean: /\b(?:false|true)\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      },
      operator: {
        pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
        lookbehind: true
      }
    });
    Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;
  }
  return scss_1;
}
var shellSession_1;
var hasRequiredShellSession;
function requireShellSession() {
  if (hasRequiredShellSession) return shellSession_1;
  hasRequiredShellSession = 1;
  var refractorBash = requireBash();
  shellSession_1 = shellSession;
  shellSession.displayName = "shellSession";
  shellSession.aliases = [];
  function shellSession(Prism) {
    Prism.register(refractorBash);
    (function(Prism2) {
      var strings = [
        // normal string
        /"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
        /'[^']*'/.source,
        /\$'(?:[^'\\]|\\[\s\S])*'/.source,
        // here doc
        // 2 capturing groups
        /<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
      ].join("|");
      Prism2.languages["shell-session"] = {
        command: {
          pattern: RegExp(
            // user info
            /^/.source + "(?:" + // <user> ":" ( <path> )?
            (/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source + "|" + // <path>
            // Since the path pattern is quite general, we will require it to start with a special character to
            // prevent false positives.
            /[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) + ")?" + // shell symbol
            /[$#%](?=\s)/.source + // bash command
            /(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(
              /<<str>>/g,
              function() {
                return strings;
              }
            ),
            "m"
          ),
          greedy: true,
          inside: {
            info: {
              // foo@bar:~/files$ exit
              // foo@bar$ exit
              // ~/files$ exit
              pattern: /^[^#$%]+/,
              alias: "punctuation",
              inside: {
                user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
                punctuation: /:/,
                path: /[\s\S]+/
              }
            },
            bash: {
              pattern: /(^[$#%]\s*)\S[\s\S]*/,
              lookbehind: true,
              alias: "language-bash",
              inside: Prism2.languages.bash
            },
            "shell-symbol": {
              pattern: /^[$#%]/,
              alias: "important"
            }
          }
        },
        output: /.(?:.*(?:[\r\n]|.$))*/
      };
      Prism2.languages["sh-session"] = Prism2.languages["shellsession"] = Prism2.languages["shell-session"];
    })(Prism);
  }
  return shellSession_1;
}
var smali_1;
var hasRequiredSmali;
function requireSmali() {
  if (hasRequiredSmali) return smali_1;
  hasRequiredSmali = 1;
  smali_1 = smali;
  smali.displayName = "smali";
  smali.aliases = [];
  function smali(Prism) {
    Prism.languages.smali = {
      comment: /#.*/,
      string: {
        pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
        greedy: true
      },
      "class-name": {
        pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
        lookbehind: true,
        inside: {
          "class-name": {
            pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
            lookbehind: true
          },
          namespace: {
            pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
            lookbehind: true,
            inside: {
              punctuation: /\//
            }
          },
          builtin: /^L/
        }
      },
      builtin: [
        {
          // Reference: https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields#types
          pattern: /([();\[])[BCDFIJSVZ]+/,
          lookbehind: true
        },
        {
          // e.g. .field mWifiOnUid:I
          pattern: /([\w$>]:)[BCDFIJSVZ]/,
          lookbehind: true
        }
      ],
      keyword: [
        {
          pattern: /(\.end\s+)[\w-]+/,
          lookbehind: true
        },
        {
          pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
          lookbehind: true
        },
        {
          pattern: /(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
          lookbehind: true
        }
      ],
      function: {
        pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
        lookbehind: true
      },
      field: {
        pattern: /[\w$]+(?=:)/,
        alias: "variable"
      },
      register: {
        pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
        lookbehind: true,
        alias: "variable"
      },
      boolean: {
        pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
        lookbehind: true
      },
      number: {
        pattern: /(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
        lookbehind: true
      },
      label: {
        pattern: /(:)\w+/,
        lookbehind: true,
        alias: "property"
      },
      operator: /->|\.\.|[\[=]/,
      punctuation: /[{}(),;:]/
    };
  }
  return smali_1;
}
var smalltalk_1;
var hasRequiredSmalltalk;
function requireSmalltalk() {
  if (hasRequiredSmalltalk) return smalltalk_1;
  hasRequiredSmalltalk = 1;
  smalltalk_1 = smalltalk;
  smalltalk.displayName = "smalltalk";
  smalltalk.aliases = [];
  function smalltalk(Prism) {
    Prism.languages.smalltalk = {
      comment: {
        pattern: /"(?:""|[^"])*"/,
        greedy: true
      },
      char: {
        pattern: /\$./,
        greedy: true
      },
      string: {
        pattern: /'(?:''|[^'])*'/,
        greedy: true
      },
      symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
      "block-arguments": {
        pattern: /(\[\s*):[^\[|]*\|/,
        lookbehind: true,
        inside: {
          variable: /:[\da-z]+/i,
          punctuation: /\|/
        }
      },
      "temporary-variables": {
        pattern: /\|[^|]+\|/,
        inside: {
          variable: /[\da-z]+/i,
          punctuation: /\|/
        }
      },
      keyword: /\b(?:new|nil|self|super)\b/,
      boolean: /\b(?:false|true)\b/,
      number: [
        /\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/,
        /\b\d+(?:\.\d+)?(?:e-?\d+)?/
      ],
      operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
      punctuation: /[.;:?\[\](){}]/
    };
  }
  return smalltalk_1;
}
var smarty_1;
var hasRequiredSmarty;
function requireSmarty() {
  if (hasRequiredSmarty) return smarty_1;
  hasRequiredSmarty = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  smarty_1 = smarty;
  smarty.displayName = "smarty";
  smarty.aliases = [];
  function smarty(Prism) {
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      Prism2.languages.smarty = {
        comment: {
          pattern: /^\{\*[\s\S]*?\*\}/,
          greedy: true
        },
        "embedded-php": {
          pattern: /^\{php\}[\s\S]*?\{\/php\}/,
          greedy: true,
          inside: {
            smarty: {
              pattern: /^\{php\}|\{\/php\}$/,
              inside: null
              // see below
            },
            php: {
              pattern: /[\s\S]+/,
              alias: "language-php",
              inside: Prism2.languages.php
            }
          }
        },
        string: [
          {
            pattern: /"(?:\\.|[^"\\\r\n])*"/,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /\{[^{}]*\}|`[^`]*`/,
                inside: {
                  "interpolation-punctuation": {
                    pattern: /^[{`]|[`}]$/,
                    alias: "punctuation"
                  },
                  expression: {
                    pattern: /[\s\S]+/,
                    inside: null
                    // see below
                  }
                }
              },
              variable: /\$\w+/
            }
          },
          {
            pattern: /'(?:\\.|[^'\\\r\n])*'/,
            greedy: true
          }
        ],
        keyword: {
          pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
          lookbehind: true,
          greedy: true
        },
        delimiter: {
          pattern: /^\{\/?|\}$/,
          greedy: true,
          alias: "punctuation"
        },
        number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
        variable: [
          /\$(?!\d)\w+/,
          /#(?!\d)\w+#/,
          {
            pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
            lookbehind: true
          },
          {
            pattern: /(\[)(?!\d)\w+(?=\])/,
            lookbehind: true
          }
        ],
        function: {
          pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
          lookbehind: true
        },
        "attr-name": /\b[a-z_]\w*(?=\s*=)/i,
        boolean: /\b(?:false|no|off|on|true|yes)\b/,
        punctuation: /[\[\](){}.,:`]|->/,
        operator: [
          /[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
          /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
          /\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
        ]
      };
      Prism2.languages.smarty["embedded-php"].inside.smarty.inside = Prism2.languages.smarty;
      Prism2.languages.smarty.string[0].inside.interpolation.inside.expression.inside = Prism2.languages.smarty;
      var string = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/;
      var smartyPattern = RegExp(
        // comments
        /\{\*[\s\S]*?\*\}/.source + "|" + // php tags
        /\{php\}[\s\S]*?\{\/php\}/.source + "|" + // smarty blocks
        /\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(
          /<str>/g,
          function() {
            return string.source;
          }
        ),
        "g"
      );
      Prism2.hooks.add("before-tokenize", function(env) {
        var smartyLiteralStart = "{literal}";
        var smartyLiteralEnd = "{/literal}";
        var smartyLiteralMode = false;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "smarty",
          smartyPattern,
          function(match2) {
            if (match2 === smartyLiteralEnd) {
              smartyLiteralMode = false;
            }
            if (!smartyLiteralMode) {
              if (match2 === smartyLiteralStart) {
                smartyLiteralMode = true;
              }
              return true;
            }
            return false;
          }
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "smarty");
      });
    })(Prism);
  }
  return smarty_1;
}
var sml_1;
var hasRequiredSml;
function requireSml() {
  if (hasRequiredSml) return sml_1;
  hasRequiredSml = 1;
  sml_1 = sml;
  sml.displayName = "sml";
  sml.aliases = ["smlnj"];
  function sml(Prism) {
    (function(Prism2) {
      var keywords = /\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
      Prism2.languages.sml = {
        // allow one level of nesting
        comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
        string: {
          pattern: /#?"(?:[^"\\]|\\.)*"/,
          greedy: true
        },
        "class-name": [
          {
            // This is only an approximation since the real grammar is context-free
            //
            // Why the main loop so complex?
            // The main loop is approximately the same as /(?:\s*(?:[*,]|->)\s*<TERMINAL>)*/ which is, obviously, a lot
            // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be
            // followed by a long identifier.
            pattern: RegExp(
              /((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function() {
                return /\s*(?:[*,]|->)/.source;
              }).replace(/<TERMINAL>/g, function() {
                return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/.source;
              }).replace(/<LONG-ID>/g, function() {
                return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
              }).replace(/<KEYWORD>/g, function() {
                return keywords.source;
              }),
              "i"
            ),
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          {
            pattern: /((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
            lookbehind: true
          }
        ],
        function: {
          pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
          lookbehind: true
        },
        keyword: keywords,
        variable: {
          pattern: /(^|[^\w'])'[\w']*/,
          lookbehind: true
        },
        number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
        word: {
          pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
          alias: "constant"
        },
        boolean: /\b(?:false|true)\b/i,
        operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
        punctuation: /[(){}\[\].:,;]/
      };
      Prism2.languages.sml["class-name"][0].inside = Prism2.languages.sml;
      Prism2.languages.smlnj = Prism2.languages.sml;
    })(Prism);
  }
  return sml_1;
}
var solidity_1;
var hasRequiredSolidity;
function requireSolidity() {
  if (hasRequiredSolidity) return solidity_1;
  hasRequiredSolidity = 1;
  solidity_1 = solidity;
  solidity.displayName = "solidity";
  solidity.aliases = ["sol"];
  function solidity(Prism) {
    Prism.languages.solidity = Prism.languages.extend("clike", {
      "class-name": {
        pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
        lookbehind: true
      },
      keyword: /\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
      operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
    });
    Prism.languages.insertBefore("solidity", "keyword", {
      builtin: /\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
    });
    Prism.languages.insertBefore("solidity", "number", {
      version: {
        pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
        lookbehind: true,
        alias: "number"
      }
    });
    Prism.languages.sol = Prism.languages.solidity;
  }
  return solidity_1;
}
var solutionFile_1;
var hasRequiredSolutionFile;
function requireSolutionFile() {
  if (hasRequiredSolutionFile) return solutionFile_1;
  hasRequiredSolutionFile = 1;
  solutionFile_1 = solutionFile;
  solutionFile.displayName = "solutionFile";
  solutionFile.aliases = [];
  function solutionFile(Prism) {
    (function(Prism2) {
      var guid = {
        // https://en.wikipedia.org/wiki/Universally_unique_identifier#Format
        pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
        alias: "constant",
        inside: {
          punctuation: /[{}]/
        }
      };
      Prism2.languages["solution-file"] = {
        comment: {
          pattern: /#.*/,
          greedy: true
        },
        string: {
          pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
          greedy: true,
          inside: {
            guid
          }
        },
        object: {
          // Foo
          //   Bar("abs") = 9
          //   EndBar
          //   Prop = TRUE
          // EndFoo
          pattern: /^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
          lookbehind: true,
          greedy: true,
          alias: "keyword"
        },
        property: {
          pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
          lookbehind: true,
          inside: {
            guid
          }
        },
        guid,
        number: /\b\d+(?:\.\d+)*\b/,
        boolean: /\b(?:FALSE|TRUE)\b/,
        operator: /=/,
        punctuation: /[(),]/
      };
      Prism2.languages["sln"] = Prism2.languages["solution-file"];
    })(Prism);
  }
  return solutionFile_1;
}
var soy_1;
var hasRequiredSoy;
function requireSoy() {
  if (hasRequiredSoy) return soy_1;
  hasRequiredSoy = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  soy_1 = soy;
  soy.displayName = "soy";
  soy.aliases = [];
  function soy(Prism) {
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      var stringPattern = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
      var numberPattern = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
      Prism2.languages.soy = {
        comment: [
          /\/\*[\s\S]*?\*\//,
          {
            pattern: /(\s)\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        "command-arg": {
          pattern: /(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
          lookbehind: true,
          alias: "string",
          inside: {
            punctuation: /\./
          }
        },
        parameter: {
          pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
          lookbehind: true,
          alias: "variable"
        },
        keyword: [
          {
            pattern: /(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
            lookbehind: true
          },
          /\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/
        ],
        delimiter: {
          pattern: /^\{+\/?|\/?\}+$/,
          alias: "punctuation"
        },
        property: /\w+(?==)/,
        variable: {
          pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
          inside: {
            string: {
              pattern: stringPattern,
              greedy: true
            },
            number: numberPattern,
            punctuation: /[\[\].?]/
          }
        },
        string: {
          pattern: stringPattern,
          greedy: true
        },
        function: [
          /\w+(?=\()/,
          {
            pattern: /(\|[^\S\r\n]*)\w+/,
            lookbehind: true
          }
        ],
        boolean: /\b(?:false|true)\b/,
        number: numberPattern,
        operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
        punctuation: /[{}()\[\]|.,:]/
      };
      Prism2.hooks.add("before-tokenize", function(env) {
        var soyPattern = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g;
        var soyLitteralStart = "{literal}";
        var soyLitteralEnd = "{/literal}";
        var soyLitteralMode = false;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "soy",
          soyPattern,
          function(match2) {
            if (match2 === soyLitteralEnd) {
              soyLitteralMode = false;
            }
            if (!soyLitteralMode) {
              if (match2 === soyLitteralStart) {
                soyLitteralMode = true;
              }
              return true;
            }
            return false;
          }
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "soy");
      });
    })(Prism);
  }
  return soy_1;
}
var turtle_1;
var hasRequiredTurtle;
function requireTurtle() {
  if (hasRequiredTurtle) return turtle_1;
  hasRequiredTurtle = 1;
  turtle_1 = turtle;
  turtle.displayName = "turtle";
  turtle.aliases = [];
  function turtle(Prism) {
    Prism.languages.turtle = {
      comment: {
        pattern: /#.*/,
        greedy: true
      },
      "multiline-string": {
        pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
        greedy: true,
        alias: "string",
        inside: {
          comment: /#.*/
        }
      },
      string: {
        pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
        greedy: true
      },
      url: {
        pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
        greedy: true,
        inside: {
          punctuation: /[<>]/
        }
      },
      function: {
        pattern: /(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
        inside: {
          "local-name": {
            pattern: /([^:]*:)[\s\S]+/,
            lookbehind: true
          },
          prefix: {
            pattern: /[\s\S]+/,
            inside: {
              punctuation: /:/
            }
          }
        }
      },
      number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
      punctuation: /[{}.,;()[\]]|\^\^/,
      boolean: /\b(?:false|true)\b/,
      keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
      tag: {
        pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
        inside: {
          punctuation: /@/
        }
      }
    };
    Prism.languages.trig = Prism.languages["turtle"];
  }
  return turtle_1;
}
var sparql_1;
var hasRequiredSparql;
function requireSparql() {
  if (hasRequiredSparql) return sparql_1;
  hasRequiredSparql = 1;
  var refractorTurtle = requireTurtle();
  sparql_1 = sparql;
  sparql.displayName = "sparql";
  sparql.aliases = ["rq"];
  function sparql(Prism) {
    Prism.register(refractorTurtle);
    Prism.languages.sparql = Prism.languages.extend("turtle", {
      boolean: /\b(?:false|true)\b/i,
      variable: {
        pattern: /[?$]\w+/,
        greedy: true
      }
    });
    Prism.languages.insertBefore("sparql", "punctuation", {
      keyword: [
        /\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
        /\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
        /\b(?:BASE|GRAPH|PREFIX)\b/i
      ]
    });
    Prism.languages.rq = Prism.languages.sparql;
  }
  return sparql_1;
}
var splunkSpl_1;
var hasRequiredSplunkSpl;
function requireSplunkSpl() {
  if (hasRequiredSplunkSpl) return splunkSpl_1;
  hasRequiredSplunkSpl = 1;
  splunkSpl_1 = splunkSpl;
  splunkSpl.displayName = "splunkSpl";
  splunkSpl.aliases = [];
  function splunkSpl(Prism) {
    Prism.languages["splunk-spl"] = {
      comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
      string: {
        pattern: /"(?:\\.|[^\\"])*"/,
        greedy: true
      },
      // https://docs.splunk.com/Documentation/Splunk/7.3.0/SearchReference/ListOfSearchCommands
      keyword: /\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
      "operator-word": {
        pattern: /\b(?:and|as|by|not|or|xor)\b/i,
        alias: "operator"
      },
      function: /\b\w+(?=\s*\()/,
      property: /\b\w+(?=\s*=(?!=))/,
      date: {
        // MM/DD/YYYY(:HH:MM:SS)?
        pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
        alias: "number"
      },
      number: /\b\d+(?:\.\d+)?\b/,
      boolean: /\b(?:f|false|t|true)\b/i,
      operator: /[<>=]=?|[-+*/%|]/,
      punctuation: /[()[\],]/
    };
  }
  return splunkSpl_1;
}
var sqf_1;
var hasRequiredSqf;
function requireSqf() {
  if (hasRequiredSqf) return sqf_1;
  hasRequiredSqf = 1;
  sqf_1 = sqf;
  sqf.displayName = "sqf";
  sqf.aliases = [];
  function sqf(Prism) {
    Prism.languages.sqf = Prism.languages.extend("clike", {
      string: {
        pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
        greedy: true
      },
      keyword: /\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
      number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
      operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
      "magic-variable": {
        pattern: /\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
        alias: "keyword"
      },
      constant: /\bDIK(?:_[a-z\d]+)+\b/i
    });
    Prism.languages.insertBefore("sqf", "string", {
      macro: {
        pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: true,
        greedy: true,
        alias: "property",
        inside: {
          directive: {
            pattern: /#[a-z]+\b/i,
            alias: "keyword"
          },
          comment: Prism.languages.sqf.comment
        }
      }
    });
    delete Prism.languages.sqf["class-name"];
  }
  return sqf_1;
}
var squirrel_1;
var hasRequiredSquirrel;
function requireSquirrel() {
  if (hasRequiredSquirrel) return squirrel_1;
  hasRequiredSquirrel = 1;
  squirrel_1 = squirrel;
  squirrel.displayName = "squirrel";
  squirrel.aliases = [];
  function squirrel(Prism) {
    Prism.languages.squirrel = Prism.languages.extend("clike", {
      comment: [
        Prism.languages.clike["comment"][0],
        {
          pattern: /(^|[^\\:])(?:\/\/|#).*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
        lookbehind: true,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
        lookbehind: true,
        inside: {
          punctuation: /\./
        }
      },
      keyword: /\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
      number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
      operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
      punctuation: /[(){}\[\],;.]/
    });
    Prism.languages.insertBefore("squirrel", "string", {
      char: {
        pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
        lookbehind: true,
        greedy: true
      }
    });
    Prism.languages.insertBefore("squirrel", "operator", {
      "attribute-punctuation": {
        pattern: /<\/|\/>/,
        alias: "important"
      },
      lambda: {
        pattern: /@(?=\()/,
        alias: "operator"
      }
    });
  }
  return squirrel_1;
}
var stan_1;
var hasRequiredStan;
function requireStan() {
  if (hasRequiredStan) return stan_1;
  hasRequiredStan = 1;
  stan_1 = stan;
  stan.displayName = "stan";
  stan.aliases = [];
  function stan(Prism) {
    (function(Prism2) {
      var higherOrderFunctions = /\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
      Prism2.languages.stan = {
        comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
        string: {
          // String literals can contain spaces and any printable ASCII characters except for " and \
          // https://mc-stan.org/docs/2_24/reference-manual/print-statements-section.html#string-literals
          pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
          greedy: true
        },
        directive: {
          pattern: /^([ \t]*)#include\b.*/m,
          lookbehind: true,
          alias: "property"
        },
        "function-arg": {
          pattern: RegExp(
            "(" + higherOrderFunctions.source + /\s*\(\s*/.source + ")" + /[a-zA-Z]\w*/.source
          ),
          lookbehind: true,
          alias: "function"
        },
        constraint: {
          pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
          lookbehind: true,
          inside: {
            expression: {
              pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
              lookbehind: true,
              inside: null
              // see below
            },
            property: /\b[a-z]\w*(?=\s*=)/i,
            operator: /=/,
            punctuation: /^<|>$|,/
          }
        },
        keyword: [
          {
            pattern: /\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
            alias: "program-block"
          },
          /\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
          // these are functions that are known to take another function as their first argument.
          higherOrderFunctions
        ],
        function: /\b[a-z]\w*(?=\s*\()/i,
        number: /(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
        boolean: /\b(?:false|true)\b/,
        operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
        punctuation: /[()\[\]{},;]/
      };
      Prism2.languages.stan.constraint.inside.expression.inside = Prism2.languages.stan;
    })(Prism);
  }
  return stan_1;
}
var stylus_1;
var hasRequiredStylus;
function requireStylus() {
  if (hasRequiredStylus) return stylus_1;
  hasRequiredStylus = 1;
  stylus_1 = stylus;
  stylus.displayName = "stylus";
  stylus.aliases = [];
  function stylus(Prism) {
    (function(Prism2) {
      var unit = {
        pattern: /(\b\d+)(?:%|[a-z]+)/,
        lookbehind: true
      };
      var number2 = {
        pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
        lookbehind: true
      };
      var inside = {
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
          lookbehind: true
        },
        url: {
          pattern: /\burl\((["']?).*?\1\)/i,
          greedy: true
        },
        string: {
          pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
          greedy: true
        },
        interpolation: null,
        // See below
        func: null,
        // See below
        important: /\B!(?:important|optional)\b/i,
        keyword: {
          pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
          lookbehind: true
        },
        hexcode: /#[\da-f]{3,6}/i,
        color: [
          /\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
          {
            pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
            inside: {
              unit,
              number: number2,
              function: /[\w-]+(?=\()/,
              punctuation: /[(),]/
            }
          }
        ],
        entity: /\\[\da-f]{1,8}/i,
        unit,
        boolean: /\b(?:false|true)\b/,
        operator: [
          // We want non-word chars around "-" because it is
          // accepted in property names.
          /~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
        ],
        number: number2,
        punctuation: /[{}()\[\];:,]/
      };
      inside["interpolation"] = {
        pattern: /\{[^\r\n}:]+\}/,
        alias: "variable",
        inside: {
          delimiter: {
            pattern: /^\{|\}$/,
            alias: "punctuation"
          },
          rest: inside
        }
      };
      inside["func"] = {
        pattern: /[\w-]+\([^)]*\).*/,
        inside: {
          function: /^[^(]+/,
          rest: inside
        }
      };
      Prism2.languages.stylus = {
        "atrule-declaration": {
          pattern: /(^[ \t]*)@.+/m,
          lookbehind: true,
          inside: {
            atrule: /^@[\w-]+/,
            rest: inside
          }
        },
        "variable-declaration": {
          pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
          lookbehind: true,
          inside: {
            variable: /^\S+/,
            rest: inside
          }
        },
        statement: {
          pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
          lookbehind: true,
          inside: {
            keyword: /^\S+/,
            rest: inside
          }
        },
        // A property/value pair cannot end with a comma or a brace
        // It cannot have indented content unless it ended with a semicolon
        "property-declaration": {
          pattern: /((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
          lookbehind: true,
          inside: {
            property: {
              pattern: /^[^\s:]+/,
              inside: {
                interpolation: inside.interpolation
              }
            },
            rest: inside
          }
        },
        // A selector can contain parentheses only as part of a pseudo-element
        // It can span multiple lines.
        // It must end with a comma or an accolade or have indented content.
        selector: {
          pattern: /(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
          lookbehind: true,
          inside: {
            interpolation: inside.interpolation,
            comment: inside.comment,
            punctuation: /[{},]/
          }
        },
        func: inside.func,
        string: inside.string,
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
          lookbehind: true,
          greedy: true
        },
        interpolation: inside.interpolation,
        punctuation: /[{}()\[\];:.]/
      };
    })(Prism);
  }
  return stylus_1;
}
var swift_1;
var hasRequiredSwift;
function requireSwift() {
  if (hasRequiredSwift) return swift_1;
  hasRequiredSwift = 1;
  swift_1 = swift;
  swift.displayName = "swift";
  swift.aliases = [];
  function swift(Prism) {
    Prism.languages.swift = {
      comment: {
        // Nested comments are supported up to 2 levels
        pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
        lookbehind: true,
        greedy: true
      },
      "string-literal": [
        // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
        {
          pattern: RegExp(
            /(^|[^"#])/.source + "(?:" + // single-line string
            /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + // multi-line string
            /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            interpolation: {
              pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
              lookbehind: true,
              inside: null
              // see below
            },
            "interpolation-punctuation": {
              pattern: /^\)|\\\($/,
              alias: "punctuation"
            },
            punctuation: /\\(?=[\r\n])/,
            string: /[\s\S]+/
          }
        },
        {
          pattern: RegExp(
            /(^|[^"#])(#+)/.source + "(?:" + // single-line string
            /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + // multi-line string
            /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            interpolation: {
              pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
              lookbehind: true,
              inside: null
              // see below
            },
            "interpolation-punctuation": {
              pattern: /^\)|\\#+\($/,
              alias: "punctuation"
            },
            string: /[\s\S]+/
          }
        }
      ],
      directive: {
        // directives with conditions
        pattern: RegExp(
          /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + // This regex is a little complex. It's equivalent to this:
          //   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
          // where <round> is a general parentheses expression.
          /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
        ),
        alias: "property",
        inside: {
          "directive-name": /^#\w+/,
          boolean: /\b(?:false|true)\b/,
          number: /\b\d+(?:\.\d+)*\b/,
          operator: /!|&&|\|\||[<>]=?/,
          punctuation: /[(),]/
        }
      },
      literal: {
        pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
        alias: "constant"
      },
      "other-directive": {
        pattern: /#\w+\b/,
        alias: "property"
      },
      attribute: {
        pattern: /@\w+/,
        alias: "atrule"
      },
      "function-definition": {
        pattern: /(\bfunc\s+)\w+/,
        lookbehind: true,
        alias: "function"
      },
      label: {
        // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
        pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
        lookbehind: true,
        alias: "important"
      },
      keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
      boolean: /\b(?:false|true)\b/,
      nil: {
        pattern: /\bnil\b/,
        alias: "constant"
      },
      "short-argument": /\$\d+\b/,
      omit: {
        pattern: /\b_\b/,
        alias: "keyword"
      },
      number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
      // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
      "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
      // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
      // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
      // This regex only supports ASCII operators.
      operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
      punctuation: /[{}[\]();,.:\\]/
    };
    Prism.languages.swift["string-literal"].forEach(function(rule) {
      rule.inside["interpolation"].inside = Prism.languages.swift;
    });
  }
  return swift_1;
}
var systemd_1;
var hasRequiredSystemd;
function requireSystemd() {
  if (hasRequiredSystemd) return systemd_1;
  hasRequiredSystemd = 1;
  systemd_1 = systemd;
  systemd.displayName = "systemd";
  systemd.aliases = [];
  function systemd(Prism) {
    (function(Prism2) {
      var comment = {
        pattern: /^[;#].*/m,
        greedy: true
      };
      var quotesSource = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
      Prism2.languages.systemd = {
        comment,
        section: {
          pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
          greedy: true,
          inside: {
            punctuation: /^\[|\]$/,
            "section-name": {
              pattern: /[\s\S]+/,
              alias: "selector"
            }
          }
        },
        key: {
          pattern: /^[^\s=]+(?=[ \t]*=)/m,
          greedy: true,
          alias: "attr-name"
        },
        value: {
          // This pattern is quite complex because of two properties:
          //  1) Quotes (strings) must be preceded by a space. Since we can't use lookbehinds, we have to "resolve"
          //     the lookbehind. You will see this in the main loop where spaces are handled separately.
          //  2) Line continuations.
          //     After line continuations, empty lines and comments are ignored so we have to consume them.
          pattern: RegExp(
            /(=[ \t]*(?!\s))/.source + // the value either starts with quotes or not
            "(?:" + quotesSource + '|(?=[^"\r\n]))(?:' + (/[^\s\\]/.source + // handle spaces separately because of quotes
            '|[ 	]+(?:(?![ 	"])|' + quotesSource + ")|" + /\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) + ")*"
          ),
          lookbehind: true,
          greedy: true,
          alias: "attr-value",
          inside: {
            comment,
            quoted: {
              pattern: RegExp(/(^|\s)/.source + quotesSource),
              lookbehind: true,
              greedy: true
            },
            punctuation: /\\$/m,
            boolean: {
              pattern: /^(?:false|no|off|on|true|yes)$/,
              greedy: true
            }
          }
        },
        punctuation: /=/
      };
    })(Prism);
  }
  return systemd_1;
}
var t4Templating_1;
var hasRequiredT4Templating;
function requireT4Templating() {
  if (hasRequiredT4Templating) return t4Templating_1;
  hasRequiredT4Templating = 1;
  t4Templating_1 = t4Templating;
  t4Templating.displayName = "t4Templating";
  t4Templating.aliases = [];
  function t4Templating(Prism) {
    (function(Prism2) {
      function createBlock(prefix, inside, contentAlias) {
        return {
          pattern: RegExp("<#" + prefix + "[\\s\\S]*?#>"),
          alias: "block",
          inside: {
            delimiter: {
              pattern: RegExp("^<#" + prefix + "|#>$"),
              alias: "important"
            },
            content: {
              pattern: /[\s\S]+/,
              inside,
              alias: contentAlias
            }
          }
        };
      }
      function createT4(insideLang) {
        var grammar = Prism2.languages[insideLang];
        var className = "language-" + insideLang;
        return {
          block: {
            pattern: /<#[\s\S]+?#>/,
            inside: {
              directive: createBlock("@", {
                "attr-value": {
                  pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
                  inside: {
                    punctuation: /^=|^["']|["']$/
                  }
                },
                keyword: /\b\w+(?=\s)/,
                "attr-name": /\b\w+/
              }),
              expression: createBlock("=", grammar, className),
              "class-feature": createBlock("\\+", grammar, className),
              standard: createBlock("", grammar, className)
            }
          }
        };
      }
      Prism2.languages["t4-templating"] = Object.defineProperty({}, "createT4", {
        value: createT4
      });
    })(Prism);
  }
  return t4Templating_1;
}
var t4Cs_1;
var hasRequiredT4Cs;
function requireT4Cs() {
  if (hasRequiredT4Cs) return t4Cs_1;
  hasRequiredT4Cs = 1;
  var refractorT4Templating = requireT4Templating();
  var refractorCsharp = requireCsharp();
  t4Cs_1 = t4Cs;
  t4Cs.displayName = "t4Cs";
  t4Cs.aliases = [];
  function t4Cs(Prism) {
    Prism.register(refractorT4Templating);
    Prism.register(refractorCsharp);
    Prism.languages.t4 = Prism.languages["t4-cs"] = Prism.languages["t4-templating"].createT4("csharp");
  }
  return t4Cs_1;
}
var vbnet_1;
var hasRequiredVbnet;
function requireVbnet() {
  if (hasRequiredVbnet) return vbnet_1;
  hasRequiredVbnet = 1;
  var refractorBasic = requireBasic();
  vbnet_1 = vbnet;
  vbnet.displayName = "vbnet";
  vbnet.aliases = [];
  function vbnet(Prism) {
    Prism.register(refractorBasic);
    Prism.languages.vbnet = Prism.languages.extend("basic", {
      comment: [
        {
          pattern: /(?:!|REM\b).+/i,
          inside: {
            keyword: /^REM/i
          }
        },
        {
          pattern: /(^|[^\\:])'.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      string: {
        pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
        lookbehind: true,
        greedy: true
      },
      keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
      punctuation: /[,;:(){}]/
    });
  }
  return vbnet_1;
}
var t4Vb_1;
var hasRequiredT4Vb;
function requireT4Vb() {
  if (hasRequiredT4Vb) return t4Vb_1;
  hasRequiredT4Vb = 1;
  var refractorT4Templating = requireT4Templating();
  var refractorVbnet = requireVbnet();
  t4Vb_1 = t4Vb;
  t4Vb.displayName = "t4Vb";
  t4Vb.aliases = [];
  function t4Vb(Prism) {
    Prism.register(refractorT4Templating);
    Prism.register(refractorVbnet);
    Prism.languages["t4-vb"] = Prism.languages["t4-templating"].createT4("vbnet");
  }
  return t4Vb_1;
}
var yaml_1;
var hasRequiredYaml;
function requireYaml() {
  if (hasRequiredYaml) return yaml_1;
  hasRequiredYaml = 1;
  yaml_1 = yaml;
  yaml.displayName = "yaml";
  yaml.aliases = ["yml"];
  function yaml(Prism) {
    (function(Prism2) {
      var anchorOrAlias = /[*&][^\s[\]{},]+/;
      var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
      var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
      var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
        /<PLAIN>/g,
        function() {
          return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
        }
      );
      var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
      function createValuePattern(value, flags) {
        flags = (flags || "").replace(/m/g, "") + "m";
        var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
          return properties;
        }).replace(/<<value>>/g, function() {
          return value;
        });
        return RegExp(pattern, flags);
      }
      Prism2.languages.yaml = {
        scalar: {
          pattern: RegExp(
            /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
              /<<prop>>/g,
              function() {
                return properties;
              }
            )
          ),
          lookbehind: true,
          alias: "string"
        },
        comment: /#.*/,
        key: {
          pattern: RegExp(
            /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
              return properties;
            }).replace(/<<key>>/g, function() {
              return "(?:" + plainKey + "|" + string + ")";
            })
          ),
          lookbehind: true,
          greedy: true,
          alias: "atrule"
        },
        directive: {
          pattern: /(^[ \t]*)%.+/m,
          lookbehind: true,
          alias: "important"
        },
        datetime: {
          pattern: createValuePattern(
            /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source
          ),
          lookbehind: true,
          alias: "number"
        },
        boolean: {
          pattern: createValuePattern(/false|true/.source, "i"),
          lookbehind: true,
          alias: "important"
        },
        null: {
          pattern: createValuePattern(/null|~/.source, "i"),
          lookbehind: true,
          alias: "important"
        },
        string: {
          pattern: createValuePattern(string),
          lookbehind: true,
          greedy: true
        },
        number: {
          pattern: createValuePattern(
            /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,
            "i"
          ),
          lookbehind: true
        },
        tag,
        important: anchorOrAlias,
        punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
      };
      Prism2.languages.yml = Prism2.languages.yaml;
    })(Prism);
  }
  return yaml_1;
}
var tap_1;
var hasRequiredTap;
function requireTap() {
  if (hasRequiredTap) return tap_1;
  hasRequiredTap = 1;
  var refractorYaml = requireYaml();
  tap_1 = tap;
  tap.displayName = "tap";
  tap.aliases = [];
  function tap(Prism) {
    Prism.register(refractorYaml);
    Prism.languages.tap = {
      fail: /not ok[^#{\n\r]*/,
      pass: /ok[^#{\n\r]*/,
      pragma: /pragma [+-][a-z]+/,
      bailout: /bail out!.*/i,
      version: /TAP version \d+/i,
      plan: /\b\d+\.\.\d+(?: +#.*)?/,
      subtest: {
        pattern: /# Subtest(?:: .*)?/,
        greedy: true
      },
      punctuation: /[{}]/,
      directive: /#.*/,
      yamlish: {
        pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
        lookbehind: true,
        inside: Prism.languages.yaml,
        alias: "language-yaml"
      }
    };
  }
  return tap_1;
}
var tcl_1;
var hasRequiredTcl;
function requireTcl() {
  if (hasRequiredTcl) return tcl_1;
  hasRequiredTcl = 1;
  tcl_1 = tcl;
  tcl.displayName = "tcl";
  tcl.aliases = [];
  function tcl(Prism) {
    Prism.languages.tcl = {
      comment: {
        pattern: /(^|[^\\])#.*/,
        lookbehind: true
      },
      string: {
        pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
        greedy: true
      },
      variable: [
        {
          pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
          lookbehind: true
        },
        {
          pattern: /(\$)\{[^}]+\}/,
          lookbehind: true
        },
        {
          pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
          lookbehind: true
        }
      ],
      function: {
        pattern: /(^[\t ]*proc[ \t]+)\S+/m,
        lookbehind: true
      },
      builtin: [
        {
          pattern: /(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
          lookbehind: true
        },
        /\b(?:else|elseif)\b/
      ],
      scope: {
        pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
        lookbehind: true,
        alias: "constant"
      },
      keyword: {
        pattern: /(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
        lookbehind: true
      },
      operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
      punctuation: /[{}()\[\]]/
    };
  }
  return tcl_1;
}
var textile_1;
var hasRequiredTextile;
function requireTextile() {
  if (hasRequiredTextile) return textile_1;
  hasRequiredTextile = 1;
  textile_1 = textile;
  textile.displayName = "textile";
  textile.aliases = [];
  function textile(Prism) {
    (function(Prism2) {
      var modifierRegex = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source;
      var parenthesesRegex = /\)|\((?![^|()\n]+\))/.source;
      function withModifier(source, flags) {
        return RegExp(
          source.replace(/<MOD>/g, function() {
            return "(?:" + modifierRegex + ")";
          }).replace(/<PAR>/g, function() {
            return "(?:" + parenthesesRegex + ")";
          }),
          flags || ""
        );
      }
      var modifierTokens = {
        css: {
          pattern: /\{[^{}]+\}/,
          inside: {
            rest: Prism2.languages.css
          }
        },
        "class-id": {
          pattern: /(\()[^()]+(?=\))/,
          lookbehind: true,
          alias: "attr-value"
        },
        lang: {
          pattern: /(\[)[^\[\]]+(?=\])/,
          lookbehind: true,
          alias: "attr-value"
        },
        // Anything else is punctuation (the first pattern is for row/col spans inside tables)
        punctuation: /[\\\/]\d+|\S/
      };
      var textile2 = Prism2.languages.textile = Prism2.languages.extend("markup", {
        phrase: {
          pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
          lookbehind: true,
          inside: {
            // h1. Header 1
            "block-tag": {
              pattern: withModifier(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
              inside: {
                modifier: {
                  pattern: withModifier(
                    /(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source
                  ),
                  lookbehind: true,
                  inside: modifierTokens
                },
                tag: /^[a-z]\w*/,
                punctuation: /\.$/
              }
            },
            // # List item
            // * List item
            list: {
              pattern: withModifier(/^[*#]+<MOD>*\s+\S.*/.source, "m"),
              inside: {
                modifier: {
                  pattern: withModifier(/(^[*#]+)<MOD>+/.source),
                  lookbehind: true,
                  inside: modifierTokens
                },
                punctuation: /^[*#]+/
              }
            },
            // | cell | cell | cell |
            table: {
              // Modifiers can be applied to the row: {color:red}.|1|2|3|
              // or the cell: |{color:red}.1|2|3|
              pattern: withModifier(
                /^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/.source,
                "m"
              ),
              inside: {
                modifier: {
                  // Modifiers for rows after the first one are
                  // preceded by a pipe and a line feed
                  pattern: withModifier(
                    /(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source
                  ),
                  lookbehind: true,
                  inside: modifierTokens
                },
                punctuation: /\||^\./
              }
            },
            inline: {
              // eslint-disable-next-line regexp/no-super-linear-backtracking
              pattern: withModifier(
                /(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source
              ),
              lookbehind: true,
              inside: {
                // Note: superscripts and subscripts are not handled specifically
                // *bold*, **bold**
                bold: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
                  lookbehind: true
                },
                // _italic_, __italic__
                italic: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(/(^(__?)<MOD>*).+?(?=\2)/.source),
                  lookbehind: true
                },
                // ??cite??
                cite: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
                  lookbehind: true,
                  alias: "string"
                },
                // @code@
                code: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(/(^@<MOD>*).+?(?=@)/.source),
                  lookbehind: true,
                  alias: "keyword"
                },
                // +inserted+
                inserted: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(/(^\+<MOD>*).+?(?=\+)/.source),
                  lookbehind: true
                },
                // -deleted-
                deleted: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(/(^-<MOD>*).+?(?=-)/.source),
                  lookbehind: true
                },
                // %span%
                span: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(/(^%<MOD>*).+?(?=%)/.source),
                  lookbehind: true
                },
                modifier: {
                  pattern: withModifier(
                    /(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source
                  ),
                  lookbehind: true,
                  inside: modifierTokens
                },
                punctuation: /[*_%?@+\-^~]+/
              }
            },
            // [alias]http://example.com
            "link-ref": {
              pattern: /^\[[^\]]+\]\S+$/m,
              inside: {
                string: {
                  pattern: /(^\[)[^\]]+(?=\])/,
                  lookbehind: true
                },
                url: {
                  pattern: /(^\])\S+$/,
                  lookbehind: true
                },
                punctuation: /[\[\]]/
              }
            },
            // "text":http://example.com
            // "text":link-ref
            link: {
              // eslint-disable-next-line regexp/no-super-linear-backtracking
              pattern: withModifier(
                /"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source
              ),
              inside: {
                text: {
                  // eslint-disable-next-line regexp/no-super-linear-backtracking
                  pattern: withModifier(/(^"<MOD>*)[^"]+(?=")/.source),
                  lookbehind: true
                },
                modifier: {
                  pattern: withModifier(/(^")<MOD>+/.source),
                  lookbehind: true,
                  inside: modifierTokens
                },
                url: {
                  pattern: /(:).+/,
                  lookbehind: true
                },
                punctuation: /[":]/
              }
            },
            // !image.jpg!
            // !image.jpg(Title)!:http://example.com
            image: {
              pattern: withModifier(
                /!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/.source
              ),
              inside: {
                source: {
                  pattern: withModifier(
                    /(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source
                  ),
                  lookbehind: true,
                  alias: "url"
                },
                modifier: {
                  pattern: withModifier(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
                  lookbehind: true,
                  inside: modifierTokens
                },
                url: {
                  pattern: /(:).+/,
                  lookbehind: true
                },
                punctuation: /[!:]/
              }
            },
            // Footnote[1]
            footnote: {
              pattern: /\b\[\d+\]/,
              alias: "comment",
              inside: {
                punctuation: /\[|\]/
              }
            },
            // CSS(Cascading Style Sheet)
            acronym: {
              pattern: /\b[A-Z\d]+\([^)]+\)/,
              inside: {
                comment: {
                  pattern: /(\()[^()]+(?=\))/,
                  lookbehind: true
                },
                punctuation: /[()]/
              }
            },
            // Prism(C)
            mark: {
              pattern: /\b\((?:C|R|TM)\)/,
              alias: "comment",
              inside: {
                punctuation: /[()]/
              }
            }
          }
        }
      });
      var phraseInside = textile2["phrase"].inside;
      var nestedPatterns = {
        inline: phraseInside["inline"],
        link: phraseInside["link"],
        image: phraseInside["image"],
        footnote: phraseInside["footnote"],
        acronym: phraseInside["acronym"],
        mark: phraseInside["mark"]
      };
      textile2.tag.pattern = /<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
      var phraseInlineInside = phraseInside["inline"].inside;
      phraseInlineInside["bold"].inside = nestedPatterns;
      phraseInlineInside["italic"].inside = nestedPatterns;
      phraseInlineInside["inserted"].inside = nestedPatterns;
      phraseInlineInside["deleted"].inside = nestedPatterns;
      phraseInlineInside["span"].inside = nestedPatterns;
      var phraseTableInside = phraseInside["table"].inside;
      phraseTableInside["inline"] = nestedPatterns["inline"];
      phraseTableInside["link"] = nestedPatterns["link"];
      phraseTableInside["image"] = nestedPatterns["image"];
      phraseTableInside["footnote"] = nestedPatterns["footnote"];
      phraseTableInside["acronym"] = nestedPatterns["acronym"];
      phraseTableInside["mark"] = nestedPatterns["mark"];
    })(Prism);
  }
  return textile_1;
}
var toml_1;
var hasRequiredToml;
function requireToml() {
  if (hasRequiredToml) return toml_1;
  hasRequiredToml = 1;
  toml_1 = toml;
  toml.displayName = "toml";
  toml.aliases = [];
  function toml(Prism) {
    (function(Prism2) {
      var key = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
      function insertKey(pattern) {
        return pattern.replace(/__/g, function() {
          return key;
        });
      }
      Prism2.languages.toml = {
        comment: {
          pattern: /#.*/,
          greedy: true
        },
        table: {
          pattern: RegExp(
            insertKey(
              /(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source
            ),
            "m"
          ),
          lookbehind: true,
          greedy: true,
          alias: "class-name"
        },
        key: {
          pattern: RegExp(
            insertKey(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source),
            "m"
          ),
          lookbehind: true,
          greedy: true,
          alias: "property"
        },
        string: {
          pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
          greedy: true
        },
        date: [
          {
            // Offset Date-Time, Local Date-Time, Local Date
            pattern: /\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
            alias: "number"
          },
          {
            // Local Time
            pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
            alias: "number"
          }
        ],
        number: /(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
        boolean: /\b(?:false|true)\b/,
        punctuation: /[.,=[\]{}]/
      };
    })(Prism);
  }
  return toml_1;
}
var tremor_1;
var hasRequiredTremor;
function requireTremor() {
  if (hasRequiredTremor) return tremor_1;
  hasRequiredTremor = 1;
  tremor_1 = tremor;
  tremor.displayName = "tremor";
  tremor.aliases = [];
  function tremor(Prism) {
    (function(Prism2) {
      Prism2.languages.tremor = {
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
          lookbehind: true
        },
        "interpolated-string": null,
        // see below
        extractor: {
          pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
          greedy: true,
          inside: {
            regex: {
              pattern: /(^re)\|[\s\S]+/,
              lookbehind: true
            },
            function: /^\w+/,
            value: /\|[\s\S]+/
          }
        },
        identifier: {
          pattern: /`[^`]*`/,
          greedy: true
        },
        function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
        keyword: /\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
        boolean: /\b(?:false|null|true)\b/i,
        number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
        "pattern-punctuation": {
          pattern: /%(?=[({[])/,
          alias: "punctuation"
        },
        operator: /[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
        punctuation: /::|[;\[\]()\{\},.:]/
      };
      var interpolationPattern = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/.source;
      Prism2.languages.tremor["interpolated-string"] = {
        pattern: RegExp(
          /(^|[^\\])/.source + '(?:"""(?:' + /[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source + "|" + interpolationPattern + ')*"""|"(?:' + /[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source + "|" + interpolationPattern + ')*")'
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          interpolation: {
            pattern: RegExp(interpolationPattern),
            inside: {
              punctuation: /^#\{|\}$/,
              expression: {
                pattern: /[\s\S]+/,
                inside: Prism2.languages.tremor
              }
            }
          },
          string: /[\s\S]+/
        }
      };
      Prism2.languages.troy = Prism2.languages["tremor"];
      Prism2.languages.trickle = Prism2.languages["tremor"];
    })(Prism);
  }
  return tremor_1;
}
var tsx_1;
var hasRequiredTsx;
function requireTsx() {
  if (hasRequiredTsx) return tsx_1;
  hasRequiredTsx = 1;
  var refractorJsx = requireJsx();
  var refractorTypescript = requireTypescript();
  tsx_1 = tsx;
  tsx.displayName = "tsx";
  tsx.aliases = [];
  function tsx(Prism) {
    Prism.register(refractorJsx);
    Prism.register(refractorTypescript);
    (function(Prism2) {
      var typescript = Prism2.util.clone(Prism2.languages.typescript);
      Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
      delete Prism2.languages.tsx["parameter"];
      delete Prism2.languages.tsx["literal-property"];
      var tag = Prism2.languages.tsx.tag;
      tag.pattern = RegExp(
        /(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")",
        tag.pattern.flags
      );
      tag.lookbehind = true;
    })(Prism);
  }
  return tsx_1;
}
var tt2_1;
var hasRequiredTt2;
function requireTt2() {
  if (hasRequiredTt2) return tt2_1;
  hasRequiredTt2 = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  tt2_1 = tt2;
  tt2.displayName = "tt2";
  tt2.aliases = [];
  function tt2(Prism) {
    Prism.register(refractorMarkupTemplating);
    (function(Prism2) {
      Prism2.languages.tt2 = Prism2.languages.extend("clike", {
        comment: /#.*|\[%#[\s\S]*?%\]/,
        keyword: /\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
        punctuation: /[[\]{},()]/
      });
      Prism2.languages.insertBefore("tt2", "number", {
        operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
        variable: {
          pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
        }
      });
      Prism2.languages.insertBefore("tt2", "keyword", {
        delimiter: {
          pattern: /^(?:\[%|%%)-?|-?%\]$/,
          alias: "punctuation"
        }
      });
      Prism2.languages.insertBefore("tt2", "string", {
        "single-quoted-string": {
          pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
          greedy: true,
          alias: "string"
        },
        "double-quoted-string": {
          pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
          greedy: true,
          alias: "string",
          inside: {
            variable: {
              pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
            }
          }
        }
      });
      delete Prism2.languages.tt2.string;
      Prism2.hooks.add("before-tokenize", function(env) {
        var tt2Pattern = /\[%[\s\S]+?%\]/g;
        Prism2.languages["markup-templating"].buildPlaceholders(
          env,
          "tt2",
          tt2Pattern
        );
      });
      Prism2.hooks.add("after-tokenize", function(env) {
        Prism2.languages["markup-templating"].tokenizePlaceholders(env, "tt2");
      });
    })(Prism);
  }
  return tt2_1;
}
var twig_1;
var hasRequiredTwig;
function requireTwig() {
  if (hasRequiredTwig) return twig_1;
  hasRequiredTwig = 1;
  var refractorMarkupTemplating = requireMarkupTemplating();
  twig_1 = twig;
  twig.displayName = "twig";
  twig.aliases = [];
  function twig(Prism) {
    Prism.register(refractorMarkupTemplating);
    Prism.languages.twig = {
      comment: /^\{#[\s\S]*?#\}$/,
      "tag-name": {
        pattern: /(^\{%-?\s*)\w+/,
        lookbehind: true,
        alias: "keyword"
      },
      delimiter: {
        pattern: /^\{[{%]-?|-?[%}]\}$/,
        alias: "punctuation"
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        inside: {
          punctuation: /^['"]|['"]$/
        }
      },
      keyword: /\b(?:even|if|odd)\b/,
      boolean: /\b(?:false|null|true)\b/,
      number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
      operator: [
        {
          pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
          lookbehind: true
        },
        /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
      ],
      punctuation: /[()\[\]{}:.,]/
    };
    Prism.hooks.add("before-tokenize", function(env) {
      if (env.language !== "twig") {
        return;
      }
      var pattern = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
      Prism.languages["markup-templating"].buildPlaceholders(env, "twig", pattern);
    });
    Prism.hooks.add("after-tokenize", function(env) {
      Prism.languages["markup-templating"].tokenizePlaceholders(env, "twig");
    });
  }
  return twig_1;
}
var typoscript_1;
var hasRequiredTyposcript;
function requireTyposcript() {
  if (hasRequiredTyposcript) return typoscript_1;
  hasRequiredTyposcript = 1;
  typoscript_1 = typoscript;
  typoscript.displayName = "typoscript";
  typoscript.aliases = ["tsconfig"];
  function typoscript(Prism) {
    (function(Prism2) {
      var keywords = /\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
      Prism2.languages.typoscript = {
        comment: [
          {
            // multiline comments /* */
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true
          },
          {
            // double-slash comments - ignored when backslashes or colon is found in front
            // also ignored whenever directly after an equal-sign, because it would probably be an url without protocol
            pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
            lookbehind: true,
            greedy: true
          },
          {
            // hash comments - ignored when leading quote is found for hex colors in strings
            pattern: /(^|[^"'])#.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        function: [
          {
            // old include style
            pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
            inside: {
              string: {
                pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
                inside: {
                  keyword: keywords
                }
              },
              keyword: {
                pattern: /INCLUDE_TYPOSCRIPT/
              }
            }
          },
          {
            // new include style
            pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
            inside: {
              string: /"[^"\r\n]*"|'[^'\r\n]*'/
            }
          }
        ],
        string: {
          pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
          lookbehind: true,
          inside: {
            function: /\{\$.*\}/,
            // constants include
            keyword: keywords,
            number: /^\d+$/,
            punctuation: /[,|:]/
          }
        },
        keyword: keywords,
        number: {
          // special highlighting for indexes of arrays in tags
          pattern: /\b\d+\s*[.{=]/,
          inside: {
            operator: /[.{=]/
          }
        },
        tag: {
          pattern: /\.?[-\w\\]+\.?/,
          inside: {
            punctuation: /\./
          }
        },
        punctuation: /[{}[\];(),.:|]/,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
      };
      Prism2.languages.tsconfig = Prism2.languages.typoscript;
    })(Prism);
  }
  return typoscript_1;
}
var unrealscript_1;
var hasRequiredUnrealscript;
function requireUnrealscript() {
  if (hasRequiredUnrealscript) return unrealscript_1;
  hasRequiredUnrealscript = 1;
  unrealscript_1 = unrealscript;
  unrealscript.displayName = "unrealscript";
  unrealscript.aliases = ["uc", "uscript"];
  function unrealscript(Prism) {
    Prism.languages.unrealscript = {
      comment: /\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      category: {
        pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
        lookbehind: true,
        greedy: true,
        alias: "property"
      },
      metadata: {
        pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
        lookbehind: true,
        greedy: true,
        inside: {
          property: /\b\w+(?=\s*=)/,
          operator: /=/,
          punctuation: /[<>|]/
        }
      },
      macro: {
        pattern: /`\w+/,
        alias: "property"
      },
      "class-name": {
        pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
        lookbehind: true
      },
      keyword: /\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
      function: /\b[a-z_]\w*(?=\s*\()/i,
      boolean: /\b(?:false|true)\b/,
      number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      // https://docs.unrealengine.com/udk/Three/UnrealScriptExpressions.html
      operator: />>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
      punctuation: /[()[\]{};,.]/
    };
    Prism.languages.uc = Prism.languages.uscript = Prism.languages.unrealscript;
  }
  return unrealscript_1;
}
var uorazor_1;
var hasRequiredUorazor;
function requireUorazor() {
  if (hasRequiredUorazor) return uorazor_1;
  hasRequiredUorazor = 1;
  uorazor_1 = uorazor;
  uorazor.displayName = "uorazor";
  uorazor.aliases = [];
  function uorazor(Prism) {
    Prism.languages.uorazor = {
      "comment-hash": {
        pattern: /#.*/,
        alias: "comment",
        greedy: true
      },
      "comment-slash": {
        pattern: /\/\/.*/,
        alias: "comment",
        greedy: true
      },
      string: {
        pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
        inside: {
          punctuation: /^['"]|['"]$/
        },
        greedy: true
      },
      "source-layers": {
        pattern: /\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
        alias: "function"
      },
      "source-commands": {
        pattern: /\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
        alias: "function"
      },
      "tag-name": {
        pattern: /(^\{%-?\s*)\w+/,
        lookbehind: true,
        alias: "keyword"
      },
      delimiter: {
        pattern: /^\{[{%]-?|-?[%}]\}$/,
        alias: "punctuation"
      },
      function: /\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
      keyword: /\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
      boolean: /\b(?:false|null|true)\b/,
      number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
      operator: [
        {
          pattern: /(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
          lookbehind: true
        },
        /[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
      ],
      punctuation: /[()\[\]{}:.,]/
    };
  }
  return uorazor_1;
}
var uri_1;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri_1;
  hasRequiredUri = 1;
  uri_1 = uri;
  uri.displayName = "uri";
  uri.aliases = ["url"];
  function uri(Prism) {
    Prism.languages.uri = {
      scheme: {
        pattern: /^[a-z][a-z0-9+.-]*:/im,
        greedy: true,
        inside: {
          "scheme-delimiter": /:$/
        }
      },
      fragment: {
        pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
        inside: {
          "fragment-delimiter": /^#/
        }
      },
      query: {
        pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
        inside: {
          "query-delimiter": {
            pattern: /^\?/,
            greedy: true
          },
          "pair-delimiter": /[&;]/,
          pair: {
            pattern: /^[^=][\s\S]*/,
            inside: {
              key: /^[^=]+/,
              value: {
                pattern: /(^=)[\s\S]+/,
                lookbehind: true
              }
            }
          }
        }
      },
      authority: {
        pattern: RegExp(
          /^\/\//.source + // [ userinfo "@" ]
          /(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source + // host
          ("(?:" + // IP-literal
          /\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source + "|" + // IPv4address or registered name
          /[\w\-.~!$&'()*+,;=%]*/.source + ")") + // [ ":" port ]
          /(?::\d*)?/.source,
          "m"
        ),
        inside: {
          "authority-delimiter": /^\/\//,
          "user-info-segment": {
            pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
            inside: {
              "user-info-delimiter": /@$/,
              "user-info": /^[\w\-.~!$&'()*+,;=%:]+/
            }
          },
          "port-segment": {
            pattern: /:\d*$/,
            inside: {
              "port-delimiter": /^:/,
              port: /^\d+/
            }
          },
          host: {
            pattern: /[\s\S]+/,
            inside: {
              "ip-literal": {
                pattern: /^\[[\s\S]+\]$/,
                inside: {
                  "ip-literal-delimiter": /^\[|\]$/,
                  "ipv-future": /^v[\s\S]+/,
                  "ipv6-address": /^[\s\S]+/
                }
              },
              "ipv4-address": /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
            }
          }
        }
      },
      path: {
        pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
        inside: {
          "path-separator": /\//
        }
      }
    };
    Prism.languages.url = Prism.languages.uri;
  }
  return uri_1;
}
var v_1;
var hasRequiredV;
function requireV() {
  if (hasRequiredV) return v_1;
  hasRequiredV = 1;
  v_1 = v2;
  v2.displayName = "v";
  v2.aliases = [];
  function v2(Prism) {
    (function(Prism2) {
      var interpolationExpr = {
        pattern: /[\s\S]+/,
        inside: null
      };
      Prism2.languages.v = Prism2.languages.extend("clike", {
        string: {
          pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          alias: "quoted-string",
          greedy: true,
          inside: {
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
              lookbehind: true,
              inside: {
                "interpolation-variable": {
                  pattern: /^\$\w[\s\S]*$/,
                  alias: "variable"
                },
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                "interpolation-expression": interpolationExpr
              }
            }
          }
        },
        "class-name": {
          pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
          lookbehind: true
        },
        keyword: /(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
        number: /\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
        operator: /~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
        builtin: /\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
      });
      interpolationExpr.inside = Prism2.languages.v;
      Prism2.languages.insertBefore("v", "string", {
        char: {
          pattern: /`(?:\\`|\\?[^`]{1,2})`/,
          // using {1,2} instead of `u` flag for compatibility
          alias: "rune"
        }
      });
      Prism2.languages.insertBefore("v", "operator", {
        attribute: {
          pattern: /(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
          lookbehind: true,
          alias: "annotation",
          inside: {
            punctuation: /[\[\]]/,
            keyword: /\w+/
          }
        },
        generic: {
          pattern: /<\w+>(?=\s*[\)\{])/,
          inside: {
            punctuation: /[<>]/,
            "class-name": /\w+/
          }
        }
      });
      Prism2.languages.insertBefore("v", "function", {
        "generic-function": {
          // e.g. foo<T>( ...
          pattern: /\b\w+\s*<\w+>(?=\()/,
          inside: {
            function: /^\w+/,
            generic: {
              pattern: /<\w+>/,
              inside: Prism2.languages.v.generic.inside
            }
          }
        }
      });
    })(Prism);
  }
  return v_1;
}
var vala_1;
var hasRequiredVala;
function requireVala() {
  if (hasRequiredVala) return vala_1;
  hasRequiredVala = 1;
  vala_1 = vala;
  vala.displayName = "vala";
  vala.aliases = [];
  function vala(Prism) {
    Prism.languages.vala = Prism.languages.extend("clike", {
      // Classes copied from prism-csharp
      "class-name": [
        {
          // (Foo bar, Bar baz)
          pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
          inside: {
            punctuation: /\./
          }
        },
        {
          // [Foo]
          pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
          lookbehind: true,
          inside: {
            punctuation: /\./
          }
        },
        {
          // class Foo : Bar
          pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
          lookbehind: true,
          inside: {
            punctuation: /\./
          }
        },
        {
          // class Foo
          pattern: /((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
          lookbehind: true,
          inside: {
            punctuation: /\./
          }
        }
      ],
      keyword: /\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
      function: /\b\w+(?=\s*\()/,
      number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
      operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
      punctuation: /[{}[\];(),.:]/,
      constant: /\b[A-Z0-9_]+\b/
    });
    Prism.languages.insertBefore("vala", "string", {
      "raw-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: true,
        alias: "string"
      },
      "template-string": {
        pattern: /@"[\s\S]*?"/,
        greedy: true,
        inside: {
          interpolation: {
            pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
            inside: {
              delimiter: {
                pattern: /^\$\(?|\)$/,
                alias: "punctuation"
              },
              rest: Prism.languages.vala
            }
          },
          string: /[\s\S]+/
        }
      }
    });
    Prism.languages.insertBefore("vala", "keyword", {
      regex: {
        pattern: /\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism.languages.regex
          },
          "regex-delimiter": /^\//,
          "regex-flags": /^[a-z]+$/
        }
      }
    });
  }
  return vala_1;
}
var velocity_1;
var hasRequiredVelocity;
function requireVelocity() {
  if (hasRequiredVelocity) return velocity_1;
  hasRequiredVelocity = 1;
  velocity_1 = velocity;
  velocity.displayName = "velocity";
  velocity.aliases = [];
  function velocity(Prism) {
    (function(Prism2) {
      Prism2.languages.velocity = Prism2.languages.extend("markup", {});
      var velocity2 = {
        variable: {
          pattern: /(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
          lookbehind: true,
          inside: {}
          // See below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        number: /\b\d+\b/,
        boolean: /\b(?:false|true)\b/,
        operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
        punctuation: /[(){}[\]:,.]/
      };
      velocity2.variable.inside = {
        string: velocity2["string"],
        function: {
          pattern: /([^\w-])[a-z][\w-]*(?=\()/,
          lookbehind: true
        },
        number: velocity2["number"],
        boolean: velocity2["boolean"],
        punctuation: velocity2["punctuation"]
      };
      Prism2.languages.insertBefore("velocity", "comment", {
        unparsed: {
          pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
          lookbehind: true,
          greedy: true,
          inside: {
            punctuation: /^#\[\[|\]\]#$/
          }
        },
        "velocity-comment": [
          {
            pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
            lookbehind: true,
            greedy: true,
            alias: "comment"
          },
          {
            pattern: /(^|[^\\])##.*/,
            lookbehind: true,
            greedy: true,
            alias: "comment"
          }
        ],
        directive: {
          pattern: /(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
          lookbehind: true,
          inside: {
            keyword: {
              pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
              inside: {
                punctuation: /[{}]/
              }
            },
            rest: velocity2
          }
        },
        variable: velocity2["variable"]
      });
      Prism2.languages.velocity["tag"].inside["attr-value"].inside.rest = Prism2.languages.velocity;
    })(Prism);
  }
  return velocity_1;
}
var verilog_1;
var hasRequiredVerilog;
function requireVerilog() {
  if (hasRequiredVerilog) return verilog_1;
  hasRequiredVerilog = 1;
  verilog_1 = verilog;
  verilog.displayName = "verilog";
  verilog.aliases = [];
  function verilog(Prism) {
    Prism.languages.verilog = {
      comment: {
        pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
        greedy: true
      },
      string: {
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: true
      },
      "kernel-function": {
        // support for any kernel function (ex: $display())
        pattern: /\B\$\w+\b/,
        alias: "property"
      },
      // support for user defined constants (ex: `define)
      constant: /\B`\w+\b/,
      function: /\b\w+(?=\()/,
      // support for verilog and system verilog keywords
      keyword: /\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
      // bold highlighting for all verilog and system verilog logic blocks
      important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
      // support for time ticks, vectors, and real numbers
      number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
      operator: /[-+{}^~%*\/?=!<>&|]+/,
      punctuation: /[[\];(),.:]/
    };
  }
  return verilog_1;
}
var vhdl_1;
var hasRequiredVhdl;
function requireVhdl() {
  if (hasRequiredVhdl) return vhdl_1;
  hasRequiredVhdl = 1;
  vhdl_1 = vhdl;
  vhdl.displayName = "vhdl";
  vhdl.aliases = [];
  function vhdl(Prism) {
    Prism.languages.vhdl = {
      comment: /--.+/,
      // support for all logic vectors
      "vhdl-vectors": {
        pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
        alias: "number"
      },
      // support for operator overloading included
      "quoted-function": {
        pattern: /"\S+?"(?=\()/,
        alias: "function"
      },
      string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
      constant: /\b(?:library|use)\b/i,
      // support for predefined attributes included
      keyword: /\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,
      boolean: /\b(?:false|true)\b/i,
      function: /\w+(?=\()/,
      // decimal, based, physical, and exponential numbers supported
      number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
      operator: /[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
      punctuation: /[{}[\];(),.:]/
    };
  }
  return vhdl_1;
}
var vim_1;
var hasRequiredVim;
function requireVim() {
  if (hasRequiredVim) return vim_1;
  hasRequiredVim = 1;
  vim_1 = vim;
  vim.displayName = "vim";
  vim.aliases = [];
  function vim(Prism) {
    Prism.languages.vim = {
      string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
      comment: /".*/,
      function: /\b\w+(?=\()/,
      keyword: /\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
      builtin: /\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
      operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
      punctuation: /[{}[\](),;:]/
    };
  }
  return vim_1;
}
var visualBasic_1;
var hasRequiredVisualBasic;
function requireVisualBasic() {
  if (hasRequiredVisualBasic) return visualBasic_1;
  hasRequiredVisualBasic = 1;
  visualBasic_1 = visualBasic;
  visualBasic.displayName = "visualBasic";
  visualBasic.aliases = [];
  function visualBasic(Prism) {
    Prism.languages["visual-basic"] = {
      comment: {
        pattern: /(?:['‘’]|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
        inside: {
          keyword: /^REM/i
        }
      },
      directive: {
        pattern: /#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
        alias: "property",
        greedy: true
      },
      string: {
        pattern: /\$?["“”](?:["“”]{2}|[^"“”])*["“”]C?/i,
        greedy: true
      },
      date: {
        pattern: /#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
        alias: "number"
      },
      number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
      boolean: /\b(?:False|Nothing|True)\b/i,
      keyword: /\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
      operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
      punctuation: /[{}().,:?]/
    };
    Prism.languages.vb = Prism.languages["visual-basic"];
    Prism.languages.vba = Prism.languages["visual-basic"];
  }
  return visualBasic_1;
}
var warpscript_1;
var hasRequiredWarpscript;
function requireWarpscript() {
  if (hasRequiredWarpscript) return warpscript_1;
  hasRequiredWarpscript = 1;
  warpscript_1 = warpscript;
  warpscript.displayName = "warpscript";
  warpscript.aliases = [];
  function warpscript(Prism) {
    Prism.languages.warpscript = {
      comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
      string: {
        pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
        greedy: true
      },
      variable: /\$\S+/,
      macro: {
        pattern: /@\S+/,
        alias: "property"
      },
      // WarpScript doesn't have any keywords, these are all functions under the control category
      // https://www.warp10.io/tags/control
      keyword: /\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
      number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
      boolean: /\b(?:F|T|false|true)\b/,
      punctuation: /<%|%>|[{}[\]()]/,
      // Some operators from the "operators" category
      // https://www.warp10.io/tags/operators
      operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
    };
  }
  return warpscript_1;
}
var wasm_1;
var hasRequiredWasm;
function requireWasm() {
  if (hasRequiredWasm) return wasm_1;
  hasRequiredWasm = 1;
  wasm_1 = wasm;
  wasm.displayName = "wasm";
  wasm.aliases = [];
  function wasm(Prism) {
    Prism.languages.wasm = {
      comment: [
        /\(;[\s\S]*?;\)/,
        {
          pattern: /;;.*/,
          greedy: true
        }
      ],
      string: {
        pattern: /"(?:\\[\s\S]|[^"\\])*"/,
        greedy: true
      },
      keyword: [
        {
          pattern: /\b(?:align|offset)=/,
          inside: {
            operator: /=/
          }
        },
        {
          pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
          inside: {
            punctuation: /\./
          }
        },
        /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
      ],
      variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
      number: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
      punctuation: /[()]/
    };
  }
  return wasm_1;
}
var webIdl_1;
var hasRequiredWebIdl;
function requireWebIdl() {
  if (hasRequiredWebIdl) return webIdl_1;
  hasRequiredWebIdl = 1;
  webIdl_1 = webIdl;
  webIdl.displayName = "webIdl";
  webIdl.aliases = [];
  function webIdl(Prism) {
    (function(Prism2) {
      var id2 = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source;
      var type = "(?:" + /\b(?:unsigned\s+)?long\s+long(?![\w-])/.source + "|" + /\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source + "|" + /(?!(?:unrestricted|unsigned)\b)/.source + id2 + /(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source + ")" + /(?:\s*\?)?/.source;
      var typeInside = {};
      Prism2.languages["web-idl"] = {
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
          greedy: true
        },
        string: {
          pattern: /"[^"]*"/,
          greedy: true
        },
        namespace: {
          pattern: RegExp(/(\bnamespace\s+)/.source + id2),
          lookbehind: true
        },
        "class-name": [
          {
            pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
            lookbehind: true,
            inside: typeInside
          },
          {
            pattern: RegExp(
              /(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + type
            ),
            lookbehind: true,
            inside: typeInside
          },
          {
            // callback return type
            pattern: RegExp(
              "(" + /\bcallback\s+/.source + id2 + /\s*=\s*/.source + ")" + type
            ),
            lookbehind: true,
            inside: typeInside
          },
          {
            // typedef
            pattern: RegExp(/(\btypedef\b\s*)/.source + type),
            lookbehind: true,
            inside: typeInside
          },
          {
            pattern: RegExp(
              /(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/.source + id2
            ),
            lookbehind: true
          },
          {
            // inheritance
            pattern: RegExp(/(:\s*)/.source + id2),
            lookbehind: true
          },
          // includes and implements
          RegExp(id2 + /(?=\s+(?:implements|includes)\b)/.source),
          {
            pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + id2),
            lookbehind: true
          },
          {
            // function return type, parameter types, and dictionary members
            pattern: RegExp(
              type + "(?=" + /\s*(?:\.{3}\s*)?/.source + id2 + /\s*[(),;=]/.source + ")"
            ),
            inside: typeInside
          }
        ],
        builtin: /\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
        keyword: [
          /\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/,
          // type keywords
          /\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
        ],
        boolean: /\b(?:false|true)\b/,
        number: {
          pattern: /(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
          lookbehind: true
        },
        operator: /\.{3}|[=:?<>-]/,
        punctuation: /[(){}[\].,;]/
      };
      for (var key in Prism2.languages["web-idl"]) {
        if (key !== "class-name") {
          typeInside[key] = Prism2.languages["web-idl"][key];
        }
      }
      Prism2.languages["webidl"] = Prism2.languages["web-idl"];
    })(Prism);
  }
  return webIdl_1;
}
var wiki_1;
var hasRequiredWiki;
function requireWiki() {
  if (hasRequiredWiki) return wiki_1;
  hasRequiredWiki = 1;
  wiki_1 = wiki;
  wiki.displayName = "wiki";
  wiki.aliases = [];
  function wiki(Prism) {
    Prism.languages.wiki = Prism.languages.extend("markup", {
      "block-comment": {
        pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
        lookbehind: true,
        alias: "comment"
      },
      heading: {
        pattern: /^(=+)[^=\r\n].*?\1/m,
        inside: {
          punctuation: /^=+|=+$/,
          important: /.+/
        }
      },
      emphasis: {
        // TODO Multi-line
        pattern: /('{2,5}).+?\1/,
        inside: {
          "bold-italic": {
            pattern: /(''''').+?(?=\1)/,
            lookbehind: true,
            alias: ["bold", "italic"]
          },
          bold: {
            pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
            lookbehind: true
          },
          italic: {
            pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
            lookbehind: true
          },
          punctuation: /^''+|''+$/
        }
      },
      hr: {
        pattern: /^-{4,}/m,
        alias: "punctuation"
      },
      url: [
        /ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i,
        /\[\[.+?\]\]|\[.+?\]/
      ],
      variable: [
        /__[A-Z]+__/,
        // FIXME Nested structures should be handled
        // {{formatnum:{{#expr:{{{3}}}}}}}
        /\{{3}.+?\}{3}/,
        /\{\{.+?\}\}/
      ],
      symbol: [/^#redirect/im, /~{3,5}/],
      // Handle table attrs:
      // {|
      // ! style="text-align:left;"| Item
      // |}
      "table-tag": {
        pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
        lookbehind: true,
        inside: {
          "table-bar": {
            pattern: /\|$/,
            alias: "punctuation"
          },
          rest: Prism.languages.markup["tag"].inside
        }
      },
      punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
    });
    Prism.languages.insertBefore("wiki", "tag", {
      // Prevent highlighting inside <nowiki>, <source> and <pre> tags
      nowiki: {
        pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
        inside: {
          tag: {
            pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
            inside: Prism.languages.markup["tag"].inside
          }
        }
      }
    });
  }
  return wiki_1;
}
var wolfram_1;
var hasRequiredWolfram;
function requireWolfram() {
  if (hasRequiredWolfram) return wolfram_1;
  hasRequiredWolfram = 1;
  wolfram_1 = wolfram;
  wolfram.displayName = "wolfram";
  wolfram.aliases = ["mathematica", "wl", "nb"];
  function wolfram(Prism) {
    Prism.languages.wolfram = {
      // Allow one level of nesting - note: regex taken from applescipt
      comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
      string: {
        pattern: /"(?:\\.|[^"\\\r\n])*"/,
        greedy: true
      },
      keyword: /\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
      context: {
        pattern: /\b\w+`+\w*/,
        alias: "class-name"
      },
      blank: {
        pattern: /\b\w+_\b/,
        alias: "regex"
      },
      "global-variable": {
        pattern: /\$\w+/,
        alias: "variable"
      },
      boolean: /\b(?:False|True)\b/,
      number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
      operator: /\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\^|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
      punctuation: /[{}[\];(),.:]/
    };
    Prism.languages.mathematica = Prism.languages.wolfram;
    Prism.languages.wl = Prism.languages.wolfram;
    Prism.languages.nb = Prism.languages.wolfram;
  }
  return wolfram_1;
}
var wren_1;
var hasRequiredWren;
function requireWren() {
  if (hasRequiredWren) return wren_1;
  hasRequiredWren = 1;
  wren_1 = wren;
  wren.displayName = "wren";
  wren.aliases = [];
  function wren(Prism) {
    Prism.languages.wren = {
      // Multiline comments in Wren can have nested multiline comments
      // Comments: // and /* */
      comment: [
        {
          // support 3 levels of nesting
          // regex: \/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\/
          pattern: /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      // Triple quoted strings are multiline but cannot have interpolation (raw strings)
      // Based on prism-python.js
      "triple-quoted-string": {
        pattern: /"""[\s\S]*?"""/,
        greedy: true,
        alias: "string"
      },
      // see below
      "string-literal": null,
      // #!/usr/bin/env wren on the first line
      hashbang: {
        pattern: /^#!\/.+/,
        greedy: true,
        alias: "comment"
      },
      // Attributes are special keywords to add meta data to classes
      attribute: {
        // #! attributes are stored in class properties
        // #!myvar = true
        // #attributes are not stored and dismissed at compilation
        pattern: /#!?[ \t\u3000]*\w+/,
        alias: "keyword"
      },
      "class-name": [
        {
          // class definition
          // class Meta {}
          pattern: /(\bclass\s+)\w+/,
          lookbehind: true
        },
        // A class must always start with an uppercase.
        // File.read
        /\b[A-Z][a-z\d_]*\b/
      ],
      // A constant can be a variable, class, property or method. Just named in all uppercase letters
      constant: /\b[A-Z][A-Z\d_]*\b/,
      null: {
        pattern: /\bnull\b/,
        alias: "keyword"
      },
      keyword: /\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
      boolean: /\b(?:false|true)\b/,
      number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
      // Functions can be Class.method()
      function: /\b[a-z_]\w*(?=\s*[({])/i,
      operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
      punctuation: /[\[\](){}.,;]/
    };
    Prism.languages.wren["string-literal"] = {
      // A single quote string is multiline and can have interpolation (similar to JS backticks ``)
      pattern: /(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
      lookbehind: true,
      greedy: true,
      inside: {
        interpolation: {
          // "%(interpolation)"
          pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
          lookbehind: true,
          inside: {
            expression: {
              pattern: /^(%\()[\s\S]+(?=\)$)/,
              lookbehind: true,
              inside: Prism.languages.wren
            },
            "interpolation-punctuation": {
              pattern: /^%\(|\)$/,
              alias: "punctuation"
            }
          }
        },
        string: /[\s\S]+/
      }
    };
  }
  return wren_1;
}
var xeora_1;
var hasRequiredXeora;
function requireXeora() {
  if (hasRequiredXeora) return xeora_1;
  hasRequiredXeora = 1;
  xeora_1 = xeora;
  xeora.displayName = "xeora";
  xeora.aliases = ["xeoracube"];
  function xeora(Prism) {
    (function(Prism2) {
      Prism2.languages.xeora = Prism2.languages.extend("markup", {
        constant: {
          pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
          inside: {
            punctuation: {
              pattern: /\$/
            }
          }
        },
        variable: {
          pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /[$.]/
            },
            operator: {
              pattern: /#+|[-+*~=^@]/
            }
          }
        },
        "function-inline": {
          pattern: /\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
          inside: {
            variable: {
              pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
              inside: {
                punctuation: {
                  pattern: /[,.|]/
                },
                operator: {
                  pattern: /#+|[-+*~=^@]/
                }
              }
            },
            punctuation: {
              pattern: /\$\w:|[$:?.,|]/
            }
          },
          alias: "function"
        },
        "function-block": {
          pattern: /\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
          inside: {
            punctuation: {
              pattern: /[$:{}?.,|]/
            }
          },
          alias: "function"
        },
        "directive-inline": {
          pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
              inside: {
                tag: {
                  pattern: /#\d/
                }
              }
            }
          },
          alias: "function"
        },
        "directive-block-open": {
          pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
          inside: {
            punctuation: {
              pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
              inside: {
                tag: {
                  pattern: /#\d/
                }
              }
            },
            attribute: {
              pattern: /![A-Z]+$/,
              inside: {
                punctuation: {
                  pattern: /!/
                }
              },
              alias: "keyword"
            }
          },
          alias: "function"
        },
        "directive-block-separator": {
          pattern: /\}:[-\w.]+:\{/,
          inside: {
            punctuation: {
              pattern: /[:{}]/
            }
          },
          alias: "function"
        },
        "directive-block-close": {
          pattern: /\}:[-\w.]+\$/,
          inside: {
            punctuation: {
              pattern: /[:{}$]/
            }
          },
          alias: "function"
        }
      });
      Prism2.languages.insertBefore(
        "inside",
        "punctuation",
        {
          variable: Prism2.languages.xeora["function-inline"].inside["variable"]
        },
        Prism2.languages.xeora["function-block"]
      );
      Prism2.languages.xeoracube = Prism2.languages.xeora;
    })(Prism);
  }
  return xeora_1;
}
var xmlDoc_1;
var hasRequiredXmlDoc;
function requireXmlDoc() {
  if (hasRequiredXmlDoc) return xmlDoc_1;
  hasRequiredXmlDoc = 1;
  xmlDoc_1 = xmlDoc;
  xmlDoc.displayName = "xmlDoc";
  xmlDoc.aliases = [];
  function xmlDoc(Prism) {
    (function(Prism2) {
      function insertDocComment(lang, docComment) {
        if (Prism2.languages[lang]) {
          Prism2.languages.insertBefore(lang, "comment", {
            "doc-comment": docComment
          });
        }
      }
      var tag = Prism2.languages.markup.tag;
      var slashDocComment = {
        pattern: /\/\/\/.*/,
        greedy: true,
        alias: "comment",
        inside: {
          tag
        }
      };
      var tickDocComment = {
        pattern: /'''.*/,
        greedy: true,
        alias: "comment",
        inside: {
          tag
        }
      };
      insertDocComment("csharp", slashDocComment);
      insertDocComment("fsharp", slashDocComment);
      insertDocComment("vbnet", tickDocComment);
    })(Prism);
  }
  return xmlDoc_1;
}
var xojo_1;
var hasRequiredXojo;
function requireXojo() {
  if (hasRequiredXojo) return xojo_1;
  hasRequiredXojo = 1;
  xojo_1 = xojo;
  xojo.displayName = "xojo";
  xojo.aliases = [];
  function xojo(Prism) {
    Prism.languages.xojo = {
      comment: {
        pattern: /(?:'|\/\/|Rem\b).+/i,
        greedy: true
      },
      string: {
        pattern: /"(?:""|[^"])*"/,
        greedy: true
      },
      number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
      directive: {
        pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
        alias: "property"
      },
      keyword: /\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
      operator: /<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
      punctuation: /[.,;:()]/
    };
  }
  return xojo_1;
}
var xquery_1;
var hasRequiredXquery;
function requireXquery() {
  if (hasRequiredXquery) return xquery_1;
  hasRequiredXquery = 1;
  xquery_1 = xquery;
  xquery.displayName = "xquery";
  xquery.aliases = [];
  function xquery(Prism) {
    (function(Prism2) {
      Prism2.languages.xquery = Prism2.languages.extend("markup", {
        "xquery-comment": {
          pattern: /\(:[\s\S]*?:\)/,
          greedy: true,
          alias: "comment"
        },
        string: {
          pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
          greedy: true
        },
        extension: {
          pattern: /\(#.+?#\)/,
          alias: "symbol"
        },
        variable: /\$[-\w:]+/,
        axis: {
          pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
          lookbehind: true,
          alias: "operator"
        },
        "keyword-operator": {
          pattern: /(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
          lookbehind: true,
          alias: "operator"
        },
        keyword: {
          pattern: /(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
          lookbehind: true
        },
        function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
        "xquery-element": {
          pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
          lookbehind: true,
          alias: "tag"
        },
        "xquery-attribute": {
          pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
          lookbehind: true,
          alias: "attr-name"
        },
        builtin: {
          pattern: /(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
          lookbehind: true
        },
        number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
        operator: [
          /[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/,
          {
            pattern: /(\s)-(?=\s)/,
            lookbehind: true
          }
        ],
        punctuation: /[[\](){},;:/]/
      });
      Prism2.languages.xquery.tag.pattern = /<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
      Prism2.languages.xquery["tag"].inside["attr-value"].pattern = /=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/;
      Prism2.languages.xquery["tag"].inside["attr-value"].inside["punctuation"] = /^="|"$/;
      Prism2.languages.xquery["tag"].inside["attr-value"].inside["expression"] = {
        // Allow for two levels of nesting
        pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
        inside: Prism2.languages.xquery,
        alias: "language-xquery"
      };
      var stringifyToken = function(token) {
        if (typeof token === "string") {
          return token;
        }
        if (typeof token.content === "string") {
          return token.content;
        }
        return token.content.map(stringifyToken).join("");
      };
      var walkTokens = function(tokens) {
        var openedTags = [];
        for (var i2 = 0; i2 < tokens.length; i2++) {
          var token = tokens[i2];
          var notTagNorBrace = false;
          if (typeof token !== "string") {
            if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
              if (token.content[0].content[0].content === "</") {
                if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
                  openedTags.pop();
                }
              } else {
                if (token.content[token.content.length - 1].content === "/>") ;
                else {
                  openedTags.push({
                    tagName: stringifyToken(token.content[0].content[1]),
                    openedBraces: 0
                  });
                }
              }
            } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{" && // Ignore `{{`
            (!tokens[i2 + 1] || tokens[i2 + 1].type !== "punctuation" || tokens[i2 + 1].content !== "{") && (!tokens[i2 - 1] || tokens[i2 - 1].type !== "plain-text" || tokens[i2 - 1].content !== "{")) {
              openedTags[openedTags.length - 1].openedBraces++;
            } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
              openedTags[openedTags.length - 1].openedBraces--;
            } else if (token.type !== "comment") {
              notTagNorBrace = true;
            }
          }
          if (notTagNorBrace || typeof token === "string") {
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
              var plainText = stringifyToken(token);
              if (i2 < tokens.length - 1 && (typeof tokens[i2 + 1] === "string" || tokens[i2 + 1].type === "plain-text")) {
                plainText += stringifyToken(tokens[i2 + 1]);
                tokens.splice(i2 + 1, 1);
              }
              if (i2 > 0 && (typeof tokens[i2 - 1] === "string" || tokens[i2 - 1].type === "plain-text")) {
                plainText = stringifyToken(tokens[i2 - 1]) + plainText;
                tokens.splice(i2 - 1, 1);
                i2--;
              }
              if (/^\s+$/.test(plainText)) {
                tokens[i2] = plainText;
              } else {
                tokens[i2] = new Prism2.Token(
                  "plain-text",
                  plainText,
                  null,
                  plainText
                );
              }
            }
          }
          if (token.content && typeof token.content !== "string") {
            walkTokens(token.content);
          }
        }
      };
      Prism2.hooks.add("after-tokenize", function(env) {
        if (env.language !== "xquery") {
          return;
        }
        walkTokens(env.tokens);
      });
    })(Prism);
  }
  return xquery_1;
}
var yang_1;
var hasRequiredYang;
function requireYang() {
  if (hasRequiredYang) return yang_1;
  hasRequiredYang = 1;
  yang_1 = yang;
  yang.displayName = "yang";
  yang.aliases = [];
  function yang(Prism) {
    Prism.languages.yang = {
      // https://tools.ietf.org/html/rfc6020#page-34
      // http://www.yang-central.org/twiki/bin/view/Main/YangExamples
      comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
      string: {
        pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
        greedy: true
      },
      keyword: {
        pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
        lookbehind: true
      },
      namespace: {
        pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
        lookbehind: true
      },
      boolean: /\b(?:false|true)\b/,
      operator: /\+/,
      punctuation: /[{};:]/
    };
  }
  return yang_1;
}
var zig_1;
var hasRequiredZig;
function requireZig() {
  if (hasRequiredZig) return zig_1;
  hasRequiredZig = 1;
  zig_1 = zig;
  zig.displayName = "zig";
  zig.aliases = [];
  function zig(Prism) {
    (function(Prism2) {
      function literal(str) {
        return function() {
          return str;
        };
      }
      var keyword = /\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/;
      var IDENTIFIER = "\\b(?!" + keyword.source + ")(?!\\d)\\w+\\b";
      var ALIGN = /align\s*\((?:[^()]|\([^()]*\))*\)/.source;
      var PREFIX_TYPE_OP = /(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(
        /<ALIGN>/g,
        literal(ALIGN)
      );
      var SUFFIX_EXPR = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(
        /<ID>/g,
        literal(IDENTIFIER)
      );
      var TYPE = "(?!\\s)(?:!?\\s*(?:" + PREFIX_TYPE_OP + "\\s*)*" + SUFFIX_EXPR + ")+";
      Prism2.languages.zig = {
        comment: [
          {
            pattern: /\/\/[/!].*/,
            alias: "doc-comment"
          },
          /\/{2}.*/
        ],
        string: [
          {
            // "string" and c"string"
            pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
            lookbehind: true,
            greedy: true
          },
          {
            // multiline strings and c-strings
            pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
            lookbehind: true,
            greedy: true
          }
        ],
        char: {
          // characters 'a', '\n', '\xFF', '\u{10FFFF}'
          pattern: /(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
          lookbehind: true,
          greedy: true
        },
        builtin: /\B@(?!\d)\w+(?=\s*\()/,
        label: {
          pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
          lookbehind: true
        },
        "class-name": [
          // const Foo = struct {};
          /\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
          {
            // const x: i32 = 9;
            // var x: Bar;
            // fn foo(x: bool, y: f32) void {}
            pattern: RegExp(
              /(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))
            ),
            lookbehind: true,
            inside: null
            // see below
          },
          {
            // extern fn foo(x: f64) f64; (optional alignment)
            pattern: RegExp(
              /(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source.replace(/<TYPE>/g, literal(TYPE)).replace(/<ALIGN>/g, literal(ALIGN))
            ),
            lookbehind: true,
            inside: null
            // see below
          }
        ],
        "builtin-type": {
          pattern: /\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
          alias: "keyword"
        },
        keyword,
        function: /\b(?!\d)\w+(?=\s*\()/,
        number: /\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
        boolean: /\b(?:false|true)\b/,
        operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
        punctuation: /[.:,;(){}[\]]/
      };
      Prism2.languages.zig["class-name"].forEach(function(obj) {
        if (obj.inside === null) {
          obj.inside = Prism2.languages.zig;
        }
      });
    })(Prism);
  }
  return zig_1;
}
var refractor_1;
var hasRequiredRefractor;
function requireRefractor() {
  if (hasRequiredRefractor) return refractor_1;
  hasRequiredRefractor = 1;
  var refractor2 = requireCore();
  refractor_1 = refractor2;
  refractor2.register(requireAbap());
  refractor2.register(requireAbnf());
  refractor2.register(requireActionscript());
  refractor2.register(requireAda());
  refractor2.register(requireAgda());
  refractor2.register(requireAl());
  refractor2.register(requireAntlr4());
  refractor2.register(requireApacheconf());
  refractor2.register(requireApex());
  refractor2.register(requireApl());
  refractor2.register(requireApplescript());
  refractor2.register(requireAql());
  refractor2.register(requireArduino());
  refractor2.register(requireArff());
  refractor2.register(requireAsciidoc());
  refractor2.register(requireAsm6502());
  refractor2.register(requireAsmatmel());
  refractor2.register(requireAspnet());
  refractor2.register(requireAutohotkey());
  refractor2.register(requireAutoit());
  refractor2.register(requireAvisynth());
  refractor2.register(requireAvroIdl());
  refractor2.register(requireBash());
  refractor2.register(requireBasic());
  refractor2.register(requireBatch());
  refractor2.register(requireBbcode());
  refractor2.register(requireBicep());
  refractor2.register(requireBirb());
  refractor2.register(requireBison());
  refractor2.register(requireBnf());
  refractor2.register(requireBrainfuck());
  refractor2.register(requireBrightscript());
  refractor2.register(requireBro());
  refractor2.register(requireBsl());
  refractor2.register(requireC());
  refractor2.register(requireCfscript());
  refractor2.register(requireChaiscript());
  refractor2.register(requireCil());
  refractor2.register(requireClojure());
  refractor2.register(requireCmake());
  refractor2.register(requireCobol());
  refractor2.register(requireCoffeescript());
  refractor2.register(requireConcurnas());
  refractor2.register(requireCoq());
  refractor2.register(requireCpp());
  refractor2.register(requireCrystal());
  refractor2.register(requireCsharp());
  refractor2.register(requireCshtml());
  refractor2.register(requireCsp());
  refractor2.register(requireCssExtras());
  refractor2.register(requireCsv());
  refractor2.register(requireCypher());
  refractor2.register(requireD());
  refractor2.register(requireDart());
  refractor2.register(requireDataweave());
  refractor2.register(requireDax());
  refractor2.register(requireDhall());
  refractor2.register(requireDiff());
  refractor2.register(requireDjango());
  refractor2.register(requireDnsZoneFile());
  refractor2.register(requireDocker());
  refractor2.register(requireDot());
  refractor2.register(requireEbnf());
  refractor2.register(requireEditorconfig());
  refractor2.register(requireEiffel());
  refractor2.register(requireEjs());
  refractor2.register(requireElixir());
  refractor2.register(requireElm());
  refractor2.register(requireErb());
  refractor2.register(requireErlang());
  refractor2.register(requireEtlua());
  refractor2.register(requireExcelFormula());
  refractor2.register(requireFactor());
  refractor2.register(require_false());
  refractor2.register(requireFirestoreSecurityRules());
  refractor2.register(requireFlow());
  refractor2.register(requireFortran());
  refractor2.register(requireFsharp());
  refractor2.register(requireFtl());
  refractor2.register(requireGap());
  refractor2.register(requireGcode());
  refractor2.register(requireGdscript());
  refractor2.register(requireGedcom());
  refractor2.register(requireGherkin());
  refractor2.register(requireGit());
  refractor2.register(requireGlsl());
  refractor2.register(requireGml());
  refractor2.register(requireGn());
  refractor2.register(requireGoModule());
  refractor2.register(requireGo());
  refractor2.register(requireGraphql());
  refractor2.register(requireGroovy());
  refractor2.register(requireHaml());
  refractor2.register(requireHandlebars());
  refractor2.register(requireHaskell());
  refractor2.register(requireHaxe());
  refractor2.register(requireHcl());
  refractor2.register(requireHlsl());
  refractor2.register(requireHoon());
  refractor2.register(requireHpkp());
  refractor2.register(requireHsts());
  refractor2.register(requireHttp());
  refractor2.register(requireIchigojam());
  refractor2.register(requireIcon());
  refractor2.register(requireIcuMessageFormat());
  refractor2.register(requireIdris());
  refractor2.register(requireIecst());
  refractor2.register(requireIgnore());
  refractor2.register(requireInform7());
  refractor2.register(requireIni());
  refractor2.register(requireIo());
  refractor2.register(requireJ());
  refractor2.register(requireJava());
  refractor2.register(requireJavadoc());
  refractor2.register(requireJavadoclike());
  refractor2.register(requireJavastacktrace());
  refractor2.register(requireJexl());
  refractor2.register(requireJolie());
  refractor2.register(requireJq());
  refractor2.register(requireJsExtras());
  refractor2.register(requireJsTemplates());
  refractor2.register(requireJsdoc());
  refractor2.register(requireJson());
  refractor2.register(requireJson5());
  refractor2.register(requireJsonp());
  refractor2.register(requireJsstacktrace());
  refractor2.register(requireJsx());
  refractor2.register(requireJulia());
  refractor2.register(requireKeepalived());
  refractor2.register(requireKeyman());
  refractor2.register(requireKotlin());
  refractor2.register(requireKumir());
  refractor2.register(requireKusto());
  refractor2.register(requireLatex());
  refractor2.register(requireLatte());
  refractor2.register(requireLess());
  refractor2.register(requireLilypond());
  refractor2.register(requireLiquid());
  refractor2.register(requireLisp());
  refractor2.register(requireLivescript());
  refractor2.register(requireLlvm());
  refractor2.register(requireLog());
  refractor2.register(requireLolcode());
  refractor2.register(requireLua());
  refractor2.register(requireMagma());
  refractor2.register(requireMakefile());
  refractor2.register(requireMarkdown());
  refractor2.register(requireMarkupTemplating());
  refractor2.register(requireMatlab());
  refractor2.register(requireMaxscript());
  refractor2.register(requireMel());
  refractor2.register(requireMermaid());
  refractor2.register(requireMizar());
  refractor2.register(requireMongodb());
  refractor2.register(requireMonkey());
  refractor2.register(requireMoonscript());
  refractor2.register(requireN1ql());
  refractor2.register(requireN4js());
  refractor2.register(requireNand2tetrisHdl());
  refractor2.register(requireNaniscript());
  refractor2.register(requireNasm());
  refractor2.register(requireNeon());
  refractor2.register(requireNevod());
  refractor2.register(requireNginx());
  refractor2.register(requireNim());
  refractor2.register(requireNix());
  refractor2.register(requireNsis());
  refractor2.register(requireObjectivec());
  refractor2.register(requireOcaml());
  refractor2.register(requireOpencl());
  refractor2.register(requireOpenqasm());
  refractor2.register(requireOz());
  refractor2.register(requireParigp());
  refractor2.register(requireParser());
  refractor2.register(requirePascal());
  refractor2.register(requirePascaligo());
  refractor2.register(requirePcaxis());
  refractor2.register(requirePeoplecode());
  refractor2.register(requirePerl());
  refractor2.register(requirePhpExtras());
  refractor2.register(requirePhp());
  refractor2.register(requirePhpdoc());
  refractor2.register(requirePlsql());
  refractor2.register(requirePowerquery());
  refractor2.register(requirePowershell());
  refractor2.register(requireProcessing());
  refractor2.register(requireProlog());
  refractor2.register(requirePromql());
  refractor2.register(requireProperties());
  refractor2.register(requireProtobuf());
  refractor2.register(requirePsl());
  refractor2.register(requirePug());
  refractor2.register(requirePuppet());
  refractor2.register(requirePure());
  refractor2.register(requirePurebasic());
  refractor2.register(requirePurescript());
  refractor2.register(requirePython());
  refractor2.register(requireQ());
  refractor2.register(requireQml());
  refractor2.register(requireQore());
  refractor2.register(requireQsharp());
  refractor2.register(requireR());
  refractor2.register(requireRacket());
  refractor2.register(requireReason());
  refractor2.register(requireRegex());
  refractor2.register(requireRego());
  refractor2.register(requireRenpy());
  refractor2.register(requireRest());
  refractor2.register(requireRip());
  refractor2.register(requireRoboconf());
  refractor2.register(requireRobotframework());
  refractor2.register(requireRuby());
  refractor2.register(requireRust());
  refractor2.register(requireSas());
  refractor2.register(requireSass());
  refractor2.register(requireScala());
  refractor2.register(requireScheme());
  refractor2.register(requireScss());
  refractor2.register(requireShellSession());
  refractor2.register(requireSmali());
  refractor2.register(requireSmalltalk());
  refractor2.register(requireSmarty());
  refractor2.register(requireSml());
  refractor2.register(requireSolidity());
  refractor2.register(requireSolutionFile());
  refractor2.register(requireSoy());
  refractor2.register(requireSparql());
  refractor2.register(requireSplunkSpl());
  refractor2.register(requireSqf());
  refractor2.register(requireSql());
  refractor2.register(requireSquirrel());
  refractor2.register(requireStan());
  refractor2.register(requireStylus());
  refractor2.register(requireSwift());
  refractor2.register(requireSystemd());
  refractor2.register(requireT4Cs());
  refractor2.register(requireT4Templating());
  refractor2.register(requireT4Vb());
  refractor2.register(requireTap());
  refractor2.register(requireTcl());
  refractor2.register(requireTextile());
  refractor2.register(requireToml());
  refractor2.register(requireTremor());
  refractor2.register(requireTsx());
  refractor2.register(requireTt2());
  refractor2.register(requireTurtle());
  refractor2.register(requireTwig());
  refractor2.register(requireTypescript());
  refractor2.register(requireTyposcript());
  refractor2.register(requireUnrealscript());
  refractor2.register(requireUorazor());
  refractor2.register(requireUri());
  refractor2.register(requireV());
  refractor2.register(requireVala());
  refractor2.register(requireVbnet());
  refractor2.register(requireVelocity());
  refractor2.register(requireVerilog());
  refractor2.register(requireVhdl());
  refractor2.register(requireVim());
  refractor2.register(requireVisualBasic());
  refractor2.register(requireWarpscript());
  refractor2.register(requireWasm());
  refractor2.register(requireWebIdl());
  refractor2.register(requireWiki());
  refractor2.register(requireWolfram());
  refractor2.register(requireWren());
  refractor2.register(requireXeora());
  refractor2.register(requireXmlDoc());
  refractor2.register(requireXojo());
  refractor2.register(requireXquery());
  refractor2.register(requireYaml());
  refractor2.register(requireYang());
  refractor2.register(requireZig());
  return refractor_1;
}
var refractorExports = requireRefractor();
const refractor = /* @__PURE__ */ getDefaultExportFromCjs(refractorExports);
var highlighter = highlight(refractor, defaultStyle);
highlighter.supportedLanguages = supportedLanguages;
const vscDarkPlus = {
  'pre[class*="language-"]': {
    "color": "#d4d4d4",
    "fontSize": "13px",
    "textShadow": "none",
    "fontFamily": 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
    "direction": "ltr",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none",
    "padding": "1em",
    "margin": ".5em 0",
    "overflow": "auto",
    "background": "#1e1e1e"
  },
  'code[class*="language-"]': {
    "color": "#d4d4d4",
    "fontSize": "13px",
    "textShadow": "none",
    "fontFamily": 'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',
    "direction": "ltr",
    "textAlign": "left",
    "whiteSpace": "pre",
    "wordSpacing": "normal",
    "wordBreak": "normal",
    "lineHeight": "1.5",
    "MozTabSize": "4",
    "OTabSize": "4",
    "tabSize": "4",
    "WebkitHyphens": "none",
    "MozHyphens": "none",
    "msHyphens": "none",
    "hyphens": "none"
  },
  'pre[class*="language-"]::selection': {
    "textShadow": "none",
    "background": "#264F78"
  },
  'code[class*="language-"]::selection': {
    "textShadow": "none",
    "background": "#264F78"
  },
  'pre[class*="language-"] *::selection': {
    "textShadow": "none",
    "background": "#264F78"
  },
  'code[class*="language-"] *::selection': {
    "textShadow": "none",
    "background": "#264F78"
  },
  ':not(pre) > code[class*="language-"]': {
    "padding": ".1em .3em",
    "borderRadius": ".3em",
    "color": "#db4c69",
    "background": "#1e1e1e"
  },
  ".namespace": {
    "Opacity": ".7"
  },
  "doctype.doctype-tag": {
    "color": "#569CD6"
  },
  "doctype.name": {
    "color": "#9cdcfe"
  },
  "comment": {
    "color": "#6a9955"
  },
  "prolog": {
    "color": "#6a9955"
  },
  "punctuation": {
    "color": "#d4d4d4"
  },
  ".language-html .language-css .token.punctuation": {
    "color": "#d4d4d4"
  },
  ".language-html .language-javascript .token.punctuation": {
    "color": "#d4d4d4"
  },
  "property": {
    "color": "#9cdcfe"
  },
  "tag": {
    "color": "#569cd6"
  },
  "boolean": {
    "color": "#569cd6"
  },
  "number": {
    "color": "#b5cea8"
  },
  "constant": {
    "color": "#9cdcfe"
  },
  "symbol": {
    "color": "#b5cea8"
  },
  "inserted": {
    "color": "#b5cea8"
  },
  "unit": {
    "color": "#b5cea8"
  },
  "selector": {
    "color": "#d7ba7d"
  },
  "attr-name": {
    "color": "#9cdcfe"
  },
  "string": {
    "color": "#ce9178"
  },
  "char": {
    "color": "#ce9178"
  },
  "builtin": {
    "color": "#ce9178"
  },
  "deleted": {
    "color": "#ce9178"
  },
  ".language-css .token.string.url": {
    "textDecoration": "underline"
  },
  "operator": {
    "color": "#d4d4d4"
  },
  "entity": {
    "color": "#569cd6"
  },
  "operator.arrow": {
    "color": "#569CD6"
  },
  "atrule": {
    "color": "#ce9178"
  },
  "atrule.rule": {
    "color": "#c586c0"
  },
  "atrule.url": {
    "color": "#9cdcfe"
  },
  "atrule.url.function": {
    "color": "#dcdcaa"
  },
  "atrule.url.punctuation": {
    "color": "#d4d4d4"
  },
  "keyword": {
    "color": "#569CD6"
  },
  "keyword.module": {
    "color": "#c586c0"
  },
  "keyword.control-flow": {
    "color": "#c586c0"
  },
  "function": {
    "color": "#dcdcaa"
  },
  "function.maybe-class-name": {
    "color": "#dcdcaa"
  },
  "regex": {
    "color": "#d16969"
  },
  "important": {
    "color": "#569cd6"
  },
  "italic": {
    "fontStyle": "italic"
  },
  "class-name": {
    "color": "#4ec9b0"
  },
  "maybe-class-name": {
    "color": "#4ec9b0"
  },
  "console": {
    "color": "#9cdcfe"
  },
  "parameter": {
    "color": "#9cdcfe"
  },
  "interpolation": {
    "color": "#9cdcfe"
  },
  "punctuation.interpolation-punctuation": {
    "color": "#569cd6"
  },
  "variable": {
    "color": "#9cdcfe"
  },
  "imports.maybe-class-name": {
    "color": "#9cdcfe"
  },
  "exports.maybe-class-name": {
    "color": "#9cdcfe"
  },
  "escape": {
    "color": "#d7ba7d"
  },
  "tag.punctuation": {
    "color": "#808080"
  },
  "cdata": {
    "color": "#808080"
  },
  "attr-value": {
    "color": "#ce9178"
  },
  "attr-value.punctuation": {
    "color": "#ce9178"
  },
  "attr-value.punctuation.attr-equals": {
    "color": "#d4d4d4"
  },
  "namespace": {
    "color": "#4ec9b0"
  },
  'pre[class*="language-javascript"]': {
    "color": "#9cdcfe"
  },
  'code[class*="language-javascript"]': {
    "color": "#9cdcfe"
  },
  'pre[class*="language-jsx"]': {
    "color": "#9cdcfe"
  },
  'code[class*="language-jsx"]': {
    "color": "#9cdcfe"
  },
  'pre[class*="language-typescript"]': {
    "color": "#9cdcfe"
  },
  'code[class*="language-typescript"]': {
    "color": "#9cdcfe"
  },
  'pre[class*="language-tsx"]': {
    "color": "#9cdcfe"
  },
  'code[class*="language-tsx"]': {
    "color": "#9cdcfe"
  },
  'pre[class*="language-css"]': {
    "color": "#ce9178"
  },
  'code[class*="language-css"]': {
    "color": "#ce9178"
  },
  'pre[class*="language-html"]': {
    "color": "#d4d4d4"
  },
  'code[class*="language-html"]': {
    "color": "#d4d4d4"
  },
  ".language-regex .token.anchor": {
    "color": "#dcdcaa"
  },
  ".language-html .token.punctuation": {
    "color": "#808080"
  },
  'pre[class*="language-"] > code[class*="language-"]': {
    "position": "relative",
    "zIndex": "1"
  },
  ".line-highlight.line-highlight": {
    "background": "#f7ebc6",
    "boxShadow": "inset 5px 0 0 #f7d87c",
    "zIndex": "0"
  }
};
function r$8(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o4 = e2.length;
    for (t2 = 0; t2 < o4; t2++) e2[t2] && (f2 = r$8(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o4 = arguments.length; f2 < o4; f2++) (e2 = arguments[f2]) && (t2 = r$8(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const sizeClasses = {
  xs: "text-xs",
  sm: "text-sm",
  md: "text-base",
  lg: "text-lg",
  xl: "text-xl"
};
const variantClasses = {
  default: "bg-gray-800 text-gray-100",
  minimal: "bg-gray-50 text-gray-900 border border-gray-200",
  elevated: "bg-white dark:bg-gray-900 shadow-lg",
  bordered: "border-2 border-gray-300 dark:border-gray-700",
  filled: "bg-gray-800 text-gray-100"
};
const CodeBlock = ({
  code,
  language = "text",
  title,
  containerClassName,
  size: size2 = "md",
  variant = "default",
  hasLineNumbers = true,
  hasCopyButton = true,
  copyButtonText = "Copy",
  copiedButtonText = "Copied!",
  onCopy,
  ...props
}) => {
  const [isCopied, setIsCopied] = useState(false);
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code);
      setIsCopied(true);
      onCopy?.(code);
      setTimeout(() => setIsCopied(false), 2e3);
    } catch (err) {
      console.error("Failed to copy code:", err);
    }
  };
  const containerClasses = clsx(
    "relative",
    "overflow-hidden",
    "rounded-lg",
    variantClasses[variant],
    // Use the variant for background and text color
    containerClassName
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, ...props, children: [
    (title || hasCopyButton) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between px-4 py-2 bg-gray-900/50", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        title && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-gray-300", children: title }),
        language && language !== "text" && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 text-xs bg-gray-700 text-gray-300 rounded", children: language })
      ] }),
      hasCopyButton && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: handleCopy,
          className: "flex items-center gap-1.5 px-2 py-1 text-xs text-gray-300 transition-colors border border-gray-600 rounded-md hover:bg-gray-700 hover:text-white",
          "aria-label": isCopied ? copiedButtonText : copyButtonText,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-4 h-4", children: isCopied ? "check" : "content_copy" }),
            isCopied ? copiedButtonText : copyButtonText
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      highlighter,
      {
        language,
        style: vscDarkPlus,
        showLineNumbers: hasLineNumbers,
        wrapLines: true,
        customStyle: {
          backgroundColor: "transparent",
          // Let the container control the background
          margin: 0,
          padding: "1rem",
          fontSize: sizeClasses[size2]
          // Use the size classes
        },
        codeTagProps: {
          className: sizeClasses[size2]
        },
        children: String(code).trim()
      }
    )
  ] });
};
const ComponentPreview = ({
  children,
  title,
  description,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  // State Props
  isDisabled = false,
  isLoading = false,
  isExpanded = true,
  isCollapsible = false,
  isInteractive = false,
  isEditable = false,
  isResizable = false,
  isDraggable = false,
  isDroppable = false,
  // Feature Props
  hasBackground = true,
  hasBorder = true,
  isRounded = true,
  hasShadow = false,
  hasTitleBar = false,
  hasDescription = false,
  hasToolbar = false,
  hasFooter = false,
  hasBorderRadius = true,
  hasPadding = true,
  hasMargin = false,
  hasOverlays = true,
  hasGridLayout = false,
  hasColumnLayout = false,
  hasRowLayout = false,
  hasFlexboxLayout = true,
  hasCSSGridLayout = false,
  // Layout Props
  isResponsive = true,
  hasFixedWidth = false,
  isFullWidth = true,
  hasFixedHeight = false,
  isScrollable = false,
  isCentered = true,
  hasMaxWidth = false,
  hasMinWidth = false,
  hasMaxHeight = false,
  hasMinHeight = false,
  // Content Props
  headerContent,
  footerContent,
  toolbarContent,
  overlayContent,
  backgroundContent,
  borderContent,
  shadowContent,
  paddingContent,
  marginContent,
  // Event Handlers
  onClick,
  onFocus,
  onBlur,
  onToggle,
  onResize,
  onDrag,
  onDrop,
  ...props
}) => {
  const [expanded, setExpanded] = useState(isExpanded);
  const [isDragging2, setIsDragging] = useState(false);
  const sizeClasses2 = {
    xs: "p-2 gap-2",
    sm: "p-3 gap-3",
    md: "p-4 gap-4",
    lg: "p-6 gap-6",
    xl: "p-8 gap-8"
  };
  const variantClasses2 = {
    default: "bg-white dark:bg-gray-900",
    minimal: "bg-transparent",
    elevated: "bg-white dark:bg-gray-900 shadow-lg",
    bordered: "bg-white dark:bg-gray-900 border-2 border-gray-200 dark:border-gray-700",
    filled: "bg-gray-50 dark:bg-gray-800"
  };
  const layoutClasses = {
    grid: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4",
    column: "flex flex-col items-start gap-4",
    row: "flex flex-row items-center gap-4",
    flexbox: "flex flex-wrap items-center gap-4",
    cssGrid: "grid grid-cols-1 gap-4"
  };
  const handleToggle = () => {
    if (isCollapsible && !isDisabled) {
      const newExpanded = !expanded;
      setExpanded(newExpanded);
      onToggle?.(newExpanded);
    }
  };
  const handleDragStart = (event) => {
    if (isDraggable && !isDisabled) {
      setIsDragging(true);
      onDrag?.(event);
    }
  };
  const handleDragEnd = () => {
    setIsDragging(false);
  };
  const handleDrop = (event) => {
    if (isDroppable && !isDisabled) {
      onDrop?.(event);
    }
  };
  const containerClasses = `
    ${hasBackground ? "bg-white dark:bg-gray-900" : ""}
    ${hasBorder ? "border border-gray-300 dark:border-gray-600" : ""}
    ${isRounded ? "rounded-lg" : ""}
    ${hasShadow ? "shadow-md" : ""}
    ${isResponsive ? "w-full" : ""}
    ${hasFixedWidth ? "" : "w-full"}
    ${isFullWidth ? "w-full" : ""}
    ${hasFixedHeight ? "" : "min-h-0"}
    ${isScrollable ? "overflow-auto" : "overflow-hidden"}
    ${hasPadding ? "p-4" : ""}
    ${hasMargin ? "m-4" : ""}
    ${isCentered ? "mx-auto" : ""}
    ${hasMaxWidth ? "max-w-7xl" : ""}
    ${hasMinWidth ? "min-w-0" : ""}
    ${hasMaxHeight ? "max-h-96" : ""}
    ${hasMinHeight ? "min-h-0" : ""}
    ${containerClassName}
    ${className}
  `.trim().replace(/\s+/g, " ");
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClasses, style, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center h-32", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-primary-500" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-gray-500", children: "Loading preview..." })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, style, ...props, children: [
    (hasTitleBar || title || headerContent) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4 p-3 bg-gray-100 dark:bg-gray-800 rounded-t-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        title && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-gray-900 dark:text-gray-100", children: title }),
        description && hasDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-600 dark:text-gray-400", children: description })
      ] }),
      headerContent
    ] }),
    hasToolbar && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4 p-2 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        isCollapsible && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleToggle,
            disabled: isDisabled,
            className: "px-2 py-1 text-xs bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3 mr-1", children: expanded ? "expand_less" : "expand_more" }),
              expanded ? "Collapse" : "Expand"
            ]
          }
        ),
        isResizable && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-500", children: "Resizable" }),
        isDraggable && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-500", children: "Draggable" })
      ] }),
      toolbarContent
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `
          relative ${variantClasses2[variant]}
          ${sizeClasses2[size2]}
          ${layoutClasses[hasGridLayout ? "grid" : hasColumnLayout ? "column" : hasRowLayout ? "row" : hasFlexboxLayout ? "flexbox" : hasCSSGridLayout ? "cssGrid" : "flexbox"]}
          ${hasBorderRadius ? "rounded-lg" : ""}
          ${hasPadding ? "p-4" : ""}
          ${hasMargin ? "m-4" : ""}
          ${isInteractive ? "cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800" : ""}
          ${isEditable ? "cursor-text" : ""}
          ${isResizable ? "resize" : ""}
          ${isDraggable ? "cursor-move" : ""}
          ${isDroppable ? "border-dashed border-2 border-gray-300 dark:border-gray-600" : ""}
          ${isDisabled ? "opacity-50 cursor-not-allowed" : ""}
          ${isDragging2 ? "opacity-75" : ""}
          transition-all duration-200
        `.trim().replace(/\s+/g, " "),
        onClick,
        onFocus,
        onBlur,
        draggable: isDraggable,
        onDragStart: handleDragStart,
        onDragEnd: handleDragEnd,
        onDrop: handleDrop,
        onDragOver: (e2) => e2.preventDefault(),
        children: [
          backgroundContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 -z-10", children: backgroundContent }),
          borderContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: borderContent }),
          shadowContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: shadowContent }),
          paddingContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: paddingContent }),
          marginContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: marginContent }),
          expanded && children,
          hasOverlays && overlayContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: overlayContent })
        ]
      }
    ),
    hasFooter && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 p-3 bg-gray-100 dark:bg-gray-800 rounded-b-lg", children: footerContent })
  ] });
};
const ContainerFC = ({
  as,
  children,
  containerClassName = "",
  contentClassName = "",
  loadingClassName = "",
  statusClassName = "",
  style,
  size: size2 = "screen",
  variant = "default",
  color: color2 = "primary",
  padding = "md",
  isCentered = true,
  isFullWidth = false,
  isCollapsed = false,
  isExpanded = false,
  isVisible = true,
  isHidden: isHidden3 = false,
  isTransparent = false,
  isOpaque = false,
  hasBackground = false,
  hasBorder = false,
  hasRoundedCorners = false,
  hasShadow = false,
  hasBackdropBlur = false,
  hasGlassEffect = false,
  hasGradient = false,
  hasFocusRing = false,
  hasHoverEffect = false,
  hasFocusEffect = false,
  hasActiveEffect = false,
  disabled = false,
  fullWidth = false,
  loading = false,
  isReady = true,
  isUnmounted = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  hasLoadingText = false,
  loadingText = "Loading...",
  hasSuccessText = false,
  successText = "Success!",
  hasWarningText = false,
  warningText = "Warning!",
  hasErrorText = false,
  errorText = "Error!",
  hasInfoText = false,
  infoText = "Info",
  hasTooltip = false,
  tooltipText,
  customColor,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onContextMenu,
  onScroll,
  onResize,
  onMount,
  onUnmount,
  onStateChange,
  onVariantChange,
  onSizeChange,
  onColorChange,
  ...rest
}) => {
  const Component2 = as || "div";
  const sizeClasses2 = {
    xs: "max-w-xs sm:max-w-sm md:max-w-md",
    sm: "max-w-sm sm:max-w-md md:max-w-lg",
    md: "max-w-md sm:max-w-lg md:max-w-xl",
    lg: "max-w-lg sm:max-w-xl md:max-w-2xl",
    xl: "max-w-xl sm:max-w-2xl md:max-w-4xl",
    "2xl": "max-w-2xl sm:max-w-4xl md:max-w-6xl",
    full: "max-w-full",
    screen: "max-w-full sm:max-w-screen-lg md:max-w-screen-xl lg:max-w-screen-2xl"
  };
  const paddingClasses = {
    none: "",
    sm: "px-2 sm:px-4 md:px-6",
    md: "px-3 sm:px-4 md:px-6 lg:px-8",
    lg: "px-4 sm:px-6 md:px-8 lg:px-12",
    xl: "px-6 sm:px-8 md:px-12 lg:px-16"
  };
  const variantClasses2 = {
    default: "",
    article: "prose prose-sm sm:prose-base md:prose-lg max-w-full sm:max-w-2xl md:max-w-4xl",
    main: "min-h-screen",
    aside: "max-w-full sm:max-w-sm md:max-w-md",
    section: "py-4 sm:py-6 md:py-8 lg:py-12",
    card: "bg-white dark:bg-dark-bg-primary rounded-lg shadow-md",
    panel: "bg-bg-secondary dark:bg-dark-bg-secondary rounded-lg border border-border-color dark:border-dark-border-color",
    modal: "bg-white dark:bg-dark-bg-primary rounded-lg shadow-2xl border border-border-color dark:border-dark-border-color"
  };
  const colorClasses2 = {
    primary: "border-brand-navy dark:border-dark-brand-orange",
    success: "border-system-success",
    warning: "border-system-warning-border dark:border-system-warning",
    danger: "border-system-error",
    info: "border-system-info"
  };
  const baseClasses = "w-full";
  const sizeClass = sizeClasses2[size2];
  const paddingClass = paddingClasses[padding];
  const variantClass = variantClasses2[variant];
  const centerClass = isCentered ? "mx-auto" : "";
  const backgroundClass = hasBackground ? "bg-bg-primary dark:bg-dark-bg-primary" : "";
  const borderClass = hasBorder ? `border ${colorClasses2[color2]}` : "";
  const roundedClass = hasRoundedCorners ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const widthClass = fullWidth ? "w-full" : "";
  const collapsedClass = isCollapsed ? "max-w-xs" : "";
  const expandedClass = isExpanded ? "max-w-7xl" : "";
  const visibleClass = isVisible ? "opacity-100" : "opacity-0";
  const hiddenClass = isHidden3 ? "hidden" : "";
  const transparentClass = isTransparent ? "bg-transparent" : "";
  const opaqueClass = isOpaque ? "bg-opacity-100" : "";
  const backdropClass = hasBackdropBlur ? "backdrop-blur-sm" : "";
  const glassClass = hasGlassEffect ? "bg-white/20 dark:bg-black/20 backdrop-blur-md border border-white/30 dark:border-white/10" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-bg-primary to-bg-secondary dark:from-dark-bg-primary dark:to-dark-bg-secondary" : "";
  const focusRingClass = hasFocusRing ? "focus:outline-none focus:ring-2 focus:ring-brand-orange focus:ring-offset-2" : "";
  const hoverClass = hasHoverEffect ? "hover:opacity-80 transition-opacity duration-200" : "";
  const focusEffectClass = hasFocusEffect ? "focus:outline-none focus:ring-2 focus:ring-brand-orange focus:ring-offset-2" : "";
  const activeClass = hasActiveEffect ? "active:opacity-60" : "";
  const disabledClass = disabled ? "opacity-50 cursor-not-allowed" : "";
  const readOnlyClass = false;
  const requiredClass = false;
  const validClass = false;
  const invalidClass = false;
  const pendingClass = false;
  const busyClass = false;
  const readyClass = isReady ? "opacity-100" : "opacity-50";
  const mountedClass = true;
  const unmountedClass = isUnmounted ? "hidden" : "";
  const loadingClass = loading ? "animate-pulse" : "";
  const errorClass = isError ? `border-2 ${colorClasses2.danger} bg-system-error/10` : "";
  const warningClass = isWarning ? `border-2 ${colorClasses2.warning} bg-system-warning-light/50 dark:bg-system-warning-dark-bg/20` : "";
  const successClass = isSuccess ? `border-2 ${colorClasses2.success} bg-system-success/10` : "";
  const infoClass = isInfo ? `border-2 ${colorClasses2.info} bg-system-info/10` : "";
  const customColorClass = customColor ? `bg-[${customColor}]` : "";
  const combinedClasses = [
    baseClasses,
    sizeClass,
    paddingClass,
    variantClass,
    centerClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    widthClass,
    collapsedClass,
    expandedClass,
    visibleClass,
    hiddenClass,
    transparentClass,
    opaqueClass,
    backdropClass,
    glassClass,
    gradientClass,
    focusRingClass,
    hoverClass,
    focusEffectClass,
    activeClass,
    disabledClass,
    readOnlyClass,
    requiredClass,
    validClass,
    invalidClass,
    pendingClass,
    busyClass,
    readyClass,
    mountedClass,
    unmountedClass,
    loadingClass,
    errorClass,
    warningClass,
    successClass,
    infoClass,
    customColorClass,
    containerClassName
  ].filter(Boolean).join(" ");
  const containerContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Component2,
    {
      className: combinedClasses,
      style,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onContextMenu,
      onScroll,
      onResize,
      ...rest,
      children: [
        loading && hasLoadingText && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center justify-center p-4 ${loadingClassName}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent mr-2" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: loadingText })
        ] }),
        isSuccess && hasSuccessText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex items-center justify-center p-4 text-system-success ${statusClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: successText }) }),
        isWarning && hasWarningText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex items-center justify-center p-4 text-system-warning-dark dark:text-system-warning-light-text ${statusClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: warningText }) }),
        isError && hasErrorText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex items-center justify-center p-4 text-system-error ${statusClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: errorText }) }),
        isInfo && hasInfoText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex items-center justify-center p-4 text-system-info ${statusClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium", children: infoText }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: contentClassName, children })
      ]
    }
  );
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      containerContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return containerContent;
};
const Container = ContainerFC;
const CopiedFeedback = ({
  text = "Copied",
  icon = "check",
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "success",
  // State Props
  isVisible = true,
  isDisabled = false,
  isLoading = false,
  isAnimated = true,
  isPersistent = false,
  isDismissible = false,
  isInteractive = false,
  isDraggable = false,
  // Feature Props
  hasBackground = true,
  hasBorder = false,
  isRounded = true,
  hasShadow = true,
  hasOverlay = true,
  hasBackdropBlur = true,
  hasPulseEffect = false,
  hasBounceEffect = false,
  hasFadeEffect = true,
  hasSlideEffect = false,
  hasScaleEffect = false,
  hasRotationEffect = false,
  // Layout Props
  isResponsive = true,
  hasFixedWidth = false,
  isFullWidth = false,
  hasFixedHeight = false,
  isCentered = true,
  hasMaxWidth = false,
  hasMinWidth = false,
  hasMaxHeight = false,
  hasMinHeight = false,
  // Content Props
  iconContent,
  textContent,
  backgroundContent,
  borderContent,
  shadowContent,
  overlayContent,
  backdropContent,
  // Timing Props
  autoHideDuration = 2e3,
  showDelay = 0,
  animationDuration = 300,
  transitionDuration = 200,
  // Event Handlers
  onShow,
  onHide,
  onDismiss,
  onClick,
  onFocus,
  onBlur,
  onDrag,
  onDrop,
  ...props
}) => {
  const [visible, setVisible] = useState(isVisible);
  const [isDragging2, setIsDragging] = useState(false);
  useEffect(() => {
    if (!isPersistent && isVisible && autoHideDuration > 0) {
      const timer = setTimeout(() => {
        setVisible(false);
        onHide?.();
      }, autoHideDuration);
      return () => clearTimeout(timer);
    }
  }, [isVisible, isPersistent, autoHideDuration, onHide]);
  useEffect(() => {
    if (showDelay > 0) {
      const timer = setTimeout(() => {
        setVisible(true);
        onShow?.();
      }, showDelay);
      return () => clearTimeout(timer);
    }
  }, [showDelay, onShow]);
  const sizeClasses2 = {
    xs: "px-2 py-1 text-xs gap-1",
    sm: "px-2.5 py-1.5 text-sm gap-1.5",
    md: "px-3 py-2 text-sm gap-2",
    lg: "px-4 py-2.5 text-base gap-2.5",
    xl: "px-5 py-3 text-lg gap-3"
  };
  const variantClasses2 = {
    default: "bg-white dark:bg-gray-900",
    minimal: "bg-transparent",
    elevated: "bg-white dark:bg-gray-900 shadow-lg",
    bordered: "bg-white dark:bg-gray-900 border-2",
    filled: "bg-gray-50 dark:bg-gray-800"
  };
  const colorClasses2 = {
    primary: "text-primary-600 dark:text-primary-400 bg-primary-50 dark:bg-primary-900/20 border-primary-200 dark:border-primary-700",
    success: "text-success-600 dark:text-success-400 bg-success-50 dark:bg-success-900/20 border-success-200 dark:border-success-700",
    warning: "text-warning-600 dark:text-warning-400 bg-warning-50 dark:bg-warning-900/20 border-warning-200 dark:border-warning-700",
    danger: "text-danger-600 dark:text-danger-400 bg-danger-50 dark:bg-danger-900/20 border-danger-200 dark:border-danger-700",
    info: "text-info-600 dark:text-info-400 bg-info-50 dark:bg-info-900/20 border-info-200 dark:border-info-700",
    neutral: "text-gray-600 dark:text-gray-400 bg-gray-50 dark:bg-gray-900/20 border-gray-200 dark:border-gray-700"
  };
  const animationClasses = {
    pulse: hasPulseEffect ? "animate-pulse" : "",
    bounce: hasBounceEffect ? "animate-bounce" : "",
    fade: hasFadeEffect ? "transition-opacity duration-300" : "",
    slide: hasSlideEffect ? "transition-transform duration-300" : "",
    scale: hasScaleEffect ? "transition-transform duration-300 hover:scale-105" : "",
    rotation: hasRotationEffect ? "transition-transform duration-300 hover:rotate-12" : ""
  };
  const handleDismiss = () => {
    if (isDismissible && !isDisabled) {
      setVisible(false);
      onDismiss?.();
    }
  };
  const handleDragStart = (event) => {
    if (isDraggable && !isDisabled) {
      setIsDragging(true);
      onDrag?.(event);
    }
  };
  const handleDragEnd = () => {
    setIsDragging(false);
  };
  const handleDrop = (event) => {
    if (isDraggable && !isDisabled) {
      onDrop?.(event);
    }
  };
  const containerClasses = `
    ${hasOverlay ? "absolute inset-0" : "relative"}
    ${isCentered ? "flex items-center justify-center" : ""}
    ${isResponsive ? "w-full" : ""}
    ${hasFixedWidth ? "" : "w-auto"}
    ${isFullWidth ? "w-full" : ""}
    ${hasFixedHeight ? "" : "h-auto"}
    ${hasMaxWidth ? "max-w-sm" : ""}
    ${hasMinWidth ? "min-w-0" : ""}
    ${hasMaxHeight ? "max-h-32" : ""}
    ${hasMinHeight ? "min-h-0" : ""}
    ${containerClassName}
    ${className}
  `.trim().replace(/\s+/g, " ");
  const feedbackClasses = `
    flex items-center gap-2 rounded-lg font-medium transition-all
    ${sizeClasses2[size2]}
    ${variantClasses2[variant]}
    ${colorClasses2[color2]}
    ${hasBorder ? "border" : ""}
    ${isRounded ? "rounded-lg" : ""}
    ${hasShadow ? "shadow-md" : ""}
    ${isInteractive ? "cursor-pointer hover:shadow-lg" : ""}
    ${isDraggable ? "cursor-move" : ""}
    ${isDisabled ? "opacity-50 cursor-not-allowed" : ""}
    ${isDragging2 ? "opacity-75" : ""}
    ${animationClasses.pulse}
    ${animationClasses.bounce}
    ${animationClasses.fade}
    ${animationClasses.slide}
    ${animationClasses.scale}
    ${animationClasses.rotation}
  `.trim().replace(/\s+/g, " ");
  if (!visible || isLoading) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, style, ...props, children: [
    hasOverlay && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `
          absolute inset-0 rounded-lg
          ${hasBackdropBlur ? "backdrop-blur-sm" : ""}
          ${overlayContent ? "" : "bg-black/60"}
        `.trim().replace(/\s+/g, " "), children: overlayContent }),
    backdropContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: backdropContent }),
    backgroundContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 -z-10", children: backgroundContent }),
    borderContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: borderContent }),
    shadowContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: shadowContent }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: feedbackClasses,
        onClick,
        onFocus,
        onBlur,
        draggable: isDraggable,
        onDragStart: handleDragStart,
        onDragEnd: handleDragEnd,
        onDrop: handleDrop,
        onDragOver: (e2) => e2.preventDefault(),
        style: {
          animationDuration: `${animationDuration}ms`,
          transitionDuration: `${transitionDuration}ms`
        },
        children: [
          iconContent || /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `!text-base ${size2 === "xs" ? "!text-xs" : size2 === "lg" ? "!text-lg" : size2 === "xl" ? "!text-xl" : "!text-base"}`, children: icon }),
          textContent || /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: text }),
          isDismissible && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleDismiss,
              disabled: isDisabled,
              className: "ml-2 p-0.5 text-current hover:bg-current hover:bg-opacity-10 rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
              title: "Dismiss",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3", children: "close" })
            }
          )
        ]
      }
    )
  ] });
};
const PopoverContext = createContext(null);
const usePopover = () => {
  const context = useContext(PopoverContext);
  if (!context) throw new Error("usePopover must be used within a Popover.Root");
  return context;
};
const PopoverRoot = ({
  children,
  isDisabled = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  isRequired = false,
  isReadonly = false,
  hasBackground = true,
  isBordered = true,
  isRounded = true,
  hasShadow = true,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  isFullWidth = false,
  hasHoverEffect = true,
  hasFocusEffect = true,
  hasActiveEffect = true,
  isTransparent = false,
  hasGradient = false,
  customColor,
  className = "",
  style,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  isCentered = false,
  isResponsive = true,
  hasContainer = true,
  hasMaxWidth = true,
  hasMinWidth = false,
  hasFixedHeight = false,
  hasFixedWidth = false,
  hasScrollableOverflow = false,
  hasHiddenOverflow = false,
  hasVisibleOverflow = false,
  hasClipOverflow = false,
  hasScrollOverflow = false,
  hasAutoOverflow = false,
  hasInitialOverflow = false,
  hasInheritOverflow = false,
  hasUnsetOverflow = false,
  hasRevertOverflow = false,
  hasRevertLayerOverflow = false,
  hasLabel = false,
  isLabelHidden = false,
  ...props
}) => {
  const [isOpen, setIsOpen] = useState(false);
  const popoverRef = useRef(null);
  useOnClickOutside(popoverRef, () => setIsOpen(false));
  const containerClasses = [
    "relative inline-block",
    isFullWidth && "w-full",
    isCentered && "text-center",
    isResponsive && "responsive",
    hasContainer && "container",
    hasMaxWidth && "max-w-full",
    hasMinWidth && "min-w-fit",
    hasFixedHeight && "h-auto",
    hasFixedWidth && "w-auto",
    hasScrollableOverflow && "overflow-auto",
    hasHiddenOverflow && "overflow-hidden",
    hasVisibleOverflow && "overflow-visible",
    hasClipOverflow && "overflow-clip",
    hasScrollOverflow && "overflow-scroll",
    hasAutoOverflow && "overflow-auto",
    hasInitialOverflow && "overflow-initial",
    hasInheritOverflow && "overflow-inherit",
    hasUnsetOverflow && "overflow-unset",
    hasRevertOverflow && "overflow-revert",
    hasRevertLayerOverflow && "overflow-revert-layer",
    hasLabel && "has-label",
    isLabelHidden && "label-hidden",
    className
  ].filter(Boolean).join(" ");
  const containerStyles = {
    ...style,
    ...customColor && { backgroundColor: customColor },
    ...hasFixedHeight && { height: "auto" },
    ...hasFixedWidth && { width: "auto" },
    ...hasMaxWidth && { maxWidth: "100%" },
    ...hasMinWidth && { minWidth: "fit-content" }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContext.Provider, { value: { isOpen, setIsOpen }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: popoverRef,
      className: containerClasses,
      style: containerStyles,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      ...props,
      children
    }
  ) });
};
PopoverRoot.displayName = "Popover.Root";
const PopoverTrigger = ({
  children,
  isDisabled = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  isRequired = false,
  isReadonly = false,
  hasBackground = true,
  isBordered = true,
  isRounded = true,
  hasShadow = true,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  isFullWidth = false,
  hasHoverEffect = true,
  hasFocusEffect = true,
  hasActiveEffect = true,
  isTransparent = false,
  hasGradient = false,
  customColor,
  className = "",
  style,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  ...props
}) => {
  const { isOpen, setIsOpen } = usePopover();
  const child = React__default.Children.only(children);
  const triggerClasses = [
    isDisabled && "opacity-50 cursor-not-allowed",
    isLoading && "animate-pulse",
    isError && "border-system-error text-system-error-dark dark:text-system-error-light-text",
    isWarning && "border-system-warning text-system-warning-dark dark:text-system-warning-light-text",
    isSuccess && "border-system-success text-system-success-dark dark:text-system-success-light-text",
    isInfo && "border-system-info text-system-info-dark dark:text-system-info-light-text",
    isRequired && "required",
    isReadonly && "cursor-default",
    hasBackground && "bg-bg-primary dark:bg-dark-bg-primary",
    isBordered && "border border-border-color dark:border-dark-border-color",
    isRounded && "rounded",
    hasShadow && "shadow",
    hasBackdropBlur && "backdrop-blur-sm",
    hasGlassMorphism && "bg-white/20 backdrop-blur-md",
    hasMinHeight && "min-h-fit",
    isFullWidth && "w-full",
    hasHoverEffect && "",
    hasFocusEffect && "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    hasActiveEffect && "",
    isTransparent && "bg-transparent",
    hasGradient && "bg-gradient-to-r from-brand-navy to-brand-blue dark:from-dark-brand-orange dark:to-dark-brand-yellow",
    customColor && "custom-color",
    className
  ].filter(Boolean).join(" ");
  const triggerStyles = {
    ...style,
    ...customColor && { backgroundColor: customColor }
  };
  return React__default.cloneElement(child, {
    onClick: (e2) => {
      if (isDisabled || isLoading) return;
      e2.preventDefault();
      setIsOpen((prev) => !prev);
      child.props.onClick?.(e2);
      onClick?.(e2);
    },
    onFocus: (e2) => {
      if (isDisabled || isLoading) return;
      child.props.onFocus?.(e2);
      onFocus?.(e2);
    },
    onBlur: (e2) => {
      child.props.onBlur?.(e2);
      onBlur?.(e2);
    },
    onMouseEnter: (e2) => {
      child.props.onMouseEnter?.(e2);
      onMouseEnter?.(e2);
    },
    onMouseLeave: (e2) => {
      child.props.onMouseLeave?.(e2);
      onMouseLeave?.(e2);
    },
    onMouseDown: (e2) => {
      child.props.onMouseDown?.(e2);
      onMouseDown?.(e2);
    },
    onMouseUp: (e2) => {
      child.props.onMouseUp?.(e2);
      onMouseUp?.(e2);
    },
    onDoubleClick: (e2) => {
      child.props.onDoubleClick?.(e2);
      onDoubleClick?.(e2);
    },
    onKeyDown: (e2) => {
      child.props.onKeyDown?.(e2);
      onKeyDown?.(e2);
    },
    onKeyUp: (e2) => {
      child.props.onKeyUp?.(e2);
      onKeyUp?.(e2);
    },
    onKeyPress: (e2) => {
      child.props.onKeyPress?.(e2);
      onKeyPress?.(e2);
    },
    className: `${child.props.className || ""} ${triggerClasses}`.trim(),
    style: { ...child.props.style, ...triggerStyles },
    "aria-haspopup": "dialog",
    "aria-expanded": isOpen,
    "data-state": isOpen ? "open" : "closed",
    "aria-disabled": isDisabled,
    "aria-busy": isLoading,
    ...props
  });
};
PopoverTrigger.displayName = "Popover.Trigger";
const PopoverContent = ({
  children,
  position = "bottom",
  size: size2 = "md",
  color: color2 = "default",
  isDisabled = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  isRequired = false,
  isReadonly = false,
  hasBackground = true,
  isBordered = true,
  isRounded = true,
  hasShadow = true,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  isFullWidth = false,
  hasHoverEffect = true,
  hasFocusEffect = true,
  hasActiveEffect = true,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasArrow = false,
  hasDelay = false,
  hasFadeEffect = true,
  className = "",
  style,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  delay: delay3 = 0,
  maxWidth = "lg",
  isInteractive = true,
  hasFollowCursor = false,
  hasCloseButton = false,
  hasTitle = false,
  title,
  hasDescription = false,
  description,
  hasHelpText = false,
  helpText,
  hasValidationMessage = false,
  validationMessage,
  hasRequiredIndicator = false,
  hasDisabledState = false,
  hasReadonlyState = false,
  hasLoadingState = false,
  hasSuccessState = false,
  hasWarningState = false,
  hasErrorState = false,
  hasInfoState = false,
  hasNeutralState = false,
  hasPrimaryState = false,
  hasSecondaryState = false,
  hasTertiaryState = false,
  hasQuaternaryState = false,
  hasQuinaryState = false,
  hasSenaryState = false,
  hasSeptenaryState = false,
  hasOctonaryState = false,
  hasNonaryState = false,
  hasDenaryState = false,
  hasPadding = true,
  hasMargin = true,
  isCentered = false,
  isResponsive = true,
  hasContainer = true,
  hasMaxWidth = true,
  hasMinWidth = false,
  hasFixedHeight = false,
  hasFixedWidth = false,
  hasScrollableOverflow = false,
  hasHiddenOverflow = false,
  hasVisibleOverflow = false,
  hasClipOverflow = false,
  hasScrollOverflow = false,
  hasAutoOverflow = false,
  hasInitialOverflow = false,
  hasInheritOverflow = false,
  hasUnsetOverflow = false,
  hasRevertOverflow = false,
  hasRevertLayerOverflow = false,
  hasLabel = false,
  isLabelHidden = false,
  ...props
}) => {
  const { isOpen } = usePopover();
  const positionClasses = {
    "top": "bottom-full left-1/2 -translate-x-1/2 mb-2 origin-bottom",
    "top-start": "bottom-full left-0 mb-2 origin-bottom-left",
    "top-end": "bottom-full right-0 mb-2 origin-bottom-right",
    "bottom": "top-full left-1/2 -translate-x-1/2 mt-2 origin-top",
    "bottom-start": "top-full left-0 mt-2 origin-top-left",
    "bottom-end": "top-full right-0 mt-2 origin-top-right",
    "left": "right-full top-1/2 -translate-y-1/2 mr-2 origin-right",
    "left-start": "right-full top-0 mr-2 origin-top-right",
    "left-end": "right-full bottom-0 mr-2 origin-bottom-right",
    "right": "left-full top-1/2 -translate-y-1/2 ml-2 origin-left",
    "right-start": "left-full top-0 ml-2 origin-top-left",
    "right-end": "left-full bottom-0 ml-2 origin-bottom-left"
  };
  const sizeClasses2 = {
    xs: "max-w-xs p-2 text-xs",
    sm: "max-w-sm p-3 text-sm",
    md: "max-w-md p-4 text-base",
    lg: "max-w-lg p-5 text-lg",
    xl: "max-w-xl p-6 text-xl"
  };
  const colorClasses2 = {
    default: "bg-bg-secondary dark:bg-dark-bg-secondary border-border-color dark:border-dark-border-color",
    primary: "bg-brand-navy dark:bg-dark-brand-orange text-white border-brand-navy dark:border-dark-brand-orange",
    accent: "bg-brand-blue dark:bg-dark-brand-yellow text-white border-brand-blue dark:border-dark-brand-yellow",
    info: "bg-system-info text-system-info-light-text border-system-info",
    success: "bg-system-success text-system-success-light-text border-system-success",
    error: "bg-system-error text-system-error-light-text border-system-error",
    warning: "bg-system-warning text-system-warning-light-text border-system-warning",
    danger: "bg-system-error text-system-error-light-text border-system-error"
  };
  const arrowPositionClasses = {
    top: "bottom-[-4px] left-1/2 -translate-x-1/2 border-l-transparent border-r-transparent",
    "top-start": "bottom-[-4px] left-0 border-l-transparent border-r-transparent",
    "top-end": "bottom-[-4px] right-0 border-l-transparent border-r-transparent",
    bottom: "top-[-4px] left-1/2 -translate-x-1/2 border-l-transparent border-r-transparent",
    "bottom-start": "top-[-4px] left-0 border-l-transparent border-r-transparent",
    "bottom-end": "top-[-4px] right-0 border-l-transparent border-r-transparent",
    left: "right-[-4px] top-1/2 -translate-y-1/2 border-t-transparent border-b-transparent",
    "left-start": "right-[-4px] top-0 border-t-transparent border-b-transparent",
    "left-end": "right-[-4px] bottom-0 border-t-transparent border-b-transparent",
    right: "left-[-4px] top-1/2 -translate-y-1/2 border-t-transparent border-b-transparent",
    "right-start": "left-[-4px] top-0 border-t-transparent border-b-transparent",
    "right-end": "left-[-4px] bottom-0 border-t-transparent border-b-transparent"
  };
  const contentClasses = [
    "absolute z-[9999] rounded-lg shadow-2xl focus:outline-none",
    sizeClasses2[size2],
    colorClasses2[color2],
    isDisabled && "opacity-50 cursor-not-allowed",
    isLoading && "animate-pulse",
    isError && "border-system-error text-system-error-dark dark:text-system-error-light-text",
    isWarning && "border-system-warning text-system-warning-dark dark:text-system-warning-light-text",
    isSuccess && "border-system-success text-system-success-dark dark:text-system-success-light-text",
    isInfo && "border-system-info text-system-info-dark dark:text-system-info-light-text",
    isRequired && "required",
    isReadonly && "cursor-default",
    hasBackground && "bg-bg-secondary dark:bg-dark-bg-secondary",
    isBordered && "border border-border-color dark:border-dark-border-color",
    isRounded && "rounded-lg",
    hasShadow && "shadow-2xl",
    hasBackdropBlur && "backdrop-blur-sm",
    hasGlassMorphism && "bg-white/20 backdrop-blur-md",
    hasMinHeight && "min-h-fit",
    isFullWidth && "w-full",
    hasHoverEffect && "",
    hasFocusEffect && "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    hasActiveEffect && "",
    isTransparent && "bg-transparent",
    hasGradient && "bg-gradient-to-r from-brand-navy to-brand-blue dark:from-dark-brand-orange dark:to-dark-brand-yellow",
    customColor && "custom-color",
    hasPadding && "p-4",
    hasMargin && "m-2",
    isCentered && "text-center",
    isResponsive && "responsive",
    hasContainer && "container",
    hasMaxWidth && `max-w-${maxWidth}`,
    hasMinWidth && "min-w-fit",
    hasFixedHeight && "h-auto",
    hasFixedWidth && "w-auto",
    hasScrollableOverflow && "overflow-auto",
    hasHiddenOverflow && "overflow-hidden",
    hasVisibleOverflow && "overflow-visible",
    hasClipOverflow && "overflow-clip",
    hasScrollOverflow && "overflow-scroll",
    hasAutoOverflow && "overflow-auto",
    hasInitialOverflow && "overflow-initial",
    hasInheritOverflow && "overflow-inherit",
    hasUnsetOverflow && "overflow-unset",
    hasRevertOverflow && "overflow-revert",
    hasRevertLayerOverflow && "overflow-revert-layer",
    hasLabel && "has-label",
    isLabelHidden && "label-hidden",
    positionClasses[position],
    className
  ].filter(Boolean).join(" ");
  const contentStyles = {
    ...style,
    ...customColor && { backgroundColor: customColor },
    ...hasFixedHeight && { height: "auto" },
    ...hasFixedWidth && { width: "auto" },
    ...hasMaxWidth && { maxWidth: typeof maxWidth === "string" ? maxWidth : `${maxWidth}px` },
    ...hasMinWidth && { minWidth: "fit-content" },
    ...delay3 && { transitionDelay: `${delay3}ms` }
  };
  const visibilityClasses = isOpen ? "opacity-100" : "opacity-0 pointer-events-none";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      role: "dialog",
      className: `${contentClasses} ${visibilityClasses}`,
      style: contentStyles,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      ...props,
      children: [
        hasTitle && title && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-semibold mb-2 text-lg", children: [
          title,
          hasRequiredIndicator && isRequired && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        hasDescription && description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400 mb-3", children: description }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "popover-content", children }),
        hasHelpText && helpText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500 dark:text-gray-500 mt-2", children: helpText }),
        hasValidationMessage && validationMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-red-500 mt-2", children: validationMessage }),
        hasArrow && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute w-0 h-0 border-4 ${arrowPositionClasses[position]} ${colorClasses2[color2].split(" ")[0]}` })
      ]
    }
  );
};
PopoverContent.displayName = "Popover.Content";
const Popover = Object.assign(PopoverRoot, {
  Trigger: PopoverTrigger,
  Content: PopoverContent
});
const formatPresets = {
  short: { month: "numeric", day: "numeric", year: "2-digit" },
  medium: { month: "short", day: "numeric", year: "numeric" },
  long: { month: "long", day: "numeric", year: "numeric" },
  full: { weekday: "long", month: "long", day: "numeric", year: "numeric" },
  iso: "yyyy-MM-dd",
  us: "MM/dd/yyyy",
  eu: "dd/MM/yyyy",
  uk: "dd MMM yyyy",
  numeric: "yyyy-MM-dd"
};
const formatDateWithOptions = (date, dateFormat = "medium", locale = "en-US") => {
  if (!date) return "";
  if (typeof dateFormat === "function") {
    return dateFormat(date);
  }
  if (dateFormat in formatPresets) {
    const preset = formatPresets[dateFormat];
    if (typeof preset === "string") {
      try {
        return format(date, preset);
      } catch {
        return date.toLocaleDateString(locale);
      }
    }
    return date.toLocaleDateString(locale, preset);
  }
  try {
    return format(date, dateFormat);
  } catch {
    return date.toLocaleDateString(locale, formatPresets.medium);
  }
};
const formatDate = (date) => {
  return formatDateWithOptions(date, "medium");
};
const parseDateInput = (input, formatHint) => {
  if (!input) return void 0;
  if (input instanceof Date) {
    return isNaN(input.getTime()) ? void 0 : input;
  }
  const str = input.trim();
  if (!str) return void 0;
  const isoMatch = str.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/);
  if (isoMatch) {
    const [, year, month, day] = isoMatch;
    const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
    return isNaN(date.getTime()) ? void 0 : date;
  }
  const slashMatch = str.match(/^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/);
  if (slashMatch) {
    const [, first, second, year] = slashMatch;
    let month, day;
    if (formatHint === "eu") {
      day = parseInt(first);
      month = parseInt(second);
    } else if (formatHint === "us") {
      month = parseInt(first);
      day = parseInt(second);
    } else {
      if (parseInt(first) > 12) {
        day = parseInt(first);
        month = parseInt(second);
      } else if (parseInt(second) > 12) {
        month = parseInt(first);
        day = parseInt(second);
      } else {
        month = parseInt(first);
        day = parseInt(second);
      }
    }
    const date = new Date(parseInt(year), month - 1, day);
    return isNaN(date.getTime()) ? void 0 : date;
  }
  const months = {
    jan: 0,
    january: 0,
    feb: 1,
    february: 1,
    mar: 2,
    march: 2,
    apr: 3,
    april: 3,
    may: 4,
    jun: 5,
    june: 5,
    jul: 6,
    july: 6,
    aug: 7,
    august: 7,
    sep: 8,
    sept: 8,
    september: 8,
    oct: 9,
    october: 9,
    nov: 10,
    november: 10,
    dec: 11,
    december: 11
  };
  const ukMatch = str.match(/^(\d{1,2})[\s-]([a-zA-Z]{3,9})[\s,-]*(\d{4})$/);
  if (ukMatch) {
    const [, day, monthStr, year] = ukMatch;
    const monthNum = months[monthStr.toLowerCase()];
    if (monthNum !== void 0) {
      const date = new Date(parseInt(year), monthNum, parseInt(day));
      return isNaN(date.getTime()) ? void 0 : date;
    }
  }
  const naturalMatch = str.match(/^([a-zA-Z]{3,9})[\s]+(\d{1,2})[,\s]+(\d{4})$/);
  if (naturalMatch) {
    const [, monthStr, day, year] = naturalMatch;
    const monthNum = months[monthStr.toLowerCase()];
    if (monthNum !== void 0) {
      const date = new Date(parseInt(year), monthNum, parseInt(day));
      return isNaN(date.getTime()) ? void 0 : date;
    }
  }
  const parsed = new Date(str);
  return isNaN(parsed.getTime()) ? void 0 : parsed;
};
const getPresetRanges = () => {
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const yesterday = new Date(today);
  yesterday.setDate(today.getDate() - 1);
  const thisWeekStart = new Date(today);
  thisWeekStart.setDate(today.getDate() - today.getDay());
  const thisWeekEnd = new Date(thisWeekStart);
  thisWeekEnd.setDate(thisWeekStart.getDate() + 6);
  const last7DaysStart = new Date(today);
  last7DaysStart.setDate(today.getDate() - 6);
  const last30DaysStart = new Date(today);
  last30DaysStart.setDate(today.getDate() - 29);
  const thisMonthStart = new Date(today.getFullYear(), today.getMonth(), 1);
  const thisMonthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
  const lastMonthDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
  const lastMonthStart = new Date(lastMonthDate.getFullYear(), lastMonthDate.getMonth(), 1);
  const lastMonthEnd = new Date(lastMonthDate.getFullYear(), lastMonthDate.getMonth() + 1, 0);
  const currentQuarter = Math.floor(today.getMonth() / 3);
  const thisQuarterStart = new Date(today.getFullYear(), currentQuarter * 3, 1);
  const thisQuarterEnd = new Date(today.getFullYear(), (currentQuarter + 1) * 3, 0);
  const lastQuarterIndex = currentQuarter === 0 ? 3 : currentQuarter - 1;
  const lastQuarterYear = currentQuarter === 0 ? today.getFullYear() - 1 : today.getFullYear();
  const lastQuarterStart = new Date(lastQuarterYear, lastQuarterIndex * 3, 1);
  const lastQuarterEnd = new Date(lastQuarterYear, (lastQuarterIndex + 1) * 3, 0);
  const thisYearStart = new Date(today.getFullYear(), 0, 1);
  const thisYearEnd = new Date(today.getFullYear(), 11, 31);
  return {
    today: { start: today, end: today },
    yesterday: { start: yesterday, end: yesterday },
    thisWeek: { start: thisWeekStart, end: thisWeekEnd },
    last7Days: { start: last7DaysStart, end: today },
    last30Days: { start: last30DaysStart, end: today },
    thisMonth: { start: thisMonthStart, end: thisMonthEnd },
    lastMonth: { start: lastMonthStart, end: lastMonthEnd },
    thisQuarter: { start: thisQuarterStart, end: thisQuarterEnd },
    lastQuarter: { start: lastQuarterStart, end: lastQuarterEnd },
    thisYear: { start: thisYearStart, end: thisYearEnd }
  };
};
const dateFormatExamples = {
  iso: "yyyy-MM-dd",
  us: "MM/dd/yyyy",
  eu: "dd/MM/yyyy",
  uk: "d MMM yyyy",
  fullMonth: "MMMM d, yyyy",
  shortMonth: "MMM d, yyyy",
  withDay: "EEE, MMM d",
  fullDay: "EEEE, MMMM do, yyyy",
  ordinal: "do 'of' MMMM, yyyy",
  asian: "yyyy/MM/dd",
  dashSeparated: "dd-MMM-yyyy"
};
const DatePickerPopoverContent = ({
  value,
  onChange,
  displayDate,
  setDisplayDate,
  hasTodayButton,
  hasPopoverClearButton,
  onTodayClick,
  onClearClick,
  closeOnSelect,
  calendarVariant,
  calendarSize,
  calendarColor,
  calendarDensity,
  calendarRadius,
  calendarNavigation,
  showWeekNumber,
  weekStartsOn,
  fromYear,
  toYear,
  minDate,
  maxDate
}) => {
  const { setIsOpen } = usePopover();
  const { language: contextLanguage } = useLanguage();
  const handleDateSelect = (date) => {
    onChange(date ?? null);
    if (closeOnSelect && date) {
      setIsOpen(false);
    }
  };
  const handleTodayClick = () => {
    const today = /* @__PURE__ */ new Date();
    setDisplayDate(today);
    onChange(today);
    onTodayClick?.();
    if (closeOnSelect) {
      setIsOpen(false);
    }
  };
  const handleClearClick = () => {
    onChange(null);
    onClearClick?.();
    if (closeOnSelect) {
      setIsOpen(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Calendar$1,
      {
        mode: "single",
        value: value ?? void 0,
        onDateSelect: handleDateSelect,
        displayMonth: displayDate,
        onDisplayMonthChange: setDisplayDate,
        variant: calendarVariant,
        size: calendarSize,
        color: calendarColor,
        density: calendarDensity,
        radius: calendarRadius,
        navigation: calendarNavigation,
        showWeekNumber,
        weekStartsOn,
        fromYear,
        toYear,
        fromDate: minDate,
        toDate: maxDate
      }
    ),
    (hasTodayButton || hasPopoverClearButton) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-2 border-t border-border-color dark:border-dark-border-color flex justify-between gap-2 bg-bg-secondary dark:bg-dark-bg-secondary", children: [
      hasTodayButton && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "text", size: "sm", onClick: handleTodayClick, children: ui_i18n[contextLanguage]?.today || "Today" }),
      hasPopoverClearButton && /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { variant: "text", size: "sm", onClick: handleClearClick, children: ui_i18n[contextLanguage]?.clear || "Clear" })
    ] })
  ] });
};
const DatePicker = ({
  // Core
  value,
  onChange,
  label,
  placeholder = "Select date",
  id: providedId,
  dateFormat = "medium",
  // Design System
  size: size2 = "md",
  inputVariant = "outline",
  color: color2 = "primary",
  labelMode = "top",
  radius = "md",
  // States
  isDisabled = false,
  isLoading = false,
  isError = false,
  isSuccess = false,
  isRequired = false,
  isReadOnly = false,
  isFullWidth = true,
  // Features
  hasClearButton = true,
  hasCalendarIcon = true,
  hasTodayButton = true,
  hasPopoverClearButton = true,
  hasRequiredIndicator = true,
  // Helper Text
  helperText,
  errorMessage,
  successMessage,
  // Date Constraints
  minDate,
  maxDate,
  // Calendar Props
  calendarVariant = "solid",
  calendarSize,
  calendarDensity = "comfortable",
  calendarRadius = "md",
  calendarNavigation = "dropdown",
  showWeekNumber = false,
  weekStartsOn = 0,
  fromYear,
  toYear,
  // Behavior
  closeOnSelect = true,
  position = "bottom-start",
  // Events
  onOpen: _onOpen,
  onClose: _onClose,
  onTodayClick,
  onClearClick,
  onFocus,
  onBlur,
  // Style
  className,
  style,
  // Legacy
  variant: _variant,
  error: error2,
  description
}) => {
  const generatedId = useId$1();
  const id2 = providedId || generatedId;
  const [isFocused, setIsFocused] = useState(false);
  const parsedMinDate = parseDateInput(minDate);
  const parsedMaxDate = parseDateInput(maxDate);
  const getInitialDisplayDate = () => {
    if (value) return value;
    const today = /* @__PURE__ */ new Date();
    if (parsedMaxDate && parsedMaxDate < today) {
      return parsedMaxDate;
    }
    if (parsedMinDate && parsedMinDate > today) {
      return parsedMinDate;
    }
    return today;
  };
  const [displayDate, setDisplayDate] = useState(getInitialDisplayDate);
  const effectiveErrorMessage = errorMessage || error2;
  const effectiveHelperText = helperText || description;
  const effectiveCalendarSize = calendarSize || size2;
  const sizeConfig2 = {
    xs: { height: "h-8", text: "text-xs", icon: "text-sm", padding: "px-2.5", gap: "gap-1.5" },
    sm: { height: "h-9", text: "text-sm", icon: "text-base", padding: "px-3", gap: "gap-2" },
    md: { height: "h-10", text: "text-base", icon: "text-lg", padding: "px-3.5", gap: "gap-2" },
    lg: { height: "h-12", text: "text-lg", icon: "text-xl", padding: "px-4", gap: "gap-2.5" },
    xl: { height: "h-14", text: "text-xl", icon: "text-2xl", padding: "px-5", gap: "gap-3" }
  };
  const radiusConfig2 = {
    none: "rounded-none",
    sm: "rounded-sm",
    md: "rounded-md",
    lg: "rounded-lg",
    xl: "rounded-xl",
    full: "rounded-full"
  };
  const colorConfig2 = {
    primary: {
      focus: "focus:ring-brand-orange focus:border-brand-orange",
      accent: "text-brand-orange",
      bg: "bg-brand-orange/5"
    },
    secondary: {
      focus: "focus:ring-brand-navy-500 focus:border-brand-navy-500 dark:focus:ring-brand-navy-400",
      accent: "text-brand-navy-600 dark:text-brand-navy-400",
      bg: "bg-brand-navy-500/5"
    },
    success: {
      focus: "focus:ring-system-success focus:border-system-success",
      accent: "text-system-success-dark",
      bg: "bg-system-success/5"
    },
    warning: {
      focus: "focus:ring-system-warning focus:border-system-warning",
      accent: "text-system-warning-dark",
      bg: "bg-system-warning/5"
    },
    danger: {
      focus: "focus:ring-system-error focus:border-system-error",
      accent: "text-system-error-dark",
      bg: "bg-system-error/5"
    },
    info: {
      focus: "focus:ring-system-info focus:border-system-info",
      accent: "text-system-info-dark",
      bg: "bg-system-info/5"
    },
    neutral: {
      focus: "focus:ring-text-secondary focus:border-text-secondary",
      accent: "text-text-secondary",
      bg: "bg-bg-tertiary"
    }
  };
  const getInputVariantClasses = () => {
    const base = "transition-all duration-200 ease-in-out";
    switch (inputVariant) {
      case "filled":
        return cn(
          base,
          "bg-bg-tertiary dark:bg-dark-bg-tertiary",
          "border-transparent",
          "hover:bg-bg-secondary dark:hover:bg-dark-bg-secondary",
          isFocused && "bg-bg-primary dark:bg-dark-bg-primary border-b-2",
          radiusConfig2[radius]
        );
      case "underline":
        return cn(
          base,
          "bg-transparent",
          "border-0 border-b-2 border-border-color dark:border-dark-border-color",
          "rounded-none",
          "hover:border-text-secondary dark:hover:border-dark-text-secondary"
        );
      case "flushed":
        return cn(
          base,
          "bg-transparent",
          "border-0 border-b border-border-color dark:border-dark-border-color",
          "rounded-none px-0",
          "hover:border-text-secondary dark:hover:border-dark-text-secondary"
        );
      case "ghost":
        return cn(
          base,
          "bg-transparent",
          "border-transparent",
          "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
          radiusConfig2[radius]
        );
      case "outline":
      default:
        return cn(
          base,
          "bg-bg-primary dark:bg-dark-bg-primary",
          "border border-border-color dark:border-dark-border-color",
          "hover:border-text-secondary dark:hover:border-dark-text-secondary",
          radiusConfig2[radius]
        );
    }
  };
  const getStateClasses = () => {
    if (isDisabled) {
      return "opacity-50 cursor-not-allowed pointer-events-none";
    }
    if (isError) {
      return "border-system-error dark:border-system-error focus:ring-system-error focus:border-system-error";
    }
    if (isSuccess) {
      return "border-system-success dark:border-system-success focus:ring-system-success focus:border-system-success";
    }
    return colorConfig2[color2].focus;
  };
  const handleClear = (e2) => {
    e2.stopPropagation();
    onChange(null);
    onClearClick?.();
  };
  const handleFocus = (e2) => {
    setIsFocused(true);
    onFocus?.(e2);
  };
  const handleBlur = (e2) => {
    setIsFocused(false);
    onBlur?.(e2);
  };
  const inputClasses = cn(
    // Base
    "relative flex items-center w-full cursor-pointer",
    "text-text-primary dark:text-dark-text-primary",
    "focus:outline-none focus:ring-2 focus:ring-offset-0",
    // Size
    sizeConfig2[size2].height,
    sizeConfig2[size2].text,
    sizeConfig2[size2].padding,
    sizeConfig2[size2].gap,
    // Variant
    getInputVariantClasses(),
    // State
    getStateClasses(),
    // Loading
    isLoading && "animate-pulse",
    // Full width
    isFullWidth ? "w-full" : "w-auto",
    className
  );
  const showLabel = label && labelMode !== "none";
  const isFloatingLabel = labelMode === "floating" || labelMode === "inside";
  const hasValue = value !== null;
  const shouldFloatLabel = isFloatingLabel && (hasValue || isFocused);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("relative", isFullWidth ? "w-full" : "w-auto"), children: [
    showLabel && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "label",
      {
        htmlFor: id2,
        className: cn(
          "block text-sm font-medium mb-1.5",
          "text-text-primary dark:text-dark-text-primary",
          isError && "text-system-error-dark",
          isSuccess && "text-system-success-dark"
        ),
        children: [
          label,
          isRequired && hasRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Popover.Trigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          id: id2,
          type: "button",
          disabled: isDisabled || isLoading || isReadOnly,
          className: inputClasses,
          onFocus: handleFocus,
          onBlur: handleBlur,
          style,
          "aria-label": label || placeholder,
          "aria-invalid": isError,
          "aria-required": isRequired,
          children: [
            showLabel && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                className: cn(
                  "absolute left-3 transition-all duration-200 pointer-events-none",
                  "text-text-secondary dark:text-dark-text-secondary",
                  shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-1/2 -translate-y-1/2",
                  shouldFloatLabel && colorConfig2[color2].accent,
                  isError && "text-system-error-dark",
                  isSuccess && "text-system-success-dark"
                ),
                children: [
                  label,
                  isRequired && hasRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
                ]
              }
            ),
            showLabel && labelMode === "inline" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-text-secondary dark:text-dark-text-secondary font-medium mr-2 flex-shrink-0", children: [
              label,
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("flex-1 text-left truncate", isFloatingLabel && !hasValue && "opacity-0"), children: value ? formatDateWithOptions(value, dateFormat) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-text-secondary/60 dark:text-dark-text-secondary/60 italic", children: placeholder }) }),
            value && !isDisabled && !isReadOnly && hasClearButton && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                role: "button",
                tabIndex: 0,
                onClick: handleClear,
                onKeyDown: (e2) => {
                  if (e2.key === "Enter" || e2.key === " ") {
                    e2.preventDefault();
                    handleClear(e2);
                  }
                },
                className: cn(
                  "p-1 rounded-full flex-shrink-0",
                  "text-text-secondary/60 hover:text-text-primary",
                  "hover:bg-black/10 dark:hover:bg-white/10",
                  "cursor-pointer transition-colors",
                  "focus:outline-none focus:ring-2 focus:ring-brand-orange"
                ),
                "aria-label": "Clear date",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: sizeConfig2[size2].icon, children: "close" })
              }
            ),
            isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "animate-spin text-text-secondary", children: "progress_activity" }) }),
            hasCalendarIcon && !isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon,
              {
                className: cn(
                  "flex-shrink-0 text-text-secondary/60 dark:text-dark-text-secondary/60",
                  isFocused && colorConfig2[color2].accent
                ),
                children: "calendar_today"
              }
            ),
            isError && !isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "flex-shrink-0 text-system-error", children: "error" }),
            isSuccess && !isLoading && !isError && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "flex-shrink-0 text-system-success", children: "check_circle" })
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Popover.Content,
        {
          position,
          isFullWidth: false,
          hasVisibleOverflow: true,
          className: "!p-0 !min-w-fit",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DatePickerPopoverContent,
            {
              value,
              onChange,
              displayDate,
              setDisplayDate,
              hasTodayButton,
              hasPopoverClearButton,
              onTodayClick,
              onClearClick,
              closeOnSelect,
              calendarVariant,
              calendarSize: effectiveCalendarSize,
              calendarColor: color2,
              calendarDensity,
              calendarRadius,
              calendarNavigation,
              showWeekNumber,
              weekStartsOn,
              fromYear,
              toYear,
              minDate: parsedMinDate,
              maxDate: parsedMaxDate
            }
          )
        }
      )
    ] }),
    (effectiveHelperText || effectiveErrorMessage || successMessage) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1.5", children: [
      isError && effectiveErrorMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-system-error-dark dark:text-system-error-light-text flex items-center gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "error" }),
        effectiveErrorMessage
      ] }),
      isSuccess && successMessage && !isError && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-system-success-dark dark:text-system-success flex items-center gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "check_circle" }),
        successMessage
      ] }),
      effectiveHelperText && !isError && !isSuccess && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: effectiveHelperText })
    ] })
  ] });
};
const getRadiusClass = (radius) => {
  switch (radius) {
    case "none":
      return "rounded-none";
    case "sm":
      return "rounded-sm";
    case "md":
      return "rounded";
    case "lg":
      return "rounded-lg";
    case "xl":
      return "rounded-xl";
    case "full":
      return "rounded-full";
    default:
      return "rounded";
  }
};
const StyledInput = React__default.forwardRef(({ children, className = "", radius = "md", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    ref,
    className: `
      w-full h-12 px-4 text-left
      bg-white dark:bg-dark-bg-secondary
      border border-border-color dark:border-dark-border-color
      ${getRadiusClass(radius)}
      text-text-primary dark:text-dark-text-primary
      placeholder:text-text-secondary/60 dark:placeholder:text-dark-text-secondary/60
      focus:outline-none focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange
      disabled:opacity-50 disabled:cursor-not-allowed
      ${className}
    `,
    ...props,
    children
  }
));
const StyledCalendar = React__default.forwardRef(({ children, className = "", radius = "md", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref,
    className: `
      bg-white dark:bg-dark-bg-secondary
      border border-border-color dark:border-dark-border-color
      ${getRadiusClass(radius)} shadow-md
      p-4 min-w-[320px]
      ${className}
    `,
    ...props,
    children
  }
));
const StyledCalendarHeader = ({ children, className = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex items-center justify-between mb-4 ${className}`, children });
const StyledCalendarGrid = ({ children, className = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `grid grid-cols-7 gap-1 ${className}`, children });
const StyledDayButton = React__default.forwardRef(({ children, className = "", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    ref,
    className: `
      w-10 h-10 text-sm rounded-md
      text-text-primary dark:text-dark-text-primary
      focus:outline-none focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange
      disabled:opacity-50 disabled:cursor-not-allowed
      ${className}
    `,
    ...props,
    children
  }
));
const StyledWeekdayHeader = ({ children, className = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `text-center text-sm font-medium text-text-secondary dark:text-dark-text-secondary py-2 ${className}`, children });
const StyledActionButton = React__default.forwardRef(({ children, className = "", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    ref,
    className: `
      px-3 py-1.5 text-sm rounded-md
      text-brand-orange dark:text-dark-brand-orange
      focus:outline-none focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange
      disabled:opacity-50 disabled:cursor-not-allowed
      ${className}
    `,
    ...props,
    children
  }
));
const Calendar = ({
  displayDate,
  onDisplayDateChange,
  selectedValue,
  onDateSelect,
  minDate,
  maxDate,
  isDateDisabled,
  variant,
  firstDayOfWeek = 0,
  closeOnSelect = true,
  radius = "md"
}) => {
  const { setIsOpen } = usePopover();
  const [focusedDate, setFocusedDate] = useState(null);
  const calendarRef = useRef(null);
  const dayButtonsRef = useRef([]);
  const monthStart = startOfMonth(displayDate);
  const monthEnd = endOfMonth(displayDate);
  const startDate = startOfWeek(monthStart, { weekStartsOn: firstDayOfWeek });
  const endDate = endOfWeek(monthEnd, { weekStartsOn: firstDayOfWeek });
  const dateFormat = "MMM yyyy";
  const weekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  const reorderedWeekdays = firstDayOfWeek === 1 ? [...weekdays.slice(1), weekdays[0]] : weekdays;
  const days = [];
  let day = startDate;
  while (day <= endDate) {
    days.push(new Date(day));
    day = addDays(day, 1);
  }
  const isDateSelected = useCallback((date) => {
    if (!selectedValue) return false;
    if (variant === "single" && selectedValue instanceof Date) {
      return isSameDay(date, selectedValue);
    }
    if (variant === "range" && selectedValue && "start" in selectedValue && "end" in selectedValue) {
      const range = selectedValue;
      if (range.start && range.end) {
        return isSameDay(date, range.start) || isSameDay(date, range.end) || date > range.start && date < range.end;
      }
      if (range.start) {
        return isSameDay(date, range.start);
      }
    }
    return false;
  }, [selectedValue, variant]);
  const isDateInRange = useCallback((date) => {
    if (variant !== "range" || !selectedValue || !("start" in selectedValue)) return false;
    const range = selectedValue;
    if (range.start && range.end) {
      return date > range.start && date < range.end;
    }
    return false;
  }, [selectedValue, variant]);
  const isDateDisabledCheck = useCallback((date) => {
    if (minDate && isBefore(date, startOfDay(minDate))) return true;
    if (maxDate && isAfter(date, endOfDay(maxDate))) return true;
    if (isDateDisabled && isDateDisabled(date)) return true;
    return false;
  }, [minDate, maxDate, isDateDisabled]);
  const handleKeyDown = useCallback((e2, date, index2) => {
    const totalDays = days.length;
    let newIndex = index2;
    let newDate = date;
    switch (e2.key) {
      case "ArrowLeft":
        e2.preventDefault();
        newIndex = Math.max(0, index2 - 1);
        newDate = days[newIndex];
        break;
      case "ArrowRight":
        e2.preventDefault();
        newIndex = Math.min(totalDays - 1, index2 + 1);
        newDate = days[newIndex];
        break;
      case "ArrowUp":
        e2.preventDefault();
        newIndex = Math.max(0, index2 - 7);
        newDate = days[newIndex];
        break;
      case "ArrowDown":
        e2.preventDefault();
        newIndex = Math.min(totalDays - 1, index2 + 7);
        newDate = days[newIndex];
        break;
      case "Home":
        e2.preventDefault();
        newIndex = Math.floor(index2 / 7) * 7;
        newDate = days[newIndex];
        break;
      case "End":
        e2.preventDefault();
        newIndex = Math.min(totalDays - 1, Math.floor(index2 / 7) * 7 + 6);
        newDate = days[newIndex];
        break;
      case "PageUp":
        e2.preventDefault();
        onDisplayDateChange(subMonths(displayDate));
        return;
      case "PageDown":
        e2.preventDefault();
        onDisplayDateChange(addMonths(displayDate, 1));
        return;
      case "Enter":
      case " ":
        e2.preventDefault();
        if (!isDateDisabledCheck(date)) {
          onDateSelect(date);
          if (closeOnSelect && variant === "single") {
            setIsOpen(false);
          }
        }
        return;
      case "Escape":
        e2.preventDefault();
        setIsOpen(false);
        return;
    }
    if (newDate && !isDateDisabledCheck(newDate)) {
      setFocusedDate(newDate);
      dayButtonsRef.current[newIndex]?.focus();
    }
  }, [days, displayDate, onDisplayDateChange, onDateSelect, isDateDisabledCheck]);
  const handlePrevMonth = () => {
    onDisplayDateChange(subMonths(displayDate));
  };
  const handleNextMonth = () => {
    onDisplayDateChange(addMonths(displayDate, 1));
  };
  const handleTodayClick = () => {
    const today = /* @__PURE__ */ new Date();
    onDisplayDateChange(today);
    onDateSelect(today);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    StyledCalendar,
    {
      ref: calendarRef,
      role: "grid",
      radius,
      "aria-label": `Calendar for ${format(displayDate, dateFormat)}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(StyledCalendarHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant: "ghost",
              size: "sm",
              onClick: handlePrevMonth,
              "aria-label": "Previous month",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "chevron_left" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "text-lg font-semibold text-text-primary dark:text-dark-text-primary",
              onClick: () => {
              },
              children: format(displayDate, dateFormat)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant: "ghost",
              size: "sm",
              onClick: handleNextMonth,
              "aria-label": "Next month",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "chevron_right" })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(StyledCalendarGrid, { children: reorderedWeekdays.map((weekday) => /* @__PURE__ */ jsxRuntimeExports.jsx(StyledWeekdayHeader, { children: weekday }, weekday)) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(StyledCalendarGrid, { children: days.map((date, index2) => {
          const isSelected = isDateSelected(date);
          const isInRange = isDateInRange(date);
          const isCurrentMonth = isSameMonth(date, displayDate);
          const isTodayDate = isToday(date);
          const isDisabled = isDateDisabledCheck(date);
          const isFocused = focusedDate && isSameDay(date, focusedDate);
          let className = "";
          if (isSelected) {
            className = "bg-brand-orange text-white";
          } else if (isInRange) {
            className = "bg-brand-orange/20 text-brand-orange";
          } else if (isTodayDate) {
            className = "ring-2 ring-brand-orange text-brand-orange";
          } else if (!isCurrentMonth) {
            className = "text-text-secondary/50 dark:text-dark-text-secondary/50";
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            StyledDayButton,
            {
              ref: (el) => {
                dayButtonsRef.current[index2] = el;
              },
              className,
              onClick: () => {
                if (!isDisabled) {
                  onDateSelect(date);
                  if (closeOnSelect && variant === "single") {
                    setIsOpen(false);
                  }
                }
              },
              onKeyDown: (e2) => handleKeyDown(e2, date, index2),
              disabled: isDisabled,
              "aria-selected": isSelected,
              "aria-disabled": isDisabled,
              "aria-label": `${format(date, "MMMM d, yyyy")}${isTodayDate ? ", today" : ""}`,
              tabIndex: isFocused ? 0 : -1,
              children: date.getDate()
            },
            date.toISOString()
          );
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between mt-4 pt-4 border-t border-border-color dark:border-dark-border-color", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledActionButton, { onClick: handleTodayClick, children: "Today" }) })
      ]
    }
  );
};
const DatePickerTrigger = ({ value, placeholder, isDisabled, showClearButton, dateFormat, variant, onClear, inputRef, radius = "md" }) => {
  const { isOpen, setIsOpen } = usePopover();
  const formatDisplayValue = () => {
    if (!value) return placeholder;
    if (variant === "single" && value instanceof Date) {
      return format(value, dateFormat);
    }
    if (variant === "range" && value && "start" in value) {
      const range = value;
      if (range.start && range.end) {
        return `${format(range.start, dateFormat)} - ${format(range.end, dateFormat)}`;
      }
      if (range.start) {
        return format(range.start, dateFormat);
      }
    }
    return placeholder;
  };
  const handleKeyDown = (e2) => {
    switch (e2.key) {
      case "Enter":
      case " ":
        e2.preventDefault();
        if (!isDisabled) {
          setIsOpen(!isOpen);
        }
        break;
      case "Escape":
        if (isOpen) {
          setIsOpen(false);
        }
        break;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StyledInput,
    {
      ref: inputRef,
      radius,
      onClick: () => !isDisabled && setIsOpen(!isOpen),
      onKeyDown: handleKeyDown,
      disabled: isDisabled,
      "aria-expanded": isOpen,
      "aria-haspopup": "dialog",
      "aria-label": `Date picker, ${formatDisplayValue()}`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: value ? "text-text-primary dark:text-dark-text-primary" : "text-text-secondary/60 dark:text-dark-text-secondary/60", children: formatDisplayValue() }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          value && showClearButton && !isDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: (e2) => {
                e2.stopPropagation();
                onClear();
              },
              className: "p-1 rounded-full",
              "aria-label": "Clear date",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "close" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: "text-text-secondary dark:text-dark-text-secondary", children: "calendar_today" })
        ] })
      ] })
    }
  );
};
const EnhancedDatePicker = ({
  variant = "single",
  value,
  onChange,
  minDate,
  maxDate,
  isDateDisabled,
  placeholder = "Select date",
  isDisabled = false,
  className = "",
  closeOnSelect = true,
  showClearButton = true,
  dateFormat = "MMM d, yyyy",
  firstDayOfWeek = 0,
  position = "bottom-start",
  align = "left",
  radius = "md"
}) => {
  const [displayDate, setDisplayDate] = useState(() => {
    if (variant === "single" && value instanceof Date) {
      return value;
    }
    if (variant === "range" && value && "start" in value && value.start) {
      return value.start;
    }
    return /* @__PURE__ */ new Date();
  });
  const inputRef = useRef(null);
  useEffect(() => {
    if (variant === "single" && value instanceof Date) {
      setDisplayDate(value);
    } else if (variant === "range" && value && "start" in value && value.start) {
      setDisplayDate(value.start);
    }
  }, [value, variant]);
  const handleDateSelect = (date) => {
    if (variant === "single") {
      onChange(date);
    } else {
      const currentRange = value;
      if (!currentRange || !currentRange.start || currentRange.start && currentRange.end) {
        onChange({ start: date, end: null });
      } else {
        const start = currentRange.start;
        const end = date;
        onChange({ start: start < end ? start : end, end: start < end ? end : start });
      }
    }
  };
  const handleClear = () => {
    onChange(null);
  };
  const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `relative ${alignmentClass} ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Popover.Trigger, { hasHoverEffect: false, hasFocusEffect: false, hasActiveEffect: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DatePickerTrigger,
      {
        value,
        placeholder,
        isDisabled,
        showClearButton,
        dateFormat,
        variant,
        onClear: handleClear,
        inputRef,
        radius
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Popover.Content, { position, isFullWidth: true, className: "!p-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Calendar,
      {
        displayDate,
        onDisplayDateChange: setDisplayDate,
        selectedValue: value,
        onDateSelect: handleDateSelect,
        minDate,
        maxDate,
        isDateDisabled,
        variant,
        firstDayOfWeek,
        closeOnSelect,
        radius
      }
    ) })
  ] }) });
};
const PresetPanel = ({ onSelect, color: color2 }) => {
  const presets = [
    { label: "Today", range: getPresetRanges().today },
    { label: "Yesterday", range: getPresetRanges().yesterday },
    { label: "This Week", range: getPresetRanges().thisWeek },
    { label: "Last 7 Days", range: getPresetRanges().last7Days },
    { label: "This Month", range: getPresetRanges().thisMonth },
    { label: "Last Month", range: getPresetRanges().lastMonth },
    { label: "Last 30 Days", range: getPresetRanges().last30Days },
    { label: "This Quarter", range: getPresetRanges().thisQuarter }
  ];
  const colorHoverClasses = {
    primary: "hover:bg-brand-orange/10 hover:text-brand-orange",
    secondary: "hover:bg-brand-navy-500/10 hover:text-brand-navy-700 dark:hover:text-brand-navy-300",
    success: "hover:bg-system-success/10 hover:text-system-success-dark",
    warning: "hover:bg-system-warning-light/60 hover:text-system-warning-dark dark:hover:bg-system-warning-dark-bg/30 dark:hover:text-system-warning-light-text",
    danger: "hover:bg-system-error/10 hover:text-system-error-dark",
    info: "hover:bg-system-info/10 hover:text-system-info-dark",
    neutral: "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full sm:w-40 p-3 border-b sm:border-b-0 sm:border-r border-border-color dark:border-dark-border-color bg-bg-secondary dark:bg-dark-bg-secondary", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs font-semibold text-text-secondary dark:text-dark-text-secondary uppercase tracking-wider mb-2", children: "Quick Select" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "space-y-0.5", children: presets.map(({ label, range }) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => onSelect(range),
        className: cn(
          "w-full text-left px-2.5 py-1.5 text-sm rounded-md transition-colors",
          "text-text-primary dark:text-dark-text-primary",
          colorHoverClasses[color2]
        ),
        children: label
      }
    ) }, label)) })
  ] });
};
const DateRangePicker = ({
  // Core
  value,
  onChange,
  label,
  placeholder = "Select date range",
  id: providedId,
  dateFormat = "medium",
  // Design System
  size: size2 = "md",
  inputVariant = "outline",
  color: color2 = "primary",
  labelMode = "top",
  radius = "md",
  // States
  isDisabled = false,
  isLoading = false,
  isError = false,
  isSuccess = false,
  isRequired = false,
  isReadOnly = false,
  isFullWidth = true,
  // Features
  hasClearButton = true,
  hasCalendarIcon = true,
  hasPresetRanges = true,
  hasPresetPanel = true,
  hasDualCalendar = true,
  hasRequiredIndicator = true,
  // Helper Text
  helperText,
  errorMessage,
  successMessage,
  // Date Constraints
  minDate,
  maxDate,
  // Calendar Props
  calendarVariant = "solid",
  calendarSize,
  calendarDensity = "comfortable",
  calendarRadius = "md",
  calendarNavigation = "dropdown",
  adjustable = true,
  draggable = true,
  showWeekNumber = false,
  weekStartsOn = 0,
  independentNavigation = true,
  fromYear,
  toYear,
  // Events
  onOpen: _onOpen,
  onClose: _onClose,
  onClearClick,
  onPresetSelect,
  onFocus,
  onBlur,
  // Behavior
  position = "bottom-start",
  // Style
  className,
  style,
  // Legacy
  error: error2
}) => {
  const generatedId = useId$1();
  const id2 = providedId || generatedId;
  const [isFocused, setIsFocused] = useState(false);
  const parsedMinDate = parseDateInput(minDate);
  const parsedMaxDate = parseDateInput(maxDate);
  const [displayMonth, setDisplayMonth] = useState(value.start || /* @__PURE__ */ new Date());
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const startYear = fromYear ?? currentYear - 100;
  const endYear = toYear ?? currentYear + 10;
  const effectiveErrorMessage = errorMessage || error2;
  const effectiveCalendarSize = calendarSize || size2;
  const showPresets = hasPresetPanel && hasPresetRanges;
  const sizeConfig2 = {
    xs: { height: "h-8", text: "text-xs", icon: "text-sm", padding: "px-2.5", gap: "gap-1.5" },
    sm: { height: "h-9", text: "text-sm", icon: "text-base", padding: "px-3", gap: "gap-2" },
    md: { height: "h-10", text: "text-base", icon: "text-lg", padding: "px-3.5", gap: "gap-2" },
    lg: { height: "h-12", text: "text-lg", icon: "text-xl", padding: "px-4", gap: "gap-2.5" },
    xl: { height: "h-14", text: "text-xl", icon: "text-2xl", padding: "px-5", gap: "gap-3" }
  };
  const radiusConfig2 = {
    none: "rounded-none",
    sm: "rounded-sm",
    md: "rounded-md",
    lg: "rounded-lg",
    xl: "rounded-xl",
    full: "rounded-full"
  };
  const colorConfig2 = {
    primary: {
      focus: "focus:ring-brand-orange focus:border-brand-orange",
      accent: "text-brand-orange",
      bg: "bg-brand-orange/5"
    },
    secondary: {
      focus: "focus:ring-brand-navy-500 focus:border-brand-navy-500 dark:focus:ring-brand-navy-400",
      accent: "text-brand-navy-600 dark:text-brand-navy-400",
      bg: "bg-brand-navy-500/5"
    },
    success: {
      focus: "focus:ring-system-success focus:border-system-success",
      accent: "text-system-success-dark",
      bg: "bg-system-success/5"
    },
    warning: {
      focus: "focus:ring-system-warning-border focus:border-system-warning-border dark:focus:ring-system-warning dark:focus:border-system-warning",
      accent: "text-system-warning-dark dark:text-system-warning-light-text",
      bg: "bg-system-warning-light/50 dark:bg-system-warning-dark-bg/20"
    },
    danger: {
      focus: "focus:ring-system-error focus:border-system-error",
      accent: "text-system-error-dark",
      bg: "bg-system-error/5"
    },
    info: {
      focus: "focus:ring-system-info focus:border-system-info",
      accent: "text-system-info-dark",
      bg: "bg-system-info/5"
    },
    neutral: {
      focus: "focus:ring-text-secondary focus:border-text-secondary",
      accent: "text-text-secondary",
      bg: "bg-bg-tertiary"
    }
  };
  const getInputVariantClasses = () => {
    const base = "transition-all duration-200 ease-in-out";
    switch (inputVariant) {
      case "filled":
        return cn(
          base,
          "bg-bg-tertiary dark:bg-dark-bg-tertiary",
          "border-transparent",
          "hover:bg-bg-secondary dark:hover:bg-dark-bg-secondary",
          isFocused && "bg-bg-primary dark:bg-dark-bg-primary border-b-2",
          radiusConfig2[radius]
        );
      case "underline":
        return cn(
          base,
          "bg-transparent",
          "border-0 border-b-2 border-border-color dark:border-dark-border-color",
          "rounded-none",
          "hover:border-text-secondary dark:hover:border-dark-text-secondary"
        );
      case "flushed":
        return cn(
          base,
          "bg-transparent",
          "border-0 border-b border-border-color dark:border-dark-border-color",
          "rounded-none px-0",
          "hover:border-text-secondary dark:hover:border-dark-text-secondary"
        );
      case "ghost":
        return cn(
          base,
          "bg-transparent",
          "border-transparent",
          "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
          radiusConfig2[radius]
        );
      case "outline":
      default:
        return cn(
          base,
          "bg-bg-primary dark:bg-dark-bg-primary",
          "border border-border-color dark:border-dark-border-color",
          "hover:border-text-secondary dark:hover:border-dark-text-secondary",
          radiusConfig2[radius]
        );
    }
  };
  const getStateClasses = () => {
    if (isDisabled) {
      return "opacity-50 cursor-not-allowed pointer-events-none";
    }
    if (isError) {
      return "border-system-error dark:border-system-error focus:ring-system-error focus:border-system-error";
    }
    if (isSuccess) {
      return "border-system-success dark:border-system-success focus:ring-system-success focus:border-system-success";
    }
    return colorConfig2[color2].focus;
  };
  const calendarRange = useMemo(() => {
    if (value.start || value.end) {
      return { from: value.start ?? void 0, to: value.end ?? void 0 };
    }
    return void 0;
  }, [value]);
  const handleRangeSelect = (range) => {
    if (range) {
      onChange({ start: range.from || null, end: range.to || null });
    } else {
      onChange({ start: null, end: null });
    }
  };
  const handlePresetSelect = (range) => {
    onChange(range);
    if (range.start) {
      setDisplayMonth(range.start);
    }
    onPresetSelect?.(range);
  };
  const handleClear = (e2) => {
    e2.stopPropagation();
    onChange({ start: null, end: null });
    onClearClick?.();
  };
  const handleFocus = (e2) => {
    setIsFocused(true);
    onFocus?.(e2);
  };
  const handleBlur = (e2) => {
    setIsFocused(false);
    onBlur?.(e2);
  };
  const inputClasses = cn(
    "relative flex items-center w-full cursor-pointer",
    "text-text-primary dark:text-dark-text-primary",
    "focus:outline-none focus:ring-2 focus:ring-offset-0",
    sizeConfig2[size2].height,
    sizeConfig2[size2].text,
    sizeConfig2[size2].padding,
    sizeConfig2[size2].gap,
    getInputVariantClasses(),
    getStateClasses(),
    isLoading && "animate-pulse",
    isFullWidth ? "w-full" : "w-auto",
    className
  );
  const showLabel = label && labelMode !== "none";
  const isFloatingLabel = labelMode === "floating" || labelMode === "inside";
  const hasValue = value.start !== null;
  const shouldFloatLabel = isFloatingLabel && (hasValue || isFocused);
  const daysSelected = value.start && value.end ? Math.ceil((value.end.getTime() - value.start.getTime()) / (1e3 * 60 * 60 * 24)) + 1 : 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("relative", isFullWidth ? "w-full" : "w-auto"), children: [
    showLabel && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "label",
      {
        htmlFor: id2,
        className: cn(
          "block text-sm font-medium mb-1.5",
          "text-text-primary dark:text-dark-text-primary",
          isError && "text-system-error-dark",
          isSuccess && "text-system-success-dark"
        ),
        children: [
          label,
          isRequired && hasRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Popover.Trigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          id: id2,
          type: "button",
          disabled: isDisabled || isLoading || isReadOnly,
          className: inputClasses,
          onFocus: handleFocus,
          onBlur: handleBlur,
          style,
          "aria-label": label || placeholder,
          "aria-invalid": isError,
          "aria-required": isRequired,
          children: [
            showLabel && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                className: cn(
                  "absolute left-3 transition-all duration-200 pointer-events-none",
                  "text-text-secondary dark:text-dark-text-secondary",
                  shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-1/2 -translate-y-1/2",
                  shouldFloatLabel && colorConfig2[color2].accent,
                  isError && "text-system-error-dark",
                  isSuccess && "text-system-success-dark"
                ),
                children: [
                  label,
                  isRequired && hasRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
                ]
              }
            ),
            showLabel && labelMode === "inline" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-text-secondary dark:text-dark-text-secondary font-medium mr-2 flex-shrink-0", children: [
              label,
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("flex-1 text-left truncate", isFloatingLabel && !hasValue && "opacity-0"), children: value.start && value.end ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              formatDateWithOptions(value.start, dateFormat),
              " — ",
              formatDateWithOptions(value.end, dateFormat)
            ] }) : value.start ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              formatDateWithOptions(value.start, dateFormat),
              " — ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "italic opacity-60", children: "Select end" })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-text-secondary/60 dark:text-dark-text-secondary/60 italic", children: placeholder }) }),
            value.start && !isDisabled && !isReadOnly && hasClearButton && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                role: "button",
                tabIndex: 0,
                onClick: handleClear,
                onKeyDown: (e2) => {
                  if (e2.key === "Enter" || e2.key === " ") {
                    e2.preventDefault();
                    handleClear(e2);
                  }
                },
                className: cn(
                  "p-1 rounded-full flex-shrink-0",
                  "text-text-secondary/60 hover:text-text-primary",
                  "hover:bg-black/10 dark:hover:bg-white/10",
                  "cursor-pointer transition-colors",
                  "focus:outline-none focus:ring-2 focus:ring-brand-orange"
                ),
                "aria-label": "Clear date range",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: sizeConfig2[size2].icon, children: "close" })
              }
            ),
            isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "animate-spin text-text-secondary", children: "progress_activity" }) }),
            hasCalendarIcon && !isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon,
              {
                className: cn(
                  "flex-shrink-0 text-text-secondary/60 dark:text-dark-text-secondary/60",
                  isFocused && colorConfig2[color2].accent
                ),
                children: "date_range"
              }
            ),
            isError && !isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "flex-shrink-0 text-system-error", children: "error" }),
            isSuccess && !isLoading && !isError && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "flex-shrink-0 text-system-success", children: "check_circle" })
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Popover.Content,
        {
          position,
          isFullWidth: false,
          hasVisibleOverflow: true,
          className: "!max-w-none !p-0 !min-w-fit",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row", children: [
              showPresets && /* @__PURE__ */ jsxRuntimeExports.jsx(PresetPanel, { onSelect: handlePresetSelect, color: color2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Calendar$1,
                {
                  mode: "range",
                  rangeValue: calendarRange,
                  onRangeSelect: handleRangeSelect,
                  displayMonth,
                  onDisplayMonthChange: setDisplayMonth,
                  variant: calendarVariant,
                  size: effectiveCalendarSize,
                  color: color2,
                  density: calendarDensity,
                  radius: calendarRadius,
                  navigation: calendarNavigation,
                  adjustable,
                  draggable,
                  numberOfMonths: hasDualCalendar ? 2 : 1,
                  independentNavigation: hasDualCalendar && independentNavigation,
                  fromDate: parsedMinDate,
                  toDate: parsedMaxDate,
                  fromYear: startYear,
                  toYear: endYear,
                  showWeekNumber,
                  weekStartsOn
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-2 border-t border-border-color dark:border-dark-border-color flex justify-between items-center gap-2 bg-bg-secondary dark:bg-dark-bg-secondary", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button$1,
                {
                  variant: "text",
                  size: "sm",
                  onClick: (e2) => handleClear(e2),
                  children: "Clear"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-text-secondary dark:text-dark-text-secondary", children: daysSelected > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
                daysSelected,
                " day",
                daysSelected !== 1 ? "s" : "",
                " selected"
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Select a range" }) })
            ] })
          ]
        }
      )
    ] }),
    (helperText || effectiveErrorMessage || successMessage) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1.5", children: [
      isError && effectiveErrorMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-system-error-dark dark:text-system-error-light-text flex items-center gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "error" }),
        effectiveErrorMessage
      ] }),
      isSuccess && successMessage && !isError && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-system-success-dark dark:text-system-success flex items-center gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "check_circle" }),
        successMessage
      ] }),
      helperText && !isError && !isSuccess && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
    ] })
  ] });
};
const LayoutGroupContext = createContext({});
function useConstant(init) {
  const ref = useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const isBrowser$1 = typeof window !== "undefined";
const useIsomorphicLayoutEffect$2 = isBrowser$1 ? useLayoutEffect : useEffect;
const PresenceContext = /* @__PURE__ */ createContext(null);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
const clamp$1 = (min2, max2, v2) => {
  if (v2 > max2)
    return max2;
  if (v2 < min2)
    return min2;
  return v2;
};
function formatErrorMessage(message2, errorCode) {
  return errorCode ? `${message2}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${errorCode}` : message2;
}
let warning = () => {
};
let invariant = () => {
};
if (typeof process !== "undefined" && process.env?.NODE_ENV !== "production") {
  warning = (check, message2, errorCode) => {
    if (!check && typeof console !== "undefined") {
      console.warn(formatErrorMessage(message2, errorCode));
    }
  };
  invariant = (check, message2, errorCode) => {
    if (!check) {
      throw new Error(formatErrorMessage(message2, errorCode));
    }
  };
}
const MotionGlobalConfig = {};
const isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);
function isObject(value) {
  return typeof value === "object" && value !== null;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);
// @__NO_SIDE_EFFECTS__
function memo$1(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
const noop$1 = /* @__NO_SIDE_EFFECTS__ */ (any) => any;
const combineFunctions = (a3, b2) => (v2) => b2(a3(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
const progress = /* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a3, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a3, b2, c2);
    } else {
      for (let i2 = 0; i2 < numSubscriptions; i2++) {
        const handler = this.subscriptions[i2];
        handler && handler(a3, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
const millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message2, errorCode) {
  if (condition || warned.has(message2))
    return;
  console.warn(formatErrorMessage(message2, errorCode));
  warned.add(message2);
}
const calcBezier = (t2, a1, a22) => (((1 - 3 * a22 + 3 * a1) * t2 + (3 * a22 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop$1;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = /* @__PURE__ */ reverseEasing(backOut);
const backInOut = /* @__PURE__ */ mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
const easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
const easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
const easingLookup = {
  linear: noop$1,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const isValidEasing = (easing) => {
  return typeof easing === "string";
};
const easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`, "cubic-bezier-length");
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (isValidEasing(definition)) {
    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`, "invalid-easing-type");
    return easingLookup[definition];
  }
  return definition;
};
const stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    if (!MotionGlobalConfig.useManualTiming) {
      state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    }
    state.timestamp = timestamp;
    state.isProcessing = true;
    setup.process(state);
    read.process(state);
    resolveKeyframes.process(state);
    preUpdate.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process2) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++) {
      steps[stepsOrder[i2]].cancel(process2);
    }
  };
  return { schedule, cancel, state, steps };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop$1, true);
let now;
function clearTime() {
  now = void 0;
}
const time = {
  now: () => {
    if (now === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now;
  },
  set: (newTime) => {
    now = newTime;
    queueMicrotask(clearTime);
  }
};
const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
const startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
const isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function containsCSSVariable(value) {
  if (typeof value !== "string")
    return false;
  return value.split("/*")[0].includes("var(--");
}
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = {
  ...number,
  transform: (v2) => clamp$1(0, 1, v2)
};
const scale = {
  ...number,
  default: 1
};
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v2) {
  return v2 == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
const isColorString = (type, testProp) => (v2) => {
  return Boolean(typeof v2 === "string" && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (typeof v2 !== "string")
    return v2;
  const [a3, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a3),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp$1(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a3 = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a3 = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a3 = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a3 += a3;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a3 ? parseInt(a3, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
  test: (v2) => typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = /* @__PURE__ */ createUnitType("deg");
const percent = /* @__PURE__ */ createUnitType("%");
const px = /* @__PURE__ */ createUnitType("px");
const vh = /* @__PURE__ */ createUnitType("vh");
const vw = /* @__PURE__ */ createUnitType("vw");
const progressPercentage = /* @__PURE__ */ (() => ({
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
}))();
const hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return typeof v2 === "string" ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  },
  getAnimatableNone: (v2) => {
    const parsed = color.parse(v2);
    parsed.alpha = 0;
    return color.transform(parsed);
  }
};
const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v2) {
  return isNaN(v2) && typeof v2 === "string" && (v2.match(floatRegex)?.length || 0) + (v2.match(colorRegex)?.length || 0) > 0;
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types2 = [];
  let i2 = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i2);
      types2.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i2);
      types2.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i2);
      types2.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i2;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values, split, indexes, types: types2 };
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { split, types: types2 } = analyseComplexValue(source);
  const numSections = split.length;
  return (v2) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++) {
      output += split[i2];
      if (v2[i2] !== void 0) {
        const type = types2[i2];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v2[i2]);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v2[i2]);
        } else {
          output += v2[i2];
        }
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : color.test(v2) ? color.getAnimatableNone(v2) : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
function mixImmediate(a3, b2) {
  return (p2) => p2 > 0 ? b2 : a3;
}
const mixNumber$1 = (from, to, progress2) => {
  return from + (to - from) * progress2;
};
const mixLinearColor = (from, to, v2) => {
  const fromExpo = from * from;
  const expo = v2 * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color2) {
  const type = getColorType(color2);
  warning(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable");
  if (!Boolean(type))
    return false;
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from, to);
  }
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
};
const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p2) => p2 <= 0 ? origin : target;
  } else {
    return (p2) => p2 >= 1 ? target : origin;
  }
}
function mixNumber(a3, b2) {
  return (p2) => mixNumber$1(a3, b2, p2);
}
function getMixer(a3) {
  if (typeof a3 === "number") {
    return mixNumber;
  } else if (typeof a3 === "string") {
    return isCSSVariableToken(a3) ? mixImmediate : color.test(a3) ? mixColor : mixComplex;
  } else if (Array.isArray(a3)) {
    return mixArray;
  } else if (typeof a3 === "object") {
    return color.test(a3) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a3, b2) {
  const output = [...a3];
  const numValues = output.length;
  const blendValue = a3.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](p2);
    }
    return output;
  };
}
function mixObject(a3, b2) {
  const output = { ...a3, ...b2 };
  const blendValue = {};
  for (const key in output) {
    if (a3[key] !== void 0 && b2[key] !== void 0) {
      blendValue[key] = getMixer(a3[key])(a3[key], b2[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type = target.types[i2];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i2] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different");
    return mixImmediate(origin, target);
  }
};
function mix(from, to, p2) {
  if (typeof from === "number" && typeof to === "number" && typeof p2 === "number") {
    return mixNumber$1(from, to, p2);
  }
  const mixer = getMixer(from);
  return mixer(from, to);
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
};
const generateLinearEasing = (easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++) {
    points += Math.round(easing(i2 / (numPoints - 1)) * 1e4) / 1e4 + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
};
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] });
  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => {
      return generator.next(duration * progress2).value / scale2;
    },
    duration: /* @__PURE__ */ millisecondsToSeconds(duration)
  };
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};
const safeMin = 1e-3;
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  warning(duration <= /* @__PURE__ */ secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$1(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp$1(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a3 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a3 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a3 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a3 * b2;
    };
    derivative = (undampedFreq2) => {
      const a3 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a3 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = /* @__PURE__ */ secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root * root;
      const damping = 2 * clamp$1(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = t2 === 0 ? initialVelocity : 0;
        if (dampingRatio < 1) {
          currentVelocity = t2 === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  options.ease = generatorOptions.ease;
  options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration);
  options.type = "keyframes";
  return options;
};
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2;
  const nearestBoundary = (v2) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
  const calcLatest = (t2) => target + calcDelta(t2);
  const applyFriction = (t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t2) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state;
      }
    }
  };
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop$1 : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length", "range-length");
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    if (isZeroDeltaRange && v2 < input[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1) {
      for (; i2 < input.length - 2; i2++) {
        if (v2 < input[i2 + 1])
          break;
      }
    }
    const progressInRange = /* @__PURE__ */ progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp$1(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i2);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  fillOffset(offset2, arr.length - 1);
  return offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o4) => o4 * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times: times2, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times2 && times2.length === keyframeValues.length ? times2 : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => {
      state.value = mapTimeToKeyframe(t2);
      state.done = t2 >= duration;
      return state;
    }
  };
}
const isNotNull$1 = (value) => value !== null;
function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
  const resolvedKeyframes = keyframes2.filter(isNotNull$1);
  const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
  const index2 = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function replaceTransitionType(transition) {
  if (typeof transition.type === "string") {
    transition.type = transitionTypeMap[transition.type];
  }
}
class WithPromise {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(onResolve, onReject) {
    return this.finished.then(onResolve, onReject);
  }
}
const percentToProgress = (percent2) => percent2 / 100;
class JSAnimation extends WithPromise {
  constructor(options) {
    super();
    this.state = "idle";
    this.startTime = null;
    this.isStopped = false;
    this.currentTime = 0;
    this.holdTime = null;
    this.playbackSpeed = 1;
    this.stop = () => {
      const { motionValue: motionValue2 } = this.options;
      if (motionValue2 && motionValue2.updatedAt !== time.now()) {
        this.tick(time.now());
      }
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      this.options.onStop?.();
    };
    this.options = options;
    this.initAnimation();
    this.play();
    if (options.autoplay === false)
      this.pause();
  }
  initAnimation() {
    const { options } = this;
    replaceTransitionType(options);
    const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
    let { keyframes: keyframes$1 } = options;
    const generatorFactory = type || keyframes;
    if (process.env.NODE_ENV !== "production" && generatorFactory !== keyframes) {
      invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`, "spring-two-frames");
    }
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      this.mirroredGenerator = generatorFactory({
        ...options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    this.calculatedDuration = calculatedDuration;
    this.resolvedDuration = calculatedDuration + repeatDelay;
    this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
    this.generator = generator;
  }
  updateTime(timestamp) {
    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
    if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = animationTime;
    }
  }
  tick(timestamp, sample = false) {
    const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay3 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else {
      this.updateTime(timestamp);
    }
    const timeWithoutDelay = this.currentTime - delay3 * (this.playbackSpeed >= 0 ? 1 : -1);
    const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp$1(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mixKeyframes) {
      state.value = mixKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && type !== inertia) {
      state.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.finished.then(resolve, reject);
  }
  get duration() {
    return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: delay3 = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay3);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.playbackSpeed;
    }
    this.driver?.start(false);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    this.updateTime(time.now());
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    this.options.onPlay?.();
    const now2 = this.driver.now();
    if (this.state === "finished") {
      this.updateFinished();
      this.startTime = now2;
    } else if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime ?? now2;
    }
    if (this.state === "finished" && this.speed < 0) {
      this.startTime += this.calculatedDuration;
    }
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    this.state = "paused";
    this.updateTime(time.now());
    this.holdTime = this.currentTime;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.notifyFinished();
    this.teardown();
    this.state = "finished";
    this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null;
    this.startTime = 0;
    this.tick(0);
    this.teardown();
    this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.startTime = this.holdTime = null;
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(sampleTime) {
    this.startTime = 0;
    return this.tick(sampleTime, true);
  }
  attachTimeline(timeline) {
    if (this.options.allowFlatten) {
      this.options.type = "keyframes";
      this.options.ease = "linear";
      this.initAnimation();
    }
    this.driver?.stop();
    return timeline.observe(this);
  }
}
function fillWildcards(keyframes2) {
  for (let i2 = 1; i2 < keyframes2.length; i2++) {
    keyframes2[i2] ?? (keyframes2[i2] = keyframes2[i2 - 1]);
  }
}
const radToDeg = (rad) => rad * 180 / Math.PI;
const rotate = (v2) => {
  const angle = radToDeg(Math.atan2(v2[1], v2[0]));
  return rebaseAngle(angle);
};
const matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v2) => (Math.abs(v2[0]) + Math.abs(v2[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v2) => radToDeg(Math.atan(v2[1])),
  skewY: (v2) => radToDeg(Math.atan(v2[2])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[2])) / 2
};
const rebaseAngle = (angle) => {
  angle = angle % 360;
  if (angle < 0)
    angle += 360;
  return angle;
};
const rotateZ = rotate;
const scaleX = (v2) => Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
const scaleY = (v2) => Math.sqrt(v2[4] * v2[4] + v2[5] * v2[5]);
const matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v2) => (scaleX(v2) + scaleY(v2)) / 2,
  rotateX: (v2) => rebaseAngle(radToDeg(Math.atan2(v2[6], v2[5]))),
  rotateY: (v2) => rebaseAngle(radToDeg(Math.atan2(-v2[2], v2[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v2) => radToDeg(Math.atan(v2[4])),
  skewY: (v2) => radToDeg(Math.atan(v2[1])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[4])) / 2
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform, name) {
  if (!transform || transform === "none") {
    return defaultTransformValue(name);
  }
  const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers;
  let match2;
  if (matrix3dMatch) {
    parsers = matrix3dParsers;
    match2 = matrix3dMatch;
  } else {
    const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers;
    match2 = matrix2dMatch;
  }
  if (!match2) {
    return defaultTransformValue(name);
  }
  const valueParser = parsers[name];
  const values = match2[1].split(",").map(convertTransformToNumber);
  return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
}
const readTransformValue = (instance, name) => {
  const { transform = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();
const isNumOrPxType = (v2) => v2 === number || v2 === px;
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
  y: (_bbox, { transform }) => parseValueFromTransform(transform, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
let isForced = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          element.getValue(key)?.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete(isForced));
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  isForced = true;
  readAllKeyframes();
  measureAllKeyframes();
  isForced = false;
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.state = "pending";
    this.isAsync = false;
    this.needsMeasurement = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.state = "scheduled";
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    if (unresolvedKeyframes[0] === null) {
      const currentValue = motionValue2?.get();
      const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (currentValue !== void 0) {
        unresolvedKeyframes[0] = currentValue;
      } else if (element && name) {
        const valueAsRead = element.readValue(name, finalKeyframe);
        if (valueAsRead !== void 0 && valueAsRead !== null) {
          unresolvedKeyframes[0] = valueAsRead;
        }
      }
      if (unresolvedKeyframes[0] === void 0) {
        unresolvedKeyframes[0] = finalKeyframe;
      }
      if (motionValue2 && currentValue === void 0) {
        motionValue2.set(unresolvedKeyframes[0]);
      }
    }
    fillWildcards(unresolvedKeyframes);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(isForcedComplete = false) {
    this.state = "complete";
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
    toResolve.delete(this);
  }
  cancel() {
    if (this.state === "scheduled") {
      toResolve.delete(this);
      this.state = "pending";
    }
  }
  resume() {
    if (this.state === "pending")
      this.scheduleResolve();
  }
}
const isCSSVar = (name) => name.startsWith("--");
function setStyle(element, name, value) {
  isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
}
const supportsScrollTimeline = /* @__PURE__ */ memo$1(() => window.ScrollTimeline !== void 0);
const supportsFlags = {};
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo$1(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e2) {
    return false;
  }
  return true;
}, "linearEasing");
const cubicBezierAsString = ([a3, b2, c2, d2]) => `cubic-bezier(${a3}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function") {
    return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing];
  }
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay3 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times: times2 } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  if (times2)
    keyframeOptions.offset = times2;
  const easing = mapEasingToNativeEasing(ease2, duration);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  const options = {
    delay: delay3,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  };
  if (pseudoElement)
    options.pseudoElement = pseudoElement;
  const animation = element.animate(keyframeOptions, options);
  return animation;
}
function isGenerator(type) {
  return typeof type === "function" && "applyToOptions" in type;
}
function applyGeneratorOptions({ type, ...options }) {
  if (isGenerator(type) && supportsLinearEasing()) {
    return type.applyToOptions(options);
  } else {
    options.duration ?? (options.duration = 300);
    options.ease ?? (options.ease = "easeOut");
  }
  return options;
}
class NativeAnimation extends WithPromise {
  constructor(options) {
    super();
    this.finishedTime = null;
    this.isStopped = false;
    this.manualStartTime = null;
    if (!options)
      return;
    const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
    this.isPseudoElement = Boolean(pseudoElement);
    this.allowFlatten = allowFlatten;
    this.options = options;
    invariant(typeof options.type !== "string", `Mini animate() doesn't support "type" as a string.`, "mini-spring");
    const transition = applyGeneratorOptions(options);
    this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
    if (transition.autoplay === false) {
      this.animation.pause();
    }
    this.animation.onfinish = () => {
      this.finishedTime = this.time;
      if (!pseudoElement) {
        const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
        if (this.updateMotionValue) {
          this.updateMotionValue(keyframe);
        } else {
          setStyle(element, name, keyframe);
        }
        this.animation.cancel();
      }
      onComplete?.();
      this.notifyFinished();
    };
  }
  play() {
    if (this.isStopped)
      return;
    this.manualStartTime = null;
    this.animation.play();
    if (this.state === "finished") {
      this.updateFinished();
    }
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch (e2) {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = true;
    const { state } = this;
    if (state === "idle" || state === "finished") {
      return;
    }
    if (this.updateMotionValue) {
      this.updateMotionValue();
    } else {
      this.commitStyles();
    }
    if (!this.isPseudoElement)
      this.cancel();
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    if (!this.isPseudoElement) {
      this.animation.commitStyles?.();
    }
  }
  get duration() {
    const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ millisecondsToSeconds(Number(duration));
  }
  get iterationDuration() {
    const { delay: delay3 = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ millisecondsToSeconds(delay3);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(newTime) {
    this.manualStartTime = null;
    this.finishedTime = null;
    this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(newSpeed) {
    if (newSpeed < 0)
      this.finishedTime = null;
    this.animation.playbackRate = newSpeed;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(newStartTime) {
    this.manualStartTime = this.animation.startTime = newStartTime;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline, observe }) {
    if (this.allowFlatten) {
      this.animation.effect?.updateTiming({ easing: "linear" });
    }
    this.animation.onfinish = null;
    if (timeline && supportsScrollTimeline()) {
      this.animation.timeline = timeline;
      return noop$1;
    } else {
      return observe(this);
    }
  }
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
function replaceStringEasing(transition) {
  if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
    transition.ease = unsupportedEasingFunctions[transition.ease];
  }
}
const sampleDelta = 10;
class NativeAnimationExtended extends NativeAnimation {
  constructor(options) {
    replaceStringEasing(options);
    replaceTransitionType(options);
    super(options);
    if (options.startTime !== void 0) {
      this.startTime = options.startTime;
    }
    this.options = options;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read committed styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(value) {
    const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
    if (!motionValue2)
      return;
    if (value !== void 0) {
      motionValue2.set(value);
      return;
    }
    const sampleAnimation = new JSAnimation({
      ...options,
      autoplay: false
    });
    const sampleTime = Math.max(sampleDelta, time.now() - this.startTime);
    const delta = clamp$1(0, sampleDelta, sampleTime - sampleDelta);
    motionValue2.setWithVelocity(sampleAnimation.sample(Math.max(0, sampleTime - delta)).value, sampleAnimation.sample(sampleTime).value, delta);
    sampleAnimation.stop();
  }
}
const isAnimatable = (value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    if (keyframes2[i2] !== current)
      return true;
  }
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null) {
    return false;
  }
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". "${isOriginAnimatable ? targetKeyframe : originKeyframe}" is not an animatable value.`, "value-not-animatable");
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
function makeAnimationInstant(options) {
  options.duration = 0;
  options.type = "keyframes";
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]);
const supportsWaapi = /* @__PURE__ */ memo$1(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(options) {
  const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
  const subject = motionValue2?.owner?.current;
  if (!(subject instanceof HTMLElement)) {
    return false;
  }
  const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
  return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
}
const MAX_RESOLVE_DELAY = 40;
class AsyncMotionValueAnimation extends WithPromise {
  constructor({ autoplay = true, delay: delay3 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
    super();
    this.stop = () => {
      if (this._animation) {
        this._animation.stop();
        this.stopTimeline?.();
      }
      this.keyframeResolver?.cancel();
    };
    this.createdAt = time.now();
    const optionsWithDefaults = {
      autoplay,
      delay: delay3,
      type,
      repeat,
      repeatDelay,
      repeatType,
      name,
      motionValue: motionValue2,
      element,
      ...options
    };
    const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
    this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
    this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
    this.keyframeResolver = void 0;
    const { name, type, velocity, delay: delay3, isHandoff, onUpdate } = options;
    this.resolvedAt = time.now();
    if (!canAnimate(keyframes2, name, type, velocity)) {
      if (MotionGlobalConfig.instantAnimations || !delay3) {
        onUpdate?.(getFinalKeyframe$1(keyframes2, options, finalKeyframe));
      }
      keyframes2[0] = keyframes2[keyframes2.length - 1];
      makeAnimationInstant(options);
      options.repeat = 0;
    }
    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
    const resolvedOptions = {
      startTime,
      finalKeyframe,
      ...options,
      keyframes: keyframes2
    };
    const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions);
    const element = resolvedOptions.motionValue?.owner?.current;
    const animation = useWaapi ? new NativeAnimationExtended({
      ...resolvedOptions,
      element
    }) : new JSAnimation(resolvedOptions);
    animation.finished.then(() => {
      this.notifyFinished();
    }).catch(noop$1);
    if (this.pendingTimeline) {
      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
      this.pendingTimeline = void 0;
    }
    this._animation = animation;
  }
  get finished() {
    if (!this._animation) {
      return this._finished;
    } else {
      return this.animation.finished;
    }
  }
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
  get animation() {
    if (!this._animation) {
      this.keyframeResolver?.resume();
      flushKeyframeResolvers();
    }
    return this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(newTime) {
    this.animation.time = newTime;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(newSpeed) {
    this.animation.speed = newSpeed;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(timeline) {
    if (this._animation) {
      this.stopTimeline = this.animation.attachTimeline(timeline);
    } else {
      this.pendingTimeline = timeline;
    }
    return () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    if (this._animation) {
      this.animation.cancel();
    }
    this.keyframeResolver?.cancel();
  }
}
function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
  const index2 = Array.from(children).sort((a3, b2) => a3.sortNodePosition(b2)).indexOf(child);
  const numChildren = children.size;
  const maxStaggerDuration = (numChildren - 1) * staggerChildren;
  const delayIsFunction = typeof delayChildren === "function";
  return delayIsFunction ? delayChildren(index2, numChildren) : staggerDirection === 1 ? index2 * staggerChildren : maxStaggerDuration - index2 * staggerChildren;
}
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token1, token2, fallback] = match2;
  return [`--${token1 ?? token2}`, fallback];
}
const maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`, "max-css-var-depth");
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return resolvedKeyframes[index2];
}
function getValueTransition(transition, key) {
  return transition?.[key] ?? transition?.["default"] ?? transition;
}
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay3 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay3);
  const options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2);
      valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    Object.assign(options, getDefaultTransition(name, options));
  }
  options.duration && (options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration));
  options.repeatDelay && (options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay));
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    makeAnimationInstant(options);
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    makeAnimationInstant(options);
    options.delay = 0;
  }
  options.allowFlatten = !valueTransition.type && !valueTransition.ease;
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return;
    }
  }
  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
};
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement?.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);
const MAX_VELOCITY_DELTA = 30;
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init, options = {}) {
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v2) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v2);
      if (this.current !== this.prev) {
        this.events.change?.notify(this.current);
        if (this.dependents) {
          for (const dependent of this.dependents) {
            dependent.dirty();
          }
        }
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    if (process.env.NODE_ENV !== "production") {
      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
    }
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2) {
    if (!this.passiveEffect) {
      this.updateAndNotify(v2);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2, endAnimation = true) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(dependent) {
    if (!this.dependents) {
      this.dependents = /* @__PURE__ */ new Set();
    }
    this.dependents.add(dependent);
  }
  removeDependent(dependent) {
    if (this.dependents) {
      this.dependents.delete(dependent);
    }
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear();
    this.events.destroy?.notify();
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function resolveFinalValueInKeyframes(v2) {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  } else if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange);
    newWillChange.add(key);
  }
}
function camelToDash(str) {
  return str.replace(/([A-Z])/g, (match2) => `-${match2.toLowerCase()}`);
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay3 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  const reduceMotion = transition?.reduceMotion;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay3,
      ...getValueTransition(transition || {}, key)
    };
    const currentValue = value.get();
    if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
      continue;
    }
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    const shouldReduceMotion = reduceMotion ?? visualElement.shouldReduceMotion;
    value.start(animateMotionValue(key, value, valueTarget, shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delay3 = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  for (const child of visualElement.variantChildren) {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delay3 + (typeof delayChildren === "function" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)
    }).then(() => child.notify("AnimationComplete", variant)));
  }
  return Promise.all(animations2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const testValueType = (v2) => (type) => type.test(v2);
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const int = {
  ...number,
  transform: Math.round
};
const transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  inset: px,
  insetBlock: px,
  insetBlockStart: px,
  insetBlockEnd: px,
  insetInline: px,
  insetInlineStart: px,
  insetInlineEnd: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  paddingBlock: px,
  paddingBlockStart: px,
  paddingBlockEnd: px,
  paddingInline: px,
  paddingInlineStart: px,
  paddingInlineEnd: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  marginBlock: px,
  marginBlockStart: px,
  marginBlockEnd: px,
  marginInline: px,
  marginInlineStart: px,
  marginInlineEnd: px,
  // Typography
  fontSize: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0;
  let animatableTemplate = void 0;
  while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i2];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i2];
    }
    i2++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
    }
  }
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i2] = resolved;
          }
          if (i2 === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    const originHasVar = containsCSSVariable(origin);
    const targetHasVar = containsCSSVariable(target);
    if (originHasVar !== targetHasVar && positionalValues[name]) {
      this.needsMeasurement = true;
      return;
    }
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        const value = unresolvedKeyframes[i2];
        if (typeof value === "string") {
          unresolvedKeyframes[i2] = parseFloat(value);
        }
      }
    } else if (positionalValues[name]) {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      if (unresolvedKeyframes[i2] === null || isNone(unresolvedKeyframes[i2])) {
        noneKeyframeIndexes.push(i2);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if (this.removedTransforms?.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
}
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector == null) {
    return [];
  }
  if (elementOrSelector instanceof EventTarget) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root = document;
    const elements = selectorCache?.[elementOrSelector] ?? root.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector).filter((element) => element != null);
}
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
function isHTMLElement$1(element) {
  return isObject(element) && "offsetHeight" in element;
}
const { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);
const isDragging = {
  x: false,
  y: false
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal
  };
  const cancel = () => gestureAbortController.abort();
  return [elements, eventOptions, cancel];
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      if (!isValidHover(leaveEvent))
        return;
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
const interactiveElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return interactiveElements.has(element.tagName) || element.isContentEditable === true;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    });
    const handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions);
    element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions);
  element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
  const startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent);
    const onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (isPressing.has(target)) {
        isPressing.delete(target);
      }
      if (!isValidPressEvent(endEvent)) {
        return;
      }
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    };
    const onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    };
    const onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  targets.forEach((target) => {
    const pointerDownTarget = options.useGlobalTarget ? window : target;
    pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
    if (isHTMLElement$1(target)) {
      target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
      if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
        target.tabIndex = 0;
      }
    }
  });
  return cancelEvents;
}
function isSVGElement(element) {
  return isObject(element) && "ownerSVGElement" in element;
}
function isSVGSVGElement(element) {
  return isSVGElement(element) && element.tagName === "svg";
}
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
const isBrowser = typeof window !== "undefined";
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addEventListener("change", setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let featureDefinitions = {};
function setFeatureDefinitions(definitions) {
  featureDefinitions = definitions;
}
function getFeatureDefinitions() {
  return featureDefinitions;
}
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key]);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (this.reducedMotionConfig === "never") {
      this.shouldReduceMotion = false;
    } else if (this.reducedMotionConfig === "always") {
      this.shouldReduceMotion = true;
    } else {
      if (!hasReducedMotionListener.current) {
        initPrefersReducedMotion();
      }
      this.shouldReduceMotion = prefersReducedMotion.current;
    }
    if (process.env.NODE_ENV !== "production") {
      warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.", "reduced-motion-disabled");
    }
    this.parent?.addChild(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent?.removeChild(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  addChild(child) {
    this.children.add(child);
    this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set());
    this.enteringChildren.add(child);
  }
  removeChild(child) {
    this.children.delete(child);
    this.enteringChildren && this.enteringChildren.delete(child);
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    if (valueIsTransform && this.onBindTransform) {
      this.onBindTransform();
    }
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
      this.scheduleRender();
    });
    let removeSyncCheck;
    if (typeof window !== "undefined" && window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key = propEventHandlers[i2];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
  scheduleRenderMicrotask() {
    microtask.render(this.render);
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a3, b2) {
    return a3.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    const style = props.style;
    return style ? style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}
class Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node = treePath[i2];
    delta = node.projectionDelta;
    const { visualElement } = node.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key = transformPropOrder[i2];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      const parsed = parseFloat(value);
      valueIsDefault = key.startsWith("scale") ? parsed === 1 : parsed === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
function renderHTML(element, { style, vars }, styleProp, projection) {
  const elementStyle = element.style;
  let key;
  for (key in style) {
    elementStyle[key] = style[key];
  }
  projection?.applyProjectionStyles(elementStyle, styleProp);
  for (key in vars) {
    elementStyle.setProperty(key, vars[key]);
  }
}
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node.target.x);
    const y2 = pixelsToPercent(latest, node.target.y);
    return `${x2}% ${y2}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset2 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale;
    shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset2] === "number")
      shadow[2 + offset2] /= averageScale;
    if (typeof shadow[3 + offset2] === "number")
      shadow[3 + offset2] /= averageScale;
    return template(shadow);
  }
};
const scaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  const style = props.style;
  const prevStyle = prevProps?.style;
  const newValues = {};
  if (!style)
    return newValues;
  for (const key in style) {
    if (isMotionValue(style[key]) || prevStyle && isMotionValue(prevStyle[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function getComputedStyle$2(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key);
    } else {
      const computedStyle = getComputedStyle$2(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset2 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = `${-offset2}`;
  attrs[keys.array] = `${length} ${spacing}`;
}
const cssMotionPathProperties = [
  "offsetDistance",
  "offsetPath",
  "offsetRotate",
  "offsetAnchor"
];
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate, styleProp) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style } = state;
  if (attrs.transform) {
    style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (style.transform || attrs.transformOrigin) {
    style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
    delete attrs.transformOrigin;
  }
  if (style.transform) {
    style.transformBox = styleProp?.transformBox ?? "fill-box";
    delete attrs.transformBox;
  }
  for (const key of cssMotionPathProperties) {
    if (attrs[key] !== void 0) {
      style[key] = attrs[key];
      delete attrs[key];
    }
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev[i2] !== next[i2])
      return false;
  }
  return true;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function createAnimateFunction(visualElement) {
  return (animations2) => {
    return Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
  };
}
function createAnimationState(visualElement) {
  let animate = createAnimateFunction(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? visualElement.presenceContext?.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
          valueHasChanged = !shallowCompare(next, prev);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== void 0 && next !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation) => {
          const options = { type };
          if (typeof animation === "string" && isInitialRender && !willAnimateViaParent && visualElement.manuallyAnimateOnMount && visualElement.parent) {
            const { parent } = visualElement;
            const parentVariant = resolveVariant(parent, animation);
            if (parent.enteringChildren && parentVariant) {
              const { delayChildren } = parentVariant.transition || {};
              options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);
            }
          }
          return {
            animation,
            options
          };
        }));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial !== "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        if (initialTransition && initialTransition.transition) {
          fallbackAnimation.transition = initialTransition.transition;
        }
      }
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget ?? null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    if (state[type].isActive === isActive)
      return Promise.resolve();
    visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type, isActive));
    state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
const SCALE_PRECISION = 1e-4;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a3, b2) {
  return a3.min === b2.min && a3.max === b2.max;
}
function boxEquals(a3, b2) {
  return axisEquals(a3.x, b2.x) && axisEquals(a3.y, b2.y);
}
function axisEqualsRounded(a3, b2) {
  return Math.round(a3.min) === Math.round(b2.min) && Math.round(a3.max) === Math.round(b2.max);
}
function boxEqualsRounded(a3, b2) {
  return axisEqualsRounded(a3.x, b2.x) && axisEqualsRounded(a3.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a3, b2) {
  return a3.translate === b2.translate && a3.scale === b2.scale && a3.originPoint === b2.originPoint;
}
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = latestTransform?.z || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate2)
      transform += `rotate(${rotate2}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform += `skewX(${skewX}deg) `;
    if (skewY)
      transform += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
    target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop$1);
function compress(min2, max2, easing) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing(/* @__PURE__ */ progress(min2, max2, p2));
  };
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
const compareByDepth = (a3, b2) => a3.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay$1(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.setup(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      const prevDep = prevLead.options.layoutDependency;
      const nextDep = node.options.layoutDependency;
      const dependencyMatches = prevDep !== void 0 && nextDep !== void 0 && prevDep === nextDep;
      if (!dependencyMatches) {
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
        }
        if (node.root && node.root.isUpdating) {
          node.isLayoutDirty = true;
        }
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id$1 = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent?.()) {
      this.id = id$1++;
      this.animationId = 0;
      this.animationCommitId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.layoutVersion = 0;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
      };
      this.resolvedRelativeTargetAt = 0;
      this.linkedParentVersion = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        let innerWidth = 0;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        frame.read(() => {
          innerWidth = window.innerWidth;
        });
        attachResizeListener(instance, () => {
          const newInnerWidth = window.innerWidth;
          if (newInnerWidth === innerWidth)
            return;
          innerWidth = newInnerWidth;
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay$1(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
          if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      this.eventHandlers.clear();
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(clearIsLayoutDirty);
        return;
      }
      this.animationCommitId = this.animationId;
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      } else {
        this.isUpdating = false;
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
      }
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp$1(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
      if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
        this.snapshot = void 0;
      }
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutVersion++;
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if (this.scroll?.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      const relativeParent = this.getClosestProjectingParent();
      if (relativeParent && this.linkedParentVersion !== relativeParent.layoutVersion && !relativeParent.options.layoutRoot) {
        this.removeRelativeTarget();
      }
      if (!this.targetDelta && !this.relativeTarget) {
        if (relativeParent && relativeParent.layout) {
          this.createRelativeTarget(relativeParent, this.layout.layoutBox, relativeParent.layout.layoutBox);
        } else {
          this.removeRelativeTarget();
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.createRelativeTarget(relativeParent, this.target, relativeParent.target);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(relativeParent, layout2, parentLayout) {
      this.relativeParent = relativeParent;
      this.linkedParentVersion = relativeParent.layoutVersion;
      this.forceRelativeParentToResolveTarget();
      this.relativeTarget = createBox();
      this.relativeTargetOrigin = createBox();
      calcRelativePosition(this.relativeTargetOrigin, layout2, parentLayout);
      copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.visualElement?.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation?.stop();
      this.resumingFrom?.currentAnimation?.stop();
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.motionValue || (this.motionValue = motionValue(0));
        this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          velocity: 0,
          isSync: true,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    applyProjectionStyles(targetStyle, styleProp) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        targetStyle.visibility = "hidden";
        return;
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        targetStyle.visibility = "";
        targetStyle.opacity = "";
        targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
        targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        if (this.options.layoutId) {
          targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          targetStyle.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return;
      }
      targetStyle.visibility = "";
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        transform = transformTemplate(valuesToRender, transform);
      }
      targetStyle.transform = transform;
      const { x: x2, y: y2 } = this.projectionDelta;
      targetStyle.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
        const corrected = transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            targetStyle[applyTo[i2]] = corrected;
          }
        } else {
          if (isCSSVariable) {
            this.options.visualElement.renderState.vars[key] = corrected;
          } else {
            targetStyle[key] = corrected;
          }
        }
      }
      if (this.options.layoutId) {
        targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
      }
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => node.currentAnimation?.stop());
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  const snapshot = node.resumeFrom?.snapshot || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeLayoutChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2);
  output.scale = mixNumber$1(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p2) {
  output.min = mixNumber$1(from.min, to.min, p2);
  output.max = mixNumber$1(from.max, to.max, p2);
}
function mixBox(output, from, to, p2) {
  mixAxis(output.x, from.x, to.x, p2);
  mixAxis(output.y, from.y, to.y, p2);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop$1;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node) {
  return node !== node.root && node.scroll?.wasRoot;
}
const DocumentProjectionNode = createProjectionNode$1({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body?.scrollLeft || 0,
    y: document.documentElement.scrollTop || document.body?.scrollTop || 0
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode$1({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const MotionConfigContext = createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup === "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i2 = 0; i2 < cleanups.length; i2++) {
          const cleanup = cleanups[i2];
          if (typeof cleanup === "function") {
            cleanup();
          } else {
            setRef(refs[i2], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React.useCallback(composeRefs(...refs), refs);
}
class PopChildMeasure extends React.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const parent = element.offsetParent;
      const parentWidth = isHTMLElement$1(parent) ? parent.offsetWidth || 0 : 0;
      const parentHeight = isHTMLElement$1(parent) ? parent.offsetHeight || 0 : 0;
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0;
      size2.width = element.offsetWidth || 0;
      size2.top = element.offsetTop;
      size2.left = element.offsetLeft;
      size2.right = parentWidth - size2.width - size2.left;
      size2.bottom = parentHeight - size2.height - size2.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent, anchorX, anchorY, root }) {
  const id2 = useId$1();
  const ref = useRef(null);
  const size2 = useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  });
  const { nonce } = useContext(MotionConfigContext);
  const childRef = children.props?.ref ?? children?.ref;
  const composedRef = useComposedRefs(ref, childRef);
  useInsertionEffect$1(() => {
    const { width, height, top, left, right, bottom } = size2.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
    const y2 = anchorY === "bottom" ? `bottom: ${bottom}` : `top: ${top}`;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    if (nonce)
      style.nonce = nonce;
    const parent = root ?? document.head;
    parent.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x2}px !important;
            ${y2}px !important;
          }
        `);
    }
    return () => {
      if (parent.contains(style)) {
        parent.removeChild(style);
      }
    };
  }, [isPresent]);
  return jsxRuntimeExports.jsx(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2, children: React.cloneElement(children, { ref: composedRef }) });
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, anchorY, root }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = useId$1();
  let isReusedContext = true;
  let context = useMemo(() => {
    isReusedContext = false;
    return {
      id: id2,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    };
  }, [isPresent, presenceChildren, onExitComplete]);
  if (presenceAffectsLayout && isReusedContext) {
    context = { ...context };
  }
  useMemo(() => {
    presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  React.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = jsxRuntimeExports.jsx(PopChild, { isPresent, anchorX, anchorY, root, children });
  }
  return jsxRuntimeExports.jsx(PresenceContext.Provider, { value: context, children });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function usePresence(subscribe = true) {
  const context = useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = useId$1();
  useEffect(() => {
    if (subscribe) {
      return register(id2);
    }
  }, [subscribe]);
  const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const getChildKey = (child) => child.key || "";
function onlyElements(children) {
  const filtered = [];
  Children.forEach(children, (child) => {
    if (isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", anchorY = "top", root }) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate);
  const presentChildren = useMemo(() => onlyElements(children), [children]);
  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
  const isInitialRender = useRef(true);
  const pendingPresentChildren = useRef(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const exitingComponents = useRef(/* @__PURE__ */ new Set());
  const [diffedChildren, setDiffedChildren] = useState(presentChildren);
  const [renderedChildren, setRenderedChildren] = useState(presentChildren);
  useIsomorphicLayoutEffect$2(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key = getChildKey(renderedChildren[i2]);
      if (!presentKeys.includes(key)) {
        if (exitComplete.get(key) !== true) {
          exitComplete.set(key, false);
        }
      } else {
        exitComplete.delete(key);
        exitingComponents.current.delete(key);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2];
      const key = getChildKey(child);
      if (!presentKeys.includes(key)) {
        nextChildren.splice(i2, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return null;
  }
  if (process.env.NODE_ENV !== "production" && mode === "wait" && renderedChildren.length > 1) {
    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  }
  const { forceRender } = useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: renderedChildren.map((child) => {
    const key = getChildKey(child);
    const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
    const onExit = () => {
      if (exitingComponents.current.has(key)) {
        return;
      }
      exitingComponents.current.add(key);
      if (exitComplete.has(key)) {
        exitComplete.set(key, true);
      } else {
        return;
      }
      let isEveryExitComplete = true;
      exitComplete.forEach((isExitComplete) => {
        if (!isExitComplete)
          isEveryExitComplete = false;
      });
      if (isEveryExitComplete) {
        forceRender?.();
        setRenderedChildren(pendingPresentChildren.current);
        propagate && safeToRemove?.();
        onExitComplete && onExitComplete();
      }
    };
    return jsxRuntimeExports.jsx(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, root, onExitComplete: isPresent ? void 0 : onExit, anchorX, anchorY, children: child }, key);
  }) });
};
const LazyContext = createContext({ strict: false });
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
let isInitialized = false;
function initFeatureDefinitions() {
  if (isInitialized)
    return;
  const initialFeatureDefinitions = {};
  for (const key in featureProps) {
    initialFeatureDefinitions[key] = {
      isEnabled: (props) => featureProps[key].some((name) => !!props[name])
    };
  }
  setFeatureDefinitions(initialFeatureDefinitions);
  isInitialized = true;
}
function getInitializedFeatureDefinitions() {
  initFeatureDefinitions();
  return getFeatureDefinitions();
}
function loadFeatures(features) {
  const featureDefinitions2 = getInitializedFeatureDefinitions();
  for (const key in features) {
    featureDefinitions2[key] = {
      ...featureDefinitions2[key],
      ...features[key]
    };
  }
  setFeatureDefinitions(featureDefinitions2);
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (typeof isValidProp !== "function")
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
const MotionContext = /* @__PURE__ */ createContext({});
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));
  return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
function useSVGProps(props, visualState, _isStatic, Component2) {
  const visualProps = useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component2), props.transformTemplate, props.style);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component2) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component2 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component2.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component2) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component2)
  ) {
    return true;
  }
  return false;
}
function useRender(Component2, props, ref, { latestValues }, isStatic, forwardMotionProps = false, isSVG) {
  const useVisualProps = isSVG ?? isSVGComponent(Component2) ? useSVGProps : useHTMLProps;
  const visualProps = useVisualProps(props, latestValues, isStatic, Component2);
  const filteredProps = filterProps(props, typeof Component2 === "string", forwardMotionProps);
  const elementProps = Component2 !== Fragment ? { ...filteredProps, ...visualProps, ref } : {};
  const { children } = props;
  const renderedChildren = useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
  return createElement$1(Component2, {
    ...elementProps,
    children: renderedChildren
  });
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  return state;
}
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list.length; i2++) {
      const resolved = resolveVariantFromProps(props, list[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = useContext(MotionContext);
  const presenceContext = useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
const useHTMLVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
  createRenderState: createHtmlRenderState
});
const useSVGVisualState = /* @__PURE__ */ makeUseVisualState({
  scrapeMotionValuesFromProps,
  createRenderState: createSvgRenderState
});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function useMotionRef(visualState, visualElement, externalRef) {
  const externalRefContainer = useRef(externalRef);
  useInsertionEffect$1(() => {
    externalRefContainer.current = externalRef;
  });
  const refCleanup = useRef(null);
  return useCallback((instance) => {
    if (instance) {
      visualState.onMount?.(instance);
    }
    if (visualElement) {
      instance ? visualElement.mount(instance) : visualElement.unmount();
    }
    const ref = externalRefContainer.current;
    if (typeof ref === "function") {
      if (instance) {
        const cleanup = ref(instance);
        if (typeof cleanup === "function") {
          refCleanup.current = cleanup;
        }
      } else if (refCleanup.current) {
        refCleanup.current();
        refCleanup.current = null;
      } else {
        ref(instance);
      }
    } else if (ref) {
      ref.current = instance;
    }
  }, [visualElement]);
}
const SwitchLayoutGroupContext = createContext({});
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useVisualElement(Component2, visualState, props, createVisualElement, ProjectionNodeConstructor, isSVG) {
  const { visualElement: parent } = useContext(MotionContext);
  const lazyContext = useContext(LazyContext);
  const presenceContext = useContext(PresenceContext);
  const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = useRef(null);
  const hasMountedOnce = useRef(false);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component2, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig,
      isSVG
    });
    if (hasMountedOnce.current && visualElementRef.current) {
      visualElementRef.current.manuallyAnimateOnMount = true;
    }
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = useRef(false);
  useInsertionEffect$1(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = useRef(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
  useIsomorphicLayoutEffect$2(() => {
    hasMountedOnce.current = true;
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    visualElement.scheduleRenderMicrotask();
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  useEffect(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
    visualElement.enteringChildren = void 0;
  });
  return visualElement;
}
function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function createMotionComponent(Component2, { forwardMotionProps = false, type } = {}, preloadedFeatures, createVisualElement) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  const isSVG = type ? type === "svg" : isSVGComponent(Component2);
  const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;
  function MotionDOMComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser$1) {
      useStrictMode(configAndProps, preloadedFeatures);
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component2, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode, isSVG);
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component2, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps, isSVG)] });
  }
  MotionDOMComponent.displayName = `motion.${typeof Component2 === "string" ? Component2 : `create(${Component2.displayName ?? Component2.name ?? ""})`}`;
  const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component2;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  const isStrict = useContext(LazyContext).strict;
  if (process.env.NODE_ENV !== "production" && preloadedFeatures && isStrict) {
    const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    configAndProps.ignoreStrict ? warning(false, strictMessage, "lazy-strict-mode") : invariant(false, strictMessage, "lazy-strict-mode");
  }
}
function getProjectionFunctionality(props) {
  const featureDefinitions2 = getInitializedFeatureDefinitions();
  const { drag: drag2, layout: layout2 } = featureDefinitions2;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
function createMotionProxy(preloadedFeatures, createVisualElement) {
  if (typeof Proxy === "undefined") {
    return createMotionComponent;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const factory = (Component2, options) => {
    return createMotionComponent(Component2, options, preloadedFeatures, createVisualElement);
  };
  const deprecatedFactoryFunction = (Component2, options) => {
    if (process.env.NODE_ENV !== "production") {
      warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
    }
    return factory(Component2, options);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create")
        return factory;
      if (!componentCache.has(key)) {
        componentCache.set(key, createMotionComponent(key, void 0, preloadedFeatures, createVisualElement));
      }
      return componentCache.get(key);
    }
  });
}
const createDomVisualElement = (Component2, options) => {
  const isSVG = options.isSVG ?? isSVGComponent(Component2);
  return isSVG ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component2 !== Fragment
  });
};
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    if (isAnimationControls(animate)) {
      this.unmountControls = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    this.node.animationState.reset();
    this.unmountControls?.();
  }
}
let id = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => {
        onExitComplete(this.id);
      });
    }
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    if (onExitComplete) {
      onExitComplete(this.id);
    }
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};
const distance = (a3, b2) => Math.abs(a3 - b2);
function distance2D(a3, b2) {
  const xDelta = distance(a3.x, b2.x);
  const yDelta = distance(a3.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
const overflowStyles = /* @__PURE__ */ new Set(["auto", "scroll"]);
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3, element } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.scrollPositions = /* @__PURE__ */ new Map();
    this.removeScrollListeners = null;
    this.onElementScroll = (event2) => {
      this.handleScroll(event2.target);
    };
    this.onWindowScroll = () => {
      this.handleScroll(window);
    };
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info3 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info3.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info3;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info3);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info3);
    };
    this.handlePointerMove = (event2, info3) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info3, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info3) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin || !this.startEvent) {
        resumeAnimation && resumeAnimation();
      }
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info3, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.distanceThreshold = distanceThreshold;
    this.contextWindow = contextWindow || window;
    const info2 = extractEventInfo(event);
    const initialInfo = transformPoint(info2, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
    if (element) {
      this.startScrollTracking(element);
    }
  }
  /**
   * Start tracking scroll on ancestors and window.
   */
  startScrollTracking(element) {
    let current = element.parentElement;
    while (current) {
      const style = getComputedStyle(current);
      if (overflowStyles.has(style.overflowX) || overflowStyles.has(style.overflowY)) {
        this.scrollPositions.set(current, {
          x: current.scrollLeft,
          y: current.scrollTop
        });
      }
      current = current.parentElement;
    }
    this.scrollPositions.set(window, {
      x: window.scrollX,
      y: window.scrollY
    });
    window.addEventListener("scroll", this.onElementScroll, {
      capture: true,
      passive: true
    });
    window.addEventListener("scroll", this.onWindowScroll, {
      passive: true
    });
    this.removeScrollListeners = () => {
      window.removeEventListener("scroll", this.onElementScroll, {
        capture: true
      });
      window.removeEventListener("scroll", this.onWindowScroll);
    };
  }
  /**
   * Handle scroll compensation during drag.
   *
   * For element scroll: adjusts history origin since pageX/pageY doesn't change.
   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.
   */
  handleScroll(target) {
    const initial = this.scrollPositions.get(target);
    if (!initial)
      return;
    const isWindow = target === window;
    const current = isWindow ? { x: window.scrollX, y: window.scrollY } : {
      x: target.scrollLeft,
      y: target.scrollTop
    };
    const delta = { x: current.x - initial.x, y: current.y - initial.y };
    if (delta.x === 0 && delta.y === 0)
      return;
    if (isWindow) {
      if (this.lastMoveEventInfo) {
        this.lastMoveEventInfo.point.x += delta.x;
        this.lastMoveEventInfo.point.y += delta.y;
      }
    } else {
      if (this.history.length > 0) {
        this.history[0].x -= delta.x;
        this.history[0].y -= delta.y;
      }
    }
    this.scrollPositions.set(target, current);
    frame.update(this.updatePoint, true);
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    this.removeScrollListeners && this.removeScrollListeners();
    this.scrollPositions.clear();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info2, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info2.point) } : info2;
}
function subtractPoint(a3, b2) {
  return { x: a3.x - b2.x, y: a3.y - b2.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = /* @__PURE__ */ millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mixNumber$1(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mixNumber$1(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min);
  }
  return clamp$1(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.latestPointerEvent = null;
    this.latestPanInfo = null;
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      if (snapToCursor) {
        this.stopAnimation();
        this.snapToCursor(extractEventInfo(event).point);
      } else {
        this.pauseAnimation();
      }
    };
    const onStart = (event, info2) => {
      this.stopAnimation();
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock)
          this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock)
          return;
      }
      this.latestPointerEvent = event;
      this.latestPanInfo = info2;
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info2));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info2) => {
      this.latestPointerEvent = event;
      this.latestPanInfo = info2;
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset: offset2 } = info2;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info2.point, offset2);
      this.updateAxis("y", info2.point, offset2);
      this.visualElement.render();
      onDrag && onDrag(event, info2);
    };
    const onSessionEnd = (event, info2) => {
      this.latestPointerEvent = event;
      this.latestPanInfo = info2;
      this.stop(event, info2);
      this.latestPointerEvent = null;
      this.latestPanInfo = null;
    };
    const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play());
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      distanceThreshold,
      contextWindow: getContextWindow(this.visualElement),
      element: this.visualElement.current
    });
  }
  /**
   * @internal
   */
  stop(event, panInfo) {
    const finalEvent = event || this.latestPointerEvent;
    const finalPanInfo = panInfo || this.latestPanInfo;
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2 || !finalPanInfo || !finalEvent)
      return;
    const { velocity } = finalPanInfo;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
    }
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.endPanSession();
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  /**
   * Clean up the pan session without modifying other drag state.
   * This is used during unmount to ensure event listeners are removed
   * without affecting projection animations or drag locks.
   * @internal
   */
  endPanSession() {
    this.panSession && this.panSession.end();
    this.panSession = void 0;
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset2[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
  }
  getAnimationState(axis) {
    return this.getAxisMotionValue(axis).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        const current = axisValue.get() || 0;
        axisValue.set(point[axis] - mixNumber$1(min2, max2, 0.5) + current);
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      const target = event.target;
      const isClickingKeyboardAccessibleChild = target !== element && isElementKeyboardAccessible(target);
      if (drag2 && dragListener && !isClickingKeyboardAccessibleChild) {
        this.start(event);
      }
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    }));
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset2.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset2.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop$1;
    this.removeListeners = noop$1;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop$1;
  }
  update() {
    const { dragControls } = this.node.getProps();
    const { dragControls: prevDragControls } = this.node.prevProps || {};
    if (dragControls !== prevDragControls) {
      this.removeGroupControls();
      if (dragControls) {
        this.removeGroupControls = dragControls.subscribe(this.controls);
      }
    }
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
    if (!this.controls.isDragging) {
      this.controls.endPanSession();
    }
  }
}
const asyncHandler = (handler) => (event, info2) => {
  if (handler) {
    frame.postRender(() => handler(event, info2));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop$1;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info2) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info2));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
let hasTakenAnySnapshot = false;
class MeasureLayoutWithContext extends Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      if (hasTakenAnySnapshot) {
        projection.root.didUpdate();
      }
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        layoutDependency: this.props.layoutDependency,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const { projection } = visualElement;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (prevProps.layoutDependency !== layoutDependency) {
      projection.setOptions({
        ...projection.options,
        layoutDependency
      });
    }
    hasTakenAnySnapshot = true;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    hasTakenAnySnapshot = true;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function handleHoverEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileHover) {
    node.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class HoverGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = hover(current, (_element, startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function handlePressEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.current instanceof HTMLButtonElement && node.current.disabled) {
    return;
  }
  if (node.animationState && props.whileTap) {
    node.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class PressGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = press(current, (_element, startEvent) => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, { useGlobalTarget: this.node.props.globalTapTarget });
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
};
const motion = /* @__PURE__ */ createMotionProxy(featureBundle, createDomVisualElement);
var focusTrapReact = { exports: {} };
/*!
* tabbable 6.4.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var candidateSelectors = ["input:not([inert]):not([inert] *)", "select:not([inert]):not([inert] *)", "textarea:not([inert]):not([inert] *)", "a[href]:not([inert]):not([inert] *)", "button:not([inert]):not([inert] *)", "[tabindex]:not(slot):not([inert]):not([inert] *)", "audio[controls]:not([inert]):not([inert] *)", "video[controls]:not([inert]):not([inert] *)", '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)', "details>summary:first-of-type:not([inert]):not([inert] *)", "details:not([inert]):not([inert] *)"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var _isInert = function isInert(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && // closest does not exist on shadow roots, so we fall back to a manual
  // lookup upward, in case it is not defined.
  (typeof node.closest === "function" ? node.closest("[inert]") : _isInert(node.parentNode));
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter2) {
  if (_isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter2);
  return candidates;
};
var _getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (_isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = _getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !_isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = _getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a3, b2) {
  return a3.tabIndex === b2.tabIndex ? a3.documentOrder - b2.documentOrder : a3.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i2 = 0; i2 < nodes.length; i2++) {
    if (nodes[i2].checked && nodes[i2].form === form) {
      return nodes[i2];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (displayCheck === "full-native") {
    if ("checkVisibility" in node) {
      var visible = node.checkVisibility({
        // Checking opacity might be desirable for some use cases, but natively,
        // opacity zero elements _are_ focusable and tabbable.
        checkOpacity: false,
        opacityProperty: false,
        contentVisibilityAuto: true,
        visibilityProperty: true,
        // This is an alias for `visibilityProperty`. Contemporary browsers
        // support both. However, this alias has wider browser support (Chrome
        // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
        // we include it anyway.
        checkVisibilityCSS: true
      });
      return !visible;
    }
  }
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || // full-native can run this branch when it falls through in case
  // Element#checkVisibility is unsupported
  displayCheck === "full-native" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i2 = 0; i2 < parentNode.children.length; i2++) {
          var child = parentNode.children.item(i2);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isShadowRootTabbable = function isShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var _sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i2) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? _sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i2,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = _getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return _sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = _getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe:not([inert]):not([inert] *)").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};
const index_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  focusable,
  getTabIndex,
  isFocusable,
  isTabbable,
  tabbable
}, Symbol.toStringTag, { value: "Module" }));
/*!
* focus-trap 7.8.0
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
function _arrayLikeToArray(r2, a3) {
  (null == a3 || a3 > r2.length) && (a3 = r2.length);
  for (var e2 = 0, n2 = Array(a3); e2 < a3; e2++) n2[e2] = r2[e2];
  return n2;
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
function _createForOfIteratorHelper(r2, e2) {
  var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t2) {
    if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2) {
      t2 && (r2 = t2);
      var n2 = 0, F2 = function() {
      };
      return {
        s: F2,
        n: function() {
          return n2 >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[n2++]
          };
        },
        e: function(r3) {
          throw r3;
        },
        f: F2
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o4, a3 = true, u2 = false;
  return {
    s: function() {
      t2 = t2.call(r2);
    },
    n: function() {
      var r3 = t2.next();
      return a3 = r3.done, r3;
    },
    e: function(r3) {
      u2 = true, o4 = r3;
    },
    f: function() {
      try {
        a3 || null == t2.return || t2.return();
      } finally {
        if (u2) throw o4;
      }
    }
  };
}
function _defineProperty(e2, r2, t2) {
  return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e2);
    r2 && (o4 = o4.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o4);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _toPrimitive(t2, r2) {
  if ("object" != typeof t2 || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2);
    if ("object" != typeof i2) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == typeof i2 ? i2 : i2 + "";
}
function _unsupportedIterableToArray(r2, a3) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a3);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a3) : void 0;
  }
}
var activeFocusTraps = {
  // Returns the trap from the top of the stack.
  getActiveTrap: function getActiveTrap(trapStack) {
    if ((trapStack === null || trapStack === void 0 ? void 0 : trapStack.length) > 0) {
      return trapStack[trapStack.length - 1];
    }
    return null;
  },
  // Pauses the currently active trap, then adds a new trap to the stack.
  activateTrap: function activateTrap(trapStack, trap) {
    var activeTrap = activeFocusTraps.getActiveTrap(trapStack);
    if (trap !== activeTrap) {
      activeFocusTraps.pauseTrap(trapStack);
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  // Removes the trap from the top of the stack, then unpauses the next trap down.
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    activeFocusTraps.unpauseTrap(trapStack);
  },
  // Pauses the trap at the top of the stack.
  pauseTrap: function pauseTrap(trapStack) {
    var activeTrap = activeFocusTraps.getActiveTrap(trapStack);
    activeTrap === null || activeTrap === void 0 || activeTrap._setPausedState(true);
  },
  // Unpauses the trap at the top of the stack.
  unpauseTrap: function unpauseTrap(trapStack) {
    var activeTrap = activeFocusTraps.getActiveTrap(trapStack);
    if (activeTrap && !activeTrap._isManuallyPaused()) {
      activeTrap._setPausedState(false);
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e2) {
  return (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Escape" || (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Esc" || (e2 === null || e2 === void 0 ? void 0 : e2.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e2) {
  return (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Tab" || (e2 === null || e2 === void 0 ? void 0 : e2.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e2) {
  return isTabEvent(e2) && !e2.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e2) {
  return isTabEvent(e2) && e2.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isolateSubtrees: false,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    /** @type {Array<HTMLElement>} */
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    /** @type {Array<{
     *    container: HTMLElement,
     *    tabbableNodes: Array<HTMLElement>, // empty if none
     *    focusableNodes: Array<HTMLElement>, // empty if none
     *    posTabIndexesFound: boolean,
     *    firstTabbableNode: HTMLElement|undefined,
     *    lastTabbableNode: HTMLElement|undefined,
     *    firstDomTabbableNode: HTMLElement|undefined,
     *    lastDomTabbableNode: HTMLElement|undefined,
     *    nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
     *  }>}
     */
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    // references to nodes that are siblings to the ancestors of this trap's containers.
    /** @type {Set<HTMLElement>} */
    adjacentElements: /* @__PURE__ */ new Set(),
    // references to nodes that were inert or aria-hidden before the trap was activated.
    /** @type {Set<HTMLElement>} */
    alreadySilent: /* @__PURE__ */ new Set(),
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    manuallyPaused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      optionValue = optionValue.apply(void 0, _toConsumableArray(params));
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      try {
        node = doc.querySelector(optionValue);
      } catch (err) {
        throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
      }
      if (!node) {
        if (!hasFallback) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus", {
      hasFallback: true
    });
    if (node === false) {
      return false;
    }
    if (node === void 0 || node && !isFocusable(node, config.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    } else if (node === null) {
      node = getNodeForOption("fallbackFocus");
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node) {
        return isTabbable(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
        return isTabbable(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node) {
        return getTabIndex(node) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state.containerGroups.find(function(g2) {
      return g2.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var _getActiveElement = function getActiveElement(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return _getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var _tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === _getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      _tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", {
      params: [previousActiveElement]
    });
    return node ? node : node === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref3) {
    var target = _ref3.target, event = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
          var firstTabbableNode = _ref4.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
          var lastTabbableNode = _ref5.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target, e2) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      event.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state.containerGroups.some(function(g2) {
            return g2.tabbableNodes.some(function(n2) {
              return getTabIndex(n2) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        _tryFocus(nextNode);
      } else {
        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      _tryFocus(destinationNode);
    }
  };
  var checkTabKey = function checkTabKey2(event) {
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkEscapeKey = function checkEscapeKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
    }
  };
  var checkClick = function checkClick2(e2) {
    var target = getActualTarget(e2);
    if (findContainerIndex(target, e2) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e2)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e2)) {
      return;
    }
    e2.preventDefault();
    e2.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      _tryFocus(getInitialFocusNode());
    }) : _tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkTabKey, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var collectAdjacentElements = function collectAdjacentElements2(containers) {
    if (state.active && !state.paused) {
      trap._setSubtreeIsolation(false);
    }
    state.adjacentElements.clear();
    state.alreadySilent.clear();
    var containerAncestors = /* @__PURE__ */ new Set();
    var adjacentElements = /* @__PURE__ */ new Set();
    var _iterator = _createForOfIteratorHelper(containers), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var container = _step.value;
        containerAncestors.add(container);
        var insideShadowRoot = typeof ShadowRoot !== "undefined" && container.getRootNode() instanceof ShadowRoot;
        var current = container;
        while (current) {
          containerAncestors.add(current);
          var parent = current.parentElement;
          var siblings = [];
          if (parent) {
            siblings = parent.children;
          } else if (!parent && insideShadowRoot) {
            siblings = current.getRootNode().children;
            parent = current.getRootNode().host;
            insideShadowRoot = typeof ShadowRoot !== "undefined" && parent.getRootNode() instanceof ShadowRoot;
          }
          var _iterator2 = _createForOfIteratorHelper(siblings), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var child = _step2.value;
              adjacentElements.add(child);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          current = parent;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    containerAncestors.forEach(function(el) {
      adjacentElements["delete"](el);
    });
    state.adjacentElements = adjacentElements;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkTabKey, true);
    doc.removeEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      _tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      var preexistingTrap = activeFocusTraps.getActiveTrap(trapStack);
      var revertState = false;
      if (preexistingTrap && !preexistingTrap.paused) {
        var _preexistingTrap$_set;
        (_preexistingTrap$_set = preexistingTrap._setSubtreeIsolation) === null || _preexistingTrap$_set === void 0 || _preexistingTrap$_set.call(preexistingTrap, false);
        revertState = true;
      }
      try {
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = _getActiveElement(doc);
        onActivate === null || onActivate === void 0 || onActivate();
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          updateObservedNodes();
          if (config.isolateSubtrees) {
            trap._setSubtreeIsolation(true);
          }
          onPostActivate === null || onPostActivate === void 0 || onPostActivate();
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
      } catch (error2) {
        if (preexistingTrap === activeFocusTraps.getActiveTrap(trapStack) && revertState) {
          var _preexistingTrap$_set2;
          (_preexistingTrap$_set2 = preexistingTrap._setSubtreeIsolation) === null || _preexistingTrap$_set2 === void 0 || _preexistingTrap$_set2.call(preexistingTrap, true);
        }
        throw error2;
      }
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      if (!state.paused) {
        trap._setSubtreeIsolation(false);
      }
      state.alreadySilent.clear();
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = true;
      return this._setPausedState(true, pauseOptions);
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = false;
      if (trapStack[trapStack.length - 1] !== this) {
        return this;
      }
      return this._setPausedState(false, unpauseOptions);
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (config.isolateSubtrees) {
        collectAdjacentElements(state.containers);
      }
      if (state.active) {
        updateTabbableNodes();
        if (config.isolateSubtrees && !state.paused) {
          trap._setSubtreeIsolation(true);
        }
      }
      updateObservedNodes();
      return this;
    }
  };
  Object.defineProperties(trap, {
    _isManuallyPaused: {
      value: function value() {
        return state.manuallyPaused;
      }
    },
    _setPausedState: {
      value: function value(paused, options) {
        if (state.paused === paused) {
          return this;
        }
        state.paused = paused;
        if (paused) {
          var onPause = getOption(options, "onPause");
          var onPostPause = getOption(options, "onPostPause");
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          trap._setSubtreeIsolation(false);
          onPostPause === null || onPostPause === void 0 || onPostPause();
        } else {
          var onUnpause = getOption(options, "onUnpause");
          var onPostUnpause = getOption(options, "onPostUnpause");
          onUnpause === null || onUnpause === void 0 || onUnpause();
          trap._setSubtreeIsolation(true);
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
        }
        return this;
      }
    },
    _setSubtreeIsolation: {
      value: function value(isEnabled) {
        if (config.isolateSubtrees) {
          state.adjacentElements.forEach(function(el) {
            var _el$getAttribute;
            if (isEnabled) {
              switch (config.isolateSubtrees) {
                case "aria-hidden":
                  if (el.ariaHidden === "true" || ((_el$getAttribute = el.getAttribute("aria-hidden")) === null || _el$getAttribute === void 0 ? void 0 : _el$getAttribute.toLowerCase()) === "true") {
                    state.alreadySilent.add(el);
                  }
                  el.setAttribute("aria-hidden", "true");
                  break;
                default:
                  if (el.inert || el.hasAttribute("inert")) {
                    state.alreadySilent.add(el);
                  }
                  el.setAttribute("inert", true);
                  break;
              }
            } else {
              if (state.alreadySilent.has(el)) ;
              else {
                switch (config.isolateSubtrees) {
                  case "aria-hidden":
                    el.removeAttribute("aria-hidden");
                    break;
                  default:
                    el.removeAttribute("inert");
                    break;
                }
              }
            }
          });
        }
      }
    }
  });
  trap.updateContainerElements(elements);
  return trap;
};
const focusTrap_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createFocusTrap
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(focusTrap_esm);
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(index_esm);
var hasRequiredFocusTrapReact;
function requireFocusTrapReact() {
  if (hasRequiredFocusTrapReact) return focusTrapReact.exports;
  hasRequiredFocusTrapReact = 1;
  function _typeof2(o4) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
      return typeof o5;
    } : function(o5) {
      return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
    }, _typeof2(o4);
  }
  var _exec$, _exec;
  function _classCallCheck(a3, n2) {
    if (!(a3 instanceof n2)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e2, r2) {
    for (var t2 = 0; t2 < r2.length; t2++) {
      var o4 = r2[t2];
      o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(e2, _toPropertyKey2(o4.key), o4);
    }
  }
  function _createClass(e2, r2, t2) {
    return r2 && _defineProperties(e2.prototype, r2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
  }
  function _callSuper(t2, o4, e2) {
    return o4 = _getPrototypeOf(o4), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o4, e2 || [], _getPrototypeOf(t2).constructor) : o4.apply(t2, e2));
  }
  function _possibleConstructorReturn(t2, e2) {
    if (e2 && ("object" == _typeof2(e2) || "function" == typeof e2)) return e2;
    if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t2);
  }
  function _assertThisInitialized(e2) {
    if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e2;
  }
  function _isNativeReflectConstruct() {
    try {
      var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t3) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
      return !!t2;
    })();
  }
  function _getPrototypeOf(t2) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
      return t3.__proto__ || Object.getPrototypeOf(t3);
    }, _getPrototypeOf(t2);
  }
  function _inherits(t2, e2) {
    if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
    t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, "prototype", { writable: false }), e2 && _setPrototypeOf(t2, e2);
  }
  function _setPrototypeOf(t2, e2) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
      return t3.__proto__ = e3, t3;
    }, _setPrototypeOf(t2, e2);
  }
  function _defineProperty2(e2, r2, t2) {
    return (r2 = _toPropertyKey2(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
  }
  function _toPropertyKey2(t2) {
    var i2 = _toPrimitive2(t2, "string");
    return "symbol" == _typeof2(i2) ? i2 : i2 + "";
  }
  function _toPrimitive2(t2, r2) {
    if ("object" != _typeof2(t2) || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != _typeof2(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  var React2 = React__default;
  var _require = require$$1, createFocusTrap3 = _require.createFocusTrap;
  var _require2 = require$$2, isFocusable3 = _require2.isFocusable;
  var reactVerMajor = parseInt((_exec$ = (_exec = /^(\d+)\./.exec(React2.version)) === null || _exec === void 0 ? void 0 : _exec[1]) !== null && _exec$ !== void 0 ? _exec$ : 0, 10);
  var FocusTrap2 = /* @__PURE__ */ (function(_React$Component) {
    function FocusTrap3(props) {
      var _this;
      _classCallCheck(this, FocusTrap3);
      _this = _callSuper(this, FocusTrap3, [props]);
      _defineProperty2(_this, "getNodeForOption", function(optionName2) {
        var _this$internalOptions;
        var optionValue = (_this$internalOptions = this.internalOptions[optionName2]) !== null && _this$internalOptions !== void 0 ? _this$internalOptions : this.originalOptions[optionName2];
        if (typeof optionValue === "function") {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName2, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          var _this$getDocument;
          node = (_this$getDocument = this.getDocument()) === null || _this$getDocument === void 0 ? void 0 : _this$getDocument.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName2, "` as selector refers to no known node"));
          }
        }
        return node;
      });
      _this.handleDeactivate = _this.handleDeactivate.bind(_this);
      _this.handlePostDeactivate = _this.handlePostDeactivate.bind(_this);
      _this.handleClickOutsideDeactivates = _this.handleClickOutsideDeactivates.bind(_this);
      _this.internalOptions = {
        // We need to hijack the returnFocusOnDeactivate option,
        // because React can move focus into the element before we arrived at
        // this lifecycle hook (e.g. with autoFocus inputs). So the component
        // captures the previouslyFocusedElement in componentWillMount,
        // then (optionally) returns focus to it in componentWillUnmount.
        returnFocusOnDeactivate: false,
        // the rest of these are also related to deactivation of the trap, and we
        //  need to use them and control them as well
        checkCanReturnFocus: null,
        onDeactivate: _this.handleDeactivate,
        onPostDeactivate: _this.handlePostDeactivate,
        // we need to special-case this setting as well so that we can know if we should
        //  NOT return focus if the trap gets auto-deactivated as the result of an
        //  outside click (otherwise, we'll always think we should return focus because
        //  of how we manage that flag internally here)
        clickOutsideDeactivates: _this.handleClickOutsideDeactivates
      };
      _this.originalOptions = {
        // because of the above `internalOptions`, we maintain our own flag for
        //  this option, and default it to `true` because that's focus-trap's default
        returnFocusOnDeactivate: true,
        // because of the above `internalOptions`, we keep these separate since
        //  they're part of the deactivation process which we configure (internally) to
        //  be shared between focus-trap and focus-trap-react
        onDeactivate: null,
        onPostDeactivate: null,
        checkCanReturnFocus: null,
        // the user's setting, defaulted to false since focus-trap defaults this to false
        clickOutsideDeactivates: false
      };
      var focusTrapOptions = props.focusTrapOptions;
      for (var optionName in focusTrapOptions) {
        if (!Object.prototype.hasOwnProperty.call(focusTrapOptions, optionName)) {
          continue;
        }
        if (optionName === "returnFocusOnDeactivate" || optionName === "onDeactivate" || optionName === "onPostDeactivate" || optionName === "checkCanReturnFocus" || optionName === "clickOutsideDeactivates") {
          _this.originalOptions[optionName] = focusTrapOptions[optionName];
          continue;
        }
        _this.internalOptions[optionName] = focusTrapOptions[optionName];
      }
      _this.outsideClick = null;
      _this.focusTrapElements = props.containerElements || [];
      _this.updatePreviousElement();
      return _this;
    }
    _inherits(FocusTrap3, _React$Component);
    return _createClass(FocusTrap3, [{
      key: "getDocument",
      value: function getDocument() {
        return this.props.focusTrapOptions.document || (typeof document !== "undefined" ? document : void 0);
      }
    }, {
      key: "getReturnFocusNode",
      value: function getReturnFocusNode() {
        var node = this.getNodeForOption("setReturnFocus", this.previouslyFocusedElement);
        return node ? node : node === false ? false : this.previouslyFocusedElement;
      }
      /** Update the previously focused element with the currently focused element. */
    }, {
      key: "updatePreviousElement",
      value: function updatePreviousElement() {
        var currentDocument = this.getDocument();
        if (currentDocument) {
          this.previouslyFocusedElement = currentDocument.activeElement;
        }
      }
    }, {
      key: "deactivateTrap",
      value: function deactivateTrap2() {
        if (!this.focusTrap || !this.focusTrap.active) {
          return;
        }
        this.focusTrap.deactivate({
          // NOTE: we never let the trap return the focus since we do that ourselves
          returnFocus: false,
          // we'll call this in our own post deactivate handler so make sure the trap doesn't
          //  do it prematurely
          checkCanReturnFocus: null,
          // let it call the user's original deactivate handler, if any, instead of
          //  our own which calls back into this function
          onDeactivate: this.originalOptions.onDeactivate
          // NOTE: for post deactivate, don't specify anything so that it calls the
          //  onPostDeactivate handler specified on `this.internalOptions`
          //  which will always be our own `handlePostDeactivate()` handler, which
          //  will finish things off by calling the user's provided onPostDeactivate
          //  handler, if any, at the right time
          // onPostDeactivate: NOTHING
        });
      }
    }, {
      key: "handleClickOutsideDeactivates",
      value: function handleClickOutsideDeactivates(event) {
        var allowDeactivation = typeof this.originalOptions.clickOutsideDeactivates === "function" ? this.originalOptions.clickOutsideDeactivates.call(null, event) : this.originalOptions.clickOutsideDeactivates;
        if (allowDeactivation) {
          this.outsideClick = {
            target: event.target,
            allowDeactivation
          };
        }
        return allowDeactivation;
      }
    }, {
      key: "handleDeactivate",
      value: function handleDeactivate() {
        if (this.originalOptions.onDeactivate) {
          this.originalOptions.onDeactivate.call(null);
        }
        this.deactivateTrap();
      }
    }, {
      key: "handlePostDeactivate",
      value: function handlePostDeactivate() {
        var _this2 = this;
        var finishDeactivation = function finishDeactivation2() {
          var returnFocusNode = _this2.getReturnFocusNode();
          var canReturnFocus = !!// did the consumer allow it?
          (_this2.originalOptions.returnFocusOnDeactivate && // can we actually focus the node?
          returnFocusNode !== null && returnFocusNode !== void 0 && returnFocusNode.focus && // was there an outside click that allowed deactivation?
          (!_this2.outsideClick || // did the consumer allow deactivation when the outside node was clicked?
          _this2.outsideClick.allowDeactivation && // is the outside node NOT focusable (implying that it did NOT receive focus
          //  as a result of the click-through) -- in which case do NOT restore focus
          //  to `returnFocusNode` because focus should remain on the outside node
          !isFocusable3(_this2.outsideClick.target, _this2.internalOptions.tabbableOptions)));
          var _this2$internalOption = _this2.internalOptions.preventScroll, preventScroll = _this2$internalOption === void 0 ? false : _this2$internalOption;
          if (canReturnFocus) {
            returnFocusNode.focus({
              preventScroll
            });
          }
          if (_this2.originalOptions.onPostDeactivate) {
            _this2.originalOptions.onPostDeactivate.call(null);
          }
          _this2.outsideClick = null;
        };
        if (this.originalOptions.checkCanReturnFocus) {
          this.originalOptions.checkCanReturnFocus.call(null, this.getReturnFocusNode()).then(finishDeactivation, finishDeactivation);
        } else {
          finishDeactivation();
        }
      }
    }, {
      key: "setupFocusTrap",
      value: function setupFocusTrap() {
        if (this.focusTrap) {
          if (this.props.active && !this.focusTrap.active) {
            this.focusTrap.activate();
            if (this.props.paused) {
              this.focusTrap.pause();
            }
          }
        } else {
          var nodesExist = this.focusTrapElements.some(Boolean);
          if (nodesExist) {
            this.focusTrap = this.props._createFocusTrap(this.focusTrapElements, this.internalOptions);
            if (this.props.active) {
              this.focusTrap.activate();
            }
            if (this.props.paused) {
              this.focusTrap.pause();
            }
          }
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        if (this.props.active) {
          this.setupFocusTrap();
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (this.focusTrap) {
          if (prevProps.containerElements !== this.props.containerElements) {
            this.focusTrap.updateContainerElements(this.props.containerElements);
          }
          var hasActivated = !prevProps.active && this.props.active;
          var hasDeactivated = prevProps.active && !this.props.active;
          var hasPaused = !prevProps.paused && this.props.paused;
          var hasUnpaused = prevProps.paused && !this.props.paused;
          if (hasActivated) {
            this.updatePreviousElement();
            this.focusTrap.activate();
          }
          if (hasDeactivated) {
            this.deactivateTrap();
            return;
          }
          if (hasPaused) {
            this.focusTrap.pause();
          }
          if (hasUnpaused) {
            this.focusTrap.unpause();
          }
        } else {
          if (prevProps.containerElements !== this.props.containerElements) {
            this.focusTrapElements = this.props.containerElements;
          }
          if (this.props.active) {
            this.updatePreviousElement();
            this.setupFocusTrap();
          }
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.deactivateTrap();
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;
        var child = this.props.children ? React2.Children.only(this.props.children) : void 0;
        if (child) {
          if (child.type && child.type === React2.Fragment) {
            throw new Error("A focus-trap cannot use a Fragment as its child container. Try replacing it with a <div> element.");
          }
          var callbackRef = function callbackRef2(element) {
            var containerElements = _this3.props.containerElements;
            if (child) {
              if (reactVerMajor >= 19) {
                if (typeof child.props.ref === "function") {
                  child.props.ref(element);
                } else if (child.props.ref) {
                  child.props.ref.current = element;
                }
              } else {
                if (typeof child.ref === "function") {
                  child.ref(element);
                } else if (child.ref) {
                  child.ref.current = element;
                }
              }
            }
            _this3.focusTrapElements = containerElements ? containerElements : [element];
          };
          var childWithRef = React2.cloneElement(child, {
            ref: callbackRef
          });
          return childWithRef;
        }
        return null;
      }
    }]);
  })(React2.Component);
  FocusTrap2.defaultProps = {
    active: true,
    paused: false,
    focusTrapOptions: {},
    _createFocusTrap: createFocusTrap3
  };
  focusTrapReact.exports = FocusTrap2;
  focusTrapReact.exports.FocusTrap = FocusTrap2;
  return focusTrapReact.exports;
}
var focusTrapReactExports = requireFocusTrapReact();
const FocusTrap = /* @__PURE__ */ getDefaultExportFromCjs(focusTrapReactExports);
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message2) {
  var e2 = new Error(message2);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect$1(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a3) {
  return a3;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter2) {
          pendingQueue = pendingQueue.filter(filter2);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = React.forwardRef(function(props, parentRef) {
  var ref = React.useRef(null);
  var _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container2 = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(
    React.Fragment,
    null,
    enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container2, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle2 = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle2(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  React.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll2 = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll2) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll2;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id2 = React.useState(idCounter++)[0];
  var Style2 = React.useState(styleSingleton)[0];
  var lastProps = React.useRef(props);
  React.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  React.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el) {
        return el.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el) {
          return el.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var selection = window.getSelection();
    var anchorNode = selection && selection.anchorNode;
    var isTouchingSelection = anchorNode ? anchorNode === target || anchorNode.contains(target) : false;
    if (isTouchingSelection) {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  React.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return React.createElement(
    React.Fragment,
    null,
    inert ? React.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? React.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props, ref) {
  return React.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
const DrawerContext = createContext(null);
const useDrawerContext = () => {
  const context = useContext(DrawerContext);
  if (!context) {
    throw new Error("Drawer sub-components must be used within a Drawer.Root component.");
  }
  return context;
};
const DrawerHeader = ({ children, className = "", style, hasCloseButton = true }) => {
  const { onClose } = useDrawerContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex items-start justify-between p-6 border-b border-border-color dark:border-dark-border-color shrink-0", className), style, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { id: "drawer-title", className: "text-xl font-bold font-heading text-text-primary dark:text-dark-text-primary", children }),
    hasCloseButton && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: (e2) => {
          e2.preventDefault();
          e2.stopPropagation();
          onClose();
        },
        "aria-label": "Close drawer",
        className: "p-1 -mt-1 -mr-2 rounded-full text-text-secondary dark:text-dark-text-secondary hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary transition-colors",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "close" })
      }
    )
  ] });
};
DrawerHeader.displayName = "Drawer.Header";
const DrawerBody = ({ children, className = "", style }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "drawer-description", className: cn("p-6 overflow-y-auto custom-scrollbar flex-grow", className), style, children });
DrawerBody.displayName = "Drawer.Body";
const DrawerFooter = ({ children, className = "", style }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex justify-end items-center gap-4 p-6 bg-bg-tertiary/50 dark:bg-dark-bg-tertiary/20 border-t border-border-color dark:border-dark-border-color shrink-0", className), style, children });
DrawerFooter.displayName = "Drawer.Footer";
const DRAWER_WIDTH_REM = {
  xs: "20rem",
  sm: "24rem",
  md: "28rem",
  lg: "32rem",
  xl: "36rem",
  full: "100%"
};
const DRAWER_HEIGHT_REM = {
  xs: "12rem",
  sm: "16rem",
  md: "18rem",
  lg: "20rem",
  xl: "24rem",
  full: "100vh"
};
const DRAWER_WIDTH_THEME = {
  xs: "max-w-xs",
  sm: "max-w-sm",
  md: "max-w-md",
  lg: "max-w-lg",
  xl: "max-w-xl",
  full: "max-w-full"
};
const DRAWER_HEIGHT_THEME = {
  xs: "max-h-48",
  sm: "max-h-64",
  md: "max-h-72",
  lg: "max-h-80",
  xl: "max-h-96",
  full: "max-h-screen"
};
const DrawerRoot = ({
  isOpen,
  onClose,
  children,
  position = "right",
  size: size2 = "md",
  useThemeSizing = false,
  className,
  style,
  hasBackdrop = true,
  closeOnBackdropClick = true
}) => {
  const triggerElementRef = useRef(null);
  useEffect(() => {
    if (isOpen) {
      triggerElementRef.current = document.activeElement;
    } else {
      if (triggerElementRef.current) {
        triggerElementRef.current.focus();
      }
    }
  }, [isOpen]);
  useEffect(() => {
    const handleKeyDown = (e2) => {
      if (e2.key === "Escape" && isOpen) {
        e2.preventDefault();
        e2.stopPropagation();
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener("keydown", handleKeyDown, true);
    }
    return () => {
      document.removeEventListener("keydown", handleKeyDown, true);
    };
  }, [isOpen, onClose]);
  const positionClasses = {
    left: "left-0 top-0 h-full border-r",
    right: "right-0 top-0 h-full border-l",
    top: "top-0 left-0 w-full border-b",
    bottom: "bottom-0 left-0 w-full border-t"
  };
  const getSizeClasses2 = () => {
    if (position === "left" || position === "right") {
      if (useThemeSizing) {
        if (size2 === "full") return "w-full h-full";
        return `w-full ${DRAWER_WIDTH_THEME[size2]} h-full`;
      }
      if (size2 === "full") return "w-full h-full";
      return "w-full h-full";
    }
    if (useThemeSizing) {
      if (size2 === "full") return "w-full h-screen";
      return `w-full ${DRAWER_HEIGHT_THEME[size2]} h-full`;
    }
    if (size2 === "full") return "w-full h-full";
    return "w-full h-full";
  };
  const getSizeStyle = () => {
    if (useThemeSizing) return {};
    if (position === "left" || position === "right") {
      if (size2 === "full") return { width: "100%" };
      return { maxWidth: DRAWER_WIDTH_REM[size2] };
    }
    if (size2 === "full") return { height: "100vh" };
    return { maxHeight: DRAWER_HEIGHT_REM[size2] };
  };
  const variants = {
    left: { x: "-100%" },
    right: { x: "100%" },
    top: { y: "-100%" },
    bottom: { y: "100%" }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, { children: isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, { active: true, focusTrapOptions: { initialFocus: false, allowOutsideClick: true }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "fixed inset-0 z-[9999]",
      role: "dialog",
      "aria-modal": "true",
      "aria-labelledby": "drawer-title",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ReactRemoveScroll, { children: [
        hasBackdrop && /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: { opacity: 0 },
            animate: { opacity: 1 },
            exit: { opacity: 0 },
            transition: { duration: 0.3 },
            className: "fixed inset-0 bg-black/60 backdrop-blur-sm",
            onClick: closeOnBackdropClick ? onClose : void 0
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          motion.div,
          {
            initial: variants[position],
            animate: { x: 0, y: 0 },
            exit: variants[position],
            transition: { type: "tween", duration: 0.3, ease: "easeOut" },
            className: cn(
              "fixed bg-bg-secondary dark:bg-dark-bg-secondary shadow-2xl flex flex-col",
              "border-border-color dark:border-dark-border-color",
              "border-black/5 dark:border-white/5",
              positionClasses[position],
              getSizeClasses2(),
              className
            ),
            style: { ...getSizeStyle(), ...style },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(DrawerContext.Provider, { value: { onClose, position }, children })
          }
        )
      ] })
    }
  ) }) });
};
DrawerRoot.displayName = "Drawer.Root";
const Drawer = Object.assign(DrawerRoot, {
  Header: DrawerHeader,
  Body: DrawerBody,
  Footer: DrawerFooter
});
const DropdownContext = createContext(null);
const useDropdown = () => {
  const context = useContext(DropdownContext);
  if (!context) throw new Error("useDropdown must be used within a Dropdown.Root");
  return context;
};
const DropdownRoot = ({
  children,
  open: controlledOpen,
  onOpenChange,
  disabled = false,
  loading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  isRequired = false,
  isReadonly = false,
  hasBackground = true,
  isBordered = true,
  isRounded = true,
  hasShadow = true,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  fullWidth = false,
  hasHoverEffect = true,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isTransparent = false,
  hasGradient = false,
  customColor,
  className = "",
  style,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  isCentered = false,
  isResponsive = true,
  hasContainer = true,
  hasMaxWidth = true,
  hasMinWidth = false,
  hasFixedHeight = false,
  hasFixedWidth = false,
  hasScrollableOverflow = false,
  hasHiddenOverflow = false,
  hasVisibleOverflow = false,
  hasClipOverflow = false,
  hasScrollOverflow = false,
  hasAutoOverflow = false,
  hasInitialOverflow = false,
  hasInheritOverflow = false,
  hasUnsetOverflow = false,
  hasRevertOverflow = false,
  hasRevertLayerOverflow = false,
  hasLabel = false,
  isLabelHidden = false,
  ...props
}) => {
  const [internalOpen, setInternalOpen] = useState(false);
  const isControlled = controlledOpen !== void 0;
  const isOpen = isControlled ? controlledOpen : internalOpen;
  const setIsOpen = useCallback((value) => {
    const next = typeof value === "function" ? value(isOpen) : value;
    if (isControlled) {
      onOpenChange?.(next);
    } else {
      setInternalOpen(next);
      onOpenChange?.(next);
    }
  }, [isControlled, isOpen, onOpenChange]);
  const [triggerWidth, setTriggerWidth] = useState(null);
  const triggerRef = useRef(null);
  const dropdownRef = useRef(null);
  useOnClickOutside(dropdownRef, () => setIsOpen(false));
  const containerClasses = [
    "relative inline-block text-left",
    fullWidth && "w-full",
    isCentered && "text-center",
    isResponsive && "responsive",
    hasContainer && "container",
    hasMaxWidth && "max-w-full",
    hasMinWidth && "min-w-fit",
    hasFixedHeight && "h-auto",
    hasFixedWidth && "w-auto",
    hasScrollableOverflow && "overflow-auto",
    hasHiddenOverflow && "overflow-hidden",
    hasVisibleOverflow && "overflow-visible",
    hasClipOverflow && "overflow-clip",
    hasScrollOverflow && "overflow-scroll",
    hasAutoOverflow && "overflow-auto",
    hasInitialOverflow && "overflow-initial",
    hasInheritOverflow && "overflow-inherit",
    hasUnsetOverflow && "overflow-unset",
    hasRevertOverflow && "overflow-revert",
    hasRevertLayerOverflow && "overflow-revert-layer",
    hasLabel && "has-label",
    isLabelHidden && "label-hidden",
    className
  ].filter(Boolean).join(" ");
  const containerStyles = {
    ...style,
    ...customColor && { backgroundColor: customColor },
    ...hasFixedHeight && { height: "auto" },
    ...hasFixedWidth && { width: "auto" },
    ...hasMaxWidth && { maxWidth: "100%" },
    ...hasMinWidth && { minWidth: "fit-content" }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownContext.Provider, { value: { isOpen, setIsOpen, triggerWidth, setTriggerWidth, triggerRef }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: dropdownRef,
      className: containerClasses,
      style: containerStyles,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      ...props,
      children
    }
  ) });
};
DropdownRoot.displayName = "Dropdown.Root";
const DropdownTrigger = ({
  children,
  disabled = false,
  loading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  isRequired = false,
  isReadonly = false,
  hasBackground = true,
  isBordered = true,
  isRounded = true,
  hasShadow = true,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  fullWidth = false,
  hasHoverEffect = true,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isTransparent = false,
  hasGradient = false,
  customColor,
  className = "",
  style,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  ...props
}) => {
  const { isOpen, setIsOpen, setTriggerWidth, triggerRef } = useDropdown();
  const localTriggerRef = useRef(null);
  const child = React__default.Children.only(children);
  React__default.useEffect(() => {
    const el = localTriggerRef.current ?? triggerRef.current;
    if (el) {
      setTriggerWidth(el.offsetWidth);
    }
  }, [isOpen, setTriggerWidth, triggerRef]);
  const triggerClasses = [
    "outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange",
    disabled && "opacity-50 cursor-not-allowed",
    loading && "animate-pulse",
    isError && "border-system-error text-system-error-dark dark:text-system-error-light-text",
    isWarning && "border-system-warning text-system-warning-dark dark:text-system-warning-light-text",
    isSuccess && "border-system-success text-system-success-dark dark:text-system-success-light-text",
    isInfo && "border-system-info text-system-info-dark dark:text-system-info-light-text",
    isRequired && "required",
    isReadonly && "cursor-default",
    hasBackground && "bg-bg-primary dark:bg-dark-bg-primary",
    isBordered && "border border-border-color dark:border-dark-border-color",
    isRounded && "rounded",
    hasShadow && "shadow",
    hasBackdropBlur && "backdrop-blur-sm",
    hasGlassMorphism && "bg-white/20 backdrop-blur-md",
    hasMinHeight && "min-h-fit",
    fullWidth && "w-full",
    hasFocusEffect && "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    hasActiveEffect && "active:scale-95",
    isTransparent && "bg-transparent",
    hasGradient && "bg-gradient-to-r from-brand-navy to-brand-blue dark:from-dark-brand-orange dark:to-dark-brand-yellow",
    customColor && "custom-color",
    className
  ].filter(Boolean).join(" ");
  const triggerStyles = {
    ...style,
    ...customColor && { backgroundColor: customColor }
  };
  const focusTrigger = () => {
    const t2 = triggerRef.current;
    if (!t2) return;
    if (t2.getAttribute?.("tabindex") != null || t2.type === "submit" || t2.tagName === "BUTTON" || t2.tagName === "INPUT" || t2.tagName === "A") {
      t2.focus();
    } else {
      const focusable3 = t2.querySelector?.('input, button, [tabindex]:not([tabindex="-1"])');
      focusable3?.focus();
    }
  };
  const combinedRef = (node) => {
    triggerRef.current = node;
    localTriggerRef.current = node;
    if (typeof child.ref === "function") {
      child.ref(node);
    } else if (child.ref) {
      child.ref.current = node;
    }
  };
  const listNavigationKeys = ["ArrowDown", "ArrowUp", "Enter", "Home", "End"];
  const handleTriggerKeyDown = (e2) => {
    if (isOpen) {
      if (e2.key === "Escape") {
        setIsOpen(false);
        focusTrigger();
        e2.preventDefault();
        e2.stopPropagation();
        return;
      }
      if (e2.key === "Tab" || e2.key === "Shift+Tab") {
        setIsOpen(false);
        return;
      }
      if (listNavigationKeys.includes(e2.key)) {
        e2.preventDefault();
        e2.stopPropagation();
        child.props.onKeyDown?.(e2);
        onKeyDown?.(e2);
        return;
      }
    } else {
      if (e2.key === "ArrowDown" || e2.key === "ArrowUp" || e2.key === "Enter" || e2.key === " ") {
        if (e2.key === "Enter" || e2.key === " ") e2.preventDefault();
        if (!disabled && !loading) {
          setIsOpen(true);
          if (e2.key === "ArrowDown" || e2.key === "ArrowUp") e2.preventDefault();
        }
        return;
      }
    }
    child.props.onKeyDown?.(e2);
    onKeyDown?.(e2);
  };
  return React__default.cloneElement(child, {
    ref: combinedRef,
    onClick: (e2) => {
      if (disabled || loading) return;
      e2.preventDefault();
      setIsOpen((prev) => !prev);
      child.props.onClick?.(e2);
      onClick?.(e2);
    },
    onFocus: (e2) => {
      if (disabled || loading) return;
      child.props.onFocus?.(e2);
      onFocus?.(e2);
    },
    onBlur: (e2) => {
      child.props.onBlur?.(e2);
      onBlur?.(e2);
    },
    onMouseEnter: (e2) => {
      child.props.onMouseEnter?.(e2);
      onMouseEnter?.(e2);
    },
    onMouseLeave: (e2) => {
      child.props.onMouseLeave?.(e2);
      onMouseLeave?.(e2);
    },
    onMouseDown: (e2) => {
      child.props.onMouseDown?.(e2);
      onMouseDown?.(e2);
    },
    onMouseUp: (e2) => {
      child.props.onMouseUp?.(e2);
      onMouseUp?.(e2);
    },
    onDoubleClick: (e2) => {
      child.props.onDoubleClick?.(e2);
      onDoubleClick?.(e2);
    },
    onKeyDown: handleTriggerKeyDown,
    onKeyUp: (e2) => {
      child.props.onKeyUp?.(e2);
      onKeyUp?.(e2);
    },
    onKeyPress: (e2) => {
      child.props.onKeyPress?.(e2);
      onKeyPress?.(e2);
    },
    className: `${child.props.className || ""} ${triggerClasses}`.trim(),
    style: { ...child.props.style, ...triggerStyles },
    "aria-haspopup": "menu",
    "aria-expanded": isOpen,
    "aria-disabled": disabled,
    "aria-busy": loading,
    ...props
  });
};
DropdownTrigger.displayName = "Dropdown.Trigger";
const DropdownContent = ({
  children,
  position = "bottom-start",
  size: size2 = "md",
  color: color2 = "default",
  disabled = false,
  loading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  isRequired = false,
  isReadonly = false,
  hasBackground = true,
  isBordered = true,
  isRounded = true,
  hasShadow = true,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  fullWidth = false,
  hasHoverEffect = true,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasArrow = false,
  hasDelay = false,
  hasFadeEffect = true,
  className = "",
  style,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  delay: delay3 = 0,
  maxWidth = "lg",
  maxHeight = "15rem",
  // Industry standard: 15rem (240px) - shows ~5-7 items before scroll
  minHeight,
  height,
  isInteractive = true,
  hasFollowCursor = false,
  hasCloseButton = false,
  hasTitle = false,
  title,
  hasDescription = false,
  description,
  hasHelpText = false,
  helpText,
  hasValidationMessage = false,
  validationMessage,
  hasRequiredIndicator = false,
  hasDisabledState = false,
  hasReadonlyState = false,
  hasLoadingState = false,
  hasSuccessState = false,
  hasWarningState = false,
  hasErrorState = false,
  hasInfoState = false,
  hasNeutralState = false,
  hasPrimaryState = false,
  hasSecondaryState = false,
  hasTertiaryState = false,
  hasQuaternaryState = false,
  hasQuinaryState = false,
  hasSenaryState = false,
  hasSeptenaryState = false,
  hasOctonaryState = false,
  hasNonaryState = false,
  hasDenaryState = false,
  hasPadding = true,
  hasMargin = true,
  itemLineHeight,
  isCentered = false,
  isResponsive = true,
  hasContainer = true,
  hasMaxWidth = true,
  hasMinWidth = false,
  hasFixedHeight = false,
  hasFixedWidth = false,
  hasScrollableOverflow = false,
  hasHiddenOverflow = false,
  hasVisibleOverflow = false,
  hasClipOverflow = false,
  hasScrollOverflow = false,
  hasAutoOverflow = false,
  hasInitialOverflow = false,
  hasInheritOverflow = false,
  hasUnsetOverflow = false,
  hasRevertOverflow = false,
  hasRevertLayerOverflow = false,
  hasLabel = false,
  isLabelHidden = false,
  ...props
}) => {
  const { isOpen, setIsOpen, triggerWidth, setTriggerWidth, triggerRef } = useDropdown();
  const contentRef = useRef(null);
  React__default.useEffect(() => {
    if (!isOpen) return;
    const focusListbox = () => {
      const autofocus = contentRef.current?.querySelector?.("[data-autofocus]");
      if (autofocus) {
        autofocus.focus();
      }
    };
    const rafId = requestAnimationFrame(() => {
      focusListbox();
      setTimeout(focusListbox, 0);
    });
    return () => cancelAnimationFrame(rafId);
  }, [isOpen]);
  const focusTrigger = () => {
    const t2 = triggerRef.current;
    if (!t2) return;
    if (t2.getAttribute?.("tabindex") != null || t2.type === "submit" || t2.tagName === "BUTTON" || t2.tagName === "INPUT" || t2.tagName === "A") {
      t2.focus();
    } else {
      const focusable3 = t2.querySelector?.('input, button, [tabindex]:not([tabindex="-1"])');
      focusable3?.focus();
    }
  };
  const contentListKeys = ["ArrowDown", "ArrowUp", "Enter", "Home", "End"];
  const handleContentKeyDown = (e2) => {
    if (e2.key === "Escape") {
      setIsOpen(false);
      focusTrigger();
      e2.preventDefault();
      e2.stopPropagation();
      return;
    }
    if (e2.key === "Tab" || e2.key === "Shift+Tab") {
      setIsOpen(false);
      return;
    }
    if (contentListKeys.includes(e2.key)) {
      e2.preventDefault();
    }
    onKeyDown?.(e2);
  };
  const positionClasses = {
    "top": fullWidth ? "bottom-full left-0 right-0 mb-2 origin-bottom" : "bottom-full left-1/2 -translate-x-1/2 mb-2 origin-bottom",
    "top-start": "bottom-full left-0 mb-2 origin-bottom-left",
    "top-end": "bottom-full right-0 mb-2 origin-bottom-right",
    "bottom": fullWidth ? "top-full left-0 right-0 mt-2 origin-top" : "top-full left-1/2 -translate-x-1/2 mt-2 origin-top",
    "bottom-start": "top-full left-0 mt-2 origin-top-left",
    "bottom-end": "top-full right-0 mt-2 origin-top-right",
    "left": "right-full top-1/2 -translate-y-1/2 mr-2 origin-right",
    "left-start": "right-full top-0 mr-2 origin-top-right",
    "left-end": "right-full bottom-0 mr-2 origin-bottom-right",
    "right": "left-full top-1/2 -translate-y-1/2 ml-2 origin-left",
    "right-start": "left-full top-0 ml-2 origin-top-left",
    "right-end": "left-full bottom-0 ml-2 origin-bottom-left"
  };
  const sizeClasses2 = {
    xs: "w-32 py-0.5 text-xs",
    sm: "w-40 py-1 text-sm",
    md: "w-56 py-1 text-base",
    lg: "w-64 py-1.5 text-lg",
    xl: "w-80 py-2 text-xl"
  };
  const colorClasses2 = {
    default: "bg-bg-secondary dark:bg-dark-bg-secondary border-border-color dark:border-dark-border-color text-text-primary dark:text-dark-text-primary",
    primary: "bg-brand-navy dark:bg-dark-brand-orange text-white border-brand-navy dark:border-dark-brand-orange",
    accent: "bg-brand-orange dark:bg-dark-brand-orange text-white border-brand-orange dark:border-dark-brand-orange",
    info: "bg-system-info-light dark:bg-system-info-dark-bg text-system-info-dark dark:text-system-info-light-text border-system-info dark:border-system-info",
    success: "bg-system-success-light dark:bg-system-success-dark-bg text-system-success-dark dark:text-system-success-light-text border-system-success dark:border-system-success",
    error: "bg-system-error-light dark:bg-system-error-dark-bg text-system-error-dark dark:text-system-error-light-text border-system-error dark:border-system-error",
    warning: "bg-system-warning-light dark:bg-system-warning-dark-bg text-system-warning-dark dark:text-system-warning-light-text border-system-warning dark:border-system-warning",
    danger: "bg-system-error dark:bg-system-error text-white border-system-error dark:border-system-error"
  };
  const arrowPositionClasses = {
    top: "bottom-[-4px] left-1/2 -translate-x-1/2 border-l-transparent border-r-transparent",
    "top-start": "bottom-[-4px] left-0 border-l-transparent border-r-transparent",
    "top-end": "bottom-[-4px] right-0 border-l-transparent border-r-transparent",
    bottom: "top-[-4px] left-1/2 -translate-x-1/2 border-l-transparent border-r-transparent",
    "bottom-start": "top-[-4px] left-0 border-l-transparent border-r-transparent",
    "bottom-end": "top-[-4px] right-0 border-l-transparent border-r-transparent",
    left: "right-[-4px] top-1/2 -translate-y-1/2 border-t-transparent border-b-transparent",
    "left-start": "right-[-4px] top-0 border-t-transparent border-b-transparent",
    "left-end": "right-[-4px] bottom-0 border-t-transparent border-b-transparent",
    right: "left-[-4px] top-1/2 -translate-y-1/2 border-t-transparent border-b-transparent",
    "right-start": "left-[-4px] top-0 border-t-transparent border-b-transparent",
    "right-end": "left-[-4px] bottom-0 border-t-transparent border-b-transparent"
  };
  const shouldEnableScroll = maxHeight !== void 0;
  const contentClasses = [
    "absolute z-50 rounded-lg shadow-2xl focus:outline-none",
    // Apply size classes - width only if not fullWidth, text size always
    fullWidth ? `py-1 text-${size2 === "xs" ? "xs" : size2 === "sm" ? "sm" : size2 === "md" ? "base" : size2 === "lg" ? "lg" : "xl"}` : sizeClasses2[size2],
    colorClasses2[color2],
    disabled && "opacity-50 cursor-not-allowed",
    loading && "animate-pulse",
    isError && "border-system-error text-system-error-dark dark:text-system-error-light-text",
    isWarning && "border-system-warning text-system-warning-dark dark:text-system-warning-light-text",
    isSuccess && "border-system-success text-system-success-dark dark:text-system-success-light-text",
    isInfo && "border-system-info text-system-info-dark dark:text-system-info-light-text",
    isRequired && "required",
    isReadonly && "cursor-default",
    hasBackground && "bg-bg-secondary dark:bg-dark-bg-secondary",
    isBordered && "border border-border-color dark:border-dark-border-color",
    isRounded && "rounded-lg",
    hasShadow && "shadow-2xl",
    hasBackdropBlur && "backdrop-blur-sm",
    hasGlassMorphism && "bg-white/20 backdrop-blur-md",
    hasMinHeight && "min-h-fit",
    // fullWidth && 'w-full', // This class is removed to allow content to define width
    hasFocusEffect && "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    hasActiveEffect && "active:scale-95",
    isTransparent && "bg-transparent",
    hasGradient && "bg-gradient-to-r from-brand-navy to-brand-blue dark:from-dark-brand-orange dark:to-dark-brand-yellow",
    customColor && "custom-color",
    hasPadding && "py-1",
    hasMargin && "m-2",
    isCentered && "text-center",
    isResponsive && "responsive",
    hasContainer && "container",
    hasMaxWidth && `max-w-${maxWidth}`,
    hasMinWidth && "min-w-fit",
    hasFixedHeight && "h-auto",
    hasFixedWidth && "w-auto",
    // Auto-enable scroll when maxHeight is set, unless explicitly overridden
    // Also auto-apply custom-scrollbar class when scrollable
    shouldEnableScroll && !hasScrollableOverflow && !hasHiddenOverflow && !hasVisibleOverflow && !hasClipOverflow && !hasScrollOverflow && !hasAutoOverflow && !hasInitialOverflow && !hasInheritOverflow && !hasUnsetOverflow && !hasRevertOverflow && !hasRevertLayerOverflow && "overflow-y-auto custom-scrollbar",
    hasScrollableOverflow && "overflow-auto custom-scrollbar",
    hasHiddenOverflow && "overflow-hidden",
    hasVisibleOverflow && "overflow-visible",
    hasClipOverflow && "overflow-clip",
    hasScrollOverflow && "overflow-scroll custom-scrollbar",
    hasAutoOverflow && "overflow-auto custom-scrollbar",
    hasInitialOverflow && "overflow-initial",
    hasInheritOverflow && "overflow-inherit",
    hasUnsetOverflow && "overflow-unset",
    hasRevertOverflow && "overflow-revert",
    hasRevertLayerOverflow && "overflow-revert-layer",
    hasLabel && "has-label",
    isLabelHidden && "label-hidden",
    positionClasses[position],
    className
  ].filter(Boolean).join(" ");
  const contentStyles = {
    ...style,
    ...customColor && { backgroundColor: customColor },
    ...height && { height: typeof height === "string" ? height : `${height}px` },
    ...maxHeight && { maxHeight: typeof maxHeight === "string" ? maxHeight : `${maxHeight}px` },
    ...minHeight && { minHeight: typeof minHeight === "string" ? minHeight : `${minHeight}px` },
    ...hasFixedHeight && !height && { height: "auto" },
    ...hasFixedWidth && { width: "auto" },
    ...hasMaxWidth && { maxWidth: typeof maxWidth === "string" ? maxWidth : `${maxWidth}px` },
    ...hasMinWidth && { minWidth: "fit-content" },
    ...fullWidth && { minWidth: triggerWidth ? `${triggerWidth}px` : "auto", width: "max-content" },
    ...delay3 && { transitionDelay: `${delay3}ms` }
  };
  const visibilityClasses = isOpen ? "opacity-100 scale-100" : "opacity-0 scale-95 pointer-events-none";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: contentRef,
      role: "menu",
      tabIndex: -1,
      className: `${contentClasses} ${visibilityClasses}`,
      style: contentStyles,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown: handleContentKeyDown,
      onKeyUp,
      onKeyPress,
      ...props,
      children: [
        hasTitle && title && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "font-semibold mb-2 px-4 pt-2 text-lg", children: [
          title,
          hasRequiredIndicator && isRequired && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        hasDescription && description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 dark:text-gray-400 mb-3 px-4", children: description }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownContext.Provider, { value: {
          isOpen,
          setIsOpen,
          triggerWidth,
          setTriggerWidth,
          triggerRef,
          itemLineHeight
        }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "dropdown-content", children }) }),
        hasHelpText && helpText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500 dark:text-gray-500 mt-2 px-4 pb-2", children: helpText }),
        hasValidationMessage && validationMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-red-500 mt-2 px-4 pb-2", children: validationMessage }),
        hasArrow && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute w-0 h-0 border-4 ${arrowPositionClasses[position]} ${colorClasses2[color2].split(" ")[0]}` })
      ]
    }
  );
};
DropdownContent.displayName = "Dropdown.Content";
const DropdownItem = ({
  children,
  icon,
  onSelect,
  disabled = false,
  loading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  isRequired = false,
  isReadonly = false,
  hasBackground = true,
  isBordered = false,
  isRounded = true,
  hasShadow = false,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  fullWidth = true,
  hasHoverEffect = true,
  isHighlighted = false,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasIcon = false,
  hasDescription = false,
  description,
  hasHelpText = false,
  helpText,
  hasValidationMessage = false,
  validationMessage,
  hasRequiredIndicator = false,
  hasDisabledState = false,
  hasReadonlyState = false,
  hasLoadingState = false,
  hasSuccessState = false,
  hasWarningState = false,
  hasErrorState = false,
  hasInfoState = false,
  hasNeutralState = false,
  hasPrimaryState = false,
  hasSecondaryState = false,
  hasTertiaryState = false,
  hasQuaternaryState = false,
  hasQuinaryState = false,
  hasSenaryState = false,
  hasSeptenaryState = false,
  hasOctonaryState = false,
  hasNonaryState = false,
  hasDenaryState = false,
  hasPadding = true,
  hasMargin = false,
  isCentered = false,
  isResponsive = true,
  hasContainer = true,
  hasMaxWidth = true,
  hasMinWidth = false,
  hasFixedHeight = false,
  hasFixedWidth = false,
  hasScrollableOverflow = false,
  hasHiddenOverflow = false,
  hasVisibleOverflow = false,
  hasClipOverflow = false,
  hasScrollOverflow = false,
  hasAutoOverflow = false,
  hasInitialOverflow = false,
  hasInheritOverflow = false,
  hasUnsetOverflow = false,
  hasRevertOverflow = false,
  hasRevertLayerOverflow = false,
  hasLabel = false,
  isLabelHidden = false,
  className = "",
  style,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  ...props
}) => {
  const { setIsOpen, itemLineHeight } = useDropdown();
  const getPaddingClass = () => {
    if (itemLineHeight === void 0) return "py-2.5";
    if (typeof itemLineHeight === "string") {
      const pxValue = parseInt(itemLineHeight);
      if (!isNaN(pxValue) && pxValue < 20) return "py-1";
      return "py-1.5";
    }
    if (itemLineHeight < 1.5) return "py-1";
    return "py-1.5";
  };
  const itemClasses = [
    `w-full text-left flex gap-3 px-4 ${getPaddingClass()} text-sm font-medium items-center`,
    // Base styles WITHOUT text color - dynamic padding based on line-height
    disabled && "opacity-50 cursor-not-allowed bg-transparent",
    loading && "animate-pulse",
    // State classes - now self-contained with text and hover colors
    isError && "text-system-error-dark dark:text-system-error-light-text hover:bg-system-error-light dark:hover:bg-system-error-dark-bg",
    isWarning && "text-system-warning-dark dark:text-system-warning-light-text hover:bg-system-warning-light dark:hover:bg-system-warning-dark-bg",
    isSuccess && "text-system-success-dark dark:text-system-success-light-text hover:bg-system-success-light dark:hover:bg-system-success-dark-bg",
    isInfo && "text-system-info-dark dark:text-system-info-light-text hover:bg-system-info-light dark:hover:bg-system-info-dark-bg",
    // Default colors and hover effects (only apply if no other state is active)
    !isError && !isWarning && !isSuccess && !isInfo && "text-text-secondary dark:text-dark-text-secondary",
    !isError && !isWarning && !isSuccess && !isInfo && hasHoverEffect && "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary hover:text-text-primary dark:hover:text-dark-text-primary",
    // Keyboard highlight: same background (and text) as hover for each state, so arrow nav matches mouse hover
    isHighlighted && isError && "bg-system-error-light dark:bg-system-error-dark-bg",
    isHighlighted && isWarning && "bg-system-warning-light dark:bg-system-warning-dark-bg",
    isHighlighted && isSuccess && "bg-system-success-light dark:bg-system-success-dark-bg",
    isHighlighted && isInfo && "bg-system-info-light dark:bg-system-info-dark-bg",
    !isError && !isWarning && !isSuccess && !isInfo && isHighlighted && "bg-bg-tertiary dark:bg-dark-bg-tertiary text-text-primary dark:text-dark-text-primary",
    // Other general styles
    isRequired && "required",
    isReadonly && "cursor-default",
    hasBackground && !isHighlighted && "bg-transparent",
    isBordered && "border border-border-color dark:border-dark-border-color",
    isRounded && "rounded",
    hasShadow && "shadow",
    hasBackdropBlur && "backdrop-blur-sm",
    hasGlassMorphism && "bg-white/20 backdrop-blur-md",
    hasMinHeight && "min-h-fit",
    fullWidth && "w-full",
    hasFocusEffect && "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    isTransparent && "bg-transparent",
    hasGradient && "bg-gradient-to-r from-brand-navy to-brand-blue dark:from-dark-brand-orange dark:to-dark-brand-yellow",
    customColor && "custom-color",
    hasPadding && "px-4 py-2.5",
    hasMargin && "m-1",
    isCentered && "text-center justify-center",
    isResponsive && "responsive",
    hasContainer && "container",
    hasMaxWidth && "max-w-full",
    hasMinWidth && "min-w-fit",
    hasFixedHeight && "h-auto",
    hasFixedWidth && "w-auto",
    hasScrollableOverflow && "overflow-auto",
    hasHiddenOverflow && "overflow-hidden",
    hasVisibleOverflow && "overflow-visible",
    hasClipOverflow && "overflow-clip",
    hasScrollOverflow && "overflow-scroll",
    hasAutoOverflow && "overflow-auto",
    hasInitialOverflow && "overflow-initial",
    hasInheritOverflow && "overflow-inherit",
    hasUnsetOverflow && "overflow-unset",
    hasRevertOverflow && "overflow-revert",
    hasRevertLayerOverflow && "overflow-revert-layer",
    hasLabel && "has-label",
    isLabelHidden && "label-hidden",
    className
  ].filter(Boolean).join(" ");
  const itemStyles = {
    ...style,
    ...customColor && { backgroundColor: customColor },
    ...hasFixedHeight && { height: "auto" },
    ...hasFixedWidth && { width: "auto" },
    // Don't apply line-height to button when itemLineHeight is set - apply it to inner content instead
    // This allows line-height to work properly without being overridden by flex items-center
    ...hasMaxWidth && { maxWidth: "100%" },
    ...hasMinWidth && { minWidth: "fit-content" }
  };
  const handleSelect = () => {
    if (disabled || loading) return;
    onSelect?.();
    setIsOpen(false);
    onClick?.(new MouseEvent("click"));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      role: "menuitem",
      onClick: handleSelect,
      disabled: disabled || loading,
      className: itemClasses,
      style: itemStyles,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      ...props,
      children: [
        (icon || hasIcon) && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", children: icon || "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: itemLineHeight !== void 0 ? {
            lineHeight: typeof itemLineHeight === "string" ? itemLineHeight : itemLineHeight < 10 && itemLineHeight > 0.1 ? itemLineHeight : `${itemLineHeight}px`
          } : void 0, children }),
          hasDescription && description && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-500 dark:text-gray-500 mt-1", children: description }),
          hasHelpText && helpText && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-400 dark:text-gray-400 mt-1", children: helpText }),
          hasValidationMessage && validationMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-red-500 mt-1", children: validationMessage })
        ] }),
        hasRequiredIndicator && isRequired && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red-500 ml-auto", children: "*" })
      ]
    }
  );
};
DropdownItem.displayName = "Dropdown.Item";
const DropdownSeparator = ({
  disabled = false,
  loading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  isRequired = false,
  isReadonly = false,
  hasBackground = false,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  fullWidth = true,
  hasHoverEffect = false,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasPadding = true,
  hasMargin = true,
  isCentered = false,
  isResponsive = true,
  hasContainer = true,
  hasMaxWidth = true,
  hasMinWidth = false,
  hasFixedHeight = false,
  hasFixedWidth = false,
  hasScrollableOverflow = false,
  hasHiddenOverflow = false,
  hasVisibleOverflow = false,
  hasClipOverflow = false,
  hasScrollOverflow = false,
  hasAutoOverflow = false,
  hasInitialOverflow = false,
  hasInheritOverflow = false,
  hasUnsetOverflow = false,
  hasRevertOverflow = false,
  hasRevertLayerOverflow = false,
  hasLabel = false,
  isLabelHidden = false,
  className = "",
  style,
  ...props
}) => {
  const separatorClasses = [
    "h-px",
    disabled && "opacity-50",
    loading && "animate-pulse",
    isError && "bg-system-error",
    isWarning && "bg-system-warning",
    isSuccess && "bg-system-success",
    isInfo && "bg-system-info",
    isRequired && "required",
    isReadonly && "cursor-default",
    hasBackground && "bg-bg-tertiary dark:bg-dark-bg-tertiary",
    isBordered && "border border-border-color dark:border-dark-border-color",
    isRounded && "rounded",
    hasShadow && "shadow",
    hasBackdropBlur && "backdrop-blur-sm",
    hasGlassMorphism && "bg-white/20 backdrop-blur-md",
    hasMinHeight && "min-h-fit",
    fullWidth && "w-full",
    hasHoverEffect && "hover:opacity-75 transition-opacity",
    hasFocusEffect && "focus:opacity-100",
    hasActiveEffect && "active:opacity-50",
    isTransparent && "bg-transparent",
    hasGradient && "bg-gradient-to-r from-brand-navy to-brand-blue dark:from-dark-brand-orange dark:to-dark-brand-yellow",
    customColor && "custom-color",
    hasPadding && "py-0.5",
    hasMargin && "my-1",
    isCentered && "mx-auto",
    isResponsive && "responsive",
    hasContainer && "container",
    hasMaxWidth && "max-w-full",
    hasMinWidth && "min-w-fit",
    hasFixedHeight && "h-auto",
    hasFixedWidth && "w-auto",
    hasScrollableOverflow && "overflow-auto",
    hasHiddenOverflow && "overflow-hidden",
    hasVisibleOverflow && "overflow-visible",
    hasClipOverflow && "overflow-clip",
    hasScrollOverflow && "overflow-scroll",
    hasAutoOverflow && "overflow-auto",
    hasInitialOverflow && "overflow-initial",
    hasInheritOverflow && "overflow-inherit",
    hasUnsetOverflow && "overflow-unset",
    hasRevertOverflow && "overflow-revert",
    hasRevertLayerOverflow && "overflow-revert-layer",
    hasLabel && "has-label",
    isLabelHidden && "label-hidden",
    !customColor && "bg-border-color dark:bg-dark-border-color",
    className
  ].filter(Boolean).join(" ");
  const separatorStyles = {
    ...style,
    ...customColor && { backgroundColor: customColor },
    ...hasFixedHeight && { height: "auto" },
    ...hasFixedWidth && { width: "auto" },
    ...hasMaxWidth && { maxWidth: "100%" },
    ...hasMinWidth && { minWidth: "fit-content" }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: separatorClasses,
      style: separatorStyles,
      ...props
    }
  );
};
DropdownSeparator.displayName = "Dropdown.Separator";
const Dropdown = Object.assign(DropdownRoot, {
  Trigger: DropdownTrigger,
  Content: DropdownContent,
  Item: DropdownItem,
  Separator: DropdownSeparator
});
const EmptyState = ({
  icon = "inbox",
  title = "No content available",
  description = "There is no content to display at the moment.",
  action,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "neutral",
  // State Props
  isDisabled = false,
  isLoading = false,
  isVisible = true,
  isInteractive = false,
  isAnimated = true,
  isCollapsible = false,
  isExpanded = true,
  isDraggable = false,
  // Feature Props
  hasBackground = true,
  hasBorder = true,
  isRounded = true,
  hasShadow = false,
  hasIcon = true,
  hasTitle = true,
  hasDescription = true,
  hasAction = false,
  hasBorderRadius = true,
  hasPadding = true,
  hasMargin = false,
  hasDashedBorder = true,
  hasGradientBackground = false,
  hasPatternBackground = false,
  // Layout Props
  isResponsive = true,
  hasFixedWidth = false,
  isFullWidth = true,
  hasFixedHeight = false,
  isCentered = true,
  hasMaxWidth = false,
  hasMinWidth = false,
  hasMaxHeight = false,
  hasMinHeight = false,
  // Content Props
  iconContent,
  titleContent,
  descriptionContent,
  actionContent,
  backgroundContent,
  borderContent,
  shadowContent,
  patternContent,
  footerContent,
  headerContent,
  // Icon Props
  iconSize = "lg",
  iconColor,
  iconBackgroundColor,
  iconHasBackground = true,
  iconHasBorder = false,
  iconIsRounded = true,
  iconHasShadow = false,
  // Event Handlers
  onClick,
  onFocus,
  onBlur,
  onToggle,
  onDrag,
  onDrop,
  onActionClick,
  ...props
}) => {
  const [expanded, setExpanded] = useState(isExpanded);
  const [isDragging2, setIsDragging] = useState(false);
  const sizeClasses2 = {
    xs: "p-4",
    sm: "p-6",
    md: "p-8",
    lg: "p-10",
    xl: "p-12"
  };
  const variantClasses2 = {
    default: "bg-gray-50 dark:bg-gray-900/50",
    minimal: "bg-transparent",
    elevated: "bg-white dark:bg-gray-900 shadow-lg",
    bordered: "bg-white dark:bg-gray-900 border-2",
    filled: "bg-gray-100 dark:bg-gray-800",
    dashed: "bg-white dark:bg-gray-900 border-2 border-dashed"
  };
  const colorClasses2 = {
    primary: "border-primary-300 dark:border-primary-600 text-primary-600 dark:text-primary-400",
    success: "border-success-300 dark:border-success-600 text-success-600 dark:text-success-400",
    warning: "border-warning-300 dark:border-warning-600 text-warning-600 dark:text-warning-400",
    danger: "border-danger-300 dark:border-danger-600 text-danger-600 dark:text-danger-400",
    info: "border-info-300 dark:border-info-600 text-info-600 dark:text-info-400",
    neutral: "border-gray-300 dark:border-gray-600 text-gray-600 dark:text-gray-400"
  };
  const iconSizeClasses = {
    xs: "w-8 h-8 text-lg",
    sm: "w-10 h-10 text-xl",
    md: "w-12 h-12 text-2xl",
    lg: "w-16 h-16 text-4xl",
    xl: "w-20 h-20 text-5xl",
    "2xl": "w-24 h-24 text-6xl"
  };
  const handleToggle = () => {
    if (isCollapsible && !isDisabled) {
      const newExpanded = !expanded;
      setExpanded(newExpanded);
      onToggle?.(newExpanded);
    }
  };
  const handleDragStart = (event) => {
    if (isDraggable && !isDisabled) {
      setIsDragging(true);
      onDrag?.(event);
    }
  };
  const handleDragEnd = () => {
    setIsDragging(false);
  };
  const handleDrop = (event) => {
    if (isDraggable && !isDisabled) {
      onDrop?.(event);
    }
  };
  const containerClasses = `
    ${hasBackground ? "bg-white dark:bg-gray-900" : ""}
    ${hasBorder ? "border" : ""}
    ${hasDashedBorder ? "border-dashed" : ""}
    ${isRounded ? "rounded-lg" : ""}
    ${hasShadow ? "shadow-md" : ""}
    ${isResponsive ? "w-full" : ""}
    ${hasFixedWidth ? "" : "w-full"}
    ${isFullWidth ? "w-full" : ""}
    ${hasFixedHeight ? "" : "min-h-0"}
    ${isCentered ? "mx-auto" : ""}
    ${hasMaxWidth ? "max-w-2xl" : ""}
    ${hasMinWidth ? "min-w-0" : ""}
    ${hasMaxHeight ? "max-h-96" : ""}
    ${hasMinHeight ? "min-h-0" : ""}
    ${containerClassName}
    ${className}
  `.trim().replace(/\s+/g, " ");
  if (!isVisible || isLoading) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, style, ...props, children: [
    headerContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: headerContent }),
    backgroundContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 -z-10", children: backgroundContent }),
    borderContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: borderContent }),
    shadowContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none", children: shadowContent }),
    patternContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 pointer-events-none opacity-10", children: patternContent }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `
          relative text-center ${sizeClasses2[size2]}
          ${variantClasses2[variant]}
          ${colorClasses2[color2]}
          ${hasBorderRadius ? "rounded-lg" : ""}
          ${hasPadding ? "p-8" : ""}
          ${hasMargin ? "m-4" : ""}
          ${isInteractive ? "cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-800" : ""}
          ${isDraggable ? "cursor-move" : ""}
          ${isDisabled ? "opacity-50 cursor-not-allowed" : ""}
          ${isDragging2 ? "opacity-75" : ""}
          ${isAnimated ? "transition-all duration-200" : ""}
        `.trim().replace(/\s+/g, " "),
        onClick,
        onFocus,
        onBlur,
        draggable: isDraggable,
        onDragStart: handleDragStart,
        onDragEnd: handleDragEnd,
        onDrop: handleDrop,
        onDragOver: (e2) => e2.preventDefault(),
        children: [
          hasIcon && (iconContent || /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `
            mx-auto rounded-full flex items-center justify-center
            ${iconHasBackground ? "bg-gray-200 dark:bg-gray-700" : ""}
            ${iconHasBorder ? "border border-gray-300 dark:border-gray-600" : ""}
            ${iconIsRounded ? "rounded-full" : "rounded-lg"}
            ${iconHasShadow ? "shadow-md" : ""}
            ${iconSizeClasses[iconSize]}
          `.trim().replace(/\s+/g, " "),
              style: {
                color: iconColor,
                backgroundColor: iconBackgroundColor
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "3xl", className: "text-current", children: icon })
            }
          )),
          hasTitle && (titleContent || /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "mt-6 text-xl font-bold text-gray-900 dark:text-gray-100", children: title })),
          hasDescription && (descriptionContent || /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-sm text-gray-600 dark:text-gray-400 max-w-sm mx-auto", children: description })),
          hasAction && (actionContent || action) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-6", onClick: onActionClick, children: actionContent || action }),
          isCollapsible && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleToggle,
              disabled: isDisabled,
              className: "mt-4 px-3 py-1 text-xs bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3 mr-1", children: expanded ? "expand_less" : "expand_more" }),
                expanded ? "Collapse" : "Expand"
              ]
            }
          )
        ]
      }
    ),
    footerContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 text-center", children: footerContent })
  ] });
};
const FileUploader = ({
  label,
  id: id2,
  files,
  onFilesChange,
  multiple = false,
  accept,
  maxSize,
  maxFiles,
  disabled = false,
  required = false,
  error: error2,
  helpText,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  showPreview = false,
  showProgress = false,
  showFileList = true,
  showDragInstructions = true,
  placeholder,
  description,
  className,
  style,
  onValidation,
  onUploadError
}) => {
  const [isDragging2, setIsDragging] = useState(false);
  const [validationErrors, setValidationErrors] = useState([]);
  const inputRef = useRef(null);
  const sizeClasses2 = {
    xs: "min-h-16 p-3",
    sm: "min-h-20 p-4",
    md: "min-h-24 p-6",
    lg: "min-h-32 p-8",
    xl: "min-h-40 p-10"
  };
  const variantClasses2 = {
    default: "bg-white dark:bg-dark-bg-tertiary border-2 border-dashed",
    outlined: "bg-transparent border-2 border-solid",
    filled: "bg-bg-tertiary dark:bg-dark-bg-tertiary border-2 border-dashed",
    minimal: "bg-transparent border border-dashed"
  };
  const colorClasses2 = {
    primary: "border-brand-orange dark:border-dark-brand-orange",
    success: "border-system-success",
    warning: "border-system-warning",
    danger: "border-system-error",
    info: "border-system-info"
  };
  const getColorClasses2 = () => {
    if (error2) return "border-system-error bg-system-error/5";
    if (isDragging2) return `border-brand-orange dark:border-dark-brand-orange bg-brand-orange/10`;
    return colorClasses2[color2];
  };
  const validateFiles = useCallback((newFiles) => {
    const errors = [];
    newFiles.forEach((file) => {
      const fileErrors = [];
      if (maxSize && file.size > maxSize) {
        fileErrors.push(`File size exceeds ${(maxSize / 1024 / 1024).toFixed(1)}MB limit`);
      }
      if (accept) {
        const acceptedTypes = accept.split(",").map((type) => type.trim());
        const fileExtension = "." + file.name.split(".").pop()?.toLowerCase();
        const mimeType = file.type;
        const isAccepted = acceptedTypes.some((type) => {
          if (type.startsWith(".")) {
            return fileExtension === type;
          }
          if (type.includes("*")) {
            return mimeType.startsWith(type.replace("*", ""));
          }
          return mimeType === type;
        });
        if (!isAccepted) {
          fileErrors.push(`File type not allowed. Accepted: ${accept}`);
        }
      }
      if (fileErrors.length > 0) {
        errors.push({ file, errors: fileErrors });
      }
    });
    return errors;
  }, [maxSize, accept]);
  const handleFiles = useCallback((newFiles) => {
    if (maxFiles && files.length + newFiles.length > maxFiles) {
      const errorMessage = `Maximum ${maxFiles} files allowed`;
      onUploadError?.(errorMessage);
      return;
    }
    const errors = validateFiles(newFiles);
    setValidationErrors(errors);
    onValidation?.(errors);
    const validFiles = newFiles.filter(
      (file) => !errors.some((error22) => error22.file === file)
    );
    if (validFiles.length > 0) {
      const updatedFiles = multiple ? [...files, ...validFiles] : [validFiles[0]];
      onFilesChange(updatedFiles);
    }
  }, [files, multiple, maxFiles, validateFiles, onFilesChange, onValidation, onUploadError]);
  const handleDrag = useCallback((e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    if (disabled) return;
    if (e2.type === "dragenter" || e2.type === "dragover") {
      setIsDragging(true);
    } else if (e2.type === "dragleave") {
      setIsDragging(false);
    }
  }, [disabled]);
  const handleDrop = useCallback((e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    setIsDragging(false);
    if (disabled) return;
    if (e2.dataTransfer.files && e2.dataTransfer.files.length > 0) {
      const newFiles = Array.from(e2.dataTransfer.files);
      handleFiles(newFiles);
    }
  }, [disabled, handleFiles]);
  const handleFileSelect = useCallback((e2) => {
    if (e2.target.files && e2.target.files.length > 0) {
      const newFiles = Array.from(e2.target.files);
      handleFiles(newFiles);
    }
  }, [handleFiles]);
  const removeFile = useCallback((index2) => {
    const updatedFiles = files.filter((_2, i2) => i2 !== index2);
    onFilesChange(updatedFiles);
    setValidationErrors((prev) => prev.filter(
      (error22) => !updatedFiles.includes(error22.file)
    ));
  }, [files, onFilesChange]);
  const clearAllFiles = useCallback(() => {
    onFilesChange([]);
    setValidationErrors([]);
  }, [onFilesChange]);
  const handleAreaClick = useCallback(() => {
    if (!disabled) {
      inputRef.current?.click();
    }
  }, [disabled]);
  const formatFileSize = (bytes) => {
    if (bytes === 0) return "0 Bytes";
    const k2 = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i2 = Math.floor(Math.log(bytes) / Math.log(k2));
    return parseFloat((bytes / Math.pow(k2, i2)).toFixed(2)) + " " + sizes[i2];
  };
  const getFileIcon = (file) => {
    const type = file.type;
    if (type.startsWith("image/")) return "image";
    if (type.startsWith("video/")) return "video_file";
    if (type.startsWith("audio/")) return "audio_file";
    if (type.includes("pdf")) return "picture_as_pdf";
    if (type.includes("word") || type.includes("document")) return "description";
    if (type.includes("excel") || type.includes("spreadsheet")) return "table_chart";
    if (type.includes("powerpoint") || type.includes("presentation")) return "slideshow";
    if (type.includes("zip") || type.includes("archive")) return "folder_zip";
    return "insert_drive_file";
  };
  const combinedClasses = cn(
    "relative w-full flex flex-col items-center justify-center text-center transition-all duration-200",
    sizeClasses2[size2],
    variantClasses2[variant],
    getColorClasses2(),
    "rounded-lg",
    disabled && "opacity-50 cursor-not-allowed",
    !disabled && "hover:shadow-md cursor-pointer",
    !disabled && "outline-none focus-visible:ring-2 focus-visible:ring-brand-orange focus-visible:ring-offset-2 dark:focus-visible:ring-dark-brand-orange",
    className
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", style, children: [
    label && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: "block text-sm font-medium text-text-primary dark:text-dark-text-primary mb-2", children: [
      label,
      required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
    ] }),
    description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary mb-3", children: description }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: combinedClasses,
        onDragEnter: handleDrag,
        onDragOver: handleDrag,
        onDragLeave: handleDrag,
        onDrop: handleDrop,
        onClick: handleAreaClick,
        role: "button",
        tabIndex: disabled ? -1 : 0,
        "aria-label": placeholder || "File upload area",
        onKeyDown: (e2) => {
          if (e2.key === "Enter" || e2.key === " ") {
            e2.preventDefault();
            handleAreaClick();
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon,
            {
              size: "2xl",
              className: cn(
                "text-text-secondary dark:text-dark-text-secondary mb-2",
                isDragging2 && "text-brand-orange dark:text-dark-brand-orange"
              ),
              children: isDragging2 ? "cloud_upload" : "cloud_upload"
            }
          ),
          showDragInstructions && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium text-text-primary dark:text-dark-text-primary", children: isDragging2 ? "Drop files here" : "Drag & drop files here" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: [
              "or ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-semibold text-brand-orange", children: "browse files" })
            ] })
          ] }),
          placeholder && !showDragInstructions && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-text-secondary dark:text-dark-text-secondary", children: placeholder }),
          (maxSize || accept) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 text-xs text-text-secondary dark:text-dark-text-secondary", children: [
            maxSize && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Max size: ",
              formatFileSize(maxSize)
            ] }),
            maxSize && accept && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " • " }),
            accept && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              "Types: ",
              accept
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              ref: inputRef,
              type: "file",
              id: id2,
              multiple,
              accept,
              className: "hidden",
              onChange: handleFileSelect,
              disabled
            }
          )
        ]
      }
    ),
    showProgress && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between text-sm text-text-secondary dark:text-dark-text-secondary mb-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Upload Progress" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "0%" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full bg-bg-tertiary dark:bg-dark-bg-tertiary rounded-full h-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "bg-brand-orange h-2 rounded-full transition-all duration-300",
          style: { width: "0%" }
        }
      ) })
    ] }),
    showFileList && files.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "text-sm font-medium text-text-primary dark:text-dark-text-primary", children: [
          "Selected Files (",
          files.length,
          ")"
        ] }),
        files.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant: "text",
            size: "xs",
            onClick: clearAllFiles,
            disabled,
            className: "text-system-error hover:text-system-error/80",
            children: "Clear All"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: files.map((file, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex items-center justify-between p-3 bg-bg-secondary dark:bg-dark-bg-secondary rounded-lg border border-border-color dark:border-dark-border-color",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 flex-1 min-w-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-text-secondary dark:text-dark-text-secondary flex-shrink-0", children: getFileIcon(file) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-text-primary dark:text-dark-text-primary truncate", children: file.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-text-secondary dark:text-dark-text-secondary", children: formatFileSize(file.size) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                variant: "text",
                size: "xs",
                onClick: () => removeFile(index2),
                disabled,
                className: "text-system-error hover:text-system-error/80 flex-shrink-0",
                "aria-label": `Remove ${file.name}`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "close" })
              }
            )
          ]
        },
        `${file.name}-${index2}`
      )) })
    ] }),
    showPreview && files.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium text-text-primary dark:text-dark-text-primary mb-2", children: "Previews" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-1", children: files.map((file, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-20 h-20", children: [
        file.type.startsWith("image/") ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: URL.createObjectURL(file),
            alt: file.name,
            className: "w-20 h-20 object-cover rounded-lg border border-border-color dark:border-dark-border-color"
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-20 h-20 bg-bg-tertiary dark:bg-dark-bg-tertiary rounded-lg border border-border-color dark:border-dark-border-color flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-text-secondary dark:text-dark-text-secondary", children: getFileIcon(file) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => removeFile(index2),
            disabled,
            className: "absolute -top-1 -right-1 bg-system-error text-white rounded-full w-5 h-5 flex items-center justify-center hover:bg-system-error/80 disabled:opacity-50",
            "aria-label": `Remove ${file.name}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xs", children: "close" })
          }
        )
      ] }, `preview-${index2}`)) })
    ] }),
    validationErrors.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-3 space-y-1", children: validationErrors.map((error22, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-system-error", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "font-medium", children: [
        error22.file.name,
        ":"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "ml-2 list-disc list-inside", children: error22.errors.map((err, errIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: err }, errIndex)) })
    ] }, index2)) }),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error mt-2", children: error2 }),
    helpText && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary mt-2", children: helpText })
  ] });
};
const useDeprecationWarning = (props, deprecatedProps) => {
  useEffect(() => {
    if (process.env.NODE_ENV === "development") {
      Object.keys(deprecatedProps).forEach((oldProp) => {
        if (props[oldProp] !== void 0) {
          const newUsage = deprecatedProps[oldProp];
          console.warn(
            `[Deprecation Warning] The '${oldProp}' prop on the <Grid> component is deprecated. Please use the 'className' prop instead for better consistency. Example: <Grid className="${newUsage}" />`
          );
        }
      });
    }
  }, [props, deprecatedProps]);
};
const GridRoot = ({
  as: Component2 = "div",
  children,
  className,
  cols = 1,
  gap = 6,
  autoFit,
  minColumnWidth,
  // Deprecated props for backward compatibility
  hasBackground,
  isBordered,
  isRounded,
  hasShadow,
  hasPadding,
  style,
  ...props
}) => {
  useDeprecationWarning({ hasBackground, isBordered, isRounded, hasShadow, hasPadding }, {
    hasBackground: "bg-white dark:bg-gray-900",
    isBordered: "border border-gray-200 dark:border-gray-700",
    isRounded: "rounded-lg",
    hasShadow: "shadow-md",
    hasPadding: "p-6"
  });
  const gridClasses = React__default.useMemo(() => {
    if (autoFit && minColumnWidth) {
      return "";
    }
    if (typeof cols === "number") return `grid-cols-${cols}`;
    if (typeof cols === "object" && cols !== null) {
      const responsiveCols = cols;
      return [
        responsiveCols.xs ? `grid-cols-${responsiveCols.xs}` : "grid-cols-1",
        responsiveCols.sm ? `sm:grid-cols-${responsiveCols.sm}` : "",
        responsiveCols.md ? `md:grid-cols-${responsiveCols.md}` : "",
        responsiveCols.lg ? `lg:grid-cols-${responsiveCols.lg}` : "",
        responsiveCols.xl ? `xl:grid-cols-${responsiveCols.xl}` : "",
        responsiveCols["2xl"] ? `2xl:grid-cols-${responsiveCols["2xl"]}` : ""
      ].filter(Boolean).join(" ");
    }
    return "grid-cols-1";
  }, [cols, autoFit, minColumnWidth]);
  const deprecatedClasses = cn(
    hasBackground && "bg-white dark:bg-gray-900",
    isBordered && "border border-gray-200 dark:border-gray-700",
    isRounded && "rounded-lg",
    hasShadow && "shadow-md",
    hasPadding && "p-6"
  );
  const gridStyle = autoFit && minColumnWidth ? { gridTemplateColumns: `repeat(auto-fit, minmax(${minColumnWidth}, 1fr))` } : style;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Component2,
    {
      className: cn(
        "grid",
        `gap-${gap}`,
        gridClasses,
        deprecatedClasses,
        // Apply classes from old props
        className
        // Apply any new, user-provided classes
      ),
      style: gridStyle,
      ...props,
      children
    }
  );
};
const GridItem = ({
  as: Component2 = "div",
  children,
  className,
  span = 1,
  sm,
  md,
  lg,
  xl,
  "2xl": twoXl,
  ...props
}) => {
  const spanClasses = React__default.useMemo(() => {
    const responsiveSpans = { sm, md, lg, xl, "2xl": twoXl };
    const responsiveClasses = Object.entries(responsiveSpans).map(([bp, val]) => val ? `${bp}:col-span-${val}` : "").filter(Boolean).join(" ");
    return cn(`col-span-${span}`, responsiveClasses);
  }, [span, sm, md, lg, xl, twoXl]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Component2, { className: cn(spanClasses, className), ...props, children });
};
const Grid = Object.assign(GridRoot, {
  Item: GridItem
});
const acutrackLogoLight = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Layer_2'%20data-name='Layer%202'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20830.85%20130.02'%3e%3cdefs%3e%3cstyle%3e%20.cls-1%20{%20fill:%20%2322bec9;%20}%20.cls-1,%20.cls-2%20{%20fill-rule:%20evenodd;%20}%20.cls-2%20{%20fill:%20%23344a81;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Layer_1-2'%20data-name='Layer%201'%3e%3cg%3e%3cpath%20id='Path_1'%20data-name='Path%201'%20class='cls-2'%20d='M177.89,10.05l1.72-4.58c.21.32.37.68.45,1.06l44.1,121.32h23.41L201.16,0h-30.97l-.98,2.72-43.44,115.42H0v9.74h133.7L177.89,10.12v-.07Z'/%3e%3cg%20id='Group_1'%20data-name='Group%201'%3e%3cpath%20id='Path_2'%20data-name='Path%202'%20class='cls-1'%20d='M162.33,1.74c-31.22,30.04-45.03,73.89-36.66,116.4,2.51-41.22,15.1-81.19,36.66-116.4Z'/%3e%3cpath%20id='Path_3'%20data-name='Path%203'%20class='cls-1'%20d='M127.05,0c-20.55,36.6-21.07,81.15-1.36,118.22-9.18-38.93-8.72-79.51,1.36-118.22Z'/%3e%3cpath%20id='Path_4'%20data-name='Path%204'%20class='cls-1'%20d='M94.28,5.59c-9.36,40.42,2.48,82.83,31.42,112.55-19.5-34.39-30.28-73.03-31.42-112.55Z'/%3e%3cpath%20id='Path_5'%20data-name='Path%205'%20class='cls-1'%20d='M60.2,19.79c3.69,41.8,28.36,78.87,65.49,98.43-29.55-26.96-52.04-60.76-65.49-98.43Z'/%3e%3cpath%20id='Path_6'%20data-name='Path%206'%20class='cls-1'%20d='M32.71,39.13c15.5,40.48,50.55,70.28,92.99,79.09-36.99-18.37-68.91-45.53-92.99-79.09Z'/%3e%3cpath%20id='Path_7'%20data-name='Path%207'%20class='cls-1'%20d='M9.97,63c26.69,36.85,70.26,57.65,115.7,55.22-42.5-8.68-82.22-27.64-115.7-55.22Z'/%3e%3c/g%3e%3cpath%20id='Path_23'%20data-name='Path%2023'%20class='cls-2'%20d='M525.07,51.74v-17.3h-29.84c3.46-.15,6.51,2.26,7.18,5.66.08,5.59.08,11.94.08,19.71v68.06h22.59v-42.22c0-25,11.56-33.92,30.44-33.79v-17.3c-15.79.23-26.13,5.89-30.44,17.22v-.05Z'/%3e%3cpath%20id='Path_24'%20data-name='Path%2024'%20class='cls-2'%20d='M336.07,98.21c-3.47,15.79-14.43,31.8-40.87,31.8-27.95,0-43.21-19.57-43.21-48.27,0-27.19,16.16-49.47,44.42-49.47,29.91,0,38.9,21.46,39.66,32.48h-22.13c-1.14-8.83-9.02-15.21-17.9-14.5-13.45,0-21,11.63-21,30.75,0,20.32,7.7,31.2,20.7,31.2,8.6.25,16.18-5.6,18.13-13.98h22.21Z'/%3e%3cpath%20id='Path_25'%20data-name='Path%2025'%20class='cls-2'%20d='M428.53,100.7V34.45h-22.58v49.33c0,20.09-5.52,27.49-19.11,27.49-12.6,0-16.04-9.52-16.04-20.47v-56.42h-29.74c3.75-.19,6.98,2.61,7.32,6.35v54.69c0,24.25,13.14,34.59,31.04,34.59,12.84,0,21.37-4.38,26.59-14.05.03,3.96.25,7.92.68,11.86h22.06c-.08-7.4-.15-18.13-.15-27.12h-.08Z'/%3e%3cpath%20id='Path_26'%20data-name='Path%2026'%20class='cls-2'%20d='M490.21,51.82v-17.3h-56.7v17.3h15.03v52.2c0,16.09,6.19,25.08,23.11,25.08,5.47.26,10.95-.32,16.24-1.72v-15.96c-2.2.36-4.42.51-6.65.45-7.93,0-10.12-3.4-10.12-11.18v-48.95h19.11l-.02.08ZM471.02,8.09h0v-3.4h-22.51v25.91h.08c12.38-.03,22.41-10.06,22.43-22.43v-.07Z'/%3e%3cpath%20id='Path_27'%20data-name='Path%2027'%20class='cls-2'%20d='M619.1,84.3h-12.08c-16.54,0-23.79,4.83-23.79,15.26-.27,7.45,5.54,13.71,12.99,13.98.69.02,1.37,0,2.05-.08,18.43,0,20.85-12.6,20.85-26.51v-2.65ZM641.09,104.92h0c-.03,7.66.4,15.31,1.29,22.91h-21.6c-.89-3.33-1.34-6.75-1.36-10.2-3.4,5.59-10.13,12.39-27.11,12.39-22.34,0-31.81-14.66-31.81-29.08,0-21.08,16.84-30.82,44.34-30.82h14.2v-6.5c0-7.18-2.42-14.89-16.24-14.89-12.46,0-14.95,5.66-16.39,12.6h-21.52c1.36-15.33,10.8-29.21,38.67-29.08,24.24.15,37.55,9.74,37.55,31.65v41.02Z'/%3e%3cpath%20id='Path_28'%20data-name='Path%2028'%20class='cls-2'%20d='M731.44,98.21c-3.48,15.79-14.43,31.8-40.87,31.8-27.95,0-43.21-19.57-43.21-48.27,0-27.19,16.16-49.47,44.42-49.47,29.91,0,38.9,21.46,39.66,32.48h-22.14c-1.15-8.83-9.02-15.21-17.9-14.5-13.45,0-21,11.63-21,30.75,0,20.32,7.7,31.2,20.7,31.2,8.6.25,16.18-5.6,18.12-13.98h22.22Z'/%3e%3cpath%20id='Path_29'%20data-name='Path%2029'%20class='cls-2'%20d='M794.14,70.09l33.38-35.65h-26.13l-35.13,35.65V4.6h-29.92c3.71-.17,6.92,2.58,7.33,6.27v116.93h22.59v-31.04l12.6-12.24,26.22,43.28h25.77l-36.79-57.71h.07Z'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const acutrackLogoDark = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Layer_2'%20data-name='Layer%202'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20830.85%20130.02'%3e%3cdefs%3e%3cstyle%3e%20.cls-1%20{%20fill:%20%23fff;%20}%20.cls-1,%20.cls-2%20{%20fill-rule:%20evenodd;%20}%20.cls-2%20{%20fill:%20%2322bec9;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Layer_1-2'%20data-name='Layer%201'%3e%3cg%3e%3cpath%20id='Path_1'%20data-name='Path%201'%20class='cls-1'%20d='M177.89,10.05l1.72-4.58c.21.32.37.68.45,1.06l44.1,121.32h23.41L201.16,0h-30.97l-.98,2.72-43.44,115.42H0v9.74h133.7L177.89,10.12v-.07Z'/%3e%3cg%20id='Group_1'%20data-name='Group%201'%3e%3cpath%20id='Path_2'%20data-name='Path%202'%20class='cls-2'%20d='M162.33,1.74c-31.22,30.04-45.03,73.89-36.66,116.4,2.51-41.22,15.1-81.19,36.66-116.4Z'/%3e%3cpath%20id='Path_3'%20data-name='Path%203'%20class='cls-2'%20d='M127.05,0c-20.55,36.6-21.07,81.15-1.36,118.22-9.18-38.93-8.72-79.51,1.36-118.22Z'/%3e%3cpath%20id='Path_4'%20data-name='Path%204'%20class='cls-2'%20d='M94.28,5.59c-9.36,40.42,2.48,82.83,31.42,112.55-19.5-34.39-30.28-73.03-31.42-112.55Z'/%3e%3cpath%20id='Path_5'%20data-name='Path%205'%20class='cls-2'%20d='M60.2,19.79c3.69,41.8,28.36,78.87,65.49,98.43-29.55-26.96-52.04-60.76-65.49-98.43Z'/%3e%3cpath%20id='Path_6'%20data-name='Path%206'%20class='cls-2'%20d='M32.71,39.13c15.5,40.48,50.55,70.28,92.99,79.09-36.99-18.37-68.91-45.53-92.99-79.09Z'/%3e%3cpath%20id='Path_7'%20data-name='Path%207'%20class='cls-2'%20d='M9.97,63c26.69,36.85,70.26,57.65,115.7,55.22-42.5-8.68-82.22-27.64-115.7-55.22Z'/%3e%3c/g%3e%3cpath%20id='Path_23'%20data-name='Path%2023'%20class='cls-1'%20d='M525.07,51.74v-17.3h-29.84c3.46-.15,6.51,2.26,7.18,5.66.08,5.59.08,11.94.08,19.71v68.06h22.59v-42.22c0-25,11.56-33.92,30.44-33.79v-17.3c-15.79.23-26.13,5.89-30.44,17.22v-.05Z'/%3e%3cpath%20id='Path_24'%20data-name='Path%2024'%20class='cls-1'%20d='M336.07,98.21c-3.47,15.79-14.43,31.8-40.87,31.8-27.95,0-43.21-19.57-43.21-48.27,0-27.19,16.16-49.47,44.42-49.47,29.91,0,38.9,21.46,39.66,32.48h-22.13c-1.14-8.83-9.02-15.21-17.9-14.5-13.45,0-21,11.63-21,30.75,0,20.32,7.7,31.2,20.7,31.2,8.6.25,16.18-5.6,18.13-13.98h22.21Z'/%3e%3cpath%20id='Path_25'%20data-name='Path%2025'%20class='cls-1'%20d='M428.53,100.7V34.45h-22.58v49.33c0,20.09-5.52,27.49-19.11,27.49-12.6,0-16.04-9.52-16.04-20.47v-56.42h-29.74c3.75-.19,6.98,2.61,7.32,6.35v54.69c0,24.25,13.14,34.59,31.04,34.59,12.84,0,21.37-4.38,26.59-14.05.03,3.96.25,7.92.68,11.86h22.06c-.08-7.4-.15-18.13-.15-27.12h-.08Z'/%3e%3cpath%20id='Path_26'%20data-name='Path%2026'%20class='cls-1'%20d='M490.21,51.82v-17.3h-56.7v17.3h15.03v52.2c0,16.09,6.19,25.08,23.11,25.08,5.47.26,10.95-.32,16.24-1.72v-15.96c-2.2.36-4.42.51-6.65.45-7.93,0-10.12-3.4-10.12-11.18v-48.95h19.11l-.02.08ZM471.02,8.09h0v-3.4h-22.51v25.91h.08c12.38-.03,22.41-10.06,22.43-22.43v-.07Z'/%3e%3cpath%20id='Path_27'%20data-name='Path%2027'%20class='cls-1'%20d='M619.1,84.3h-12.08c-16.54,0-23.79,4.83-23.79,15.26-.27,7.45,5.54,13.71,12.99,13.98.69.02,1.37,0,2.05-.08,18.43,0,20.85-12.6,20.85-26.51v-2.65ZM641.09,104.92h0c-.03,7.66.4,15.31,1.29,22.91h-21.6c-.89-3.33-1.34-6.75-1.36-10.2-3.4,5.59-10.13,12.39-27.11,12.39-22.34,0-31.81-14.66-31.81-29.08,0-21.08,16.84-30.82,44.34-30.82h14.2v-6.5c0-7.18-2.42-14.89-16.24-14.89-12.46,0-14.95,5.66-16.39,12.6h-21.52c1.36-15.33,10.8-29.21,38.67-29.08,24.24.15,37.55,9.74,37.55,31.65v41.02Z'/%3e%3cpath%20id='Path_28'%20data-name='Path%2028'%20class='cls-1'%20d='M731.44,98.21c-3.48,15.79-14.43,31.8-40.87,31.8-27.95,0-43.21-19.57-43.21-48.27,0-27.19,16.16-49.47,44.42-49.47,29.91,0,38.9,21.46,39.66,32.48h-22.14c-1.15-8.83-9.02-15.21-17.9-14.5-13.45,0-21,11.63-21,30.75,0,20.32,7.7,31.2,20.7,31.2,8.6.25,16.18-5.6,18.12-13.98h22.22Z'/%3e%3cpath%20id='Path_29'%20data-name='Path%2029'%20class='cls-1'%20d='M794.14,70.09l33.38-35.65h-26.13l-35.13,35.65V4.6h-29.92c3.71-.17,6.92,2.58,7.33,6.27v116.93h22.59v-31.04l12.6-12.24,26.22,43.28h25.77l-36.79-57.71h.07Z'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const acutrackLogoIconLight = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Layer_2'%20data-name='Layer%202'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20247.58%20127.88'%3e%3cdefs%3e%3cstyle%3e%20.cls-1%20{%20fill:%20%2322bec9;%20}%20.cls-1,%20.cls-2%20{%20fill-rule:%20evenodd;%20}%20.cls-2%20{%20fill:%20%23344a81;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Layer_1-2'%20data-name='Layer%201'%3e%3cg%3e%3cpath%20id='Path_1'%20data-name='Path%201'%20class='cls-2'%20d='M177.89,10.05l1.72-4.58c.21.32.37.68.45,1.06l44.1,121.32h23.41L201.16,0h-30.97l-.98,2.72-43.44,115.42H0v9.74h133.7L177.89,10.12v-.07Z'/%3e%3cg%20id='Group_1'%20data-name='Group%201'%3e%3cpath%20id='Path_2'%20data-name='Path%202'%20class='cls-1'%20d='M162.33,1.74c-31.22,30.04-45.03,73.89-36.66,116.4,2.51-41.22,15.1-81.19,36.66-116.4Z'/%3e%3cpath%20id='Path_3'%20data-name='Path%203'%20class='cls-1'%20d='M127.05,0c-20.55,36.6-21.07,81.15-1.36,118.22-9.18-38.93-8.72-79.51,1.36-118.22Z'/%3e%3cpath%20id='Path_4'%20data-name='Path%204'%20class='cls-1'%20d='M94.28,5.59c-9.36,40.42,2.48,82.83,31.42,112.55-19.5-34.39-30.28-73.03-31.42-112.55Z'/%3e%3cpath%20id='Path_5'%20data-name='Path%205'%20class='cls-1'%20d='M60.2,19.79c3.69,41.8,28.36,78.87,65.49,98.43-29.55-26.96-52.04-60.76-65.49-98.43Z'/%3e%3cpath%20id='Path_6'%20data-name='Path%206'%20class='cls-1'%20d='M32.71,39.13c15.5,40.48,50.55,70.28,92.99,79.09-36.99-18.37-68.91-45.53-92.99-79.09Z'/%3e%3cpath%20id='Path_7'%20data-name='Path%207'%20class='cls-1'%20d='M9.97,63c26.69,36.85,70.26,57.65,115.7,55.22-42.5-8.68-82.22-27.64-115.7-55.22Z'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const acutrackLogoIconDark = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Layer_2'%20data-name='Layer%202'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20247.58%20127.88'%3e%3cdefs%3e%3cstyle%3e%20.cls-1%20{%20fill:%20%23fff;%20}%20.cls-1,%20.cls-2%20{%20fill-rule:%20evenodd;%20}%20.cls-2%20{%20fill:%20%2322bec9;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Layer_1-2'%20data-name='Layer%201'%3e%3cg%3e%3cpath%20id='Path_1'%20data-name='Path%201'%20class='cls-1'%20d='M177.89,10.05l1.72-4.58c.21.32.37.68.45,1.06l44.1,121.32h23.41L201.16,0h-30.97l-.98,2.72-43.44,115.42H0v9.74h133.7L177.89,10.12v-.07Z'/%3e%3cg%20id='Group_1'%20data-name='Group%201'%3e%3cpath%20id='Path_2'%20data-name='Path%202'%20class='cls-2'%20d='M162.33,1.74c-31.22,30.04-45.03,73.89-36.66,116.4,2.51-41.22,15.1-81.19,36.66-116.4Z'/%3e%3cpath%20id='Path_3'%20data-name='Path%203'%20class='cls-2'%20d='M127.05,0c-20.55,36.6-21.07,81.15-1.36,118.22-9.18-38.93-8.72-79.51,1.36-118.22Z'/%3e%3cpath%20id='Path_4'%20data-name='Path%204'%20class='cls-2'%20d='M94.28,5.59c-9.36,40.42,2.48,82.83,31.42,112.55-19.5-34.39-30.28-73.03-31.42-112.55Z'/%3e%3cpath%20id='Path_5'%20data-name='Path%205'%20class='cls-2'%20d='M60.2,19.79c3.69,41.8,28.36,78.87,65.49,98.43-29.55-26.96-52.04-60.76-65.49-98.43Z'/%3e%3cpath%20id='Path_6'%20data-name='Path%206'%20class='cls-2'%20d='M32.71,39.13c15.5,40.48,50.55,70.28,92.99,79.09-36.99-18.37-68.91-45.53-92.99-79.09Z'/%3e%3cpath%20id='Path_7'%20data-name='Path%207'%20class='cls-2'%20d='M9.97,63c26.69,36.85,70.26,57.65,115.7,55.22-42.5-8.68-82.22-27.64-115.7-55.22Z'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const acutrackGreyLight = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Layer_2'%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20viewBox='0%200%20830.8%20130'%3e%3c!--%20Generator:%20Adobe%20Illustrator%2029.8.1,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%202.1.1%20Build%202)%20--%3e%3cdefs%3e%3cstyle%3e%20.st0%20{%20fill:%20%23111827;%20}%20.st0,%20.st1%20{%20fill-rule:%20evenodd;%20}%20.st1%20{%20fill:%20%23d1d5db;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Layer_1-2'%3e%3cg%3e%3cpath%20id='Path_1'%20class='st0'%20d='M177.9,10.1l1.7-4.6c.2.3.4.7.4,1.1l44.1,121.3h23.4L201.2,0h-31l-1,2.7-43.4,115.4H0v9.7h133.7L177.9,10.1h0Z'/%3e%3cg%20id='Group_1'%3e%3cpath%20id='Path_2'%20class='st1'%20d='M162.3,1.7c-31.2,30-45,73.9-36.7,116.4,2.5-41.2,15.1-81.2,36.7-116.4Z'/%3e%3cpath%20id='Path_3'%20class='st1'%20d='M127.1,0c-20.6,36.6-21.1,81.2-1.4,118.2-9.2-38.9-8.7-79.5,1.4-118.2Z'/%3e%3cpath%20id='Path_4'%20class='st1'%20d='M94.3,5.6c-9.4,40.4,2.5,82.8,31.4,112.5-19.5-34.4-30.3-73-31.4-112.5Z'/%3e%3cpath%20id='Path_5'%20class='st1'%20d='M60.2,19.8c3.7,41.8,28.4,78.9,65.5,98.4-29.6-27-52-60.8-65.5-98.4Z'/%3e%3cpath%20id='Path_6'%20class='st1'%20d='M32.7,39.1c15.5,40.5,50.5,70.3,93,79.1-37-18.4-68.9-45.5-93-79.1Z'/%3e%3cpath%20id='Path_7'%20class='st1'%20d='M10,63c26.7,36.8,70.3,57.7,115.7,55.2-42.5-8.7-82.2-27.6-115.7-55.2Z'/%3e%3c/g%3e%3cpath%20id='Path_23'%20class='st0'%20d='M525.1,51.7v-17.3h-29.8c3.5-.2,6.5,2.3,7.2,5.7,0,5.6,0,11.9,0,19.7v68.1h22.6v-42.2c0-25,11.6-33.9,30.4-33.8v-17.3c-15.8.2-26.1,5.9-30.4,17.2h0s0,0,0,0Z'/%3e%3cpath%20id='Path_24'%20class='st0'%20d='M336.1,98.2c-3.5,15.8-14.4,31.8-40.9,31.8s-43.2-19.6-43.2-48.3,16.2-49.5,44.4-49.5,38.9,21.5,39.7,32.5h-22.1c-1.1-8.8-9-15.2-17.9-14.5-13.5,0-21,11.6-21,30.8s7.7,31.2,20.7,31.2c8.6.2,16.2-5.6,18.1-14h22.2,0Z'/%3e%3cpath%20id='Path_25'%20class='st0'%20d='M428.5,100.7V34.5h-22.6v49.3c0,20.1-5.5,27.5-19.1,27.5s-16-9.5-16-20.5v-56.4h-29.7c3.8-.2,7,2.6,7.3,6.3v54.7c0,24.2,13.1,34.6,31,34.6s21.4-4.4,26.6-14.1c0,4,.2,7.9.7,11.9h22.1c0-7.4-.1-18.1-.1-27.1h0,0Z'/%3e%3cpath%20id='Path_26'%20class='st0'%20d='M490.2,51.8v-17.3h-56.7v17.3h15v52.2c0,16.1,6.2,25.1,23.1,25.1,5.5.3,11-.3,16.2-1.7v-16c-2.2.4-4.4.5-6.6.4-7.9,0-10.1-3.4-10.1-11.2v-49h19.1s0,0,0,0ZM471,8.1h0v-3.4h-22.5v25.9h0c12.4,0,22.4-10.1,22.4-22.4h0c0,0,0,0,0,0Z'/%3e%3cpath%20id='Path_27'%20class='st0'%20d='M619.1,84.3h-12.1c-16.5,0-23.8,4.8-23.8,15.3-.3,7.4,5.5,13.7,13,14,.7,0,1.4,0,2,0,18.4,0,20.8-12.6,20.8-26.5v-2.7h0ZM641.1,104.9h0c0,7.7.4,15.3,1.3,22.9h-21.6c-.9-3.3-1.3-6.8-1.4-10.2-3.4,5.6-10.1,12.4-27.1,12.4s-31.8-14.7-31.8-29.1c0-21.1,16.8-30.8,44.3-30.8h14.2v-6.5c0-7.2-2.4-14.9-16.2-14.9s-15,5.7-16.4,12.6h-21.5c1.4-15.3,10.8-29.2,38.7-29.1,24.2.2,37.5,9.7,37.5,31.7v41h0Z'/%3e%3cpath%20id='Path_28'%20class='st0'%20d='M731.4,98.2c-3.5,15.8-14.4,31.8-40.9,31.8s-43.2-19.6-43.2-48.3,16.2-49.5,44.4-49.5,38.9,21.5,39.7,32.5h-22.1c-1.2-8.8-9-15.2-17.9-14.5-13.5,0-21,11.6-21,30.8s7.7,31.2,20.7,31.2c8.6.2,16.2-5.6,18.1-14h22.2Z'/%3e%3cpath%20id='Path_29'%20class='st0'%20d='M794.1,70.1l33.4-35.7h-26.1l-35.1,35.7V4.6h-29.9c3.7-.2,6.9,2.6,7.3,6.3v116.9h22.6v-31l12.6-12.2,26.2,43.3h25.8l-36.8-57.7h0Z'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const acutrackGreyIconLight = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Layer_2'%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20viewBox='0%200%20247.6%20127.9'%3e%3c!--%20Generator:%20Adobe%20Illustrator%2029.8.1,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%202.1.1%20Build%202)%20--%3e%3cdefs%3e%3cstyle%3e%20.st0%20{%20fill:%20%23111827;%20}%20.st0,%20.st1%20{%20fill-rule:%20evenodd;%20}%20.st1%20{%20fill:%20%23d1d5db;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Layer_1-2'%3e%3cg%3e%3cpath%20id='Path_1'%20class='st0'%20d='M177.9,10.1l1.7-4.6c.2.3.4.7.4,1.1l44.1,121.3h23.4L201.2,0h-31l-1,2.7-43.4,115.4H0v9.7h133.7L177.9,10.1h0Z'/%3e%3cg%20id='Group_1'%3e%3cpath%20id='Path_2'%20class='st1'%20d='M162.3,1.7c-31.2,30-45,73.9-36.7,116.4,2.5-41.2,15.1-81.2,36.7-116.4Z'/%3e%3cpath%20id='Path_3'%20class='st1'%20d='M127.1,0c-20.6,36.6-21.1,81.2-1.4,118.2-9.2-38.9-8.7-79.5,1.4-118.2Z'/%3e%3cpath%20id='Path_4'%20class='st1'%20d='M94.3,5.6c-9.4,40.4,2.5,82.8,31.4,112.5-19.5-34.4-30.3-73-31.4-112.5Z'/%3e%3cpath%20id='Path_5'%20class='st1'%20d='M60.2,19.8c3.7,41.8,28.4,78.9,65.5,98.4-29.6-27-52-60.8-65.5-98.4Z'/%3e%3cpath%20id='Path_6'%20class='st1'%20d='M32.7,39.1c15.5,40.5,50.5,70.3,93,79.1-37-18.4-68.9-45.5-93-79.1Z'/%3e%3cpath%20id='Path_7'%20class='st1'%20d='M10,63c26.7,36.8,70.3,57.7,115.7,55.2-42.5-8.7-82.2-27.6-115.7-55.2Z'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const acutrackGreyDark = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Layer_2'%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20viewBox='0%200%20830.8%20130'%3e%3c!--%20Generator:%20Adobe%20Illustrator%2029.8.1,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%202.1.1%20Build%202)%20--%3e%3cdefs%3e%3cstyle%3e%20.st0%20{%20fill:%20%23fff;%20}%20.st0,%20.st1%20{%20fill-rule:%20evenodd;%20}%20.st1%20{%20fill:%20%23e5e7eb;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Layer_1-2'%3e%3cg%3e%3cpath%20id='Path_1'%20class='st0'%20d='M177.9,10.1l1.7-4.6c.2.3.4.7.4,1.1l44.1,121.3h23.4L201.2,0h-31l-1,2.7-43.4,115.4H0v9.7h133.7L177.9,10.1h0Z'/%3e%3cg%20id='Group_1'%3e%3cpath%20id='Path_2'%20class='st1'%20d='M162.3,1.7c-31.2,30-45,73.9-36.7,116.4,2.5-41.2,15.1-81.2,36.7-116.4Z'/%3e%3cpath%20id='Path_3'%20class='st1'%20d='M127.1,0c-20.6,36.6-21.1,81.2-1.4,118.2-9.2-38.9-8.7-79.5,1.4-118.2Z'/%3e%3cpath%20id='Path_4'%20class='st1'%20d='M94.3,5.6c-9.4,40.4,2.5,82.8,31.4,112.5-19.5-34.4-30.3-73-31.4-112.5Z'/%3e%3cpath%20id='Path_5'%20class='st1'%20d='M60.2,19.8c3.7,41.8,28.4,78.9,65.5,98.4-29.6-27-52-60.8-65.5-98.4Z'/%3e%3cpath%20id='Path_6'%20class='st1'%20d='M32.7,39.1c15.5,40.5,50.5,70.3,93,79.1-37-18.4-68.9-45.5-93-79.1Z'/%3e%3cpath%20id='Path_7'%20class='st1'%20d='M10,63c26.7,36.8,70.3,57.7,115.7,55.2-42.5-8.7-82.2-27.6-115.7-55.2Z'/%3e%3c/g%3e%3cpath%20id='Path_23'%20class='st0'%20d='M525.1,51.7v-17.3h-29.8c3.5-.2,6.5,2.3,7.2,5.7,0,5.6,0,11.9,0,19.7v68.1h22.6v-42.2c0-25,11.6-33.9,30.4-33.8v-17.3c-15.8.2-26.1,5.9-30.4,17.2h0s0,0,0,0Z'/%3e%3cpath%20id='Path_24'%20class='st0'%20d='M336.1,98.2c-3.5,15.8-14.4,31.8-40.9,31.8s-43.2-19.6-43.2-48.3,16.2-49.5,44.4-49.5,38.9,21.5,39.7,32.5h-22.1c-1.1-8.8-9-15.2-17.9-14.5-13.5,0-21,11.6-21,30.8s7.7,31.2,20.7,31.2c8.6.2,16.2-5.6,18.1-14h22.2,0Z'/%3e%3cpath%20id='Path_25'%20class='st0'%20d='M428.5,100.7V34.5h-22.6v49.3c0,20.1-5.5,27.5-19.1,27.5s-16-9.5-16-20.5v-56.4h-29.7c3.8-.2,7,2.6,7.3,6.3v54.7c0,24.2,13.1,34.6,31,34.6s21.4-4.4,26.6-14.1c0,4,.2,7.9.7,11.9h22.1c0-7.4-.1-18.1-.1-27.1h0,0Z'/%3e%3cpath%20id='Path_26'%20class='st0'%20d='M490.2,51.8v-17.3h-56.7v17.3h15v52.2c0,16.1,6.2,25.1,23.1,25.1,5.5.3,11-.3,16.2-1.7v-16c-2.2.4-4.4.5-6.6.4-7.9,0-10.1-3.4-10.1-11.2v-49h19.1s0,0,0,0ZM471,8.1h0v-3.4h-22.5v25.9h0c12.4,0,22.4-10.1,22.4-22.4h0c0,0,0,0,0,0Z'/%3e%3cpath%20id='Path_27'%20class='st0'%20d='M619.1,84.3h-12.1c-16.5,0-23.8,4.8-23.8,15.3-.3,7.4,5.5,13.7,13,14,.7,0,1.4,0,2,0,18.4,0,20.8-12.6,20.8-26.5v-2.7h0ZM641.1,104.9h0c0,7.7.4,15.3,1.3,22.9h-21.6c-.9-3.3-1.3-6.8-1.4-10.2-3.4,5.6-10.1,12.4-27.1,12.4s-31.8-14.7-31.8-29.1c0-21.1,16.8-30.8,44.3-30.8h14.2v-6.5c0-7.2-2.4-14.9-16.2-14.9s-15,5.7-16.4,12.6h-21.5c1.4-15.3,10.8-29.2,38.7-29.1,24.2.2,37.5,9.7,37.5,31.7v41h0Z'/%3e%3cpath%20id='Path_28'%20class='st0'%20d='M731.4,98.2c-3.5,15.8-14.4,31.8-40.9,31.8s-43.2-19.6-43.2-48.3,16.2-49.5,44.4-49.5,38.9,21.5,39.7,32.5h-22.1c-1.2-8.8-9-15.2-17.9-14.5-13.5,0-21,11.6-21,30.8s7.7,31.2,20.7,31.2c8.6.2,16.2-5.6,18.1-14h22.2Z'/%3e%3cpath%20id='Path_29'%20class='st0'%20d='M794.1,70.1l33.4-35.7h-26.1l-35.1,35.7V4.6h-29.9c3.7-.2,6.9,2.6,7.3,6.3v116.9h22.6v-31l12.6-12.2,26.2,43.3h25.8l-36.8-57.7h0Z'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const acutrackGreyIconDark = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Layer_2'%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20viewBox='0%200%20247.6%20127.9'%3e%3c!--%20Generator:%20Adobe%20Illustrator%2029.8.1,%20SVG%20Export%20Plug-In%20.%20SVG%20Version:%202.1.1%20Build%202)%20--%3e%3cdefs%3e%3cstyle%3e%20.st0%20{%20fill:%20%23fff;%20}%20.st0,%20.st1%20{%20fill-rule:%20evenodd;%20}%20.st1%20{%20fill:%20%23e5e7eb;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Layer_1-2'%3e%3cg%3e%3cpath%20id='Path_1'%20class='st0'%20d='M177.9,10.1l1.7-4.6c.2.3.4.7.4,1.1l44.1,121.3h23.4L201.2,0h-31l-1,2.7-43.4,115.4H0v9.7h133.7L177.9,10.1h0Z'/%3e%3cg%20id='Group_1'%3e%3cpath%20id='Path_2'%20class='st1'%20d='M162.3,1.7c-31.2,30-45,73.9-36.7,116.4,2.5-41.2,15.1-81.2,36.7-116.4Z'/%3e%3cpath%20id='Path_3'%20class='st1'%20d='M127.1,0c-20.6,36.6-21.1,81.2-1.4,118.2-9.2-38.9-8.7-79.5,1.4-118.2Z'/%3e%3cpath%20id='Path_4'%20class='st1'%20d='M94.3,5.6c-9.4,40.4,2.5,82.8,31.4,112.5-19.5-34.4-30.3-73-31.4-112.5Z'/%3e%3cpath%20id='Path_5'%20class='st1'%20d='M60.2,19.8c3.7,41.8,28.4,78.9,65.5,98.4-29.6-27-52-60.8-65.5-98.4Z'/%3e%3cpath%20id='Path_6'%20class='st1'%20d='M32.7,39.1c15.5,40.5,50.5,70.3,93,79.1-37-18.4-68.9-45.5-93-79.1Z'/%3e%3cpath%20id='Path_7'%20class='st1'%20d='M10,63c26.7,36.8,70.3,57.7,115.7,55.2-42.5-8.7-82.2-27.6-115.7-55.2Z'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
const LOGO_URLS = {
  light: {
    full: acutrackLogoLight,
    icon: acutrackLogoIconLight
  },
  dark: {
    full: acutrackLogoDark,
    icon: acutrackLogoIconDark
  },
  grey: {
    light: {
      full: acutrackGreyLight,
      icon: acutrackGreyIconLight
    },
    dark: {
      full: acutrackGreyDark,
      icon: acutrackGreyIconDark
    }
  }
};
const ACUTRACK_LOGO_LIGHT = acutrackLogoLight;
const ACUTRACK_LOGO_DARK = acutrackLogoDark;
const ACUTRACK_LOGO_ICON_LIGHT = acutrackLogoIconLight;
const ACUTRACK_LOGO_ICON_DARK = acutrackLogoIconDark;
const DEFAULT_LOGO_CONFIGS = {
  light: {
    text: "Acutrack",
    href: "#",
    isClickable: true,
    src: acutrackLogoLight,
    iconSrc: acutrackLogoIconLight,
    show: true,
    useIconOnMobile: true
  },
  dark: {
    text: "Acutrack",
    href: "#",
    isClickable: true,
    src: acutrackLogoDark,
    iconSrc: acutrackLogoIconDark,
    show: true,
    useIconOnMobile: true
  },
  iconOnly: {
    text: "Acutrack",
    href: "#",
    isClickable: true,
    iconSrc: acutrackLogoIconLight,
    show: true,
    useIconOnMobile: true
  }
};
const HEADER_THEMES = {
  default: {
    // Uses design system colors (current behavior)
    background: "bg-bg-primary dark:bg-dark-bg-primary",
    text: "text-text-primary dark:text-dark-text-primary",
    textSecondary: "text-text-secondary dark:text-dark-text-secondary",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-border-color dark:border-dark-border-color",
    logo: "text-text-primary dark:text-dark-text-primary",
    button: "bg-bg-tertiary dark:bg-dark-bg-tertiary",
    buttonText: "text-text-primary dark:text-dark-text-primary",
    search: "bg-bg-secondary dark:bg-dark-bg-secondary",
    searchText: "text-text-primary dark:text-dark-text-primary"
  },
  brand: {
    background: "bg-brand-navy",
    text: "text-white",
    textSecondary: "text-gray-300",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-brand-navy-900",
    logo: "text-white",
    button: "bg-brand-orange",
    buttonText: "text-white",
    search: "bg-brand-navy-600",
    searchText: "text-white"
  },
  minimal: {
    background: "bg-white",
    text: "text-gray-900",
    textSecondary: "text-gray-600",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-gray-200",
    logo: "text-gray-900",
    button: "bg-gray-100",
    buttonText: "text-gray-700",
    search: "bg-gray-50",
    searchText: "text-gray-900"
  },
  grey: {
    background: "bg-gray-900",
    text: "text-gray-100",
    textSecondary: "text-gray-400",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-gray-600",
    logo: "text-gray-100",
    button: "bg-gray-700",
    buttonText: "text-gray-100",
    search: "bg-gray-800",
    searchText: "text-gray-100"
  },
  dark: {
    background: "bg-dark-bg-primary",
    text: "text-dark-text-primary",
    textSecondary: "text-dark-text-secondary",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-dark-border-color",
    logo: "text-dark-text-primary",
    button: "bg-dark-bg-tertiary",
    buttonText: "text-dark-text-primary",
    search: "bg-dark-bg-secondary",
    searchText: "text-dark-text-primary"
  }
};
const getHeaderThemeClasses = (theme, customColors) => {
  if (theme === "custom" && customColors) {
    return {
      background: customColors.backgroundColor ? `bg-[${customColors.backgroundColor}]` : HEADER_THEMES.default.background,
      text: customColors.textColor ? `text-[${customColors.textColor}]` : HEADER_THEMES.default.text,
      textSecondary: customColors.textSecondaryColor ? `text-[${customColors.textSecondaryColor}]` : HEADER_THEMES.default.textSecondary,
      hover: customColors.hoverColor ? `hover:text-[${customColors.hoverColor}]` : HEADER_THEMES.default.hover,
      active: customColors.activeColor ? `text-[${customColors.activeColor}]` : HEADER_THEMES.default.active,
      border: customColors.borderColor ? `border-[${customColors.borderColor}]` : HEADER_THEMES.default.border,
      logo: customColors.logoColor ? `text-[${customColors.logoColor}]` : HEADER_THEMES.default.logo,
      button: customColors.buttonColor ? `bg-[${customColors.buttonColor}]` : HEADER_THEMES.default.button,
      buttonText: customColors.buttonTextColor ? `text-[${customColors.buttonTextColor}]` : HEADER_THEMES.default.buttonText,
      search: customColors.searchColor ? `bg-[${customColors.searchColor}]` : HEADER_THEMES.default.search,
      searchText: customColors.searchTextColor ? `text-[${customColors.searchTextColor}]` : HEADER_THEMES.default.searchText
    };
  }
  return HEADER_THEMES[theme] || HEADER_THEMES.default;
};
const HeaderContext = createContext(null);
const useHeaderContext = () => {
  const context = useContext(HeaderContext);
  if (!context) {
    throw new Error("Header sub-components must be used within a Header component");
  }
  return context;
};
const HeaderRoot = ({
  variant = "default",
  size: size2 = "md",
  theme = "default",
  customColors,
  sticky = false,
  skipToContent = true,
  skipToContentId = "main-content",
  className,
  children,
  ...htmlProps
}) => {
  const [isMobileMenuOpen, setMobileMenuOpen] = useState(false);
  const themeClasses = getHeaderThemeClasses(theme, customColors);
  const sizeClasses2 = { sm: "h-14", md: "h-16", lg: "h-20" };
  const variantClasses2 = {
    default: `${themeClasses.background} border-b ${themeClasses.border}`,
    website: `${themeClasses.background} border-b ${themeClasses.border}`
  };
  const headerClasses = cn(
    "w-full flex items-center justify-between px-4 sm:px-6 transition-all duration-200 relative",
    sizeClasses2[size2],
    variantClasses2[variant],
    sticky && "sticky top-0 z-50",
    className
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(HeaderContext.Provider, { value: { variant, size: size2, theme, customColors, themeClasses, isMobileMenuOpen, setMobileMenuOpen }, children: [
    skipToContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "a",
      {
        href: `#${skipToContentId}`,
        className: cn("sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 z-50 px-4 py-2 rounded-md font-medium transition-all", themeClasses.button, themeClasses.buttonText),
        onClick: (e2) => {
          e2.preventDefault();
          const element = document.getElementById(skipToContentId);
          if (element) {
            element.focus();
            element.scrollIntoView({ behavior: "smooth" });
          }
        },
        children: "Skip to main content"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: headerClasses, ...htmlProps, children })
  ] });
};
const HeaderLogo = ({
  text,
  href = "#",
  isClickable = true,
  className,
  ...htmlProps
}) => {
  const { theme, themeClasses } = useHeaderContext();
  const hasCustomText = text !== void 0 && text !== null && text !== "";
  const [isDarkMode, setIsDarkMode] = useState(
    () => theme === "dark" || theme === "default" && document.documentElement.classList.contains("dark")
  );
  React__default.useEffect(() => {
    if (theme !== "default") {
      setIsDarkMode(theme === "dark");
      return;
    }
    const checkDarkMode = () => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    };
    checkDarkMode();
    const handleStorageChange = (e2) => {
      if (e2.key === "theme") {
        checkDarkMode();
      }
    };
    window.addEventListener("storage", handleStorageChange);
    const handleThemeChange = () => {
      checkDarkMode();
    };
    window.addEventListener("themeChanged", handleThemeChange);
    return () => {
      window.removeEventListener("storage", handleStorageChange);
      window.removeEventListener("themeChanged", handleThemeChange);
    };
  }, [theme]);
  const logoSrc = React__default.useMemo(() => {
    if (theme !== "default") {
      if (hasCustomText) {
        if (theme === "brand" || theme === "dark") {
          return LOGO_URLS.dark.icon;
        }
        if (theme === "minimal") {
          return LOGO_URLS.grey.light.icon;
        }
        if (theme === "grey") {
          return LOGO_URLS.grey.dark.icon;
        }
      } else {
        if (theme === "brand" || theme === "dark") {
          return LOGO_URLS.dark.full;
        }
        if (theme === "minimal") {
          return LOGO_URLS.grey.light.full;
        }
        if (theme === "grey") {
          return LOGO_URLS.grey.dark.full;
        }
      }
    }
    if (hasCustomText) {
      return isDarkMode ? LOGO_URLS.dark.icon : LOGO_URLS.light.icon;
    } else {
      return isDarkMode ? LOGO_URLS.dark.full : LOGO_URLS.light.full;
    }
  }, [theme, hasCustomText, isDarkMode]);
  const logoElement = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex items-center", hasCustomText ? "gap-3" : "gap-2", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn(
      "flex items-center justify-center",
      hasCustomText ? "h-8 w-8" : "h-8 w-auto"
      // Full logo should be wider
    ), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: logoSrc,
        alt: hasCustomText ? `${text} Logo` : "Acutrack Logo",
        className: cn(
          "object-contain",
          hasCustomText ? "h-8 w-8" : "h-8 w-auto"
          // Full logo should be wider
        )
      },
      logoSrc
    ) }),
    hasCustomText && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("text-xl font-bold", themeClasses.logo), children: text })
  ] });
  return isClickable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      href,
      className: "flex-shrink-0 group hover:opacity-80 transition-opacity",
      "aria-label": hasCustomText ? `${text} Home` : "Acutrack Home",
      ...htmlProps,
      children: logoElement
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: logoElement });
};
const HeaderNavigation = ({ className, children, ...htmlProps }) => {
  const { isMobileMenuOpen, themeClasses } = useHeaderContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: cn("hidden md:flex items-center space-x-8", className), ...htmlProps, children }),
    isMobileMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("absolute top-full left-0 w-full md:hidden border-b z-40", themeClasses.background, themeClasses.border), children: /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "flex flex-col space-y-2 p-4", children }) })
  ] });
};
const HeaderNavItem = ({
  href = "#",
  isActive = false,
  isDisabled = false,
  children,
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useHeaderContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      href,
      className: cn(
        "text-sm font-medium transition-colors",
        isActive ? themeClasses.active : `${themeClasses.text} ${themeClasses.hover}`,
        isDisabled && "opacity-50 cursor-not-allowed",
        className
      ),
      "aria-current": isActive ? "page" : void 0,
      ...htmlProps,
      children
    }
  );
};
const HeaderResponsiveActions = ({ common, desktop, mobile }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
    common,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden md:flex items-center gap-2", children: desktop }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex md:hidden items-center gap-1", children: mobile })
  ] });
};
const HeaderActions = ({
  className,
  children,
  ...htmlProps
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex items-center space-x-2 sm:space-x-4", className), ...htmlProps, children });
};
const HeaderSearch = ({
  placeholder = "Search...",
  variant = "default",
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useHeaderContext();
  const [isExpanded, setIsExpanded] = React__default.useState(false);
  if (variant === "expandable") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("relative", className), ...htmlProps, children: [
      isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            placeholder,
            className: cn("w-48 px-4 py-2 pl-10 text-sm border rounded-lg focus:ring-2 focus:ring-offset-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange", themeClasses.border, themeClasses.search, themeClasses.searchText, themeClasses.hover),
            autoFocus: true
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setIsExpanded(false),
            className: cn("p-2", themeClasses.textSecondary, themeClasses.hover),
            "aria-label": "Close search",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) })
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: () => setIsExpanded(true),
          className: cn("p-2", themeClasses.textSecondary, themeClasses.hover),
          "aria-label": "Open search",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) })
        }
      ),
      isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 left-0 flex items-center pl-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: cn("w-4 h-4", themeClasses.textSecondary), fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) }) })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("relative hidden sm:block", className), ...htmlProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "text",
        placeholder,
        className: cn("w-48 sm:w-64 px-4 py-2 pl-10 text-sm border rounded-lg focus:ring-2 focus:ring-offset-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange", themeClasses.border, themeClasses.search, themeClasses.searchText, themeClasses.hover)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 left-0 flex items-center pl-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: cn("w-4 h-4", themeClasses.textSecondary), fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" }) }) })
  ] });
};
const HeaderNotifications = ({
  count: count2 = 0,
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useHeaderContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      className: cn("relative p-2", themeClasses.textSecondary, themeClasses.hover, className),
      "aria-label": "Notifications",
      ...htmlProps,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" }) }),
        count2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("absolute -top-1 -right-1 h-5 w-5 text-xs rounded-full flex items-center justify-center", themeClasses.button, themeClasses.buttonText), children: count2 })
      ]
    }
  );
};
const HeaderThemeSwitcher = ({ className, ...htmlProps }) => {
  const { themeClasses } = useHeaderContext();
  const [isDark, setIsDark] = React__default.useState(false);
  React__default.useEffect(() => {
    const isDarkMode = document.documentElement.classList.contains("dark");
    setIsDark(isDarkMode);
  }, []);
  const toggleTheme = () => {
    const newTheme = !isDark;
    setIsDark(newTheme);
    if (newTheme) {
      document.documentElement.classList.add("dark");
      localStorage.setItem("theme", "dark");
    } else {
      document.documentElement.classList.remove("dark");
      localStorage.setItem("theme", "light");
    }
    window.dispatchEvent(new CustomEvent("themeChanged"));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: toggleTheme,
      className: cn("p-2", themeClasses.textSecondary, themeClasses.hover, className),
      "aria-label": "Toggle theme",
      ...htmlProps,
      children: isDark ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) })
    }
  );
};
const HeaderUserMenu = ({
  user,
  links,
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useHeaderContext();
  const [isOpen, setIsOpen] = React__default.useState(false);
  const popoverRef = useRef(null);
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (popoverRef.current && !popoverRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
      return () => document.removeEventListener("mousedown", handleClickOutside);
    }
  }, [isOpen]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("relative", className), ...htmlProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: () => setIsOpen(!isOpen),
        className: cn("flex items-center space-x-2 p-2", themeClasses.text, themeClasses.hover),
        "aria-label": "User menu",
        children: [
          user.avatar ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: user.avatar,
              alt: user.name,
              className: "w-8 h-8 rounded-full"
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("w-8 h-8 rounded-full flex items-center justify-center", themeClasses.button), children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("text-sm font-medium", themeClasses.buttonText), children: user.name.charAt(0).toUpperCase() }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("hidden sm:block text-sm font-medium", themeClasses.text), children: user.name }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: cn("w-4 h-4", themeClasses.text), fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })
        ]
      }
    ),
    isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: popoverRef, className: cn("absolute right-0 mt-2 w-auto rounded-md shadow-lg py-1 z-50 border", themeClasses.background, themeClasses.border), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-4 py-3 border-b border-border-color dark:border-dark-border-color", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: cn(themeClasses.text), children: user.userName || user.email }),
        user.role && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: cn(themeClasses.text, "text-sm text-text-secondary dark:text-dark-text-secondary truncate"), children: user.role })
      ] }),
      links.map((link, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "a",
        {
          href: link.href,
          className: cn(
            "flex items-center px-4 py-2 text-sm transition-colors",
            link.color === "danger" ? "text-system-error hover:bg-system-error-dark hover:text-white dark:text-system-error dark:hover:bg-system-error-dark dark:hover:text-white" : cn(themeClasses.text, themeClasses.hover, "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary")
          ),
          children: [
            link.icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: "mr-3", children: link.icon }),
            link.label
          ]
        },
        index2
      ))
    ] })
  ] });
};
const HeaderBreadcrumbs = ({
  items,
  separator = ">",
  className,
  ...htmlProps
}) => {
  const context = useContext(HeaderContext);
  const themeClasses = context?.themeClasses || {
    text: "text-text-primary dark:text-dark-text-primary",
    textSecondary: "text-text-secondary dark:text-dark-text-secondary",
    hover: "hover:text-brand-orange"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { "aria-label": "Breadcrumb", className: cn("flex items-center space-x-2 text-sm", className), ...htmlProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx("ol", { className: "flex items-center space-x-2", children: items.map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "flex items-center", children: [
    index2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("mx-2", themeClasses.textSecondary), "aria-hidden": "true", children: separator }),
    item.href && !item.isActive ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      "a",
      {
        href: item.href,
        className: cn("transition-colors", themeClasses.textSecondary, themeClasses.hover),
        children: item.label
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: cn(
          item.isActive ? cn("font-medium", themeClasses.text) : themeClasses.textSecondary
        ),
        "aria-current": item.isActive ? "page" : void 0,
        children: item.label
      }
    )
  ] }, index2)) }) });
};
const HeaderMobileMenu = ({ className, ...htmlProps }) => {
  const { isMobileMenuOpen, setMobileMenuOpen, themeClasses } = useHeaderContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: () => setMobileMenuOpen((prev) => !prev),
      className: cn("p-2 md:hidden", themeClasses.textSecondary, themeClasses.hover, className),
      "aria-label": "Toggle mobile menu",
      ...htmlProps,
      children: isMobileMenuOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6h16M4 12h16M4 18h16" }) })
    }
  );
};
const Header = Object.assign(HeaderRoot, {
  Logo: HeaderLogo,
  Navigation: HeaderNavigation,
  NavItem: HeaderNavItem,
  Breadcrumbs: HeaderBreadcrumbs,
  ResponsiveActions: HeaderResponsiveActions,
  Actions: HeaderActions,
  // Legacy support
  Search: HeaderSearch,
  Notifications: HeaderNotifications,
  ThemeSwitcher: HeaderThemeSwitcher,
  UserMenu: HeaderUserMenu,
  MobileMenu: HeaderMobileMenu
});
const languageList = {
  EN: {
    English: {
      code: "en",
      displayName: "English",
      flag: "🇺🇸"
    },
    Spanish: {
      code: "es",
      displayName: "Spanish",
      flag: "🇪🇸"
    },
    German: {
      code: "de",
      displayName: "German",
      flag: "🇩🇪"
    },
    Russian: {
      code: "ru",
      displayName: "Russian",
      flag: "🇷🇺"
    },
    Chinese: {
      code: "zh",
      displayName: "Chinese",
      flag: "🇨🇳"
    }
  },
  ES: {
    English: {
      code: "en",
      displayName: "Inglés",
      flag: "🇺🇸"
    },
    Spanish: {
      code: "es",
      displayName: "Español",
      flag: "🇪🇸"
    },
    German: {
      code: "de",
      displayName: "Alemán",
      flag: "🇩🇪"
    },
    Russian: {
      code: "ru",
      displayName: "Ruso",
      flag: "🇷🇺"
    },
    Chinese: {
      code: "zh",
      displayName: "Chino",
      flag: "🇨🇳"
    }
  },
  DE: {
    English: {
      code: "en",
      displayName: "Englisch",
      flag: "🇺🇸"
    },
    Spanish: {
      code: "es",
      displayName: "Spanisch",
      flag: "🇪🇸"
    },
    German: {
      code: "de",
      displayName: "Deutsch",
      flag: "🇩🇪"
    },
    Russian: {
      code: "ru",
      displayName: "Russisch",
      flag: "🇷🇺"
    },
    Chinese: {
      code: "zh",
      displayName: "Chinesisch",
      flag: "🇨🇳"
    }
  },
  RU: {
    English: {
      code: "en",
      displayName: "Английский",
      flag: "🇺🇸"
    },
    Spanish: {
      code: "es",
      displayName: "испанский",
      flag: "🇪🇸"
    },
    German: {
      code: "de",
      displayName: "немецкий",
      flag: "🇩🇪"
    },
    Russian: {
      code: "ru",
      displayName: "русский",
      flag: "🇷🇺"
    },
    Chinese: {
      code: "zh",
      displayName: "китайский",
      flag: "🇨🇳"
    }
  },
  ZH: {
    English: {
      code: "en",
      displayName: "英語",
      flag: "🇺🇸"
    },
    Spanish: {
      code: "es",
      displayName: "西班牙語",
      flag: "🇪🇸"
    },
    German: {
      code: "de",
      displayName: "德文",
      flag: "🇩🇪"
    },
    Russian: {
      code: "ru",
      displayName: "俄文",
      flag: "🇷🇺"
    },
    Chinese: {
      code: "zh",
      displayName: "中文",
      flag: "🇨🇳"
    }
  }
};
function getLanguageList() {
  return {
    Languages: {
      EN: {
        code: "en",
        displayName: "English",
        flag: "🇺🇸"
      },
      ES: {
        code: "es",
        displayName: "Spanish",
        flag: "🇪🇸"
      },
      DE: {
        code: "de",
        displayName: "German",
        flag: "🇩🇪"
      },
      RU: {
        code: "ru",
        displayName: "Russian",
        flag: "🇷🇺"
      },
      ZH: {
        code: "zh",
        displayName: "Chinese",
        flag: "🇨🇳"
      }
    }
  };
}
const LanguageSelector = ({
  language = "EN",
  display = "regular",
  variant,
  showFlags = true,
  onLanguageChange
}) => {
  function retrieveLanguage() {
    return getCurrentLanguage();
  }
  function handleLanguageChange(code) {
    if (onLanguageChange) {
      onLanguageChange(code);
    }
  }
  function getCurrentLanguage() {
    let languages = getLanguageList();
    return languages.Languages[language.toUpperCase()] || getLanguageList().Languages["EN"];
  }
  function getLanguageName(displayName) {
    let lang = displayName || retrieveLanguage().displayName;
    let code = retrieveLanguage().code.toUpperCase();
    if (display === "short") {
      return languageList[code][lang].code.toUpperCase();
    }
    return languageList[code][lang].displayName;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dropdown, { className: "w-auto", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Trigger, { className: `shadow-none ${variant !== "outline" ? "border-0" : ""}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, { className: `dark:text-white`, variant: variant === "none" ? "ghost" : variant, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-auto flex flex-row items-center gap-3 text-sm font-medium", children: [
      showFlags && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flag", children: retrieveLanguage().flag }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden sm:block", children: getLanguageName() }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "expand_more" })
    ] }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Content, { children: Object.values(getLanguageList().Languages).map((lang) => /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Item, { onClick: () => {
      handleLanguageChange(lang.code);
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 dark:text-white", children: [
      showFlags && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flag", children: lang.flag }),
      getLanguageName(lang.displayName),
      retrieveLanguage().code === lang.code && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "check" })
    ] }) }, lang.code)) })
  ] });
};
function getTranslation(key, language = "en", sourceFiles, useFallback = false, fallback, count2, gender) {
  if (key === void 0 || key === null) {
    if (useFallback && fallback !== void 0) {
      return fallback;
    } else {
      return null;
    }
  }
  let formattedKey = key.includes(" ") ? removeSpaces(key) : key;
  let returnString = "";
  sourceFiles?.forEach((translator) => {
    if (translator[language] !== null && translator[language] !== void 0) {
      let languageResource = translator[language];
      let translation = languageResource[formattedKey];
      if (translation !== null && translation !== void 0) {
        let result = checkTranslation(translation, count2, gender);
        returnString = result;
      } else {
        translation = languageResource[formattedKey.toLowerCase()];
        if (translation !== null && translation !== void 0) {
          let result = checkTranslation(translation, count2, gender);
          returnString = result;
        }
      }
    }
  });
  if (returnString === "") {
    if (useFallback && fallback !== null && fallback !== void 0) {
      return fallback;
    } else {
      return key;
    }
  }
  return returnString;
}
function checkTranslation(translation, count2, gender) {
  if (typeof translation === "string") {
    return translation;
  } else {
    let translationObject = translation;
    if ("masculine" in translationObject || "feminine" in translationObject) {
      if (gender !== null && gender !== void 0) {
        let value = translationObject[gender];
        if (value !== null && value !== void 0) {
          if (typeof value === "string") {
            return value;
          } else {
            if (count2 !== null && count2 !== void 0) {
              let countValue = value[count2];
              if (countValue !== null && countValue !== void 0) {
                return countValue;
              } else {
                console.warn("set as count but no count value");
                return "";
              }
            }
          }
        } else {
          console.warn("set as gendered but no gendered value");
          return "";
        }
      }
    } else if ("singular" in translationObject || "plural" in translationObject) {
      if (count2 !== null && count2 !== void 0) {
        let countValue = translationObject[count2];
        if (countValue !== null && countValue !== void 0) {
          return countValue;
        } else {
          console.warn("set as count but no count value");
          return "";
        }
      }
    }
  }
}
function formatString(id2, contextLanguage, translator, values, fallback) {
  const resource = getTranslation(id2, contextLanguage, translator, true, fallback) || fallback;
  if (!resource) return id2;
  return resource.replace(
    /{(\w+)}/g,
    (match2, key) => values.hasOwnProperty(key) ? String(values[key]) : match2
  );
}
function removeSpaces(label) {
  if (label) {
    return label.replace(/ /g, "");
  }
  return label;
}
const Link = ({
  children,
  href,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  // State Props
  isDisabled = false,
  isLoading = false,
  isActive = false,
  isExternal = false,
  // Feature Props
  hasUnderline = false,
  hasHoverEffect = true,
  hasFocusRing = true,
  hasBorder = false,
  isRounded = false,
  hasShadow = false,
  isFullWidth = false,
  hasIcon = false,
  hasTooltip = false,
  // Content Props
  icon,
  tooltipText,
  // Event Handlers
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  ...props
}) => {
  const sizeClasses2 = {
    xs: "text-xs px-2 py-1",
    sm: "text-sm px-3 py-1.5",
    md: "text-sm px-4 py-2",
    lg: "text-base px-5 py-2.5",
    xl: "text-lg px-6 py-3"
  };
  const variantClasses2 = {
    default: "text-primary-600 hover:text-primary-700",
    primary: "text-primary-600 hover:text-primary-700",
    secondary: "text-gray-600 hover:text-gray-700",
    outline: "border border-gray-300 text-gray-700 hover:bg-gray-50",
    ghost: "text-gray-600 hover:bg-gray-100",
    text: "text-current underline"
  };
  const colorClasses2 = {
    primary: "text-primary-600 hover:text-primary-700",
    success: "text-success-600 hover:text-success-700",
    warning: "text-warning-600 hover:text-warning-700",
    danger: "text-danger-600 hover:text-danger-700",
    info: "text-info-600 hover:text-info-700",
    neutral: "text-gray-600 hover:text-gray-700"
  };
  const baseClasses = "inline-flex items-center transition-colors duration-200";
  const disabledClass = isDisabled ? "opacity-50 cursor-not-allowed pointer-events-none" : "cursor-pointer";
  const underlineClass = hasUnderline ? "underline" : "";
  const hoverClass = hasHoverEffect ? "hover:opacity-80" : "";
  const focusClass = hasFocusRing ? "focus:outline-none focus-visible:ring-2 focus-visible:ring-brand-orange focus-visible:ring-offset-2 dark:focus-visible:ring-dark-brand-orange" : "";
  const borderClass = hasBorder ? "border border-border-color dark:border-dark-border-color" : "";
  const roundedClass = isRounded ? "rounded-md" : "";
  const shadowClass = hasShadow ? "shadow-sm" : "";
  const widthClass = isFullWidth ? "w-full justify-center" : "";
  const activeClass = isActive ? "text-primary-600 dark:text-primary-400" : "";
  const loadingClass = isLoading ? "animate-pulse" : "";
  const combinedClasses = [
    baseClasses,
    sizeClasses2[size2],
    variantClasses2[variant],
    colorClasses2[color2],
    disabledClass,
    underlineClass,
    hoverClass,
    focusClass,
    borderClass,
    roundedClass,
    shadowClass,
    widthClass,
    activeClass,
    loadingClass,
    className
  ].filter(Boolean).join(" ");
  const linkContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      href,
      className: combinedClasses,
      style,
      target: isExternal ? "_blank" : void 0,
      rel: isExternal ? "noopener noreferrer" : void 0,
      onClick: !isDisabled ? onClick : void 0,
      onFocus: !isDisabled ? onFocus : void 0,
      onBlur: !isDisabled ? onBlur : void 0,
      onMouseEnter: !isDisabled ? onMouseEnter : void 0,
      onMouseLeave: !isDisabled ? onMouseLeave : void 0,
      ...props,
      children: [
        hasIcon && icon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-2", children: icon }),
        isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Loading..." })
        ] }) : children
      ]
    }
  );
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `group relative ${containerClassName}`, children: [
      linkContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClassName, children: linkContent });
};
const PrimaryLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { ...props, variant: "primary", color: "primary" });
const SecondaryLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { ...props, variant: "secondary", color: "neutral" });
const TextLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { ...props, variant: "text" });
const ButtonLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { ...props, variant: "outline", color: "primary", hasBorder: true, isRounded: true });
const NavLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { ...props, variant: "ghost", color: "neutral", isRounded: true });
const BreadcrumbLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { ...props, size: "sm", variant: "ghost", color: "neutral" });
const SocialLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { ...props, variant: "ghost", color: "neutral" });
const useFocusTrap = (ref, isOpen) => {
  const triggerElementRef = useRef(null);
  useEffect(() => {
    if (isOpen) {
      triggerElementRef.current = document.activeElement;
      const focusableElements = ref.current?.querySelectorAll(
        'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])'
      );
      if (!focusableElements || focusableElements.length === 0) return;
      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];
      setTimeout(() => firstElement.focus(), 100);
      const handleKeyDown = (e2) => {
        if (e2.key !== "Tab") return;
        if (e2.shiftKey) {
          if (document.activeElement === firstElement) {
            e2.preventDefault();
            lastElement.focus();
          }
        } else {
          if (document.activeElement === lastElement) {
            e2.preventDefault();
            firstElement.focus();
          }
        }
      };
      const modalElement = ref.current;
      modalElement?.addEventListener("keydown", handleKeyDown);
      return () => {
        modalElement?.removeEventListener("keydown", handleKeyDown);
        triggerElementRef.current?.focus();
      };
    }
  }, [isOpen, ref]);
};
const ModalContext = createContext(null);
const useModalContext = () => {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error("Modal sub-components must be used within a Modal.Root component.");
  }
  return context;
};
const ModalHeader = ({ children, className = "" }) => {
  const { onClose } = useModalContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-start justify-between p-6 border-b border-border-color dark:border-dark-border-color shrink-0 ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { id: "modal-title", className: "text-xl font-bold font-heading text-text-primary dark:text-dark-text-primary", children }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: onClose,
        "aria-label": "Close modal",
        className: "p-1 -mt-1 -mr-2 rounded-full text-text-secondary dark:text-dark-text-secondary hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary transition-colors",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "close" })
      }
    )
  ] });
};
ModalHeader.displayName = "Modal.Header";
const ModalBody = ({ children, className = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "modal-description", className: `p-6 overflow-y-auto custom-scrollbar flex-1 min-h-0 ${className}`, children });
ModalBody.displayName = "Modal.Body";
const ModalFooter = ({ children, className = "" }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex justify-end items-center gap-4 p-6 bg-bg-tertiary/50 dark:bg-dark-bg-tertiary/20 border-t border-border-color dark:border-dark-border-color shrink-0 ${className}`, children });
ModalFooter.displayName = "Modal.Footer";
const ModalRoot = ({
  isOpen,
  onClose,
  children,
  size: size2 = "md",
  customWidth,
  minWidth,
  maxWidth,
  verticalAlign = "center",
  className = ""
}) => {
  const modalRef = useRef(null);
  const [isMounted, setMounted] = useState(isOpen);
  const containerRef = useRef(null);
  const backdropRef = useRef(null);
  const dragStateRef = useRef({ isDragging: false, startTarget: null });
  useFocusTrap(modalRef, isOpen);
  useEffect(() => {
    if (isOpen) {
      setMounted(true);
    }
  }, [isOpen]);
  useEffect(() => {
    const handleKeyDown = (e2) => {
      if (e2.key === "Escape") {
        onClose();
      }
    };
    if (isOpen) {
      window.addEventListener("keydown", handleKeyDown);
    }
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [isOpen, onClose]);
  useEffect(() => {
    const handleMouseDown = (event) => {
      if (modalRef.current?.contains(event.target)) {
        dragStateRef.current = { isDragging: false, startTarget: event.target };
      } else {
        dragStateRef.current = { isDragging: false, startTarget: null };
      }
    };
    const handleMouseMove = () => {
      if (dragStateRef.current.startTarget !== null) {
        dragStateRef.current.isDragging = true;
      }
    };
    const handleMouseUp = (event) => {
      const clickedOutside = !modalRef.current?.contains(event.target);
      const startedInside = dragStateRef.current.startTarget !== null;
      const wasDragging = dragStateRef.current.isDragging;
      if (clickedOutside && (!startedInside || !wasDragging)) {
        onClose();
      }
      dragStateRef.current = { isDragging: false, startTarget: null };
    };
    if (isOpen) {
      document.addEventListener("mousedown", handleMouseDown);
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      return () => {
        document.removeEventListener("mousedown", handleMouseDown);
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      };
    }
  }, [isOpen, onClose]);
  if (!isMounted) {
    return null;
  }
  const sizeValues = {
    sm: "24rem",
    md: "28rem",
    lg: "32rem",
    xl: "36rem",
    "2xl": "42rem"
  };
  const containerClasses = `fixed inset-0 z-50 flex flex-col justify-start items-center overflow-y-auto p-4 sm:p-6 transition-opacity duration-300 ease-in-out`;
  const backdropClasses = "fixed inset-0 bg-black/60 backdrop-blur-sm";
  const contentClasses = `relative flex flex-col bg-bg-secondary dark:bg-dark-bg-secondary rounded-xl shadow-2xl overflow-hidden border border-black/5 dark:border-white/5 transition-all duration-300 ease-in-out`;
  const modalStyles = {
    // Use min() to respect both viewport and size constraints
    maxWidth: customWidth ? customWidth : `min(${sizeValues[size2]}, calc(100vw - 2rem))`,
    width: customWidth || `min(${sizeValues[size2]}, calc(100vw - 2rem))`,
    maxHeight: "calc(100vh - 2rem)",
    // Auto margins for vertical centering in flex container
    marginTop: verticalAlign === "center" ? "auto" : "4rem",
    marginBottom: "auto"
  };
  if (minWidth) {
    modalStyles.minWidth = minWidth;
  }
  if (maxWidth) {
    modalStyles.maxWidth = maxWidth;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      id: "modal-container",
      ref: containerRef,
      className: `${containerClasses} ${isOpen ? "opacity-100" : "opacity-0"}`,
      onTransitionEnd: () => {
        if (!isOpen) setMounted(false);
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backdropClasses, ref: backdropRef }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            ref: modalRef,
            id: "modal-content",
            className: `${contentClasses} ${className} ${isOpen ? "opacity-100 scale-100" : "opacity-0 scale-95"}`,
            style: modalStyles,
            role: "dialog",
            "aria-modal": "true",
            "aria-labelledby": "modal-title",
            "aria-describedby": "modal-description",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(ModalContext.Provider, { value: { onClose }, children })
          }
        )
      ]
    }
  );
};
ModalRoot.displayName = "Modal.Root";
const Modal = Object.assign(ModalRoot, {
  Header: ModalHeader,
  Body: ModalBody,
  Footer: ModalFooter
});
const MultiSelect = ({
  label,
  id: id2,
  options,
  value,
  onChange,
  placeholder = "Select options...",
  disabled = false,
  required = false,
  error: error2,
  helpText,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  position = "bottom-start",
  labelMode = "top",
  searchable = true,
  showChips = true,
  clearable = false,
  selectAll = false,
  loading = false,
  maxSelections,
  disableCheckboxes = false,
  onSearch,
  onSelect,
  onDeselect,
  className,
  style,
  "aria-label": ariaLabel,
  "aria-describedby": ariaDescribedBy,
  "aria-invalid": ariaInvalid,
  maxDropdownHeight = "15rem",
  itemLineHeight
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [isOpen, setIsOpen] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState(-1);
  const inputRef = useRef(null);
  const inputId = id2 || `multiselect-${Math.random().toString(36).substr(2, 9)}`;
  const sizeClasses2 = {
    xs: "min-h-8 text-xs px-2 py-1",
    sm: "min-h-10 text-sm px-3 py-1.5",
    md: "min-h-12 text-base px-4 py-2",
    lg: "min-h-14 text-lg px-5 py-2.5",
    xl: "min-h-16 text-xl px-6 py-3"
  };
  const variantClasses2 = {
    primary: "bg-bg-secondary dark:bg-dark-bg-secondary text-text-primary dark:text-dark-text-primary",
    secondary: "bg-bg-tertiary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary",
    outline: "bg-transparent border-2 text-text-primary dark:text-dark-text-primary",
    ghost: "bg-transparent text-text-primary dark:text-dark-text-primary",
    filled: "bg-bg-primary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary"
  };
  const focusWithinBorderByColor = {
    primary: "focus-within:border-brand-navy dark:focus-within:border-dark-brand-orange",
    success: "focus-within:border-system-success dark:focus-within:border-system-success",
    warning: "focus-within:border-system-warning-dark dark:focus-within:border-system-warning",
    danger: "focus-within:border-system-error dark:focus-within:border-system-error",
    info: "focus-within:border-system-info dark:focus-within:border-system-info"
  };
  const focusWithinRingByColor = {
    primary: "focus-within:ring-brand-orange dark:focus-within:ring-dark-brand-orange",
    success: "focus-within:ring-system-success dark:focus-within:ring-system-success",
    warning: "focus-within:ring-system-warning dark:focus-within:ring-system-warning",
    danger: "focus-within:ring-system-error dark:focus-within:ring-system-error",
    info: "focus-within:ring-system-info dark:focus-within:ring-system-info"
  };
  const stateClasses = {
    default: "border-border-color dark:border-dark-border-color",
    error: "border-2 border-system-error dark:border-system-error"
  };
  const getStateClass = () => {
    if (error2) return stateClasses.error;
    if (variant === "ghost") return "border border-transparent hover:border-border-color dark:hover:border-dark-border-color";
    return stateClasses.default;
  };
  const getColorClass = () => `${focusWithinBorderByColor[color2]} focus-within:ring-2 focus-within:ring-offset-2 ${focusWithinRingByColor[color2]}`;
  const filteredOptions = useMemo(() => {
    if (!searchTerm) return options;
    return options.filter(
      (option) => option.label.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [options, searchTerm]);
  const availableOptions = useMemo(() => {
    if (disableCheckboxes) {
      return filteredOptions.filter((option) => !value.includes(option.value));
    } else {
      return filteredOptions;
    }
  }, [filteredOptions, value, disableCheckboxes]);
  const selectedOptions = useMemo(() => {
    return options.filter((option) => value.includes(option.value));
  }, [options, value]);
  const handleSelect = useCallback((optionValue) => {
    if (disabled || loading) return;
    const option = options.find((o4) => o4.value === optionValue);
    if (!option) return;
    if (maxSelections && value.length >= maxSelections) return;
    const newValue = [...value, optionValue];
    onChange(newValue);
    onSelect?.(option);
    setSearchTerm("");
  }, [disabled, loading, maxSelections, value, onChange, onSelect, options]);
  const handleDeselect = useCallback((optionValue) => {
    if (disabled || loading) return;
    const option = options.find((o4) => o4.value === optionValue);
    if (!option) return;
    const newValue = value.filter((v2) => v2 !== optionValue);
    onChange(newValue);
    onDeselect?.(option);
  }, [disabled, loading, value, onChange, onDeselect, options]);
  const handleSearchChange = useCallback((e2) => {
    const newSearchTerm = e2.target.value;
    setSearchTerm(newSearchTerm);
    onSearch?.(newSearchTerm);
  }, [onSearch]);
  const handleSelectAll = useCallback(() => {
    if (disabled || loading) return;
    const allValues = availableOptions.map((option) => option.value);
    const newValue = [...value, ...allValues];
    onChange(newValue);
  }, [disabled, loading, availableOptions, value, onChange]);
  const handleClearAll = useCallback(() => {
    if (disabled || loading) return;
    onChange([]);
  }, [disabled, loading, onChange]);
  const isMaxSelectionsReached = maxSelections ? value.length >= maxSelections : false;
  const handleOpenChange = useCallback((open) => {
    setIsOpen(open);
    if (open) {
      const first = availableOptions.findIndex(
        (o4) => !o4.isDisabled && !(maxSelections && value.length >= maxSelections && !value.includes(o4.value))
      );
      setHighlightedIndex(first >= 0 ? first : 0);
    } else {
      setHighlightedIndex(-1);
    }
  }, [availableOptions, maxSelections, value]);
  const handleListKeyDown = useCallback((e2) => {
    const n2 = availableOptions.length;
    if (n2 === 0) return;
    const step = (dir) => {
      let i2 = highlightedIndex + dir;
      while (i2 >= 0 && i2 < n2) {
        const opt2 = availableOptions[i2];
        const isSelected = opt2 && value.includes(opt2.value);
        const isDisabled = disabled || loading || opt2?.isDisabled || isMaxSelectionsReached && !isSelected;
        if (!isDisabled) break;
        i2 += dir;
      }
      if (i2 < 0) i2 = 0;
      if (i2 >= n2) i2 = n2 - 1;
      setHighlightedIndex(i2);
      const opt = availableOptions[i2];
      const id22 = opt ? `multiselect-option-${String(opt.value)}` : void 0;
      if (id22) requestAnimationFrame(() => document.getElementById(id22)?.scrollIntoView({ block: "nearest" }));
    };
    if (e2.key === "ArrowDown") {
      e2.preventDefault();
      step(1);
      return;
    }
    if (e2.key === "ArrowUp") {
      e2.preventDefault();
      step(-1);
      return;
    }
    if (e2.key === "Enter") {
      e2.preventDefault();
      if (highlightedIndex >= 0 && highlightedIndex < n2) {
        const opt = availableOptions[highlightedIndex];
        const isSelected = opt && value.includes(opt.value);
        const isDisabled = disabled || loading || opt.isDisabled || isMaxSelectionsReached && !isSelected;
        if (opt && !isDisabled) {
          if (disableCheckboxes) {
            handleSelect(opt.value);
          } else {
            if (isSelected) handleDeselect(opt.value);
            else handleSelect(opt.value);
          }
        }
      }
      return;
    }
    if (e2.key === "Home") {
      e2.preventDefault();
      setHighlightedIndex(0);
      const opt = availableOptions[0];
      if (opt) requestAnimationFrame(() => document.getElementById(`multiselect-option-${String(opt.value)}`)?.scrollIntoView({ block: "nearest" }));
      return;
    }
    if (e2.key === "End") {
      e2.preventDefault();
      setHighlightedIndex(n2 - 1);
      const opt = availableOptions[n2 - 1];
      if (opt) requestAnimationFrame(() => document.getElementById(`multiselect-option-${String(opt.value)}`)?.scrollIntoView({ block: "nearest" }));
      return;
    }
  }, [availableOptions, highlightedIndex, value, disabled, loading, isMaxSelectionsReached, disableCheckboxes, handleSelect, handleDeselect]);
  const handleTriggerKeyDown = useCallback((e2) => {
    if (!isOpen) return;
    if (e2.key === "ArrowDown" || e2.key === "ArrowUp" || e2.key === "Enter" || e2.key === "Home" || e2.key === "End") {
      handleListKeyDown(e2);
    }
  }, [isOpen, handleListKeyDown]);
  const handleKeyDown = useCallback((e2) => {
    if (e2.key === "Tab" || e2.key === "Shift+Tab") {
      setIsOpen(false);
      return;
    }
    if (e2.key === "Backspace" && searchTerm === "" && value.length > 0) {
      const lastValue = value[value.length - 1];
      handleDeselect(lastValue);
      e2.preventDefault();
      return;
    }
    if (e2.key === "Escape") {
      setIsOpen(false);
      inputRef.current?.blur();
      return;
    }
    if (isOpen && (e2.key === "ArrowDown" || e2.key === "ArrowUp" || e2.key === "Enter" || e2.key === "Home" || e2.key === "End")) {
      handleListKeyDown(e2);
      return;
    }
  }, [searchTerm, value, handleDeselect, isOpen, handleListKeyDown]);
  const visibleChips = selectedOptions;
  const isFloatingLabel = labelMode === "floating";
  const hasValue = value.length > 0;
  const shouldFloatLabel = isFloatingLabel && (hasValue || isOpen);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("w-full relative max-w-full", className), style, children: [
    label && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "label",
      {
        htmlFor: inputId,
        className: "block text-sm font-medium text-text-primary dark:text-dark-text-primary mb-2",
        children: [
          label,
          required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dropdown, { open: isOpen, onOpenChange: handleOpenChange, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Trigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          role: searchable ? void 0 : "combobox",
          "aria-expanded": searchable ? void 0 : isOpen,
          "aria-haspopup": searchable ? void 0 : "listbox",
          "aria-controls": searchable ? void 0 : "multiselect-listbox",
          "aria-activedescendant": searchable ? void 0 : availableOptions[highlightedIndex] ? `multiselect-option-${String(availableOptions[highlightedIndex].value)}` : void 0,
          tabIndex: searchable ? void 0 : 0,
          onKeyDown: searchable ? void 0 : handleTriggerKeyDown,
          className: cn(
            "relative w-full border rounded-md transition-colors duration-200",
            "flex items-center min-h-0",
            sizeClasses2[size2],
            variantClasses2[variant],
            getStateClass(),
            getColorClass(),
            disabled && "opacity-60 cursor-not-allowed",
            loading && "opacity-60 cursor-wait"
          ),
          children: [
            label && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                className: cn(
                  "absolute left-4 transition-all duration-200 pointer-events-none z-10",
                  "text-text-secondary dark:text-dark-text-secondary",
                  shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-1/2 -translate-y-1/2",
                  error2 && "text-system-error-dark"
                ),
                children: [
                  label,
                  required && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
                ]
              }
            ),
            showChips && selectedOptions.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap items-center gap-1 flex-1 min-w-0", children: visibleChips.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: cn(
                  "inline-flex items-center gap-1 px-2 py-1 rounded-md text-xs font-medium border flex-shrink-0 max-w-full",
                  // Error state (highest priority)
                  error2 && "bg-system-error-light dark:bg-system-error-dark-bg text-system-error-dark dark:text-system-error-light-text border-system-error",
                  // Color variants (only when not in error state)
                  !error2 && color2 === "primary" && "bg-brand-orange/10 dark:bg-dark-brand-orange/20 text-brand-navy dark:text-dark-text-primary border-brand-orange/20 dark:border-dark-brand-orange/20",
                  !error2 && color2 === "success" && "bg-system-success-light dark:bg-system-success-dark-bg text-system-success-dark dark:text-system-success-light-text border-system-success",
                  !error2 && color2 === "warning" && "bg-system-warning-light dark:bg-system-warning-dark-bg text-system-warning-dark dark:text-system-warning-light-text border-system-warning-border dark:border-system-warning",
                  !error2 && color2 === "danger" && "bg-system-error-light dark:bg-system-error-dark-bg text-system-error-dark dark:text-system-error-light-text border-system-error",
                  !error2 && color2 === "info" && "bg-system-info-light dark:bg-system-info-dark-bg text-system-info-dark dark:text-system-info-light-text border-system-info"
                ),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate max-w-20", children: option.label }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      onClick: (e2) => {
                        e2.stopPropagation();
                        handleDeselect(option.value);
                      },
                      className: "ml-1 hover:bg-black/10 dark:hover:bg-white/10 rounded-full p-0.5 transition-colors",
                      disabled: disabled || loading,
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xs", children: "close" })
                    }
                  )
                ]
              },
              option.value
            )) }),
            searchable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                ref: inputRef,
                id: inputId,
                type: "text",
                value: searchTerm,
                onChange: handleSearchChange,
                onKeyDown: handleKeyDown,
                placeholder: isFloatingLabel ? void 0 : value.length === 0 ? placeholder : "",
                className: "flex-1 bg-transparent border-0 outline-none placeholder:text-text-secondary dark:placeholder:text-dark-text-secondary min-w-0",
                disabled: disabled || loading,
                "aria-label": ariaLabel || label,
                "aria-describedby": ariaDescribedBy,
                "aria-invalid": ariaInvalid || !!error2,
                "aria-expanded": isOpen,
                "aria-controls": "multiselect-listbox",
                "aria-activedescendant": availableOptions[highlightedIndex] ? `multiselect-option-${String(availableOptions[highlightedIndex].value)}` : void 0
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 flex items-center min-w-0", children: value.length === 0 && !isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-text-secondary dark:text-dark-text-secondary text-sm", children: placeholder }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 flex-shrink-0 pr-1", children: [
              clearable && value.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: (e2) => {
                    e2.stopPropagation();
                    handleClearAll();
                  },
                  className: "p-1 hover:bg-black/10 dark:hover:bg-white/10 rounded-full transition-colors",
                  disabled: disabled || loading,
                  "aria-label": "Clear all selections",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "close" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Icon,
                {
                  size: "sm",
                  className: cn(
                    "transition-transform duration-200",
                    isOpen && "rotate-180"
                  ),
                  children: "keyboard_arrow_down"
                }
              ) })
            ] })
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Dropdown.Content,
        {
          position,
          fullWidth: true,
          maxHeight: maxDropdownHeight,
          itemLineHeight,
          className: "z-50",
          style: { position: "absolute", zIndex: 50 },
          children: [
            (selectAll || clearable) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-3 py-2 border-b border-border-color dark:border-dark-border-color flex gap-2", children: [
              selectAll && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: handleSelectAll,
                  className: "text-xs text-brand-orange dark:text-dark-brand-orange hover:underline",
                  disabled: disabled || loading || availableOptions.length === 0,
                  children: "Select All"
                }
              ),
              clearable && value.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: handleClearAll,
                  className: "text-xs text-system-error hover:underline",
                  disabled: disabled || loading,
                  children: "Clear All"
                }
              )
            ] }),
            availableOptions.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                id: "multiselect-listbox",
                role: "listbox",
                "aria-multiselectable": true,
                tabIndex: -1,
                "aria-activedescendant": availableOptions[highlightedIndex] ? `multiselect-option-${String(availableOptions[highlightedIndex].value)}` : void 0,
                children: availableOptions.map((option, index2) => {
                  const isSelected = value.includes(option.value);
                  const isDisabled = disabled || loading || isMaxSelectionsReached && !isSelected;
                  const isHighlighted = highlightedIndex === index2;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      id: `multiselect-option-${String(option.value)}`,
                      role: "option",
                      "aria-selected": isSelected,
                      tabIndex: -1,
                      className: cn(
                        `px-3 text-sm flex gap-2 items-center`,
                        !isDisabled && "cursor-pointer hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
                        isDisabled && "opacity-50 cursor-not-allowed",
                        isHighlighted && "bg-bg-tertiary dark:bg-dark-bg-tertiary"
                      ),
                      style: itemLineHeight !== void 0 ? {
                        paddingTop: typeof itemLineHeight === "string" ? parseInt(itemLineHeight) < 20 ? "0.25rem" : "0.375rem" : itemLineHeight < 1.5 ? "0.25rem" : "0.375rem",
                        paddingBottom: typeof itemLineHeight === "string" ? parseInt(itemLineHeight) < 20 ? "0.25rem" : "0.375rem" : itemLineHeight < 1.5 ? "0.25rem" : "0.375rem"
                      } : {
                        paddingTop: "0.5rem",
                        paddingBottom: "0.5rem"
                      },
                      onClick: (e2) => {
                        e2.stopPropagation();
                        if (!isDisabled) {
                          if (disableCheckboxes) {
                            handleSelect(option.value);
                          } else {
                            if (isSelected) {
                              handleDeselect(option.value);
                            } else {
                              handleSelect(option.value);
                            }
                          }
                        }
                      },
                      children: [
                        !disableCheckboxes && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn(
                          "w-4 h-4 rounded border-2 flex items-center justify-center transition-all duration-200 flex-shrink-0",
                          // Color-based styling
                          !error2 && color2 === "primary" && "border-brand-orange",
                          !error2 && color2 === "success" && "border-system-success",
                          !error2 && color2 === "warning" && "border-system-warning-border dark:border-system-warning",
                          !error2 && color2 === "danger" && "border-system-error",
                          !error2 && color2 === "info" && "border-system-info",
                          // Error state
                          error2 && "border-system-error",
                          // Disabled state
                          isDisabled && "opacity-50",
                          // Selected state
                          isSelected && !error2 && color2 === "primary" && "bg-brand-orange border-brand-orange",
                          isSelected && !error2 && color2 === "success" && "bg-system-success border-system-success",
                          isSelected && !error2 && color2 === "warning" && "bg-system-warning-border/30 dark:bg-system-warning border-system-warning-border dark:border-system-warning",
                          isSelected && !error2 && color2 === "danger" && "bg-system-error border-system-error",
                          isSelected && !error2 && color2 === "info" && "bg-system-info border-system-info",
                          isSelected && error2 && "bg-system-error border-system-error"
                        ), children: isSelected && /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Icon,
                          {
                            size: "xs",
                            className: cn(
                              "text-white",
                              // Color-based text styling
                              !error2 && color2 === "primary" && "text-white",
                              !error2 && color2 === "success" && "text-white",
                              !error2 && color2 === "warning" && "text-system-warning-dark dark:text-white",
                              !error2 && color2 === "danger" && "text-white",
                              !error2 && color2 === "info" && "text-white",
                              error2 && "text-white"
                            ),
                            children: "check"
                          }
                        ) }),
                        option.icon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: option.icon }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "div",
                            {
                              className: cn(
                                "truncate",
                                // Simple styling when checkboxes are hidden (old logic)
                                disableCheckboxes && "text-text-primary dark:text-dark-text-primary",
                                // Default styling when checkboxes are visible
                                !disableCheckboxes && isSelected && "font-medium text-text-primary dark:text-dark-text-primary",
                                !disableCheckboxes && !isSelected && "text-text-secondary dark:text-dark-text-secondary"
                              ),
                              style: itemLineHeight !== void 0 ? {
                                lineHeight: typeof itemLineHeight === "string" ? itemLineHeight : itemLineHeight < 10 && itemLineHeight > 0.1 ? itemLineHeight : `${itemLineHeight}px`
                              } : void 0,
                              children: option.label
                            }
                          ),
                          option.description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-text-secondary dark:text-dark-text-secondary mt-1 truncate", children: option.description })
                        ] })
                      ]
                    },
                    option.value
                  );
                })
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-2 text-sm text-text-secondary dark:text-dark-text-secondary", children: searchTerm ? "No options found" : "No options available" }),
            isMaxSelectionsReached && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-3 py-2 text-xs text-system-warning-dark dark:text-system-warning-light-text bg-system-warning-light/80 dark:bg-system-warning-dark-bg/40", children: [
              "Maximum ",
              maxSelections,
              " selections allowed"
            ] })
          ]
        }
      )
    ] }),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-system-error", role: "alert", children: error2 }),
    helpText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm text-text-secondary dark:text-dark-text-secondary", children: helpText })
  ] });
};
const NumberInput = ({
  label,
  placeholder = "Enter number",
  value = 0,
  onChange,
  min: min2 = 0,
  max: max2 = 100,
  step = 1,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  isDisabled = false,
  isLoading = false,
  isFullWidth = false,
  width,
  showControls = true,
  controlsPosition = "right",
  controlType = "plus-minus",
  hasBackground = true,
  hasBorder = true,
  hasShadow = false,
  hasFocusRing = true,
  radius = "md",
  align = "left",
  labelMode = "top",
  error: error2,
  helpText,
  className = "",
  minWidth,
  maxWidth,
  id: id2,
  ariaLabel,
  ariaDescribedBy,
  ariaInvalid,
  leftIcon,
  rightIcon,
  style
}) => {
  const [internalValue, setInternalValue] = useState(value);
  const [isFocused, setIsFocused] = useState(false);
  const currentValue = value !== void 0 ? value : internalValue;
  const handleValueChange = useCallback((newValue) => {
    const clampedValue = Math.min(Math.max(newValue, min2), max2);
    if (value === void 0) {
      setInternalValue(clampedValue);
    }
    onChange?.(clampedValue);
  }, [value, onChange, min2, max2]);
  const handleIncrement = useCallback(() => {
    if (!isDisabled && !isLoading) {
      handleValueChange(currentValue + step);
    }
  }, [currentValue, step, isDisabled, isLoading, handleValueChange]);
  const handleDecrement = useCallback(() => {
    if (!isDisabled && !isLoading) {
      handleValueChange(currentValue - step);
    }
  }, [currentValue, step, isDisabled, isLoading, handleValueChange]);
  const handleInputChange = useCallback((e2) => {
    const inputValue = e2.target.value;
    if (inputValue === "") {
      if (value === void 0) {
        setInternalValue(0);
      }
      onChange?.(0);
      return;
    }
    const numValue = parseFloat(inputValue);
    if (!isNaN(numValue)) {
      handleValueChange(numValue);
    }
  }, [value, onChange, handleValueChange]);
  const handleKeyDown = useCallback((e2) => {
    if (e2.key === "ArrowUp") {
      e2.preventDefault();
      handleIncrement();
    } else if (e2.key === "ArrowDown") {
      e2.preventDefault();
      handleDecrement();
    }
  }, [handleIncrement, handleDecrement]);
  const sizeClasses2 = {
    xs: "h-8 text-xs px-2",
    sm: "h-10 text-sm px-3",
    md: "h-12 text-base px-4",
    lg: "h-14 text-lg px-5",
    xl: "h-16 text-xl px-6"
  };
  const variantClasses2 = {
    primary: "bg-bg-secondary dark:bg-dark-bg-secondary text-text-primary dark:text-dark-text-primary",
    secondary: "bg-bg-tertiary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary",
    outline: "bg-transparent border-2 text-text-primary dark:text-dark-text-primary",
    ghost: "bg-transparent text-text-primary dark:text-dark-text-primary",
    filled: "bg-bg-primary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary"
  };
  const focusBorderByColor = {
    primary: "focus:border-brand-navy dark:focus:border-dark-brand-orange",
    success: "focus:border-system-success dark:focus:border-system-success",
    warning: "focus:border-system-warning-dark dark:focus:border-system-warning",
    danger: "focus:border-system-error dark:focus:border-system-error",
    info: "focus:border-system-info dark:focus:border-system-info"
  };
  const defaultBorderClass = hasBorder ? "border border-border-color dark:border-dark-border-color" : "border-0";
  const errorBorderClass = "border-2 border-system-error dark:border-system-error focus:border-system-error dark:focus:border-system-error";
  const ghostBorderClass = "border border-transparent hover:border-border-color dark:hover:border-dark-border-color";
  const isFloatingLabel = labelMode === "floating";
  const hasValue = currentValue !== void 0 && currentValue !== null && currentValue !== 0;
  const shouldFloatLabel = isFloatingLabel && (hasValue || isFocused);
  const baseClasses = `focus:outline-none text-left flex items-center justify-between ${sizeClasses2[size2]}${isFloatingLabel ? " relative" : ""}`;
  const backgroundClasses = hasBackground ? variantClasses2[variant] : "bg-transparent";
  const borderClasses = hasBorder ? error2 ? errorBorderClass : variant === "ghost" ? `${ghostBorderClass} ${focusBorderByColor[color2]}` : `${defaultBorderClass} ${focusBorderByColor[color2]}` : "border-0";
  const getRadiusClass2 = () => {
    switch (radius) {
      case "none":
        return "rounded-none";
      case "sm":
        return "rounded-sm";
      case "md":
        return "rounded";
      case "lg":
        return "rounded-lg";
      case "xl":
        return "rounded-xl";
      case "full":
        return "rounded-full";
      default:
        return "rounded";
    }
  };
  const roundedClasses = getRadiusClass2();
  const shadowClasses = hasShadow ? "shadow-md" : "";
  const focusRingByColor = {
    primary: "focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    success: "focus:ring-system-success dark:focus:ring-system-success",
    warning: "focus:ring-system-warning dark:focus:ring-system-warning",
    danger: "focus:ring-system-error dark:focus:ring-system-error",
    info: "focus:ring-system-info dark:focus:ring-system-info"
  };
  const focusClasses = hasFocusRing ? `focus:ring-2 focus:ring-offset-0 ${focusRingByColor[color2]}` : "";
  const getWidthClass = () => {
    if (isFullWidth) return "w-full";
    switch (width) {
      case "sm":
        return "w-sm";
      case "md":
        return "w-md";
      case "lg":
        return "w-lg";
      case "full":
        return "w-full";
      case "auto":
        return "w-auto";
      case "none":
        return "w-full";
      // 'none' behaves like default (full width)
      default:
        return "w-full";
    }
  };
  const getMinWidthClass = () => {
    if (minWidth) return "";
    return "min-w-24";
  };
  const getMaxWidthClass = () => {
    if (maxWidth) return "";
    return "max-w-full";
  };
  const widthClass = getWidthClass();
  const disabledClasses = isDisabled || isLoading ? "opacity-60 cursor-not-allowed" : "cursor-text";
  const loadingClasses = isLoading ? "animate-pulse" : "";
  const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
  const combinedClasses = cn(
    baseClasses,
    widthClass,
    getMinWidthClass(),
    getMaxWidthClass(),
    backgroundClasses,
    borderClasses,
    roundedClasses,
    shadowClasses,
    focusClasses,
    disabledClasses,
    loadingClasses,
    alignmentClass,
    className
  );
  const customWidthStyles = {
    ...minWidth && { minWidth },
    ...maxWidth && { maxWidth }
  };
  const controlButtonClasses = cn(
    "p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors",
    "disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent"
  );
  const renderControls = () => {
    if (!showControls) return null;
    const getControlIcons = () => {
      if (controlType === "arrows") {
        return {
          decrement: "keyboard_arrow_down",
          increment: "keyboard_arrow_up"
        };
      } else {
        return {
          decrement: "remove",
          increment: "add"
        };
      }
    };
    const icons = getControlIcons();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: handleDecrement,
          disabled: isDisabled || isLoading || currentValue <= min2,
          className: controlButtonClasses,
          "aria-label": "Decrease value",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: icons.decrement })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: handleIncrement,
          disabled: isDisabled || isLoading || currentValue >= max2,
          className: controlButtonClasses,
          "aria-label": "Increase value",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: icons.increment })
        }
      )
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full", style, children: [
    label && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "label",
      {
        htmlFor: id2,
        className: "block text-sm font-medium text-text-primary dark:text-dark-text-primary mb-2",
        children: label
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      label && isFloatingLabel && controlType === "stepper" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: [
            "absolute left-4 transition-all duration-200 pointer-events-none z-10",
            "text-text-secondary dark:text-dark-text-secondary",
            shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-1/2 -translate-y-1/2",
            error2 && "text-system-error-dark"
          ].filter(Boolean).join(" "),
          children: label
        }
      ),
      controlType === "stepper" ? (
        // Stepper layout: (-) | value | (+)
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: cn(combinedClasses, "p-0 overflow-hidden flex items-center"),
            style: customWidthStyles,
            children: [
              leftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center px-3 text-text-secondary dark:text-dark-text-secondary", children: leftIcon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: handleDecrement,
                  disabled: isDisabled || isLoading || currentValue <= min2,
                  className: cn(
                    "h-full px-3 flex items-center justify-center",
                    "border-r border-gray-300 dark:border-gray-600",
                    "hover:bg-gray-100 dark:hover:bg-gray-800",
                    "disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent",
                    "transition-colors"
                  ),
                  "aria-label": "Decrease value",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "remove" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  id: id2,
                  type: "number",
                  value: currentValue,
                  onChange: handleInputChange,
                  onKeyDown: handleKeyDown,
                  onFocus: () => setIsFocused(true),
                  onBlur: () => setIsFocused(false),
                  placeholder: isFloatingLabel ? void 0 : placeholder,
                  min: min2,
                  max: max2,
                  step,
                  disabled: isDisabled || isLoading,
                  className: cn(
                    "flex-1 bg-transparent border-0 outline-none px-3",
                    "text-text-primary dark:text-dark-text-primary",
                    "placeholder:text-text-secondary dark:placeholder:text-dark-text-secondary",
                    "appearance-none",
                    // Remove browser default styling
                    "[&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none",
                    // Remove webkit spinners
                    "[&::-moz-appearance:textfield]",
                    // Remove Firefox spinners
                    "text-center"
                    // Center align for stepper variant
                  ),
                  style: {
                    MozAppearance: "textfield"
                    // Remove Firefox spinners
                  },
                  "aria-label": ariaLabel,
                  "aria-describedby": ariaDescribedBy,
                  "aria-invalid": ariaInvalid
                }
              ),
              rightIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center px-3 text-text-secondary dark:text-dark-text-secondary", children: rightIcon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: handleIncrement,
                  disabled: isDisabled || isLoading || currentValue >= max2,
                  className: cn(
                    "h-full px-3 flex items-center justify-center",
                    "hover:bg-gray-100 dark:hover:bg-gray-800",
                    "disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent",
                    "transition-colors"
                  ),
                  "aria-label": "Increase value",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "add" })
                }
              )
            ]
          }
        )
      ) : (
        // Regular layout
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: combinedClasses,
            style: customWidthStyles,
            children: [
              label && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: [
                    "absolute left-4 transition-all duration-200 pointer-events-none z-10",
                    "text-text-secondary dark:text-dark-text-secondary",
                    shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-1/2 -translate-y-1/2",
                    error2 && "text-system-error-dark"
                  ].filter(Boolean).join(" "),
                  children: label
                }
              ),
              controlsPosition === "left" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) : renderControls() }),
              leftIcon && controlsPosition !== "left" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center text-text-secondary dark:text-dark-text-secondary", children: leftIcon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  id: id2,
                  type: "number",
                  value: currentValue,
                  onChange: handleInputChange,
                  onKeyDown: handleKeyDown,
                  onFocus: () => setIsFocused(true),
                  onBlur: () => setIsFocused(false),
                  placeholder: isFloatingLabel ? void 0 : placeholder,
                  min: min2,
                  max: max2,
                  step,
                  disabled: isDisabled || isLoading,
                  className: cn(
                    "flex-1 bg-transparent border-0 outline-none",
                    "text-text-primary dark:text-dark-text-primary",
                    "placeholder:text-text-secondary dark:placeholder:text-dark-text-secondary",
                    "appearance-none",
                    // Remove browser default styling
                    "[&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none",
                    // Remove webkit spinners
                    "[&::-moz-appearance:textfield]",
                    // Remove Firefox spinners
                    alignmentClass
                  ),
                  style: {
                    MozAppearance: "textfield"
                    // Remove Firefox spinners
                  },
                  "aria-label": ariaLabel,
                  "aria-describedby": ariaDescribedBy,
                  "aria-invalid": ariaInvalid
                }
              ),
              rightIcon && controlsPosition !== "right" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center text-text-secondary dark:text-dark-text-secondary", children: rightIcon }),
              controlsPosition === "right" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) : renderControls() })
            ]
          }
        )
      )
    ] }),
    (error2 || helpText) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2", children: [
      error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", role: "alert", children: error2 }),
      helpText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helpText })
    ] })
  ] });
};
const OTPInput = ({
  id: id2,
  label,
  value,
  onChange,
  length = 6,
  placeholder = "0",
  isDisabled = false,
  error: error2,
  className,
  inputClassName,
  labelClassName,
  isRequired = false,
  isLoading = false,
  isFullWidth = false,
  width = "auto",
  isSuccess = false,
  isWarning = false,
  hasBackground = true,
  hasBorder = true,
  hasFocusRing = true,
  hasRoundedCorners = true,
  hasShadow = false,
  showLabel = true,
  showHelperText = true,
  showErrorText = true,
  showRequiredIndicator = true,
  centerHelperText = true,
  centerLabel = true,
  isReadOnly = false,
  hasSpellCheck = false,
  helperText,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  radius = "md",
  autoFocus = true,
  allowPaste = true,
  showResendButton = false,
  resendButtonText = "Resend OTP",
  onResend,
  resendCooldown = 30,
  showTimer = false,
  timerDuration = 300,
  onTimerExpire,
  maskInput = false,
  showClearButton = false,
  onClear,
  showValidation = true,
  validateOTP,
  showSuccessAnimation = true,
  containerProps,
  inputProps
}) => {
  const [resendCooldownTime, setResendCooldownTime] = useState(0);
  const [timerTime, setTimerTime] = useState(timerDuration);
  const [isAnimating, setIsAnimating] = useState(false);
  const inputRefs = useRef([]);
  useEffect(() => {
    inputRefs.current = inputRefs.current.slice(0, length);
  }, [length]);
  useEffect(() => {
    if (autoFocus && inputRefs.current[0]) {
      inputRefs.current[0].focus();
    }
  }, [autoFocus]);
  useEffect(() => {
    if (showTimer && timerTime > 0) {
      const timer = setTimeout(() => {
        setTimerTime((prev) => prev - 1);
      }, 1e3);
      return () => clearTimeout(timer);
    } else if (showTimer && timerTime === 0) {
      onTimerExpire?.();
    }
  }, [showTimer, timerTime, onTimerExpire]);
  useEffect(() => {
    if (resendCooldownTime > 0) {
      const timer = setTimeout(() => {
        setResendCooldownTime((prev) => prev - 1);
      }, 1e3);
      return () => clearTimeout(timer);
    }
  }, [resendCooldownTime]);
  const handleInputChange = useCallback((index2, inputValue) => {
    const digit = inputValue.slice(-1);
    if (!/^\d$/.test(digit) && digit !== "") return;
    const newValue = value.split("");
    newValue[index2] = digit;
    const updatedValue = newValue.join("").slice(0, length);
    onChange(updatedValue);
    if (digit && index2 < length - 1) {
      inputRefs.current[index2 + 1]?.focus();
    }
    if (showValidation && validateOTP) {
      const validation = validateOTP(updatedValue);
      if (validation.isValid && showSuccessAnimation) {
        setIsAnimating(true);
        setTimeout(() => setIsAnimating(false), 1e3);
      }
    }
  }, [value, onChange, length, showValidation, validateOTP, showSuccessAnimation]);
  const handleKeyDown = useCallback((index2, e2) => {
    if (e2.key === "Backspace") {
      if (!value[index2] && index2 > 0) {
        inputRefs.current[index2 - 1]?.focus();
      } else {
        const newValue = value.split("");
        newValue[index2] = "";
        onChange(newValue.join(""));
      }
    } else if (e2.key === "ArrowLeft" && index2 > 0) {
      inputRefs.current[index2 - 1]?.focus();
    } else if (e2.key === "ArrowRight" && index2 < length - 1) {
      inputRefs.current[index2 + 1]?.focus();
    }
  }, [value, onChange, length]);
  const handlePaste = useCallback((e2) => {
    if (!allowPaste) return;
    e2.preventDefault();
    const pastedData = e2.clipboardData.getData("text").replace(/\D/g, "").slice(0, length);
    if (pastedData.length > 0) {
      onChange(pastedData);
      const nextIndex = Math.min(pastedData.length, length - 1);
      inputRefs.current[nextIndex]?.focus();
    }
  }, [allowPaste, onChange, length]);
  const handleResend = useCallback(() => {
    if (resendCooldownTime > 0) return;
    setResendCooldownTime(resendCooldown);
    onResend?.();
  }, [resendCooldownTime, resendCooldown, onResend]);
  const handleClear = useCallback(() => {
    onChange("");
    inputRefs.current[0]?.focus();
    onClear?.();
  }, [onChange, onClear]);
  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  };
  const getSizeClasses2 = () => {
    const sizeMap2 = {
      sm: {
        container: "gap-2",
        input: "w-10 h-10 text-sm",
        label: "text-sm",
        helper: "text-xs"
      },
      md: {
        container: "gap-3",
        input: "w-12 h-12 text-base",
        label: "text-sm",
        helper: "text-sm"
      },
      lg: {
        container: "gap-4",
        input: "w-14 h-14 text-lg",
        label: "text-base",
        helper: "text-sm"
      }
    };
    return sizeMap2[size2];
  };
  const getVariantClasses = () => {
    const variantMap = {
      primary: "border-border-color dark:border-dark-border-color focus:border-brand-orange dark:focus:border-dark-brand-orange",
      secondary: "border-border-color dark:border-dark-border-color focus:border-text-primary dark:focus:border-dark-text-primary",
      outline: "border-2 border-border-color dark:border-dark-border-color focus:border-brand-orange dark:focus:border-dark-brand-orange",
      ghost: "border-transparent focus:border-brand-orange dark:focus:border-dark-brand-orange",
      filled: "border-transparent bg-bg-secondary dark:bg-dark-bg-secondary focus:border-brand-orange dark:focus:border-dark-brand-orange"
    };
    return variantMap[variant];
  };
  const getColorClasses2 = () => {
    if (isSuccess) return "text-green-700 dark:text-green-400";
    if (isWarning) return "text-system-warning";
    if (error2) return "text-system-error";
    const colorMap = {
      primary: "text-text-primary dark:text-dark-text-primary",
      success: "text-system-success",
      warning: "text-system-warning",
      danger: "text-system-error",
      info: "text-system-info"
    };
    return colorMap[color2];
  };
  const getStateClasses = () => {
    if (isSuccess) return "border-system-success bg-system-success-light dark:bg-system-success/20 focus:border-system-success focus:ring-system-success/20";
    if (isWarning) return "border-system-warning bg-system-warning-light dark:bg-system-warning/20 focus:border-system-warning focus:ring-system-warning/20";
    if (error2) return "border-system-error bg-system-error-light dark:bg-system-error/20 focus:border-system-error focus:ring-system-error/20";
    return "";
  };
  const sizeClasses2 = getSizeClasses2();
  const variantClasses2 = getVariantClasses();
  const colorClasses2 = getColorClasses2();
  const stateClasses = getStateClasses();
  const widthClass = isFullWidth ? "w-full" : {
    sm: "w-auto",
    md: "w-auto",
    lg: "w-auto",
    full: "w-full",
    auto: "w-auto",
    none: "w-0"
  }[width];
  const radiusClass = {
    none: "rounded-none",
    sm: "rounded-sm",
    md: "rounded-md",
    lg: "rounded-lg",
    xl: "rounded-xl",
    full: "rounded-full"
  }[radius];
  const inputClasses = cn(
    "otp-input font-mono text-center border transition-all duration-200 ease-in-out",
    "focus:outline-none focus:ring-2 focus:ring-brand-orange/20 dark:focus:ring-dark-brand-orange/20",
    sizeClasses2.input,
    variantClasses2,
    colorClasses2,
    stateClasses,
    radiusClass,
    hasBackground ? "bg-bg-primary dark:bg-dark-bg-primary" : "bg-transparent",
    hasBorder ? "" : "border-transparent",
    hasFocusRing ? "" : "focus:ring-0",
    hasRoundedCorners ? "" : "rounded-none",
    hasShadow ? "shadow-sm" : "",
    isDisabled ? "opacity-50 cursor-not-allowed" : "cursor-text",
    isReadOnly ? "cursor-default" : "",
    isLoading ? "opacity-75" : "",
    isAnimating ? "animate-pulse" : "",
    inputClassName
  );
  const containerClasses = cn(
    "otp-input-container flex flex-col",
    sizeClasses2.container,
    widthClass,
    className
  );
  const labelClasses = cn(
    "block font-semibold text-text-primary dark:text-dark-text-primary mb-2",
    sizeClasses2.label,
    centerLabel ? "text-center" : "",
    labelClassName
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ...containerProps, className: containerClasses, children: [
    showLabel && label && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: labelClasses, children: [
      label,
      isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-2", children: [
      Array.from({ length }, (_2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: (el) => {
            inputRefs.current[index2] = el;
          },
          id: `${id2}-${index2}`,
          type: maskInput ? "password" : "text",
          inputMode: "numeric",
          pattern: "[0-9]*",
          maxLength: 1,
          value: value[index2] || "",
          onChange: (e2) => handleInputChange(index2, e2.target.value),
          onKeyDown: (e2) => handleKeyDown(index2, e2),
          onPaste: handlePaste,
          placeholder,
          disabled: isDisabled || isLoading,
          readOnly: isReadOnly,
          spellCheck: hasSpellCheck,
          className: inputClasses,
          ...inputProps
        },
        index2
      )),
      showClearButton && value && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: handleClear,
          disabled: isDisabled || isLoading,
          className: "ml-2 p-1 text-text-secondary hover:text-text-primary dark:text-dark-text-secondary dark:hover:text-dark-text-primary transition-colors",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-4 h-4", children: "clear" })
        }
      )
    ] }),
    showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${sizeClasses2.helper} text-text-secondary dark:text-dark-text-secondary mt-2 ${centerHelperText ? "text-center" : ""}`, children: helperText }),
    showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${sizeClasses2.helper} text-system-error mt-2`, children: error2 }),
    showResendButton && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-3 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        type: "button",
        onClick: handleResend,
        disabled: resendCooldownTime > 0 || isDisabled || isLoading,
        className: "text-brand-orange hover:text-brand-orange/80 font-medium text-sm disabled:opacity-50 disabled:cursor-not-allowed",
        children: resendCooldownTime > 0 ? `Resend in ${resendCooldownTime}s` : resendButtonText
      }
    ) }),
    showTimer && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${sizeClasses2.helper} text-text-secondary dark:text-dark-text-secondary`, children: timerTime > 0 ? `Expires in ${formatTime(timerTime)}` : "OTP expired" }) })
  ] });
};
const Pagination = ({
  currentPage,
  totalPages,
  onPageChange,
  size: size2 = "sm",
  variant = "secondary",
  alignment = "center",
  hasNavigationButtons = true,
  hasPageNumbers = true,
  hasEllipsis = true,
  hasFirstLastButtons = false,
  hasPageInfo = false,
  hasItemsPerPageSelector = false,
  isDisabled = false,
  isLoading = false,
  className = "",
  style,
  hasBackground = false,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  isFullWidth = false,
  width,
  minWidth,
  maxWidth,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  hasHoverEffect = true,
  hasFocusEffect = true,
  hasActiveEffect = false,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  hasLoadingText = false,
  loadingText = "Loading...",
  hasSuccessText = false,
  successText = "Success!",
  hasWarningText = false,
  warningText = "Warning!",
  hasErrorText = false,
  errorText = "Error!",
  hasInfoText = false,
  infoText = "Info",
  hasPadding = false,
  hasMargin = false,
  isCentered = false,
  isResponsive = true,
  hasContainer = false,
  hasMaxWidth = false,
  hasMinWidth = false,
  hasFixedHeight = false,
  hasFixedWidth = false,
  hasScrollableOverflow = false,
  hasHiddenOverflow = false,
  hasVisibleOverflow = false,
  hasClipOverflow = false,
  hasScrollOverflow = false,
  hasAutoOverflow = false,
  hasInitialOverflow = false,
  hasInheritOverflow = false,
  hasUnsetOverflow = false,
  hasRevertOverflow = false,
  hasRevertLayerOverflow = false,
  hasLabel = false,
  label,
  isLabelHidden = false,
  hasDescription = false,
  description,
  isDescriptionHidden = false,
  hasHelpText = false,
  helpText,
  isHelpTextHidden = false,
  hasValidationMessage = false,
  validationMessage,
  isValidationMessageHidden = false,
  hasRequiredIndicator = false,
  isRequired = false,
  hasDisabledState = false,
  hasReadonlyState = false,
  hasLoadingState = false,
  hasSuccessState = false,
  hasWarningState = false,
  hasErrorState = false,
  hasInfoState = false,
  hasNeutralState = false,
  hasPrimaryState = false,
  hasSecondaryState = false,
  hasTertiaryState = false,
  hasQuaternaryState = false,
  hasQuinaryState = false,
  hasSenaryState = false,
  hasSeptenaryState = false,
  hasOctonaryState = false,
  hasNonaryState = false,
  hasDenaryState = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  onPreviousPage,
  onNextPage,
  onFirstPage,
  onLastPage,
  onItemsPerPageChange,
  ...props
}) => {
  const backgroundClass = hasBackground ? "bg-white dark:bg-gray-900" : "";
  const borderClass = isBordered ? "border border-gray-200 dark:border-gray-700" : "";
  const roundedClass = isRounded ? "rounded-md" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const backdropClass = hasBackdropBlur ? "backdrop-blur-sm" : "";
  const glassClass = hasGlassMorphism ? "bg-white/20 backdrop-blur-md" : "";
  const minHeightClass = hasMinHeight ? "min-h-32" : "";
  const getWidthClass = () => {
    if (isFullWidth) return "w-full";
    switch (width) {
      case "sm":
        return "w-sm";
      case "md":
        return "w-md";
      case "lg":
        return "w-lg";
      case "full":
        return "w-full";
      case "auto":
        return "w-auto";
      case "none":
        return "w-full";
      // 'none' behaves like default (full width)
      default:
        return "w-full";
    }
  };
  const getMinWidthClass = () => {
    if (minWidth) return "";
    return "min-w-24";
  };
  const getMaxWidthClass = () => {
    if (maxWidth) return "";
    return "max-w-full";
  };
  const widthClass = getWidthClass();
  const disabledClass = isDisabled ? "opacity-50 cursor-not-allowed pointer-events-none" : "";
  const transparentClass = isTransparent ? "bg-transparent" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-blue-500 to-purple-600" : "";
  const hoverClass = hasHoverEffect ? "hover:shadow-lg transition-shadow duration-200" : "";
  const focusClass = hasFocusEffect ? "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange focus:outline-none" : "";
  const activeClass = hasActiveEffect ? "active:scale-95 transition-transform duration-100" : "";
  const paddingClass = hasPadding ? "p-2" : "";
  const marginClass = hasMargin ? "m-2" : "";
  const centerClass = isCentered ? "mx-auto" : "";
  const responsiveClass = isResponsive ? "" : "flex-col";
  const containerClass = hasContainer ? "container mx-auto" : "";
  const maxWidthClass = hasMaxWidth ? "max-w-7xl" : "";
  const minWidthClass = hasMinWidth ? "min-w-0" : "";
  const fixedHeightClass = hasFixedHeight ? "h-96" : "";
  const fixedWidthClass = hasFixedWidth ? "w-96" : "";
  const overflowClass = hasScrollableOverflow ? "overflow-auto" : hasHiddenOverflow ? "overflow-hidden" : hasVisibleOverflow ? "overflow-visible" : hasClipOverflow ? "overflow-clip" : hasScrollOverflow ? "overflow-scroll" : hasAutoOverflow ? "overflow-auto" : hasInitialOverflow ? "overflow-initial" : hasInheritOverflow ? "overflow-inherit" : hasUnsetOverflow ? "overflow-unset" : hasRevertOverflow ? "overflow-revert" : hasRevertLayerOverflow ? "overflow-revert-layer" : "";
  const alignmentClass = alignment === "left" ? "justify-start" : alignment === "center" ? "justify-center" : alignment === "right" ? "justify-end" : alignment === "justify" ? "justify-between" : "justify-center";
  const stateClasses = [
    isLoading && "animate-pulse",
    isError && "border-red-500 bg-red-50 dark:bg-red-900/20",
    isWarning && "border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20",
    isSuccess && "border-green-500 bg-green-50 dark:bg-green-900/20",
    isInfo && "border-blue-500 bg-blue-50 dark:bg-blue-900/20"
  ].filter(Boolean);
  const combinedClasses = [
    "flex items-center gap-2",
    alignmentClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    backdropClass,
    glassClass,
    minHeightClass,
    widthClass,
    getMinWidthClass(),
    getMaxWidthClass(),
    disabledClass,
    transparentClass,
    gradientClass,
    hoverClass,
    focusClass,
    activeClass,
    paddingClass,
    marginClass,
    centerClass,
    responsiveClass,
    containerClass,
    maxWidthClass,
    minWidthClass,
    fixedHeightClass,
    fixedWidthClass,
    overflowClass,
    ...stateClasses,
    className
  ].filter(Boolean).join(" ");
  const pageNumbers = useMemo(() => {
    if (totalPages <= 7) return Array.from({ length: totalPages }, (_2, i2) => i2 + 1);
    if (currentPage <= 4) return [1, 2, 3, 4, 5, "...", totalPages];
    if (currentPage >= totalPages - 3) return [1, "...", totalPages - 4, totalPages - 3, totalPages - 2, totalPages - 1, totalPages];
    return [1, "...", currentPage - 1, currentPage, currentPage + 1, "...", totalPages];
  }, [currentPage, totalPages]);
  const paginationContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "nav",
    {
      className: combinedClasses,
      style: {
        ...style,
        ...customColor && { backgroundColor: customColor },
        ...minWidth && { minWidth },
        ...maxWidth && { maxWidth }
      },
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      ...props,
      children: [
        hasLabel && label && !isLabelHidden && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "sr-only", children: label }),
        hasDescription && description && !isDescriptionHidden && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sr-only", children: description }),
        hasHelpText && helpText && !isHelpTextHidden && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sr-only", children: helpText }),
        hasValidationMessage && validationMessage && !isValidationMessageHidden && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sr-only", children: validationMessage }),
        isSuccess && hasSuccessText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-green-600 dark:text-green-400", children: successText }),
        isWarning && hasWarningText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-yellow-600 dark:text-yellow-400", children: warningText }),
        isError && hasErrorText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-red-600 dark:text-red-400", children: errorText }),
        isInfo && hasInfoText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-blue-600 dark:text-blue-400", children: infoText }),
        hasFirstLastButtons && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            size: size2,
            variant,
            onClick: () => {
              if (onFirstPage) onFirstPage();
              onPageChange(1);
            },
            disabled: isDisabled || isLoading || currentPage === 1,
            leftIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "first_page" }),
            children: "First"
          }
        ),
        hasNavigationButtons && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            size: size2,
            variant,
            onClick: () => {
              if (onPreviousPage) onPreviousPage();
              onPageChange(currentPage - 1);
            },
            disabled: isDisabled || isLoading || currentPage === 1,
            leftIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "chevron_left" }),
            children: "Prev"
          }
        ),
        hasPageNumbers && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden md:flex items-center gap-1", children: pageNumbers.map(
          (page, index2) => typeof page === "number" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => onPageChange(page),
              className: `h-9 w-9 text-sm font-bold rounded-md transition-colors ${page === currentPage ? "bg-brand-orange text-white" : "text-text-secondary dark:text-dark-text-secondary hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary"}`,
              disabled: isDisabled || isLoading,
              children: page
            },
            index2
          ) : hasEllipsis && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "h-9 w-9 flex items-center justify-center text-text-secondary dark:text-dark-text-secondary",
              children: "..."
            },
            index2
          )
        ) }),
        hasNavigationButtons && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            size: size2,
            variant,
            onClick: () => {
              if (onNextPage) onNextPage();
              onPageChange(currentPage + 1);
            },
            disabled: isDisabled || isLoading || currentPage === totalPages,
            rightIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "chevron_right" }),
            children: "Next"
          }
        ),
        hasFirstLastButtons && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            size: size2,
            variant,
            onClick: () => {
              if (onLastPage) onLastPage();
              onPageChange(totalPages);
            },
            disabled: isDisabled || isLoading || currentPage === totalPages,
            rightIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "last_page" }),
            children: "Last"
          }
        ),
        hasPageInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-text-secondary dark:text-dark-text-secondary ml-4", children: [
          "Page ",
          currentPage,
          " of ",
          totalPages
        ] })
      ]
    }
  );
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      paginationContent,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-sm text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: tooltipText })
    ] });
  }
  return paginationContent;
};
const sizeConfig = {
  xs: { height: "h-1", stripeSize: "0.5rem" },
  // 4px
  sm: { height: "h-1.5", stripeSize: "0.625rem" },
  // 6px
  md: { height: "h-2", stripeSize: "0.75rem" },
  // 8px
  lg: { height: "h-3", stripeSize: "1rem" },
  // 12px
  xl: { height: "h-4", stripeSize: "1.25rem" }
  // 16px
};
const radiusConfig = {
  none: "rounded-none",
  sm: "rounded-sm",
  md: "rounded-md",
  lg: "rounded-lg",
  full: "rounded-full"
};
const colorConfig = {
  primary: {
    solid: "bg-brand-orange",
    solidDark: "dark:bg-brand-orange",
    soft: "bg-brand-orange",
    softDark: "dark:bg-brand-orange",
    softTrack: "bg-brand-orange/20",
    softTrackDark: "dark:bg-brand-orange/25",
    gradient: "bg-gradient-to-r from-brand-orange via-teal-400 to-cyan-500",
    gradientDark: "dark:from-brand-orange dark:via-teal-500 dark:to-cyan-400",
    outline: "bg-brand-orange",
    outlineDark: "dark:bg-brand-orange",
    glowStyle: { boxShadow: "0 0 20px 6px rgba(20, 184, 166, 0.5)" }
  },
  secondary: {
    solid: "bg-brand-navy-700",
    solidDark: "dark:bg-brand-navy-500",
    soft: "bg-brand-navy-700",
    softDark: "dark:bg-brand-navy-500",
    softTrack: "bg-brand-navy-700/20",
    softTrackDark: "dark:bg-brand-navy-500/25",
    gradient: "bg-gradient-to-r from-brand-navy-700 via-brand-navy-600 to-brand-navy-500",
    gradientDark: "dark:from-brand-navy-600 dark:via-brand-navy-500 dark:to-brand-navy-400",
    outline: "bg-brand-navy-700",
    outlineDark: "dark:bg-brand-navy-500",
    glowStyle: { boxShadow: "0 0 20px 6px rgba(54, 93, 158, 0.5)" }
  },
  success: {
    solid: "bg-system-success",
    solidDark: "dark:bg-emerald-500",
    soft: "bg-system-success",
    softDark: "dark:bg-emerald-500",
    softTrack: "bg-system-success/20",
    softTrackDark: "dark:bg-emerald-500/25",
    gradient: "bg-gradient-to-r from-system-success via-emerald-400 to-teal-500",
    gradientDark: "dark:from-emerald-600 dark:via-emerald-500 dark:to-teal-400",
    outline: "bg-system-success",
    outlineDark: "dark:bg-emerald-500",
    glowStyle: { boxShadow: "0 0 20px 6px rgba(16, 185, 129, 0.5)" }
  },
  warning: {
    solid: "bg-system-warning-border dark:bg-system-warning",
    solidDark: "dark:bg-system-warning",
    soft: "bg-system-warning-border dark:bg-system-warning",
    softDark: "dark:bg-system-warning",
    softTrack: "bg-system-warning-light/80 dark:bg-system-warning-dark-bg/40",
    softTrackDark: "dark:bg-system-warning-dark-bg/40",
    gradient: "bg-gradient-to-r from-system-warning-border via-system-warning to-amber-400",
    gradientDark: "dark:from-system-warning-dark-bg dark:via-system-warning dark:to-amber-400",
    outline: "bg-system-warning-border dark:bg-system-warning",
    outlineDark: "dark:bg-system-warning",
    glowStyle: { boxShadow: "0 0 20px 6px rgba(251, 191, 36, 0.5)" }
  },
  danger: {
    solid: "bg-system-error",
    solidDark: "dark:bg-red-500",
    soft: "bg-system-error",
    softDark: "dark:bg-red-500",
    softTrack: "bg-system-error/20",
    softTrackDark: "dark:bg-red-500/25",
    gradient: "bg-gradient-to-r from-system-error via-red-400 to-rose-500",
    gradientDark: "dark:from-red-600 dark:via-red-500 dark:to-rose-400",
    outline: "bg-system-error",
    outlineDark: "dark:bg-red-500",
    glowStyle: { boxShadow: "0 0 20px 6px rgba(239, 68, 68, 0.5)" }
  },
  info: {
    solid: "bg-system-info",
    solidDark: "dark:bg-blue-500",
    soft: "bg-system-info",
    softDark: "dark:bg-blue-500",
    softTrack: "bg-system-info/20",
    softTrackDark: "dark:bg-blue-500/25",
    gradient: "bg-gradient-to-r from-system-info via-blue-400 to-cyan-500",
    gradientDark: "dark:from-blue-600 dark:via-blue-500 dark:to-cyan-400",
    outline: "bg-system-info",
    outlineDark: "dark:bg-blue-500",
    glowStyle: { boxShadow: "0 0 20px 6px rgba(59, 130, 246, 0.5)" }
  }
};
const trackConfig = {
  default: "bg-gray-200 dark:bg-gray-700",
  soft: (color2) => cn(colorConfig[color2].softTrack, colorConfig[color2].softTrackDark),
  outline: "bg-transparent border border-gray-300 dark:border-gray-600"
};
const Progress = ({
  value,
  min: min2 = 0,
  max: max2 = 100,
  size: size2 = "md",
  variant = "solid",
  color: color2 = "primary",
  radius = "full",
  isStriped = false,
  isAnimated = false,
  hasGlow = false,
  className,
  progressClassName,
  trackClassName,
  // Legacy props with defaults
  containerClassName = "",
  labelClassName = "",
  label,
  hasBackground = true,
  hasBorder = false,
  hasRoundedCorners = true,
  hasShadow = false,
  hasFocusRing = false,
  showLabel = true,
  showHelperText = true,
  showErrorText = true,
  showDescription = false,
  showPercentage = true,
  isLoading = false,
  isPulsing = false,
  isFullWidth = true,
  hasGradient = false,
  showTooltip = false,
  showValueDisplay = true,
  hasSmoothTransition = true,
  isInteractive = false,
  hasHoverEffect = false,
  isSuccess = false,
  isWarning = false,
  isError = false,
  isInfo = false,
  helperText,
  error: error2,
  description,
  tooltipText,
  customColor,
  formatValue,
  transitionDuration = 300,
  onClick,
  showCustomRange = false,
  rangeLabels,
  ...props
}) => {
  const isIndeterminate = value === void 0;
  const effectiveVariant = hasGradient ? "gradient" : variant;
  const finalVariant = hasBorder ? "outline" : effectiveVariant;
  const effectiveRadius = hasRoundedCorners ? radius : "none";
  const getEffectiveColor = () => {
    if (isSuccess) return "success";
    if (isWarning) return "warning";
    if (isError) return "danger";
    if (isInfo) return "info";
    return color2;
  };
  const effectiveColor = getEffectiveColor();
  const clampedValue = isIndeterminate ? 0 : Math.max(min2, Math.min(max2, value));
  const percentage = isIndeterminate ? 100 : max2 > min2 ? (clampedValue - min2) / (max2 - min2) * 100 : 0;
  const sizeStyles = sizeConfig[size2];
  const radiusStyles = radiusConfig[effectiveRadius];
  const colorStyles = colorConfig[effectiveColor];
  const getTrackClasses = () => {
    if (finalVariant === "soft") {
      return trackConfig.soft(effectiveColor);
    }
    if (finalVariant === "outline") {
      return trackConfig.outline;
    }
    return trackConfig.default;
  };
  const getProgressClasses = () => {
    const variantKey = finalVariant;
    const darkKey = `${finalVariant}Dark`;
    const baseClasses = cn(
      colorStyles[variantKey] || colorStyles.solid,
      colorStyles[darkKey] || colorStyles.solidDark
    );
    if (finalVariant === "gradient") {
      return cn(
        colorStyles.gradient,
        colorStyles.gradientDark
      );
    }
    return baseClasses;
  };
  const isUsingLegacyApi = !!(label || helperText || error2 || description || showCustomRange || showTooltip && tooltipText);
  const containerClasses = cn(
    "w-full transition-all duration-200 overflow-hidden",
    sizeStyles.height,
    radiusStyles,
    getTrackClasses(),
    // Legacy styling props (backward compatibility)
    !hasBackground && "bg-transparent dark:bg-transparent",
    hasShadow && "shadow-md",
    hasFocusRing && "focus:ring-2 focus:ring-offset-2 focus:ring-brand-orange",
    isLoading && "animate-pulse",
    isPulsing && "animate-pulse",
    !isFullWidth && "w-auto",
    hasHoverEffect && "hover:opacity-80",
    isInteractive && "cursor-pointer",
    trackClassName,
    className,
    containerClassName
  );
  const progressBarClasses = cn(
    "h-full transition-all duration-300 ease-out",
    radiusStyles,
    getProgressClasses(),
    // Striped pattern (only for determinate)
    isStriped && !isIndeterminate && "bg-stripes",
    isStriped && isAnimated && !isIndeterminate && "animate-progress-stripes",
    // Indeterminate animation
    isIndeterminate && "animate-indeterminate-progress",
    progressClassName
  );
  const progressBarStyle = {
    width: isIndeterminate ? "30%" : `${percentage}%`,
    ...customColor && { backgroundColor: customColor },
    ...isStriped && !isIndeterminate && {
      backgroundImage: "linear-gradient(45deg, rgba(255,255,255,.2) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.2) 50%, rgba(255,255,255,.2) 75%, transparent 75%, transparent)",
      backgroundSize: `${sizeStyles.stripeSize} ${sizeStyles.stripeSize}`
    }
  };
  const handleClick = () => {
    if (onClick && !isIndeterminate) {
      onClick(clampedValue);
    }
  };
  const focusRingClass = isInteractive ? "outline-none focus-visible:ring-2 focus-visible:ring-brand-orange focus-visible:ring-offset-2 dark:focus-visible:ring-dark-brand-orange" : "";
  const coreProgressBar = /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      role: "progressbar",
      "aria-valuenow": isIndeterminate ? void 0 : clampedValue,
      "aria-valuemin": min2,
      "aria-valuemax": max2,
      "aria-busy": isIndeterminate,
      "aria-label": typeof label === "string" ? label : void 0,
      className: [containerClasses, focusRingClass].filter(Boolean).join(" "),
      style: hasGlow ? colorStyles.glowStyle : void 0,
      onClick: isInteractive ? handleClick : void 0,
      tabIndex: isInteractive ? 0 : void 0,
      onKeyDown: isInteractive ? (e2) => {
        if (e2.key === "Enter" || e2.key === " ") {
          e2.preventDefault();
          handleClick();
        }
      } : void 0,
      ...props,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: progressBarClasses,
          style: progressBarStyle
        }
      )
    }
  );
  const progressBar = hasGlow ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-2", children: coreProgressBar }) : coreProgressBar;
  if (!isUsingLegacyApi) {
    return progressBar;
  }
  const legacyContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("w-full", !isFullWidth && "w-auto"), children: [
    showLabel && label && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-1.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn(
        "text-sm font-medium text-text-primary dark:text-dark-text-primary",
        labelClassName
      ), children: label }),
      showValueDisplay && showPercentage && !isIndeterminate && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-semibold text-text-secondary dark:text-dark-text-secondary tabular-nums", children: formatValue ? formatValue(clampedValue) : `${Math.round(percentage)}%` })
    ] }),
    showDescription && description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-text-secondary dark:text-dark-text-secondary mb-2", children: description }),
    progressBar,
    showCustomRange && rangeLabels && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-xs text-text-secondary dark:text-dark-text-secondary mt-1.5", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: rangeLabels.min }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: rangeLabels.max })
    ] }),
    (error2 || helperText) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1.5 space-y-1", children: [
      showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
      showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
    ] })
  ] });
  if (showTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      legacyContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return legacyContent;
};
const sizeConfigs = {
  xs: { size: 16, defaultThickness: 2, fontSize: "text-[6px]" },
  sm: { size: 24, defaultThickness: 3, fontSize: "text-[8px]" },
  md: { size: 40, defaultThickness: 4, fontSize: "text-xs" },
  lg: { size: 56, defaultThickness: 5, fontSize: "text-sm" },
  xl: { size: 80, defaultThickness: 6, fontSize: "text-base" }
};
const colorClasses = {
  primary: "stroke-brand-orange",
  success: "stroke-system-success",
  warning: "stroke-system-warning",
  danger: "stroke-system-error",
  info: "stroke-system-info"
};
const CircularProgress = ({
  value,
  min: min2 = 0,
  max: max2 = 100,
  size: size2 = "md",
  color: color2 = "primary",
  thickness,
  showPercentage = false,
  children,
  className,
  trackClassName,
  progressClassName,
  ...props
}) => {
  const isIndeterminate = value === void 0;
  const config = sizeConfigs[size2];
  const strokeWidth = thickness ?? config.defaultThickness;
  const svgSize = config.size;
  const radius = (svgSize - strokeWidth) / 2;
  const circumference = 2 * Math.PI * radius;
  const clampedValue = isIndeterminate ? 0 : Math.max(min2, Math.min(max2, value));
  const percentage = isIndeterminate ? 0 : (clampedValue - min2) / (max2 - min2) * 100;
  const strokeDashoffset = isIndeterminate ? 0 : circumference - percentage / 100 * circumference;
  const center = svgSize / 2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      role: "progressbar",
      "aria-valuenow": isIndeterminate ? void 0 : clampedValue,
      "aria-valuemin": min2,
      "aria-valuemax": max2,
      "aria-busy": isIndeterminate,
      className: cn("relative inline-flex items-center justify-center", className),
      style: { width: svgSize, height: svgSize },
      ...props,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            className: cn(
              "transform -rotate-90",
              isIndeterminate && "animate-circular-rotate"
            ),
            width: svgSize,
            height: svgSize,
            viewBox: `0 0 ${svgSize} ${svgSize}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  className: cn(
                    "stroke-bg-tertiary dark:stroke-dark-bg-tertiary",
                    trackClassName
                  ),
                  cx: center,
                  cy: center,
                  r: radius,
                  fill: "none",
                  strokeWidth
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "circle",
                {
                  className: cn(
                    colorClasses[color2],
                    "transition-all duration-300",
                    isIndeterminate && "animate-circular-dash",
                    progressClassName
                  ),
                  cx: center,
                  cy: center,
                  r: radius,
                  fill: "none",
                  strokeWidth,
                  strokeLinecap: "round",
                  strokeDasharray: circumference,
                  strokeDashoffset: isIndeterminate ? void 0 : strokeDashoffset,
                  style: isIndeterminate ? { strokeDasharray: "1, 200", strokeDashoffset: "0" } : void 0
                }
              )
            ]
          }
        ),
        (showPercentage || children) && !isIndeterminate && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: children ?? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: cn(
          "font-semibold text-text-primary dark:text-dark-text-primary",
          config.fontSize
        ), children: [
          Math.round(percentage),
          "%"
        ] }) })
      ]
    }
  );
};
const PropsTable = ({
  data,
  title,
  description,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  // State Props
  isDisabled = false,
  isLoading = false,
  isExpanded = true,
  isCollapsible = false,
  isSortable = false,
  isSearchable = false,
  isFilterable = false,
  isSelectable = false,
  isEditable = false,
  isResizable = false,
  // Feature Props
  hasBackground = true,
  hasBorder = true,
  isRounded = true,
  hasShadow = false,
  hasTitleBar = false,
  hasDescription = false,
  hasToolbar = false,
  hasFooter = false,
  hasStripedRows = true,
  hasHoverEffects = true,
  hasLineNumbers = false,
  hasCopyButtons = false,
  hasExpandableRows = false,
  hasCollapsibleSections = false,
  // Layout Props
  isResponsive = true,
  hasFixedWidth = false,
  isFullWidth = true,
  hasFixedHeight = false,
  isScrollable = false,
  isCentered = false,
  hasMaxWidth = false,
  hasMinWidth = false,
  hasMaxHeight = false,
  hasMinHeight = false,
  // Content Props
  headerContent,
  footerContent,
  toolbarContent,
  emptyStateContent,
  loadingStateContent,
  errorStateContent,
  noDataContent,
  // Column Props
  showPropColumn = true,
  showTypeColumn = true,
  showDefaultColumn = true,
  showDescriptionColumn = true,
  showRequiredColumn = false,
  showExampleColumn = false,
  showCategoryColumn = false,
  // Event Handlers
  onClick,
  onFocus,
  onBlur,
  onToggle,
  onRowClick,
  onRowExpand,
  onPropCopy,
  onSort,
  onFilter,
  onSearch,
  ...props
}) => {
  const [expanded, setExpanded] = useState(isExpanded);
  const [searchTerm, setSearchTerm] = useState("");
  const [sortColumn, setSortColumn] = useState("");
  const [sortDirection, setSortDirection] = useState("asc");
  const [expandedRows, setExpandedRows] = useState(/* @__PURE__ */ new Set());
  const sizeClasses2 = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-sm",
    lg: "text-base",
    xl: "text-lg"
  };
  const variantClasses2 = {
    default: "bg-white dark:bg-gray-900",
    minimal: "bg-transparent",
    elevated: "bg-white dark:bg-gray-900 shadow-lg",
    bordered: "bg-white dark:bg-gray-900 border-2 border-gray-200 dark:border-gray-700",
    filled: "bg-gray-50 dark:bg-gray-800"
  };
  const handleToggle = () => {
    if (isCollapsible && !isDisabled) {
      const newExpanded = !expanded;
      setExpanded(newExpanded);
      onToggle?.(newExpanded);
    }
  };
  const handleSort = (column) => {
    if (!isSortable || isDisabled) return;
    const newDirection = sortColumn === column && sortDirection === "asc" ? "desc" : "asc";
    setSortColumn(column);
    setSortDirection(newDirection);
    onSort?.(column, newDirection);
  };
  const handleSearch = (term) => {
    setSearchTerm(term);
    onSearch?.(term);
  };
  const handleRowExpand = (propName) => {
    if (!hasExpandableRows) return;
    const newExpandedRows = new Set(expandedRows);
    if (newExpandedRows.has(propName)) {
      newExpandedRows.delete(propName);
    } else {
      newExpandedRows.add(propName);
    }
    setExpandedRows(newExpandedRows);
    onRowExpand?.(data.find((p2) => p2.name === propName), newExpandedRows.has(propName));
  };
  const handlePropCopy = (prop) => {
    if (isDisabled) return;
    const textToCopy = `${prop.name}: ${prop.type}${prop.default ? ` = ${prop.default}` : ""}`;
    navigator.clipboard.writeText(textToCopy);
    onPropCopy?.(prop);
  };
  const filteredData = data.filter(
    (prop) => !searchTerm || prop.name.toLowerCase().includes(searchTerm.toLowerCase()) || prop.type.toLowerCase().includes(searchTerm.toLowerCase()) || prop.description.toLowerCase().includes(searchTerm.toLowerCase())
  );
  const sortedData = [...filteredData].sort((a3, b2) => {
    if (!sortColumn) return 0;
    const aValue = a3[sortColumn];
    const bValue = b2[sortColumn];
    if (aValue < bValue) return sortDirection === "asc" ? -1 : 1;
    if (aValue > bValue) return sortDirection === "asc" ? 1 : -1;
    return 0;
  });
  const containerClasses = `
    ${hasBackground ? "bg-white dark:bg-gray-900" : ""}
    ${hasBorder ? "border border-gray-300 dark:border-gray-600" : ""}
    ${isRounded ? "rounded-lg" : ""}
    ${hasShadow ? "shadow-md" : ""}
    ${isResponsive ? "w-full" : ""}
    ${hasFixedWidth ? "" : "w-full"}
    ${isFullWidth ? "w-full" : ""}
    ${hasFixedHeight ? "" : "min-h-0"}
    ${isScrollable ? "overflow-auto" : "overflow-hidden"}
    ${isCentered ? "mx-auto" : ""}
    ${hasMaxWidth ? "max-w-7xl" : ""}
    ${hasMinWidth ? "min-w-0" : ""}
    ${hasMaxHeight ? "max-h-96" : ""}
    ${hasMinHeight ? "min-h-0" : ""}
    ${containerClassName}
    ${className}
  `.trim().replace(/\s+/g, " ");
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClasses, style, children: loadingStateContent || /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center h-32", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-primary-500" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-gray-500", children: "Loading props..." })
    ] }) });
  }
  if (data.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClasses, style, children: noDataContent || /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center h-32", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-8 h-8 text-gray-400 mr-2", children: "info" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: "No props available" })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, style, ...props, children: [
    (hasTitleBar || title || headerContent) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4 p-3 bg-gray-100 dark:bg-gray-800 rounded-t-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        title && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-gray-900 dark:text-gray-100", children: title }),
        description && hasDescription && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-600 dark:text-gray-400", children: description })
      ] }),
      headerContent
    ] }),
    hasToolbar && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4 p-2 bg-gray-50 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        isSearchable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "absolute left-2 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400", children: "search" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Search props...",
              value: searchTerm,
              onChange: (e2) => handleSearch(e2.target.value),
              className: "pl-8 pr-3 py-1 text-xs bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 rounded border border-gray-300 dark:border-gray-600 focus:ring-1 focus:ring-brand-orange dark:focus:ring-dark-brand-orange focus:border-transparent"
            }
          )
        ] }),
        isCollapsible && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: handleToggle,
            disabled: isDisabled,
            className: "px-2 py-1 text-xs bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3 mr-1", children: expanded ? "expand_less" : "expand_more" }),
              expanded ? "Collapse" : "Expand"
            ]
          }
        )
      ] }),
      toolbarContent
    ] }),
    expanded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: `w-full text-left border-collapse ${sizeClasses2[size2]}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: `border-b border-border-color dark:border-dark-border-color ${variantClasses2[variant]}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        hasLineNumbers && /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary w-12", children: "#" }),
        showPropColumn && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "th",
          {
            className: `p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary cursor-pointer ${isSortable ? "hover:bg-gray-100 dark:hover:bg-gray-800" : ""}`,
            onClick: () => handleSort("name"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Prop" }),
              isSortable && sortColumn === "name" && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3", children: sortDirection === "asc" ? "arrow_upward" : "arrow_downward" })
            ] })
          }
        ),
        showTypeColumn && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "th",
          {
            className: `p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary cursor-pointer ${isSortable ? "hover:bg-gray-100 dark:hover:bg-gray-800" : ""}`,
            onClick: () => handleSort("type"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Type" }),
              isSortable && sortColumn === "type" && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3", children: sortDirection === "asc" ? "arrow_upward" : "arrow_downward" })
            ] })
          }
        ),
        showDefaultColumn && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "th",
          {
            className: `p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary cursor-pointer ${isSortable ? "hover:bg-gray-100 dark:hover:bg-gray-800" : ""}`,
            onClick: () => handleSort("default"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Default" }),
              isSortable && sortColumn === "default" && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3", children: sortDirection === "asc" ? "arrow_upward" : "arrow_downward" })
            ] })
          }
        ),
        showRequiredColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary", children: "Required" }),
        showExampleColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary", children: "Example" }),
        showCategoryColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary", children: "Category" }),
        showDescriptionColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary", children: "Description" }),
        hasCopyButtons && /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "p-3 text-sm font-bold text-text-primary dark:text-dark-text-primary w-20", children: "Actions" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: `divide-y divide-border-color dark:divide-dark-border-subtle ${variantClasses2[variant]}`, children: sortedData.map((prop, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "tr",
        {
          className: `
                    ${hasStripedRows && index2 % 2 === 0 ? "bg-gray-50 dark:bg-gray-800" : ""}
                    ${hasHoverEffects ? "hover:bg-gray-100 dark:hover:bg-gray-700" : ""}
                    ${isSelectable ? "cursor-pointer" : ""}
                    ${isDisabled ? "opacity-50" : ""}
                    transition-colors
                  `.trim().replace(/\s+/g, " "),
          onClick: (e2) => onRowClick?.(prop, e2),
          children: [
            hasLineNumbers && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 text-xs text-gray-500 font-mono", children: index2 + 1 }),
            showPropColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 font-mono text-sm text-brand-orange dark:text-brand-orange", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
              hasExpandableRows && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handleRowExpand(prop.name),
                  className: "p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3", children: expandedRows.has(prop.name) ? "expand_less" : "expand_more" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: prop.name })
            ] }) }),
            showTypeColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 font-mono text-sm text-text-secondary dark:text-dark-text-secondary", children: prop.type }),
            showDefaultColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 font-mono text-sm text-text-secondary dark:text-dark-text-secondary", children: prop.default || "-" }),
            showRequiredColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 text-sm text-text-secondary dark:text-dark-text-secondary", children: prop.required ? "Yes" : "No" }),
            showExampleColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 text-sm text-text-secondary dark:text-dark-text-secondary", children: prop.example || "-" }),
            showCategoryColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 text-sm text-text-secondary dark:text-dark-text-secondary", children: prop.category || "-" }),
            showDescriptionColumn && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 text-sm text-text-secondary dark:text-dark-text-secondary", children: prop.description }),
            hasCopyButtons && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "p-3 text-sm", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => handlePropCopy(prop),
                disabled: isDisabled,
                className: "px-2 py-1 text-xs bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
                title: "Copy prop definition",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-3 h-3", children: "content_copy" })
              }
            ) })
          ]
        },
        prop.name
      )) })
    ] }) }),
    hasFooter && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4 p-3 bg-gray-100 dark:bg-gray-800 rounded-b-lg", children: footerContent || /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between text-xs text-gray-500", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        sortedData.length,
        " props"
      ] }),
      searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
        "Filtered from ",
        data.length,
        " total"
      ] })
    ] }) })
  ] });
};
const Radio = ({
  label,
  id: id2,
  className = "",
  containerClassName = "",
  labelClassName = "",
  radioClassName = "",
  isDisabled = false,
  isRequired = false,
  isLoading = false,
  isReadOnly = false,
  hasBorder = true,
  hasRoundedCorners = true,
  hasFocusRing = true,
  hasShadow = false,
  hasBackground = true,
  showLabel = true,
  showHelperText = true,
  showErrorText = true,
  showRequiredIndicator = true,
  showDescription = false,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  align = "left",
  isLabelLeft = false,
  isFullWidth = false,
  helperText,
  error: error2,
  description,
  value,
  name,
  isChecked = false,
  onChange,
  ...props
}) => {
  const sizeClasses2 = {
    xs: "h-3 w-3",
    sm: "h-4 w-4",
    md: "h-5 w-5",
    lg: "h-6 w-6",
    xl: "h-7 w-7"
  };
  const colorClasses2 = {
    primary: "text-brand-orange dark:text-dark-brand-orange border-border-color dark:border-dark-border-color focus:border-brand-orange dark:focus:border-dark-brand-orange",
    success: "text-system-success dark:text-system-success border-border-color dark:border-dark-border-color focus:border-system-success dark:focus:border-system-success",
    warning: "text-system-warning dark:text-system-warning border-border-color dark:border-dark-border-color focus:border-system-warning dark:focus:border-system-warning",
    danger: "text-system-error dark:text-system-error border-border-color dark:border-dark-border-color focus:border-system-error dark:focus:border-system-error",
    info: "text-system-info dark:text-system-info border-border-color dark:border-dark-border-color focus:border-system-info dark:focus:border-system-info"
  };
  const baseClasses = `${sizeClasses2[size2]} shrink-0`;
  const colorClass = colorClasses2[color2];
  const stateClasses = isDisabled || isLoading ? "opacity-60 cursor-not-allowed" : "cursor-pointer";
  const loadingClasses = isLoading ? "animate-pulse" : "";
  const readOnlyClasses = isReadOnly ? "opacity-80 cursor-default" : "";
  const focusRingByColor = {
    primary: "focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange",
    success: "focus-visible:ring-system-success dark:focus-visible:ring-system-success",
    warning: "focus-visible:ring-system-warning dark:focus-visible:ring-system-warning",
    danger: "focus-visible:ring-system-error dark:focus-visible:ring-system-error",
    info: "focus-visible:ring-system-info dark:focus-visible:ring-system-info"
  };
  const focusClasses = hasFocusRing ? `outline-none focus-visible:ring-2 focus-visible:ring-offset-2 ${focusRingByColor[color2]}` : "";
  const radioClasses = `${baseClasses} ${colorClass} ${stateClasses} ${loadingClasses} ${readOnlyClasses} ${focusClasses} ${radioClassName} ${className}`;
  const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
  const labelContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "label",
    {
      htmlFor: id2,
      className: `text-sm font-medium text-text-primary dark:text-dark-text-primary cursor-pointer ${isDisabled ? "opacity-60 cursor-not-allowed" : ""} ${alignmentClass} ${labelClassName}`,
      children: [
        label,
        isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" }),
        showDescription && description && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "block text-xs text-text-secondary dark:text-dark-text-secondary mt-1", children: description })
      ]
    }
  );
  const radioContent = /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "radio",
      id: id2,
      name,
      value,
      checked: isChecked,
      onChange,
      className: radioClasses,
      disabled: isDisabled || isLoading,
      required: isRequired,
      readOnly: isReadOnly,
      ...(() => {
        const { isSuccess, isWarning, loading, ...restProps } = props;
        return restProps;
      })()
    }
  );
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-start gap-3 ${widthClass} ${containerClassName}`, children: [
    isLabelLeft && labelContent,
    radioContent,
    !isLabelLeft && labelContent,
    (helperText || error2) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-8 mt-1", children: [
      showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
      showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
    ] })
  ] });
};
const SectionContainer = ({
  id: id2,
  children,
  containerClassName = "",
  contentClassName = "",
  loadingClassName = "",
  statusClassName = "",
  style,
  size: size2,
  variant,
  color: color2,
  centerContent = false,
  padding = "lg",
  maxWidth = "2xl",
  isCentered = true,
  isFullWidth = false,
  isCollapsed = false,
  isExpanded = false,
  isVisible = true,
  isHidden: isHidden3 = false,
  isTransparent = false,
  isOpaque = false,
  hasBackground = false,
  hasBorder = false,
  hasRoundedCorners = false,
  hasShadow = false,
  hasBackdropBlur = false,
  hasGlassEffect = false,
  hasGradient = false,
  hasFocusRing = false,
  hasMinHeight = false,
  hasHoverEffect = false,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isDisabled = false,
  isReadOnly = false,
  isRequired = false,
  isValid: isValid2 = true,
  isInvalid = false,
  isPending = false,
  isBusy = false,
  isReady = false,
  isMounted = false,
  isUnmounted = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  hasLoadingText = false,
  loadingText = "Loading...",
  hasSuccessText = false,
  successText = "Success!",
  hasWarningText = false,
  warningText = "Warning!",
  hasErrorText = false,
  errorText = "Error!",
  hasInfoText = false,
  infoText = "Info",
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  onScroll,
  ...props
}) => {
  if (centerContent) {
    const baseClasses = "h-screen w-full snap-start";
    return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: id2, className: `${baseClasses} flex flex-col justify-center`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full max-w-6xl mx-auto px-4 sm:px-6 md:px-8", children }) });
  }
  const paddingClasses = {
    none: "",
    sm: "py-4 px-2 sm:px-4",
    md: "py-6 px-4 sm:px-6 md:px-8",
    lg: "py-8 px-4 sm:px-6 md:px-8 lg:px-12",
    xl: "py-12 px-8 sm:px-12 md:px-16"
  };
  const maxWidthClasses = {
    sm: "max-w-sm",
    md: "max-w-md",
    lg: "max-w-lg",
    xl: "max-w-xl",
    "2xl": "max-w-2xl",
    full: "max-w-full"
  };
  const centerClass = isCentered ? "mx-auto" : "";
  const backgroundClass = hasBackground ? "bg-white dark:bg-gray-900" : "";
  const borderClass = hasBorder ? "border border-gray-200 dark:border-gray-700" : "";
  const roundedClass = hasRoundedCorners ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const backdropClass = hasBackdropBlur ? "backdrop-blur-sm" : "";
  const glassClass = hasGlassEffect ? "bg-white/20 backdrop-blur-md" : "";
  const minHeightClass = hasMinHeight ? "min-h-32" : "";
  const fullWidthClass = isFullWidth ? "w-full" : "";
  const disabledClass = isDisabled ? "opacity-50 cursor-not-allowed pointer-events-none" : "";
  const transparentClass = isTransparent ? "bg-transparent" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-blue-500 to-purple-600" : "";
  const hoverClass = hasHoverEffect ? "hover:shadow-lg transition-shadow duration-200" : "";
  const focusClass = hasFocusEffect ? "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange focus:outline-none" : "";
  const activeClass = hasActiveEffect ? "active:scale-95 transition-transform duration-100" : "";
  const stateClasses = [
    isLoading && "animate-pulse",
    isError && "border-red-500 bg-red-50 dark:bg-red-900/20",
    isWarning && "border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20",
    isSuccess && "border-green-500 bg-green-50 dark:bg-green-900/20",
    isInfo && "border-blue-500 bg-blue-50 dark:bg-blue-900/20"
  ].filter(Boolean);
  const combinedClasses = [
    centerClass,
    paddingClasses[padding],
    maxWidthClasses[maxWidth],
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    backdropClass,
    glassClass,
    minHeightClass,
    fullWidthClass,
    disabledClass,
    transparentClass,
    gradientClass,
    hoverClass,
    focusClass,
    activeClass,
    ...stateClasses,
    containerClassName
  ].filter(Boolean).join(" ");
  const sectionContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "section",
    {
      id: id2,
      className: combinedClasses,
      style: {
        ...style,
        ...customColor && { backgroundColor: customColor }
      },
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      onScroll,
      ...props,
      children: [
        isLoading && hasLoadingText && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center py-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-2 border-current border-t-transparent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-gray-600 dark:text-gray-400", children: loadingText })
        ] }),
        isSuccess && hasSuccessText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-green-600 dark:text-green-400", children: successText }),
        isWarning && hasWarningText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-yellow-600 dark:text-yellow-400", children: warningText }),
        isError && hasErrorText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-red-600 dark:text-red-400", children: errorText }),
        isInfo && hasInfoText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-blue-600 dark:text-blue-400", children: infoText }),
        children
      ]
    }
  );
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      sectionContent,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-sm text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: tooltipText })
    ] });
  }
  return sectionContent;
};
const SelectListboxWrapper = React__default.forwardRef(({ "aria-activedescendant": ariaActivedescendant, onKeyDown, closeDropdownRef, children }, ref) => {
  const { setIsOpen } = useDropdown();
  useEffect(() => {
    if (closeDropdownRef) closeDropdownRef.current = () => setIsOpen(false);
    return () => {
      if (closeDropdownRef) closeDropdownRef.current = null;
    };
  }, [setIsOpen, closeDropdownRef]);
  const handleKeyDown = (e2) => {
    if (e2.key === "Tab" || e2.key === "Shift+Tab") {
      setIsOpen(false);
      return;
    }
    onKeyDown(e2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      role: "listbox",
      tabIndex: -1,
      "aria-activedescendant": ariaActivedescendant,
      onKeyDown: handleKeyDown,
      className: "outline-none",
      children
    }
  );
});
SelectListboxWrapper.displayName = "SelectListboxWrapper";
const Select = ({
  label,
  id: id2,
  options,
  value,
  onChange,
  error: error2,
  isDisabled = false,
  className = "",
  selectClassName = "",
  labelClassName = "",
  isRequired = false,
  isLoading = false,
  isFullWidth = false,
  width,
  minWidth,
  maxWidth,
  showRequiredIndicator = true,
  showLabel = true,
  labelMode = "top",
  showHelperText = true,
  showErrorText = true,
  hasBackground = true,
  hasBorder = true,
  hasFocusRing: _hasFocusRing = false,
  // Deprecated: Focus ring removed from Select trigger (kept for backward compatibility)
  hasShadow = false,
  helperText,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  position = "bottom-start",
  align = "left",
  radius = "md",
  placeholder = "Select an option...",
  showSelectedIcon = true,
  showDescriptions = false,
  maxDropdownHeight = "15rem",
  itemLineHeight,
  closeOnSelect = true,
  isClearable = false,
  isSearchable = false,
  allowTyping = false,
  searchPlaceholder = "Search...",
  onSearch,
  showSearchFocusBorder = false,
  noOptionsText = "No options found",
  isLoadingOptions = false,
  loadingText = "Loading...",
  ariaLabel,
  ariaDescribedBy,
  ariaInvalid,
  style
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [isOpen, setIsOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [highlightedIndex, setHighlightedIndex] = useState(-1);
  const searchInputRef = useRef(null);
  const triggerInputRef = useRef(null);
  const listboxRef = useRef(null);
  const closeDropdownRef = useRef(null);
  const selectedOption = useMemo(() => options.find((opt) => opt.value === value) || null, [options, value]);
  const isTypingRef = useRef(false);
  useEffect(() => {
    if (!allowTyping) return;
    if (isTypingRef.current) return;
    if (!isOpen) {
      if (selectedOption) {
        setInputValue(selectedOption.label);
      } else if (!value) {
        setInputValue("");
      }
    }
  }, [value, selectedOption?.label, allowTyping, isOpen]);
  const displayValue = allowTyping ? isOpen ? inputValue : selectedOption?.label || inputValue : selectedOption?.label || "";
  const sizeClasses2 = {
    xs: "h-8 text-xs px-2",
    sm: "h-10 text-sm px-3",
    md: "h-12 text-base px-4",
    lg: "h-14 text-lg px-5",
    xl: "h-16 text-xl px-6"
  };
  const variantClasses2 = {
    primary: "bg-bg-secondary dark:bg-dark-bg-secondary text-text-primary dark:text-dark-text-primary",
    secondary: "bg-bg-tertiary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary",
    outline: "bg-transparent border-2 text-text-primary dark:text-dark-text-primary",
    ghost: "bg-transparent text-text-primary dark:text-dark-text-primary",
    filled: "bg-bg-primary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary"
  };
  const defaultBorderClass = "border border-border-color dark:border-dark-border-color";
  const openBorderByColor = {
    primary: "data-[state=open]:border-brand-navy data-[state=open]:dark:border-dark-brand-orange",
    success: "data-[state=open]:border-system-success data-[state=open]:dark:border-system-success",
    warning: "data-[state=open]:border-system-warning-dark data-[state=open]:dark:border-system-warning",
    danger: "data-[state=open]:border-system-error data-[state=open]:dark:border-system-error",
    info: "data-[state=open]:border-system-info data-[state=open]:dark:border-system-info"
  };
  const baseClasses = `focus:outline-none text-left flex items-center justify-between ${sizeClasses2[size2]}`;
  const backgroundClasses = hasBackground ? variantClasses2[variant] : "bg-transparent";
  const borderClasses = hasBorder ? error2 ? "border-2 border-system-error dark:border-system-error" : variant === "ghost" ? `border border-transparent hover:border-border-color dark:hover:border-dark-border-color ${openBorderByColor[color2]}` : `${defaultBorderClass} ${openBorderByColor[color2]}` : "border-0";
  const getRadiusClass2 = () => {
    switch (radius) {
      case "none":
        return "rounded-none";
      case "sm":
        return "rounded-sm";
      case "md":
        return "rounded";
      case "lg":
        return "rounded-lg";
      case "xl":
        return "rounded-xl";
      case "full":
        return "rounded-full";
      default:
        return "rounded";
    }
  };
  const roundedClasses = getRadiusClass2();
  const shadowClasses = hasShadow ? "shadow-md" : "";
  const getWidthClass = () => {
    if (isFullWidth) return "w-full";
    switch (width) {
      case "sm":
        return "w-sm";
      case "md":
        return "w-md";
      case "lg":
        return "w-lg";
      case "full":
        return "w-full";
      case "auto":
        return "w-auto";
      case "none":
        return "w-full";
      // 'none' behaves like default (full width)
      default:
        return "w-full";
    }
  };
  const getMinWidthClass = () => {
    if (minWidth) return "";
    return "min-w-24";
  };
  const getMaxWidthClass = () => {
    if (maxWidth) return "";
    return "max-w-full";
  };
  const widthClass = getWidthClass();
  const disabledClasses = isDisabled || isLoading ? "opacity-60 cursor-not-allowed" : "cursor-pointer";
  const loadingClasses = isLoading ? "animate-pulse" : "";
  const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
  const isFloatingLabel = labelMode === "floating";
  const hasValue = !!selectedOption;
  const shouldFloatLabel = isFloatingLabel && (hasValue || isOpen);
  const combinedClasses = `${baseClasses} ${widthClass} ${getMinWidthClass()} ${getMaxWidthClass()} ${backgroundClasses} ${borderClasses} ${roundedClasses} ${shadowClasses} outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange ${disabledClasses} ${loadingClasses} ${alignmentClass} ${selectClassName}${isFloatingLabel ? " relative" : ""}`;
  const handleClear = (e2) => {
    e2.stopPropagation();
    onChange("");
  };
  const filterTerm = allowTyping ? inputValue : searchTerm;
  const filteredOptions = useMemo(() => {
    if (!filterTerm) return options;
    const shouldFilter = isSearchable || allowTyping;
    if (!shouldFilter) return options;
    return options.filter(
      (option) => option.label.toLowerCase().includes(filterTerm.toLowerCase()) || option.description && option.description.toLowerCase().includes(filterTerm.toLowerCase())
    );
  }, [options, filterTerm, isSearchable, allowTyping]);
  const handleSearchChange = useCallback((e2) => {
    const newSearchTerm = e2.target.value;
    setSearchTerm(newSearchTerm);
    onSearch?.(newSearchTerm);
  }, [onSearch]);
  const handleSearchClear = useCallback((e2) => {
    e2.stopPropagation();
    setSearchTerm("");
    onSearch?.("");
    searchInputRef.current?.focus();
  }, [onSearch]);
  const handleSearchKeyDown = useCallback((e2) => {
    if (e2.key === "Escape") {
      setSearchTerm("");
      onSearch?.("");
      searchInputRef.current?.blur();
    }
    e2.stopPropagation();
  }, [onSearch]);
  const handleTriggerInputChange = useCallback((e2) => {
    const newValue = e2.target.value;
    isTypingRef.current = true;
    setInputValue(newValue);
    setIsOpen(true);
    onSearch?.(newValue);
    setTimeout(() => {
      isTypingRef.current = false;
    }, 100);
  }, [onSearch]);
  const handleTriggerInputFocus = useCallback(() => {
    setIsOpen(true);
    if (selectedOption) {
      setInputValue(selectedOption.label);
    } else {
      setInputValue("");
    }
  }, [selectedOption]);
  const handleTriggerInputBlur = useCallback(() => {
    isTypingRef.current = false;
    setTimeout(() => {
      setIsOpen(false);
      if (selectedOption) {
        setInputValue(selectedOption.label);
      } else if (!value) {
        setInputValue("");
      }
    }, 200);
  }, [selectedOption, value]);
  const displayOptions = isSearchable || allowTyping ? filteredOptions : options;
  const handleOpenChange = useCallback((open) => {
    setIsOpen(open);
    if (open) {
      const idx = displayOptions.findIndex((o4) => o4.value === value);
      setHighlightedIndex(idx >= 0 ? idx : 0);
    } else {
      setHighlightedIndex(-1);
    }
  }, [displayOptions, value]);
  const handleListKeyDown = useCallback((e2) => {
    const n2 = displayOptions.length;
    if (n2 === 0) return;
    const step = (dir) => {
      let i2 = highlightedIndex + dir;
      while (i2 >= 0 && i2 < n2 && displayOptions[i2].isDisabled) i2 += dir;
      if (i2 < 0) i2 = 0;
      if (i2 >= n2) i2 = n2 - 1;
      setHighlightedIndex(i2);
      const opt = displayOptions[i2];
      const id22 = opt ? `select-option-${String(opt.value)}` : void 0;
      if (id22) requestAnimationFrame(() => document.getElementById(id22)?.scrollIntoView({ block: "nearest" }));
    };
    if (e2.key === "ArrowDown") {
      e2.preventDefault();
      step(1);
      return;
    }
    if (e2.key === "ArrowUp") {
      e2.preventDefault();
      step(-1);
      return;
    }
    if (e2.key === "Enter") {
      e2.preventDefault();
      if (highlightedIndex >= 0 && highlightedIndex < n2 && !displayOptions[highlightedIndex].isDisabled) {
        onChange(displayOptions[highlightedIndex].value);
        if (allowTyping) {
          const selected = options.find((opt) => opt.value === displayOptions[highlightedIndex].value);
          setInputValue(selected?.label ?? "");
          setIsOpen(false);
        } else {
          closeDropdownRef.current?.();
        }
      }
      return;
    }
    if (e2.key === "Home") {
      e2.preventDefault();
      setHighlightedIndex(0);
      const id22 = displayOptions[0] ? `select-option-${String(displayOptions[0].value)}` : void 0;
      if (id22) document.getElementById(id22)?.scrollIntoView({ block: "nearest" });
      return;
    }
    if (e2.key === "End") {
      e2.preventDefault();
      const last = n2 - 1;
      setHighlightedIndex(last);
      const id22 = displayOptions[last] ? `select-option-${String(displayOptions[last].value)}` : void 0;
      if (id22) document.getElementById(id22)?.scrollIntoView({ block: "nearest" });
      return;
    }
  }, [displayOptions, highlightedIndex, onChange, allowTyping, options, setIsOpen]);
  const handleTriggerKeyDown = useCallback((e2) => {
    if (e2.key === "Escape") {
      setInputValue("");
      setIsOpen(false);
      triggerInputRef.current?.blur();
      e2.stopPropagation();
      return;
    }
    if (e2.key === "Tab" || e2.key === "Shift+Tab") {
      setIsOpen(false);
      return;
    }
    if (isOpen && displayOptions.length > 0 && ["ArrowDown", "ArrowUp", "Enter", "Home", "End"].includes(e2.key)) {
      e2.preventDefault();
      handleListKeyDown(e2);
      e2.stopPropagation();
      return;
    }
    if (!isOpen && e2.key === "Enter" && filteredOptions.length > 0) {
      onChange(filteredOptions[0].value);
      setInputValue(filteredOptions[0].label);
      setIsOpen(false);
      e2.preventDefault();
    }
    e2.stopPropagation();
  }, [filteredOptions, onChange, isOpen, displayOptions.length, handleListKeyDown]);
  const handleSelectTriggerKeyDown = useCallback((e2) => {
    if (isOpen && displayOptions.length > 0 && ["ArrowDown", "ArrowUp", "Enter", "Home", "End"].includes(e2.key)) {
      e2.preventDefault();
      handleListKeyDown(e2);
    }
  }, [isOpen, displayOptions.length, handleListKeyDown]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${widthClass} ${className}`, children: [
    showLabel && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: `block text-sm font-semibold text-text-primary dark:text-dark-text-primary mb-2 ${alignmentClass} ${labelClassName}`, children: [
      label,
      isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Dropdown,
      {
        open: allowTyping ? isOpen : void 0,
        onOpenChange: handleOpenChange,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Trigger, { onKeyDown: handleSelectTriggerKeyDown, children: allowTyping ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${combinedClasses} focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-brand-orange dark:focus-within:ring-dark-brand-orange`, children: [
            showLabel && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                className: [
                  "absolute left-4 transition-all duration-200 pointer-events-none z-10",
                  "text-text-secondary dark:text-dark-text-secondary",
                  shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-1/2 -translate-y-1/2",
                  error2 && "text-system-error-dark"
                ].filter(Boolean).join(" "),
                children: [
                  label,
                  isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                ref: triggerInputRef,
                id: id2,
                type: "text",
                value: displayValue,
                onChange: handleTriggerInputChange,
                onFocus: handleTriggerInputFocus,
                onBlur: handleTriggerInputBlur,
                onKeyDown: handleTriggerKeyDown,
                onClick: (e2) => e2.stopPropagation(),
                placeholder: isFloatingLabel ? void 0 : placeholder,
                disabled: isDisabled || isLoading,
                className: "flex-1 bg-transparent border-0 outline-none focus:outline-none focus:ring-0 focus:border-0 placeholder:text-text-secondary dark:placeholder:text-dark-text-secondary min-w-0",
                "aria-label": ariaLabel || label,
                "aria-describedby": ariaDescribedBy,
                "aria-invalid": ariaInvalid || !!error2,
                style: {
                  ...minWidth && { minWidth },
                  ...maxWidth && { maxWidth }
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
              isClearable && (selectedOption || inputValue) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: (e2) => {
                    e2.stopPropagation();
                    handleClear(e2);
                    setInputValue("");
                  },
                  className: "p-1 rounded-full hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
                  "aria-label": "Clear selection",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: "close" })
                }
              ),
              isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "data-[state=open]:-rotate-180", children: "unfold_more" })
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              id: id2,
              type: "button",
              className: combinedClasses,
              disabled: isDisabled || isLoading,
              "data-state-error": !!error2,
              "aria-label": ariaLabel,
              "aria-describedby": ariaDescribedBy,
              "aria-invalid": ariaInvalid,
              style: {
                ...minWidth && { minWidth },
                ...maxWidth && { maxWidth },
                ...style
              },
              children: [
                showLabel && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "span",
                  {
                    className: [
                      "absolute left-4 transition-all duration-200 pointer-events-none z-10",
                      "text-text-secondary dark:text-dark-text-secondary",
                      shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-1/2 -translate-y-1/2",
                      error2 && "text-system-error-dark"
                    ].filter(Boolean).join(" "),
                    children: [
                      label,
                      isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `truncate flex-1 text-left ${selectedOption ? "" : "text-text-secondary dark:text-dark-text-secondary"} ${isFloatingLabel && !selectedOption && !isOpen ? "opacity-0" : ""}`, children: selectedOption?.label || placeholder }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                  isClearable && selectedOption && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      onClick: handleClear,
                      className: "p-1 rounded-full",
                      "aria-label": "Clear selection",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-sm", children: "close" })
                    }
                  ),
                  isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "data-[state=open]:-rotate-180", children: "unfold_more" })
                ] })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Dropdown.Content,
            {
              position,
              fullWidth: true,
              maxHeight: maxDropdownHeight,
              itemLineHeight,
              className: "custom-scrollbar",
              children: [
                isSearchable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-2 border-b border-border-color dark:border-dark-border-color sticky top-0 bg-bg-secondary dark:bg-dark-bg-secondary z-10", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Icon,
                    {
                      size: "sm",
                      className: "absolute left-0 text-text-secondary dark:text-dark-text-secondary pointer-events-none",
                      children: "search"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      ref: searchInputRef,
                      type: "text",
                      value: searchTerm,
                      onChange: handleSearchChange,
                      onKeyDown: handleSearchKeyDown,
                      placeholder: searchPlaceholder,
                      className: `w-full pl-8 pr-8 py-1.5 text-sm bg-transparent border-0 outline-none placeholder:text-text-secondary dark:placeholder:text-dark-text-secondary ${showSearchFocusBorder ? `focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-brand-orange dark:focus:ring-dark-brand-orange` : "focus:outline-none focus:ring-0 focus:border-0"}`,
                      disabled: isDisabled || isLoading,
                      "aria-label": "Search options"
                    }
                  ),
                  searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      onClick: handleSearchClear,
                      className: "absolute right-0 p-1 rounded-full hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary transition-colors",
                      "aria-label": "Clear search",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: "text-text-secondary dark:text-dark-text-secondary", children: "close" })
                    }
                  )
                ] }) }),
                isLoadingOptions ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-2 text-sm text-text-secondary dark:text-dark-text-secondary", children: loadingText }) : displayOptions.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectListboxWrapper,
                  {
                    ref: listboxRef,
                    closeDropdownRef,
                    "aria-activedescendant": displayOptions[highlightedIndex] ? `select-option-${String(displayOptions[highlightedIndex].value)}` : void 0,
                    onKeyDown: handleListKeyDown,
                    children: displayOptions.map((option, index2) => {
                      const optionColor = option.color || "primary";
                      const isError = optionColor === "danger" || optionColor === "error";
                      const isWarning = optionColor === "warning";
                      const isSuccess = optionColor === "success";
                      const isInfo = optionColor === "info";
                      const isHighlighted = index2 === highlightedIndex;
                      return /* @__PURE__ */ jsxRuntimeExports.jsx(
                        SelectItem,
                        {
                          option,
                          value,
                          isError,
                          isWarning,
                          isSuccess,
                          isInfo,
                          showSelectedIcon,
                          showDescriptions,
                          isHighlighted,
                          onChange: (val) => {
                            onChange(val);
                            if (allowTyping) {
                              isTypingRef.current = false;
                              const selected = options.find((opt) => opt.value === val);
                              if (selected) {
                                setInputValue(selected.label);
                              } else {
                                setInputValue("");
                              }
                              setIsOpen(false);
                            }
                          },
                          closeOnSelect,
                          onSelect: () => {
                            if (isSearchable) {
                              setSearchTerm("");
                              onSearch?.("");
                            }
                            if (allowTyping) {
                              setIsOpen(false);
                            }
                          }
                        },
                        option.value
                      );
                    })
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-2 text-sm text-text-secondary dark:text-dark-text-secondary", children: noOptionsText })
              ]
            }
          )
        ]
      }
    ),
    showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error mt-1", children: error2 }),
    showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary mt-1", children: helperText })
  ] });
};
const SelectItem = ({ option, value, isError, isWarning, isSuccess, isInfo, showSelectedIcon, showDescriptions, isHighlighted, onChange, closeOnSelect, onSelect }) => {
  const { itemLineHeight } = useDropdown();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dropdown.Item,
    {
      id: `select-option-${String(option.value)}`,
      role: "option",
      "aria-selected": option.value === value,
      tabIndex: -1,
      onSelect: () => {
        onChange(option.value);
        onSelect?.();
      },
      disabled: option.isDisabled,
      hasHoverEffect: true,
      isHighlighted,
      hasActiveEffect: false,
      isError,
      isWarning,
      isSuccess,
      isInfo,
      className: `${option.isDisabled ? "opacity-50 cursor-not-allowed" : ""} whitespace-normal`,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "flex w-full items-center", children: [
        showSelectedIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `mr-3 h-5 w-5 flex items-center justify-center flex-shrink-0 ${option.value === value ? "opacity-100" : "opacity-0"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", children: "check" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 w-full min-w-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 items-center", children: [
            option.icon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-shrink-0", children: option.icon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: itemLineHeight !== void 0 ? {
                  lineHeight: typeof itemLineHeight === "string" ? itemLineHeight : itemLineHeight < 10 && itemLineHeight > 0.1 ? itemLineHeight : `${itemLineHeight}px`
                } : void 0,
                children: option.label
              }
            )
          ] }),
          showDescriptions && option.description && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-text-secondary dark:text-dark-text-secondary mt-1", children: option.description })
        ] })
      ] })
    }
  );
};
function recheck(media, setMatches) {
  setMatches(media.matches);
}
const useMediaQuery = (query) => {
  const [matches2, setMatches] = useState(() => {
    if (typeof window === "undefined") return false;
    return window.matchMedia(query).matches;
  });
  useEffect(() => {
    if (typeof window === "undefined") return;
    const media = window.matchMedia(query);
    const listener = () => recheck(media, setMatches);
    media.addEventListener("change", listener);
    window.addEventListener("resize", listener);
    window.addEventListener("orientationchange", listener);
    const vv = window.visualViewport;
    if (vv) {
      vv.addEventListener("resize", listener);
      vv.addEventListener("scroll", listener);
    }
    const id2 = typeof process !== "undefined" && process.env?.NODE_ENV === "development" ? window.setInterval(listener, 800) : void 0;
    return () => {
      media.removeEventListener("change", listener);
      window.removeEventListener("resize", listener);
      window.removeEventListener("orientationchange", listener);
      if (vv) {
        vv.removeEventListener("resize", listener);
        vv.removeEventListener("scroll", listener);
      }
      if (id2 !== void 0) window.clearInterval(id2);
    };
  }, [query]);
  return matches2;
};
const SIDEBAR_THEMES = {
  default: {
    // Uses design system colors (current behavior)
    background: "bg-bg-secondary dark:bg-dark-bg-secondary",
    text: "text-text-primary dark:text-dark-text-primary",
    textSecondary: "text-text-secondary dark:text-dark-text-secondary",
    hover: "hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
    active: "bg-system-success-light text-system-success-dark dark:bg-system-success-dark-bg dark:text-system-success-light-text",
    border: "border-border-color dark:border-dark-border-color",
    groupIcon: "text-text-primary dark:text-dark-text-primary",
    badge: "bg-system-error",
    badgeText: "text-white",
    badgeSecondary: "bg-bg-tertiary dark:bg-dark-bg-tertiary",
    badgeSecondaryText: "text-text-secondary dark:text-dark-text-secondary",
    avatar: "bg-brand-orange",
    avatarText: "text-white"
  },
  brand: {
    background: "bg-brand-navy",
    text: "text-white",
    textSecondary: "text-gray-300",
    hover: "hover:bg-brand-navy-600",
    active: "bg-brand-navy-800 text-white",
    border: "border-brand-navy-900",
    groupIcon: "text-white",
    badge: "bg-brand-orange",
    badgeText: "text-white",
    badgeSecondary: "bg-gray-200",
    badgeSecondaryText: "text-gray-600",
    avatar: "bg-brand-orange",
    avatarText: "text-white"
  },
  minimal: {
    background: "bg-white",
    text: "text-gray-900",
    textSecondary: "text-gray-600",
    hover: "hover:bg-gray-200",
    active: "bg-gray-200 text-gray-900",
    border: "border-gray-200",
    groupIcon: "text-gray-600",
    badge: "bg-gray-800",
    badgeText: "text-gray-100",
    badgeSecondary: "bg-gray-100",
    badgeSecondaryText: "text-gray-600",
    avatar: "bg-gray-200",
    avatarText: "text-gray-700"
  },
  grey: {
    background: "bg-gray-900",
    text: "text-gray-100",
    textSecondary: "text-gray-400",
    hover: "hover:bg-gray-700",
    active: "bg-gray-600 text-gray-100",
    border: "border-gray-600",
    groupIcon: "text-gray-300",
    badge: "bg-gray-200",
    badgeText: "text-gray-800",
    badgeSecondary: "bg-gray-700",
    badgeSecondaryText: "text-gray-300",
    avatar: "bg-gray-600",
    avatarText: "text-gray-100"
  },
  dark: {
    background: "bg-dark-bg-secondary",
    text: "text-dark-text-primary",
    textSecondary: "text-dark-text-secondary",
    hover: "hover:bg-dark-bg-tertiary",
    active: "bg-system-success-dark-bg text-system-success-light-text",
    border: "border-dark-border-color",
    groupIcon: "text-dark-text-primary",
    badge: "bg-system-error",
    badgeText: "text-white",
    badgeSecondary: "bg-dark-bg-tertiary",
    badgeSecondaryText: "text-dark-text-secondary",
    avatar: "bg-brand-orange",
    avatarText: "text-white"
  }
};
const getSidebarThemeClasses = (theme, customColors) => {
  if (theme === "custom" && customColors) {
    return {
      background: customColors.backgroundColor ? `bg-[${customColors.backgroundColor}]` : SIDEBAR_THEMES.default.background,
      text: customColors.textColor ? `text-[${customColors.textColor}]` : SIDEBAR_THEMES.default.text,
      textSecondary: customColors.textSecondaryColor ? `text-[${customColors.textSecondaryColor}]` : SIDEBAR_THEMES.default.textSecondary,
      hover: customColors.hoverColor ? `hover:bg-[${customColors.hoverColor}]` : SIDEBAR_THEMES.default.hover,
      active: customColors.activeColor ? `bg-[${customColors.activeColor}]` : SIDEBAR_THEMES.default.active,
      border: customColors.borderColor ? `border-[${customColors.borderColor}]` : SIDEBAR_THEMES.default.border,
      groupIcon: customColors.groupIconColor ? `text-[${customColors.groupIconColor}]` : SIDEBAR_THEMES.default.groupIcon,
      badge: customColors.badgeColor ? `bg-[${customColors.badgeColor}]` : SIDEBAR_THEMES.default.badge,
      badgeText: customColors.badgeTextColor ? `text-[${customColors.badgeTextColor}]` : SIDEBAR_THEMES.default.badgeText,
      badgeSecondary: SIDEBAR_THEMES.default.badgeSecondary,
      badgeSecondaryText: SIDEBAR_THEMES.default.badgeSecondaryText,
      avatar: customColors.avatarColor ? `bg-[${customColors.avatarColor}]` : SIDEBAR_THEMES.default.avatar,
      avatarText: customColors.avatarTextColor ? `text-[${customColors.avatarTextColor}]` : SIDEBAR_THEMES.default.avatarText
    };
  }
  return SIDEBAR_THEMES[theme] || SIDEBAR_THEMES.default;
};
const SidebarContext = createContext(null);
const useSidebarContext = () => {
  const context = useContext(SidebarContext);
  if (!context) {
    throw new Error("Sidebar sub-components must be used within a Sidebar component");
  }
  return context;
};
const SidebarRoot = ({
  variant = "default",
  size: size2 = "md",
  theme = "default",
  customColors,
  collapsed = false,
  collapsible = true,
  hoverExpand = false,
  showToggleButton = true,
  togglePosition = "bottom",
  hideOnMobile = true,
  mobileOpen,
  onMobileOpenChange,
  className,
  children,
  ...htmlProps
}) => {
  const { language: contextLanguage } = useLanguage();
  const isMobile = useMediaQuery("(max-width: 767px)");
  const isMobileHidden = Boolean(hideOnMobile && isMobile);
  const useMobileOverlay = Boolean(isMobileHidden && onMobileOpenChange);
  const isMobileOverlayOpen = useMobileOverlay && (mobileOpen ?? false);
  const getInitialCollapsedState = () => {
    if (isMobile && !useMobileOverlay) return true;
    try {
      const saved = localStorage.getItem("sidebar-collapsed");
      if (saved !== null) {
        return saved === "true";
      }
    } catch (e2) {
    }
    return collapsed;
  };
  const [internalCollapsed, setInternalCollapsed] = useState(getInitialCollapsedState);
  const [isHovered, setIsHovered] = useState(false);
  const [isCollapsing, setIsCollapsing] = useState(false);
  const [headerContent, setHeaderContent] = useState(null);
  const [footerContent, setFooterContent] = useState(null);
  const [isInitialMount, setIsInitialMount] = useState(true);
  useEffect(() => {
    setIsInitialMount(false);
  }, []);
  useEffect(() => {
    if (isMobile && !useMobileOverlay) {
      setInternalCollapsed(true);
    } else if (!isInitialMount) {
      setInternalCollapsed(collapsed);
    }
  }, [isMobile, collapsed, isInitialMount, useMobileOverlay]);
  useEffect(() => {
    if (!isMobile) {
      try {
        localStorage.setItem("sidebar-collapsed", String(internalCollapsed));
      } catch (e2) {
      }
    }
  }, [internalCollapsed, isMobile]);
  const themeClasses = getSidebarThemeClasses(theme, customColors);
  const variantClasses2 = {
    default: `${themeClasses.background} border-r ${themeClasses.border}`,
    minimal: "bg-transparent",
    elevated: `${themeClasses.background} shadow-lg border-r ${themeClasses.border}`,
    transparent: "bg-transparent"
  };
  const isExpanded = !internalCollapsed || hoverExpand && isHovered;
  const effectiveExpanded = useMobileOverlay ? isMobileOverlayOpen : isExpanded;
  const isOverlayMode = hoverExpand && internalCollapsed && (isHovered || isCollapsing);
  const hoverTimeoutRef = React__default.useRef(null);
  const handleMouseEnter = React__default.useCallback(() => {
    if (!hoverExpand) return;
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
      hoverTimeoutRef.current = null;
    }
    setIsCollapsing(false);
    setIsHovered(true);
  }, [hoverExpand]);
  const handleMouseLeave = React__default.useCallback(() => {
    if (!hoverExpand) return;
    if (hoverTimeoutRef.current) {
      clearTimeout(hoverTimeoutRef.current);
    }
    setIsCollapsing(true);
    setIsHovered(false);
    hoverTimeoutRef.current = setTimeout(() => {
      setIsCollapsing(false);
      hoverTimeoutRef.current = null;
    }, 350);
  }, [hoverExpand]);
  React__default.useEffect(() => {
    return () => {
      if (hoverTimeoutRef.current) {
        clearTimeout(hoverTimeoutRef.current);
      }
    };
  }, []);
  useEffect(() => {
    if (!isMobileOverlayOpen) return;
    document.body.style.overflow = "hidden";
    const onKeyDown = (e2) => {
      if (e2.key === "Escape") onMobileOpenChange?.(false);
    };
    window.addEventListener("keydown", onKeyDown);
    return () => {
      document.body.style.overflow = "";
      window.removeEventListener("keydown", onKeyDown);
    };
  }, [isMobileOverlayOpen, onMobileOpenChange]);
  const wrapperClasses = cn(
    "flex-shrink-0",
    isMobileHidden ? "w-0 min-w-0 h-0" : internalCollapsed ? "acutrack-sidebar-collapsed" : `acutrack-sidebar-expanded-${size2}`
  );
  const baseVariantClass = variantClasses2[variant];
  const sidebarClasses = cn(
    "flex flex-col overflow-hidden relative",
    isMobileHidden ? `fixed top-0 left-0 z-[60] h-screen max-h-screen transition-transform duration-300 ease-out max-w-[85vw] ${isMobileOverlayOpen ? "translate-x-0" : "-translate-x-full"} acutrack-sidebar-expanded-${size2}` : "h-screen",
    !isMobileHidden && (isOverlayMode ? "fixed top-0 left-0 z-[60] shadow-2xl backdrop-blur-md will-change-transform transition-[width,transform] duration-300 ease-in-out max-h-screen" : "sticky top-0 acutrack-sidebar-transition z-40"),
    !isMobileHidden && (isExpanded ? `acutrack-sidebar-expanded-${size2}` : "acutrack-sidebar-collapsed"),
    baseVariantClass,
    // Frosted effect only for hover overlay, not mobile
    isOverlayMode && !isMobileHidden && 'before:content-[""] before:absolute before:inset-0 before:bg-black/3 dark:before:bg-white/3 before:backdrop-blur-md before:pointer-events-none before:z-0',
    themeClasses.text,
    // Apply theme text color to root element
    "[&>*]:text-inherit",
    // Ensure all direct children inherit text color
    theme === "default" && "[&_h1]:!text-inherit",
    theme === "default" && "[&_h2]:!text-inherit",
    theme === "default" && "[&_h3]:!text-inherit",
    theme === "default" && "[&_h4]:!text-inherit",
    theme === "default" && "[&_h5]:!text-inherit",
    theme === "default" && "[&_h6]:!text-inherit",
    hoverExpand && "group",
    className
  );
  const contextCollapsed = useMobileOverlay ? !isMobileOverlayOpen : internalCollapsed;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SidebarContext.Provider,
    {
      value: {
        variant,
        size: size2,
        theme,
        customColors,
        themeClasses,
        collapsed: contextCollapsed,
        setCollapsed: setInternalCollapsed,
        isExpanded: effectiveExpanded,
        hoverExpand,
        isMobileOverlay: useMobileOverlay,
        headerContent,
        setHeaderContent,
        footerContent,
        setFooterContent
      },
      children: [
        useMobileOverlay && isMobileOverlayOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "fixed inset-0 z-[59] bg-black/50",
            onClick: () => onMobileOpenChange?.(false),
            "aria-hidden": "true"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: wrapperClasses, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "aside",
          {
            className: sidebarClasses,
            onMouseEnter: handleMouseEnter,
            onMouseLeave: handleMouseLeave,
            style: isMobileHidden ? {
              height: "100vh",
              maxHeight: "100vh"
            } : isOverlayMode && !isMobileHidden ? {
              position: "fixed",
              top: 0,
              left: 0,
              zIndex: 60,
              height: "100vh",
              maxHeight: "100vh"
            } : void 0,
            ...htmlProps,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full relative z-10", children: [
              useMobileOverlay && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex shrink-0 items-center justify-end p-2 border-b bg-inherit", themeClasses.border), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: () => onMobileOpenChange?.(false),
                  className: cn("p-2 rounded-md transition-colors", themeClasses.text, themeClasses.hover),
                  "aria-label": "Close menu",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-5 h-5", children: "close" })
                }
              ) }),
              showToggleButton && !useMobileOverlay && togglePosition === "top" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("p-2 border-b bg-inherit", themeClasses.border), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: () => setInternalCollapsed(!internalCollapsed),
                  className: cn(
                    "w-full p-2 rounded-md transition-colors flex items-center justify-center sidebar-toggle-button",
                    themeClasses.text,
                    themeClasses.hover,
                    internalCollapsed && !isExpanded ? "px-2" : "px-4"
                  ),
                  "aria-label": internalCollapsed ? "Expand sidebar" : "Collapse sidebar",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: cn("w-5 h-5", themeClasses.text), children: internalCollapsed ? "chevron_right" : "chevron_left" }),
                    !internalCollapsed || isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-sm font-medium", children: internalCollapsed ? getTranslation("expand", contextLanguage, [ui_i18n], true, "Expand") : getTranslation("collapse", contextLanguage, [ui_i18n], true, "Collapse") }) : null
                  ]
                }
              ) }),
              headerContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: headerContent }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-0 flex-1 overflow-y-auto overflow-x-hidden", children }),
              footerContent && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: footerContent }),
              showToggleButton && !useMobileOverlay && togglePosition === "bottom" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("sticky bottom-0 p-2 border-t bg-inherit", themeClasses.border), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: () => setInternalCollapsed(!internalCollapsed),
                  className: cn(
                    "w-full p-2 rounded-md transition-colors flex items-center justify-center sidebar-toggle-button",
                    themeClasses.text,
                    themeClasses.hover,
                    internalCollapsed && !isExpanded ? "px-2" : "px-4"
                  ),
                  "aria-label": internalCollapsed ? "Expand sidebar" : "Collapse sidebar",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: cn("w-5 h-5", themeClasses.text), children: internalCollapsed ? "chevron_right" : "chevron_left" }),
                    !internalCollapsed || isExpanded ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-sm font-medium", children: internalCollapsed ? getTranslation("expand", contextLanguage, [ui_i18n], true, "Expand") : getTranslation("collapse", contextLanguage, [ui_i18n], true, "Collapse") }) : null
                  ]
                }
              ) })
            ] })
          }
        ) })
      ]
    }
  );
};
const SidebarHeader = ({
  className,
  children,
  ...htmlProps
}) => {
  const { collapsed, isExpanded, setHeaderContent, themeClasses } = useSidebarContext();
  const headerElement = React__default.useMemo(() => /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: cn(
    "border-b p-5",
    themeClasses.border,
    className
  ), ...htmlProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex items-center", collapsed && !isExpanded ? "justify-center" : "gap-3"), children }) }), [collapsed, isExpanded, themeClasses.border, className, children]);
  React__default.useEffect(() => {
    setHeaderContent(headerElement);
    return () => setHeaderContent(null);
  }, [headerElement]);
  return null;
};
const SidebarLogo = ({
  text,
  href = "#",
  isClickable = true,
  className,
  ...htmlProps
}) => {
  const { collapsed, isExpanded, theme, themeClasses } = useSidebarContext();
  const hasCustomText = text !== void 0 && text !== null && text !== "";
  const [isDarkMode, setIsDarkMode] = useState(
    () => theme === "dark" || theme === "default" && document.documentElement.classList.contains("dark")
  );
  React__default.useEffect(() => {
    if (theme !== "default") {
      setIsDarkMode(theme === "dark");
      return;
    }
    const checkDarkMode = () => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    };
    checkDarkMode();
    const handleStorageChange = (e2) => {
      if (e2.key === "theme") {
        checkDarkMode();
      }
    };
    window.addEventListener("storage", handleStorageChange);
    const handleThemeChange = () => {
      checkDarkMode();
    };
    window.addEventListener("themeChanged", handleThemeChange);
    return () => {
      window.removeEventListener("storage", handleStorageChange);
      window.removeEventListener("themeChanged", handleThemeChange);
    };
  }, [theme]);
  const logoSrc = React__default.useMemo(() => {
    if (theme !== "default") {
      if (hasCustomText) {
        if (theme === "brand" || theme === "dark") {
          return LOGO_URLS.dark.icon;
        }
        if (theme === "minimal") {
          return LOGO_URLS.grey.light.icon;
        }
        if (theme === "grey") {
          return LOGO_URLS.grey.dark.icon;
        }
      } else {
        if (theme === "brand" || theme === "dark") {
          return collapsed && !isExpanded ? LOGO_URLS.dark.icon : LOGO_URLS.dark.full;
        }
        if (theme === "minimal") {
          return collapsed && !isExpanded ? LOGO_URLS.grey.light.icon : LOGO_URLS.grey.light.full;
        }
        if (theme === "grey") {
          return collapsed && !isExpanded ? LOGO_URLS.grey.dark.icon : LOGO_URLS.grey.dark.full;
        }
      }
    }
    if (hasCustomText) {
      return isDarkMode ? LOGO_URLS.dark.icon : LOGO_URLS.light.icon;
    } else {
      if (collapsed && !isExpanded) {
        return isDarkMode ? LOGO_URLS.dark.icon : LOGO_URLS.light.icon;
      }
      return isDarkMode ? LOGO_URLS.dark.full : LOGO_URLS.light.full;
    }
  }, [hasCustomText, theme, isDarkMode, collapsed, isExpanded]);
  const logoElement = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex items-center", collapsed && !isExpanded ? "justify-center" : "gap-3", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn(
      "flex items-center justify-center",
      collapsed && !isExpanded ? "h-6 w-6" : hasCustomText ? "h-6 w-6" : "h-6 w-auto"
      // Full logo should be wider
    ), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: logoSrc,
        alt: hasCustomText ? `${text} Logo` : `Acutrack Logo (${theme} theme)`,
        className: cn(
          "object-contain",
          collapsed && !isExpanded ? "h-6 w-6" : hasCustomText ? "h-8 w-8" : "h-8 w-auto"
          // Full logo should be wider
        )
      }
    ) }),
    hasCustomText && (!collapsed || isExpanded) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("text-lg font-semibold", themeClasses.text), children: text })
  ] });
  return isClickable ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      href,
      className: "flex-shrink-0 group",
      "aria-label": hasCustomText ? `${text} Home` : `Acutrack Home (${theme} theme)`,
      ...htmlProps,
      children: logoElement
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: logoElement });
};
const SidebarToggle = ({
  className,
  ...htmlProps
}) => {
  const { collapsed, setCollapsed, themeClasses, isMobileOverlay } = useSidebarContext();
  if (isMobileOverlay) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick: () => setCollapsed(!collapsed),
      className: cn(
        "p-2 rounded-md transition-colors",
        themeClasses.hover,
        className
      ),
      "aria-label": collapsed ? "Expand sidebar" : "Collapse sidebar",
      ...htmlProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: cn("w-5 h-5", themeClasses.text), children: collapsed ? "chevron_right" : "chevron_left" })
    }
  );
};
const SidebarMobileTrigger = ({
  onClick,
  className,
  "aria-label": ariaLabel = "Open menu",
  ...htmlProps
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    type: "button",
    onClick,
    className: cn("p-2 rounded-md transition-colors", className),
    "aria-label": ariaLabel,
    ...htmlProps,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-5 h-5", children: "menu" })
  }
);
const SidebarNavigation = ({
  className,
  children,
  ...htmlProps
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: cn("flex-1 overflow-y-auto pt-4", className), ...htmlProps, children });
};
const SidebarNavGroup = ({
  title,
  icon,
  // New prop
  isCollapsible = true,
  isExpanded = true,
  className,
  children,
  ...htmlProps
}) => {
  const { collapsed, isExpanded: sidebarExpanded, themeClasses } = useSidebarContext();
  const [expanded, setExpanded] = React__default.useState(isExpanded && sidebarExpanded);
  const [isInitialMount, setIsInitialMount] = React__default.useState(true);
  const hasActiveChild = React__default.useMemo(() => {
    if (React__default.Children.count(children) === 0) return false;
    return React__default.Children.toArray(children).some((child) => {
      if (React__default.isValidElement(child)) {
        if (child.props?.isActive === true) return true;
        if (child.props?.children && React__default.Children.count(child.props.children) > 0) {
          return React__default.Children.toArray(child.props.children).some((grandChild) => {
            if (React__default.isValidElement(grandChild)) {
              return grandChild.props?.isActive === true;
            }
            return false;
          });
        }
      }
      return false;
    });
  }, [children]);
  const [prevSidebarExpanded, setPrevSidebarExpanded] = React__default.useState(sidebarExpanded);
  React__default.useEffect(() => {
    if (isInitialMount) {
      if (isExpanded && sidebarExpanded) {
        setExpanded(true);
      }
      setIsInitialMount(false);
      return;
    }
    if (sidebarExpanded && !prevSidebarExpanded && hasActiveChild) {
      setExpanded(true);
    }
    setPrevSidebarExpanded(sidebarExpanded);
  }, [sidebarExpanded, hasActiveChild, prevSidebarExpanded, isExpanded, isInitialMount]);
  if (collapsed && !sidebarExpanded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("py-2", className), ...htmlProps, children: icon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "a",
      {
        href: "#",
        className: cn(
          "w-12 h-12 flex items-center justify-center rounded-md transition-colors",
          hasActiveChild ? themeClasses.active : themeClasses.hover
        ),
        title,
        onClick: (e2) => e2.preventDefault(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", className: cn(themeClasses.groupIcon), children: icon })
      }
    ) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("py-4", className), ...htmlProps, children: [
    title && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: cn(
          "flex items-center justify-between mb-2 mx-2 px-3 py-3 rounded-md transition-colors cursor-pointer",
          themeClasses.hover
        ),
        onClick: isCollapsible ? () => setExpanded(!expanded) : void 0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            " ",
            icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", className: cn("flex-shrink-0 sidebar-nav-group-icon", themeClasses.groupIcon), children: icon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "h3",
              {
                className: cn("text-xs font-semibold uppercase tracking-wider sidebar-nav-group-title", themeClasses.text),
                children: title
              }
            )
          ] }),
          isCollapsible && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: cn("w-4 h-4 transition-transform", themeClasses.text, expanded ? "rotate-180" : ""), children: "expand_more" })
        ]
      }
    ),
    expanded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children })
  ] });
};
const SidebarNavItem = ({
  href,
  isActive = false,
  isDisabled = false,
  icon,
  badge,
  children,
  className,
  ...htmlProps
}) => {
  const { collapsed, isExpanded, themeClasses } = useSidebarContext();
  if (collapsed && !isExpanded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center px-2 mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "a",
      {
        href,
        className: cn(
          "flex items-center justify-center w-12 h-12 rounded-md transition-colors group relative sidebar-nav-item",
          themeClasses.text,
          isActive ? themeClasses.active : themeClasses.hover,
          isDisabled && "opacity-50 cursor-not-allowed"
        ),
        "aria-current": isActive ? "page" : void 0,
        title: String(children),
        ...htmlProps,
        children: [
          icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", className: cn(themeClasses.text), children: icon }),
          badge && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("absolute -top-1 -right-1 w-4 h-4 text-xs rounded-full flex items-center justify-center", themeClasses.badge, themeClasses.badgeText), children: badge })
        ]
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      href,
      className: cn(
        "flex items-center gap-3 mx-2 px-3 py-3 rounded-md text-sm font-medium leading-6 transition-colors group relative sidebar-nav-item",
        themeClasses.text,
        isActive ? themeClasses.active : themeClasses.hover,
        isDisabled && "opacity-50 cursor-not-allowed",
        className
      ),
      "aria-current": isActive ? "page" : void 0,
      ...htmlProps,
      children: [
        icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", className: cn("flex-shrink-0", themeClasses.text), children: icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-1", children }),
        badge && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("px-2 py-0.5 text-xs rounded-full", themeClasses.badgeSecondary, themeClasses.badgeSecondaryText), children: badge })
      ]
    }
  );
};
const SidebarSubNavItem = ({
  href,
  isActive = false,
  isDisabled = false,
  icon,
  badge,
  children,
  className,
  ...htmlProps
}) => {
  const { collapsed, isExpanded, themeClasses } = useSidebarContext();
  if (collapsed && !isExpanded) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      href,
      className: cn(
        "flex items-center gap-3 mx-2 px-3 py-3 rounded-md text-sm font-medium leading-6 transition-colors group relative sidebar-sub-nav-item",
        themeClasses.text,
        isActive ? themeClasses.active : themeClasses.hover,
        isDisabled && "opacity-50 cursor-not-allowed",
        className
      ),
      "aria-current": isActive ? "page" : void 0,
      ...htmlProps,
      children: [
        icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", className: cn("flex-shrink-0", themeClasses.text), children: icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-1", children }),
        badge && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("px-2 py-0.5 text-xs rounded-full", themeClasses.badgeSecondary, themeClasses.badgeSecondaryText), children: badge })
      ]
    }
  );
};
const SidebarCollapsibleSection = ({
  title,
  icon,
  badge,
  isExpanded = false,
  children,
  className,
  ...htmlProps
}) => {
  const { collapsed, isExpanded: sidebarExpanded, themeClasses } = useSidebarContext();
  const [expanded, setExpanded] = React__default.useState(isExpanded && sidebarExpanded);
  const [isInitialMount, setIsInitialMount] = React__default.useState(true);
  const hasActiveChild = React__default.useMemo(() => {
    if (React__default.Children.count(children) === 0) return false;
    return React__default.Children.toArray(children).some((child) => {
      if (React__default.isValidElement(child)) {
        return child.props?.isActive === true;
      }
      return false;
    });
  }, [children]);
  const [prevSidebarExpanded, setPrevSidebarExpanded] = React__default.useState(sidebarExpanded);
  const [userToggled, setUserToggled] = React__default.useState(false);
  const handleToggle = React__default.useCallback(() => {
    setExpanded((prev) => !prev);
    setUserToggled(true);
  }, []);
  React__default.useEffect(() => {
    if (isInitialMount) {
      if (isExpanded && sidebarExpanded) {
        setExpanded(true);
      }
      if (hasActiveChild && sidebarExpanded) {
        setExpanded(true);
      }
      setIsInitialMount(false);
      return;
    }
    if (sidebarExpanded && !prevSidebarExpanded && hasActiveChild && !userToggled) {
      setExpanded(true);
    }
    if (!sidebarExpanded && prevSidebarExpanded) {
      setUserToggled(false);
    }
    setPrevSidebarExpanded(sidebarExpanded);
  }, [sidebarExpanded, hasActiveChild, prevSidebarExpanded, isExpanded, isInitialMount, userToggled]);
  if (collapsed && !sidebarExpanded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("py-1", className), ...htmlProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center px-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: cn(
          "flex items-center justify-center w-12 h-12 rounded-md transition-colors group relative sidebar-collapsible-button",
          themeClasses.text,
          hasActiveChild ? themeClasses.active : themeClasses.hover
        ),
        title,
        children: [
          icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", className: cn(themeClasses.text), children: icon }),
          badge && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("absolute -top-1 -right-1 w-4 h-4 text-xs rounded-full flex items-center justify-center", themeClasses.badge, themeClasses.badgeText), children: badge })
        ]
      }
    ) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("space-y-2", className), ...htmlProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        onClick: handleToggle,
        className: cn("flex items-center gap-3 mx-2 px-3 py-3 rounded-md text-sm font-medium leading-6 transition-colors group relative text-left sidebar-collapsible-button", themeClasses.text, themeClasses.hover),
        style: { width: "calc(100% - 1rem)" },
        "aria-label": expanded ? "Collapse section" : "Expand section",
        children: [
          icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", className: cn("flex-shrink-0", themeClasses.text), children: icon }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-1", children: title }),
          badge && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("px-2 py-0.5 text-xs rounded-full", themeClasses.badgeSecondary, themeClasses.badgeSecondaryText), children: badge }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Icon,
            {
              className: `w-4 h-4 transition-transform duration-200 ${expanded ? "rotate-180" : "rotate-0"}`,
              children: "expand_more"
            }
          )
        ]
      }
    ),
    expanded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-1 ml-4 pl-2", children })
  ] });
};
const SidebarThemeToggle = ({ className, ...htmlProps }) => {
  const { collapsed, isExpanded, theme: sidebarTheme, themeClasses } = useSidebarContext();
  const [theme, setTheme] = useState("light");
  const { language: contextLanguage } = useLanguage();
  useEffect(() => {
    const storedTheme = localStorage.getItem("theme");
    if (storedTheme && (storedTheme === "light" || storedTheme === "dark")) {
      setTheme(storedTheme);
    } else {
      const prefersDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
      setTheme(prefersDark ? "dark" : "light");
    }
  }, []);
  const applyTheme = React__default.useCallback((themeToApply) => {
    const html2 = document.documentElement;
    if (sidebarTheme === "default") {
      html2.classList.toggle("dark", themeToApply === "dark");
      html2.classList.toggle("light", themeToApply === "light");
    } else {
      html2.classList.toggle("app-dark", themeToApply === "dark");
      html2.classList.toggle("app-light", themeToApply === "light");
      html2.classList.toggle("dark", themeToApply === "dark");
      html2.classList.toggle("light", themeToApply === "light");
    }
  }, [sidebarTheme]);
  const handleThemeToggle = () => {
    const newTheme = theme === "light" ? "dark" : "light";
    setTheme(newTheme);
    applyTheme(newTheme);
    try {
      localStorage.setItem("theme", newTheme);
    } catch (e2) {
      console.warn("Could not save theme to localStorage");
    }
    window.dispatchEvent(new CustomEvent("themeChanged"));
  };
  useEffect(() => {
    applyTheme(theme);
  }, [theme]);
  if (collapsed && !isExpanded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: handleThemeToggle,
        className: cn(
          "flex items-center justify-center w-12 h-12 rounded-md transition-colors group relative sidebar-theme-toggle",
          themeClasses.hover
        ),
        "aria-label": formatString("switchtotheme", contextLanguage, [ui_i18n], {
          theme: getTranslation(theme === "light" ? "dark" : "light", contextLanguage, [ui_i18n], true, theme === "light" ? "dark" : "light")
        }, `Switch to ${theme === "light" ? "dark" : "light"} theme`),
        title: formatString("switchtotheme", contextLanguage, [ui_i18n], {
          theme: getTranslation(theme === "light" ? "dark" : "light", contextLanguage, [ui_i18n], true, theme === "light" ? "dark" : "light")
        }, `Switch to ${theme === "light" ? "dark" : "light"} theme`),
        ...htmlProps,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: cn("w-5 h-5", themeClasses.text), children: theme === "light" ? "dark_mode" : "light_mode" })
      }
    ) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      onClick: handleThemeToggle,
      className: cn(
        "flex items-center gap-3 px-3 py-2 rounded-md text-sm font-medium transition-colors group relative sidebar-theme-toggle w-full",
        themeClasses.hover,
        themeClasses.text,
        className
      ),
      "aria-label": `Switch to ${theme === "light" ? "dark" : "light"} theme`,
      ...htmlProps,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: cn("w-5 h-5", themeClasses.text), children: theme === "light" ? "dark_mode" : "light_mode" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-1 text-left", children: theme === "light" ? getTranslation("darkmode", contextLanguage, [ui_i18n], true, "Dark Mode") : getTranslation("lightmode", contextLanguage, [ui_i18n], true, "Light Mode") })
      ]
    }
  );
};
const SidebarFooter = ({
  className,
  children,
  ...htmlProps
}) => {
  const { collapsed, isExpanded, setFooterContent, themeClasses } = useSidebarContext();
  const footerElement = React__default.useMemo(() => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "footer",
    {
      className: cn("p-4 border-t", themeClasses.border, className),
      ...htmlProps,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn(
        "flex flex-col",
        collapsed && !isExpanded ? "items-center space-y-2" : "space-y-2"
      ), children })
    }
  ), [collapsed, isExpanded, themeClasses.border, className, children]);
  React__default.useEffect(() => {
    setFooterContent(footerElement);
    return () => setFooterContent(null);
  }, [footerElement]);
  return null;
};
const SidebarContent = ({
  className,
  children,
  ...htmlProps
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex-1 overflow-y-auto", className), ...htmlProps, children });
};
const SidebarSection = ({
  title,
  className,
  children,
  ...htmlProps
}) => {
  const { collapsed, themeClasses } = useSidebarContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("px-4 py-2", className), ...htmlProps, children: [
    title && !collapsed && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: cn("text-xs font-semibold uppercase tracking-wider mb-2", themeClasses.textSecondary), children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children })
  ] });
};
const SidebarUserDetails = ({
  name = "John Doe",
  email = "john@example.com",
  avatar,
  className,
  ...htmlProps
}) => {
  const { collapsed, isExpanded, themeClasses } = useSidebarContext();
  if (collapsed && !isExpanded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center mb-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0", themeClasses.avatar, className), ...htmlProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: themeClasses.avatarText, children: "person" }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("flex items-center gap-3 w-full", className), ...htmlProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0", themeClasses.avatar), children: avatar ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: avatar, alt: name, className: "w-full h-full rounded-full object-cover" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: themeClasses.avatarText, children: "person" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-w-0 flex-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: cn("text-sm font-medium truncate", themeClasses.text), children: name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: cn("text-xs truncate opacity-70", themeClasses.textSecondary), children: email })
    ] })
  ] });
};
const Sidebar = Object.assign(SidebarRoot, {
  Header: SidebarHeader,
  Logo: SidebarLogo,
  Toggle: SidebarToggle,
  MobileTrigger: SidebarMobileTrigger,
  Navigation: SidebarNavigation,
  NavGroup: SidebarNavGroup,
  NavItem: SidebarNavItem,
  SubNavItem: SidebarSubNavItem,
  CollapsibleSection: SidebarCollapsibleSection,
  // New collapsible section component
  ThemeToggle: SidebarThemeToggle,
  // New theme toggle component
  UserDetails: SidebarUserDetails,
  // New user details component
  Footer: SidebarFooter,
  Content: SidebarContent,
  Section: SidebarSection
});
const Skeleton = ({
  className,
  count: count2 = 1,
  isAnimated = true,
  variant = "pulse",
  // Legacy props
  height,
  width,
  isRounded = true,
  isBordered = false,
  hasShadow = false,
  hasShimmer = false,
  isPulsing = false,
  isLoading = true,
  isFullWidth = false,
  hasBackground = true,
  hasGradient = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  hasBorderRadius = true,
  hasBorderStyle = false,
  borderStyle = "solid",
  hasBorderWidth = false,
  borderWidth,
  hasBorderColor = false,
  borderColor,
  hasBackgroundColor = false,
  backgroundColor,
  hasTextColor = false,
  textColor,
  hasHoverEffect = false,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isDisabled = false,
  hasLoadingText = false,
  loadingText = "Loading...",
  isSuccess = false,
  isWarning = false,
  isError = false,
  isInfo = false,
  ...props
}) => {
  const getAnimationClass = () => {
    if (hasShimmer) return "animate-shimmer";
    if (isPulsing) return "animate-pulse";
    if (!isAnimated || variant === "none") return "";
    if (variant === "shimmer") return "animate-shimmer";
    return "animate-pulse";
  };
  const isUsingLegacyApi = height !== void 0 || width !== void 0;
  const skeletonClasses = cn(
    "bg-gray-200 dark:bg-gray-700",
    getAnimationClass(),
    // Only apply default rounded if not using className override
    isRounded && "rounded-md",
    isBordered && "border border-border-color dark:border-dark-border-color",
    hasShadow && "shadow-sm",
    isFullWidth && "w-full",
    hasGradient && "bg-gradient-to-r from-gray-200 via-gray-300 to-gray-200 dark:from-gray-700 dark:via-gray-600 dark:to-gray-700",
    className
  );
  const legacyStyle = isUsingLegacyApi ? {
    height,
    width,
    ...customColor && { backgroundColor: customColor },
    ...backgroundColor && { backgroundColor }
  } : void 0;
  const renderSkeleton = (key) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: skeletonClasses,
      style: legacyStyle,
      role: "status",
      "aria-label": "Loading...",
      ...props
    },
    key
  );
  if (count2 > 1) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: Array.from({ length: count2 }).map((_2, index2) => renderSkeleton(index2)) });
  }
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative inline-block", children: [
      renderSkeleton(),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return renderSkeleton();
};
const SkeletonCircle = ({
  size: size2 = 40,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Skeleton,
  {
    className: `rounded-full`,
    style: { width: size2, height: size2 },
    ...props
  }
);
const SkeletonText = ({
  lines = 1,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Skeleton,
  {
    className: "h-4 w-full",
    count: lines,
    ...props
  }
);
const SkeletonCard = (props) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 p-4 border border-border-color dark:border-dark-border-color rounded-lg", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "h-40 w-full rounded-lg", ...props }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "h-4 w-3/4", ...props }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "h-4 w-full", ...props }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: "h-4 w-1/2", ...props })
] });
const Slider = ({
  label,
  id: id2,
  value,
  containerClassName = "",
  sliderClassName = "",
  labelClassName = "",
  isDisabled = false,
  isRequired = false,
  isLoading = false,
  isReadOnly = false,
  isFullWidth = true,
  hasBackground = true,
  hasBorder = true,
  hasRoundedCorners = true,
  hasShadow = false,
  hasFocusRing = true,
  showLabel = true,
  showHelperText = true,
  showErrorText = true,
  showRequiredIndicator = true,
  showDescription = false,
  showValue = true,
  showMarks = false,
  showTooltip = false,
  sliderSize = "md",
  variant = "primary",
  color: color2 = "primary",
  isVertical = false,
  hasRange = false,
  hasDualHandle = false,
  helperText,
  error: error2,
  description,
  tooltipText,
  marks = [],
  onChange,
  min: min2 = 0,
  max: max2 = 100,
  step = 1,
  isSuccess = false,
  isWarning = false,
  valueFormatter,
  ...props
}) => {
  const sizeClasses2 = {
    xs: "h-1",
    sm: "h-2",
    md: "h-3",
    lg: "h-4",
    xl: "h-5"
  };
  const variantClasses2 = {
    primary: "bg-bg-secondary dark:bg-dark-bg-secondary",
    secondary: "bg-bg-tertiary dark:bg-dark-bg-primary",
    outline: "bg-transparent border-2",
    ghost: "bg-transparent",
    filled: "bg-bg-primary dark:bg-dark-bg-primary"
  };
  const focusBorderByColor = {
    primary: "focus:border-brand-navy dark:focus:border-dark-brand-orange",
    success: "focus:border-system-success dark:focus:border-system-success",
    warning: "focus:border-system-warning-dark dark:focus:border-system-warning",
    danger: "focus:border-system-error dark:focus:border-system-error",
    info: "focus:border-system-info dark:focus:border-system-info"
  };
  const focusRingByColor = {
    primary: "focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    success: "focus:ring-system-success dark:focus:ring-system-success",
    warning: "focus:ring-system-warning dark:focus:ring-system-warning",
    danger: "focus:ring-system-error dark:focus:ring-system-error",
    info: "focus:ring-system-info dark:focus:ring-system-info"
  };
  const stateClasses = {
    default: hasBorder ? "border-border-color dark:border-dark-border-color" : "border-transparent",
    error: "border-2 border-system-error dark:border-system-error",
    success: "border-2 border-system-success dark:border-system-success",
    warning: "border-2 border-system-warning-dark dark:border-system-warning"
  };
  const baseClasses = "transition-all duration-200 focus:outline-none";
  const backgroundClasses = hasBackground ? variantClasses2[variant] : "bg-transparent";
  const roundedClasses = hasRoundedCorners ? "rounded-full" : "rounded-none";
  const shadowClasses = hasShadow ? "shadow-md" : "";
  const focusClasses = `${focusBorderByColor[color2]} ${hasFocusRing ? `focus:ring-2 focus:ring-offset-2 ${focusRingByColor[color2]}` : ""}`.trim();
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const disabledClasses = isDisabled || isLoading ? "opacity-60 cursor-not-allowed" : "cursor-pointer";
  const loadingClasses = isLoading ? "animate-pulse" : "";
  const readOnlyClasses = isReadOnly ? "opacity-80 cursor-default" : "";
  const verticalClasses = isVertical ? "rotate-90 origin-center" : "";
  const getStateClass = () => {
    if (error2) return stateClasses.error;
    if (isSuccess) return stateClasses.success;
    if (isWarning) return stateClasses.warning;
    return stateClasses.default;
  };
  const sliderClasses = `${baseClasses} ${sizeClasses2[sliderSize]} ${widthClass} ${backgroundClasses} ${getStateClass()} ${roundedClasses} ${shadowClasses} ${focusClasses} ${disabledClasses} ${loadingClasses} ${readOnlyClasses} ${verticalClasses} ${sliderClassName}`;
  const containerClasses = `${widthClass} ${containerClassName}`;
  const sliderContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, children: [
    showLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: `text-sm font-semibold text-text-primary dark:text-dark-text-primary ${labelClassName}`, children: [
        label,
        isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
      ] }),
      showValue && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "px-2 py-1 text-xs rounded-md bg-bg-tertiary dark:bg-dark-bg-primary text-text-secondary dark:text-dark-text-secondary", children: valueFormatter ? valueFormatter(value) : value })
    ] }),
    showDescription && description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-text-secondary dark:text-dark-text-secondary mb-2", children: description }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center bg-bg-tertiary dark:bg-dark-bg-tertiary rounded", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "range",
          id: id2,
          value,
          min: min2,
          max: max2,
          step,
          disabled: isDisabled || isLoading,
          required: isRequired,
          readOnly: isReadOnly,
          onChange,
          className: sliderClasses,
          ...(() => {
            const { isSuccess: isSuccess2, isWarning: isWarning2, loading, ...restProps } = props;
            return restProps;
          })()
        }
      ),
      showMarks && marks.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between text-xs text-text-secondary dark:text-dark-text-secondary mt-1", children: marks.map((mark, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "flex-1 text-center", children: mark.label }, index2)) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 space-y-1", children: [
      showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
      showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
    ] })
  ] });
  if (showTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      sliderContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return sliderContent;
};
const Spinner = ({
  size: size2 = "md",
  variant = "ring",
  color: color2 = "primary",
  className = "",
  isBordered = true,
  isRounded = true,
  hasShadow = false,
  hasBackground = false,
  hasFocusRing = false,
  isInteractive = false,
  isPulsing = false,
  loading = true,
  fullWidth = false,
  hasGradient = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  isAnimated = true,
  animationDuration = 1,
  hasLabel = false,
  label,
  hasDescription = false,
  description,
  isSuccess = false,
  isWarning = false,
  isError = false,
  isInfo = false,
  hasCustomSize = false,
  customWidth,
  customHeight,
  hasBorderRadius = true,
  hasBorderStyle = true,
  borderStyle = "solid",
  hasBorderWidth = true,
  borderWidth,
  hasBorderColor = true,
  borderColor,
  hasBackgroundColor = false,
  backgroundColor,
  hasTextColor = true,
  textColor,
  hasHoverEffect = false,
  hasFocusEffect = false,
  hasActiveEffect = false,
  disabled = false,
  hasLoadingText = false,
  loadingText = "Loading...",
  hasSuccessText = false,
  successText = "Success!",
  hasWarningText = false,
  warningText = "Warning!",
  hasErrorText = false,
  errorText = "Error!",
  hasInfoText = false,
  infoText = "Info",
  ...props
}) => {
  const sizeClasses2 = {
    xs: "h-4 w-4",
    sm: "h-6 w-6",
    md: "h-8 w-8",
    lg: "h-12 w-12",
    xl: "h-16 w-16"
  };
  const getColorClass = () => {
    if (customColor) return `text-[${customColor}]`;
    if (isSuccess) return "text-system-success";
    if (isWarning) return "text-system-warning";
    if (isError) return "text-system-error";
    if (isInfo) return "text-system-info";
    const colorClass2 = {
      primary: "text-brand-orange dark:text-dark-brand-orange",
      white: "text-white",
      current: "text-current",
      success: "text-system-success",
      warning: "text-system-warning",
      error: "text-system-error",
      info: "text-system-info"
    }[color2] || "text-brand-orange dark:text-dark-brand-orange";
    return colorClass2;
  };
  const colorClass = getColorClass();
  const getText = () => {
    if (isSuccess && hasSuccessText) return successText;
    if (isWarning && hasWarningText) return warningText;
    if (isError && hasErrorText) return errorText;
    if (isInfo && hasInfoText) return infoText;
    if (hasLoadingText) return loadingText;
    return "";
  };
  const text = getText();
  if (variant === "grid") {
    const dotSizeClasses = {
      xs: "h-1 w-1",
      sm: "h-1.5 w-1.5",
      md: "h-2 w-2",
      lg: "h-2.5 w-2.5",
      xl: "h-3 w-3"
    };
    const gapClasses = {
      xs: "gap-0.5",
      sm: "gap-1",
      md: "gap-1",
      lg: "gap-1.5",
      xl: "gap-2"
    };
    const combinedClasses2 = [
      "grid grid-cols-3",
      gapClasses[size2],
      hasCustomSize ? `${customWidth} ${customHeight}` : sizeClasses2[size2],
      className
    ].filter(Boolean).join(" ");
    const gridDelays = ["0.2s", "0.3s", "0.4s", "0.1s", "0.2s", "0.3s", "0.0s", "0.1s", "0.2s"];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "status", className: combinedClasses2, ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: text }),
      gridDelays.map((delay3, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `animate-grid-fade rounded-full bg-current ${colorClass} ${dotSizeClasses[size2]}`,
          style: { animationDelay: delay3 }
        },
        i2
      ))
    ] });
  }
  if (variant === "pulsar") {
    const combinedClasses2 = [
      "relative",
      hasCustomSize ? `${customWidth} ${customHeight}` : sizeClasses2[size2],
      className
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "status", className: combinedClasses2, ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: text }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute inset-0 animate-pulsar rounded-full bg-current ${colorClass}` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute inset-0 animate-pulsar rounded-full bg-current ${colorClass}`, style: { animationDelay: "0.6s" } })
    ] });
  }
  if (variant === "dual-ring") {
    const borderSizeClasses2 = {
      xs: "border-2",
      sm: "border-2",
      md: "border-[3px]",
      lg: "border-4",
      xl: "border-4"
    };
    const combinedClasses2 = [
      "relative",
      hasCustomSize ? `${customWidth} ${customHeight}` : sizeClasses2[size2],
      className
    ].filter(Boolean).join(" ");
    const ringClasses = `absolute inset-0 rounded-full border-solid border-current border-t-transparent ${borderSizeClasses2[size2]} ${colorClass}`;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "status", className: combinedClasses2, ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: text }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${ringClasses} animate-spin` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${ringClasses} animate-spin-reverse scale-75` })
    ] });
  }
  if (variant === "bars") {
    const barSizeClasses = {
      xs: "w-0.5",
      sm: "w-1",
      md: "w-1.5",
      lg: "w-2",
      xl: "w-2.5"
    };
    const gapClasses = {
      xs: "gap-0.5",
      sm: "gap-1",
      md: "gap-1.5",
      lg: "gap-1.5",
      xl: "gap-2"
    };
    const combinedClasses2 = [
      "flex items-center justify-center",
      gapClasses[size2],
      hasCustomSize ? `${customWidth} ${customHeight}` : sizeClasses2[size2],
      className
    ].filter(Boolean).join(" ");
    const barColorClass = colorClass?.replace("text-", "bg-") || "bg-brand-orange dark:bg-dark-brand-orange";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "status", className: combinedClasses2, ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: text }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `animate-bar-scale rounded-full h-full ${barColorClass} ${barSizeClasses[size2]}` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `animate-bar-scale rounded-full h-full ${barColorClass} ${barSizeClasses[size2]} [animation-delay:0.2s]` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `animate-bar-scale rounded-full h-full ${barColorClass} ${barSizeClasses[size2]} [animation-delay:0.4s]` }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `animate-bar-scale rounded-full h-full ${barColorClass} ${barSizeClasses[size2]} [animation-delay:0.6s]` })
    ] });
  }
  if (variant === "dots") {
    const dotSizeClasses = {
      xs: "h-1.5 w-1.5",
      sm: "h-2 w-2",
      md: "h-2.5 w-2.5",
      lg: "h-3 w-3",
      xl: "h-4 w-4"
    };
    const gapClasses = {
      xs: "gap-1",
      sm: "gap-1.5",
      md: "gap-2",
      lg: "gap-2.5",
      xl: "gap-3"
    };
    const combinedClasses2 = [
      "flex items-center justify-center",
      gapClasses[size2],
      hasCustomSize ? `${customWidth} ${customHeight}` : sizeClasses2[size2],
      className
    ].filter(Boolean).join(" ");
    const dotColorClass = colorClass?.replace("text-", "bg-") || "bg-brand-orange dark:bg-dark-brand-orange";
    const delays = ["0s", "0.1s", "0.2s"];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "status", className: combinedClasses2, ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: text }),
      delays.map((delay3) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: `animate-bounce rounded-full ${dotColorClass} ${dotSizeClasses[size2]}`,
          style: { animationDelay: delay3 }
        },
        delay3
      ))
    ] });
  }
  if (variant === "logo") {
    const logoSizeClasses = {
      xs: "h-8 w-8",
      sm: "h-12 w-12",
      md: "h-16 w-16",
      lg: "h-20 w-20",
      xl: "h-24 w-24"
    };
    const combinedClasses2 = [
      "logo-spinner flex items-center justify-center",
      hasCustomSize ? `${customWidth} ${customHeight}` : logoSizeClasses[size2],
      className
    ].filter(Boolean).join(" ");
    const logoSVG = /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "svg",
      {
        id: "Layer_2",
        "data-name": "Layer 2",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 247.58 127.88",
        className: "w-full h-full",
        style: { maxWidth: "100%", height: "auto" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `.cls-1 { fill: #22bec9; }
                        .cls-1, .cls-2 { fill-rule: evenodd; }
                        .cls-2 { fill: #344a81; }
                        /* Ensure navy element (svg-elem-1) always stays visible */
                        .svg-elem-1 { fill: #344a81 !important; }` }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "Layer_1-2", "data-name": "Layer 1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "path",
              {
                id: "Path_1",
                "data-name": "Path 1",
                className: "cls-2 svg-elem-1",
                d: "M177.89,10.05l1.72-4.58c.21.32.37.68.45,1.06l44.1,121.32h23.41L201.16,0h-30.97l-.98,2.72-43.44,115.42H0v9.74h133.7L177.89,10.12v-.07Z"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { id: "Group_1", "data-name": "Group 1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  id: "Path_2",
                  "data-name": "Path 2",
                  className: "cls-1 svg-elem-2",
                  d: "M162.33,1.74c-31.22,30.04-45.03,73.89-36.66,116.4,2.51-41.22,15.1-81.19,36.66-116.4Z"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  id: "Path_3",
                  "data-name": "Path 3",
                  className: "cls-1 svg-elem-3",
                  d: "M127.05,0c-20.55,36.6-21.07,81.15-1.36,118.22-9.18-38.93-8.72-79.51,1.36-118.22Z"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  id: "Path_4",
                  "data-name": "Path 4",
                  className: "cls-1 svg-elem-4",
                  d: "M94.28,5.59c-9.36,40.42,2.48,82.83,31.42,112.55-19.5-34.39-30.28-73.03-31.42-112.55Z"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  id: "Path_5",
                  "data-name": "Path 5",
                  className: "cls-1 svg-elem-5",
                  d: "M60.2,19.79c3.69,41.8,28.36,78.87,65.49,98.43-29.55-26.96-52.04-60.76-65.49-98.43Z"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  id: "Path_6",
                  "data-name": "Path 6",
                  className: "cls-1 svg-elem-6",
                  d: "M32.71,39.13c15.5,40.48,50.55,70.28,92.99,79.09-36.99-18.37-68.91-45.53-92.99-79.09Z"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  id: "Path_7",
                  "data-name": "Path 7",
                  className: "cls-1 svg-elem-7",
                  d: "M9.97,63c26.69,36.85,70.26,57.65,115.7,55.22-42.5-8.68-82.22-27.64-115.7-55.22Z"
                }
              )
            ] })
          ] }) })
        ]
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "status", className: combinedClasses2, ...props, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: text }),
      logoSVG
    ] });
  }
  const borderSizeClasses = {
    xs: "border-2",
    sm: "border-2",
    md: "border-[3px]",
    lg: "border-4",
    xl: "border-4"
  };
  const combinedClasses = [
    "animate-spin rounded-full",
    hasCustomSize ? `${customWidth} ${customHeight}` : sizeClasses2[size2],
    borderSizeClasses[size2],
    "border-current",
    colorClass,
    className
  ].filter(Boolean).join(" ");
  const spinnerContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { role: "status", ...props, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: text }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${combinedClasses} border-solid border-b-transparent border-l-transparent` })
  ] });
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      spinnerContent,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: [
        tooltipText,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-900" })
      ] })
    ] });
  }
  return spinnerContent;
};
const SplitButton = ({
  primaryActionLabel,
  onPrimaryClick,
  children,
  variant = "primary",
  size: size2 = "md",
  leftIcon,
  rightIcon,
  isDisabled = false,
  isLoading = false,
  loadingText = "Saving...",
  className = "",
  style,
  dropdownPosition = "bottom-end",
  hasBackground = false,
  isBordered = false,
  isRounded = true,
  hasShadow = false,
  hasBackdropBlur = false,
  hasGlassMorphism = false,
  hasMinHeight = false,
  isFullWidth = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  hasHoverEffect = true,
  hasFocusEffect = true,
  hasActiveEffect = false,
  isTransparent = false,
  hasGradient = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  hasLoadingText = true,
  hasSuccessText = false,
  successText = "Success!",
  hasWarningText = false,
  warningText = "Warning!",
  hasErrorText = false,
  errorText = "Error!",
  hasInfoText = false,
  infoText = "Info",
  hasPadding = false,
  hasMargin = false,
  isCentered = false,
  hasEqualWidthButtons = false,
  isResponsive = true,
  hasContainer = false,
  hasMaxWidth = false,
  hasMinWidth = false,
  hasFixedHeight = false,
  hasFixedWidth = false,
  hasScrollableOverflow = false,
  hasHiddenOverflow = false,
  hasVisibleOverflow = false,
  hasClipOverflow = false,
  hasScrollOverflow = false,
  hasAutoOverflow = false,
  hasInitialOverflow = false,
  hasInheritOverflow = false,
  hasUnsetOverflow = false,
  hasRevertOverflow = false,
  hasRevertLayerOverflow = false,
  hasLabel = false,
  label,
  isLabelHidden = false,
  hasDescription = false,
  description,
  isDescriptionHidden = false,
  hasHelpText = false,
  helpText,
  isHelpTextHidden = false,
  hasValidationMessage = false,
  validationMessage,
  isValidationMessageHidden = false,
  hasRequiredIndicator = false,
  isRequired = false,
  hasDisabledState = false,
  hasReadonlyState = false,
  hasLoadingState = false,
  hasSuccessState = false,
  hasWarningState = false,
  hasErrorState = false,
  hasInfoState = false,
  hasNeutralState = false,
  hasPrimaryState = false,
  hasSecondaryState = false,
  hasTertiaryState = false,
  hasQuaternaryState = false,
  hasQuinaryState = false,
  hasSenaryState = false,
  hasSeptenaryState = false,
  hasOctonaryState = false,
  hasNonaryState = false,
  hasDenaryState = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  onDropdownOpen,
  onDropdownClose,
  onSecondaryActionClick,
  ...props
}) => {
  const backgroundClass = hasBackground ? "bg-white dark:bg-gray-900" : "";
  const borderClass = isBordered ? "border border-gray-200 dark:border-gray-700" : "";
  const roundedClass = isRounded ? "rounded-md" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const backdropClass = hasBackdropBlur ? "backdrop-blur-sm" : "";
  const glassClass = hasGlassMorphism ? "bg-white/20 backdrop-blur-md" : "";
  const minHeightClass = hasMinHeight ? "min-h-32" : "";
  const fullWidthClass = isFullWidth ? "w-full" : "";
  const disabledClass = isDisabled ? "opacity-50 cursor-not-allowed pointer-events-none" : "";
  const transparentClass = isTransparent ? "bg-transparent" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-blue-500 to-purple-600" : "";
  const hoverClass = hasHoverEffect ? "hover:shadow-lg transition-shadow duration-200" : "";
  const focusClass = hasFocusEffect ? "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange focus:outline-none" : "";
  const activeClass = hasActiveEffect ? "active:scale-95 transition-transform duration-100" : "";
  const paddingClass = hasPadding ? "p-2" : "";
  const marginClass = hasMargin ? "m-2" : "";
  const centerClass = isCentered ? "mx-auto" : "";
  const equalWidthClass = hasEqualWidthButtons ? "w-full" : "";
  const responsiveClass = isResponsive ? "" : "flex-col";
  const containerClass = hasContainer ? "container mx-auto" : "";
  const maxWidthClass = hasMaxWidth ? "max-w-7xl" : "";
  const minWidthClass = hasMinWidth ? "min-w-0" : "";
  const fixedHeightClass = hasFixedHeight ? "h-96" : "";
  const fixedWidthClass = hasFixedWidth ? "w-96" : "";
  const overflowClass = hasScrollableOverflow ? "overflow-auto" : hasHiddenOverflow ? "overflow-hidden" : hasVisibleOverflow ? "overflow-visible" : hasClipOverflow ? "overflow-clip" : hasScrollOverflow ? "overflow-scroll" : hasAutoOverflow ? "overflow-auto" : hasInitialOverflow ? "overflow-initial" : hasInheritOverflow ? "overflow-inherit" : hasUnsetOverflow ? "overflow-unset" : hasRevertOverflow ? "overflow-revert" : hasRevertLayerOverflow ? "overflow-revert-layer" : "";
  const stateClasses = [
    isLoading && "animate-pulse",
    isError && "border-red-500 bg-red-50 dark:bg-red-900/20",
    isWarning && "border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20",
    isSuccess && "border-green-500 bg-green-50 dark:bg-green-900/20",
    isInfo && "border-blue-500 bg-blue-50 dark:bg-blue-900/20"
  ].filter(Boolean);
  const combinedClasses = [
    "inline-flex",
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    backdropClass,
    glassClass,
    minHeightClass,
    fullWidthClass,
    disabledClass,
    transparentClass,
    gradientClass,
    hoverClass,
    focusClass,
    activeClass,
    paddingClass,
    marginClass,
    centerClass,
    equalWidthClass,
    responsiveClass,
    containerClass,
    maxWidthClass,
    minWidthClass,
    fixedHeightClass,
    fixedWidthClass,
    overflowClass,
    ...stateClasses,
    className
  ].filter(Boolean).join(" ");
  const splitButtonContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: combinedClasses,
      style: {
        ...style,
        ...customColor && { backgroundColor: customColor }
      },
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      ...props,
      children: [
        hasLabel && label && !isLabelHidden && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "sr-only", children: label }),
        hasDescription && description && !isDescriptionHidden && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sr-only", children: description }),
        hasHelpText && helpText && !isHelpTextHidden && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sr-only", children: helpText }),
        hasValidationMessage && validationMessage && !isValidationMessageHidden && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sr-only", children: validationMessage }),
        isSuccess && hasSuccessText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-green-600 dark:text-green-400", children: successText }),
        isWarning && hasWarningText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-yellow-600 dark:text-yellow-400", children: warningText }),
        isError && hasErrorText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-red-600 dark:text-red-400", children: errorText }),
        isInfo && hasInfoText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-4 text-blue-600 dark:text-blue-400", children: infoText }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            variant,
            size: size2,
            leftIcon: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { size: "sm", color: variant === "primary" ? "white" : "primary" }) : leftIcon,
            rightIcon,
            onClick: onPrimaryClick,
            disabled: isDisabled || isLoading,
            className: "rounded-r-none focus:z-10",
            children: isLoading ? loadingText : primaryActionLabel
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Dropdown, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Trigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button$1,
            {
              variant,
              size: size2,
              disabled: isDisabled || isLoading,
              className: "rounded-l-none -ml-px px-2",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "arrow_drop_down" })
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Content, { position: dropdownPosition, children: React__default.Children.map(children, (child, index2) => {
            if (!React__default.isValidElement(child)) return child;
            const childElement = child;
            return React__default.cloneElement(childElement, {
              onClick: (event) => {
                if (onSecondaryActionClick) onSecondaryActionClick(index2);
                if (childElement.props.onClick) childElement.props.onClick(event);
              }
            });
          }) })
        ] })
      ]
    }
  );
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      splitButtonContent,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-sm text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: tooltipText })
    ] });
  }
  return splitButtonContent;
};
const StackFC = ({
  as,
  children,
  className = "",
  style,
  gap = 4,
  direction = "vertical",
  alignment = "start",
  justify = "start",
  hasBackground = false,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  fullWidth = false,
  hasPadding = false,
  ...rest
}) => {
  const Component2 = as || "div";
  const gapClasses = {
    1: "gap-1",
    2: "gap-2",
    3: "gap-3",
    4: "gap-4",
    5: "gap-5",
    6: "gap-6",
    8: "gap-8",
    10: "gap-10",
    12: "gap-12",
    16: "gap-16",
    20: "gap-20",
    24: "gap-24",
    32: "gap-32"
  };
  const directionClasses = {
    "vertical": "flex-col",
    "horizontal": "flex-row",
    "reverse-vertical": "flex-col-reverse",
    "reverse-horizontal": "flex-row-reverse"
  };
  const alignmentClasses = {
    "start": "items-start",
    "center": "items-center",
    "end": "items-end",
    "stretch": "items-stretch",
    "baseline": "items-baseline"
  };
  const justifyClasses = {
    "start": "justify-start",
    "center": "justify-center",
    "end": "justify-end",
    "between": "justify-between",
    "around": "justify-around",
    "evenly": "justify-evenly"
  };
  const backgroundClass = hasBackground ? "bg-white dark:bg-gray-900" : "";
  const borderClass = isBordered ? "border border-gray-200 dark:border-gray-700" : "";
  const roundedClass = isRounded ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const fullWidthClass = fullWidth ? "w-full" : "";
  const paddingClass = hasPadding ? "p-6" : "";
  const combinedClasses = [
    "flex",
    directionClasses[direction],
    gapClasses[gap],
    alignmentClasses[alignment],
    justifyClasses[justify],
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    fullWidthClass,
    paddingClass,
    className
  ].filter(Boolean).join(" ");
  const stackContent = /* @__PURE__ */ jsxRuntimeExports.jsx(
    Component2,
    {
      className: combinedClasses,
      style,
      ...rest,
      children
    }
  );
  return stackContent;
};
const Stack = StackFC;
const STEPPER_DRAW_STYLES = /* @__PURE__ */ jsxRuntimeExports.jsx("style", { dangerouslySetInnerHTML: { __html: `
@keyframes acutrack-stepper-draw-h {
  0% { transform: scaleX(0); opacity: 1; }
  60% { transform: scaleX(1); opacity: 1; }
  65% { transform: scaleX(1); opacity: 1; }
  66% { transform: scaleX(1); opacity: 0; }
  67% { transform: scaleX(0); opacity: 1; }
  100% { transform: scaleX(0); opacity: 1; }
}
@keyframes acutrack-stepper-draw-v {
  0% { transform: scaleY(0); opacity: 1; }
  60% { transform: scaleY(1); opacity: 1; }
  65% { transform: scaleY(1); opacity: 1; }
  66% { transform: scaleY(1); opacity: 0; }
  67% { transform: scaleY(0); opacity: 1; }
  100% { transform: scaleY(0); opacity: 1; }
}
  ` } });
const StepperContext = createContext(null);
const StepperStep = ({
  stepNumber: propStepNumber,
  title,
  description,
  badge,
  icon,
  completedIcon,
  status: propStatus,
  isClickable = false,
  isDisabled = false,
  isRequired = false,
  className = "",
  style,
  onClick,
  // Legacy props
  isSelected,
  hasErrors,
  hasWarnings,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress
}) => {
  const context = useContext(StepperContext);
  if (!context) throw new Error("Stepper.Step must be used within a Stepper");
  const { currentStep, totalSteps, orientation, size: size2, color: color2, indicatorShape = "circle", animateNextConnector = false } = context;
  const stepNumber = propStepNumber ?? 1;
  const isCompleted = stepNumber < currentStep;
  const isActive = stepNumber === currentStep;
  let status = "future";
  if (propStatus) {
    status = propStatus;
  } else if (hasErrors) {
    status = "error";
  } else if (hasWarnings) {
    status = "warning";
  } else if (isCompleted) {
    status = "completed";
  } else if (isActive || isSelected) {
    status = "active";
  }
  const sizeConfigs2 = {
    xs: { circle: "w-6 h-6 text-xs", text: "text-xs", line: "h-8" },
    sm: { circle: "w-8 h-8 text-sm", text: "text-sm", line: "h-10" },
    md: { circle: "w-10 h-10 text-lg", text: "text-base", line: "h-16" },
    lg: { circle: "w-12 h-12 text-xl", text: "text-lg", line: "h-20" },
    xl: { circle: "w-14 h-14 text-2xl", text: "text-xl", line: "h-24" }
  };
  const sizeConfig2 = sizeConfigs2[size2];
  const colorStepStyles = {
    primary: { completed: "bg-brand-orange dark:bg-dark-brand-orange text-white", active: "border-2 border-brand-orange dark:border-dark-brand-orange text-brand-orange dark:text-dark-brand-orange bg-transparent", connector: "bg-brand-orange dark:bg-dark-brand-orange" },
    secondary: { completed: "bg-gray-500 dark:bg-gray-400 text-white", active: "border-2 border-gray-500 dark:border-gray-400 text-gray-600 dark:text-gray-300 bg-transparent", connector: "bg-gray-500 dark:bg-gray-400" },
    success: { completed: "bg-system-success text-white", active: "border-2 border-system-success text-system-success bg-transparent", connector: "bg-system-success" },
    warning: { completed: "bg-system-warning-border dark:bg-system-warning text-white", active: "border-2 border-system-warning-border dark:border-system-warning text-system-warning-dark dark:text-system-warning-light-text bg-system-warning-light/30 dark:bg-system-warning-dark-bg/30", connector: "bg-system-warning-border dark:bg-system-warning" },
    danger: { completed: "bg-system-error text-white", active: "border-2 border-system-error text-system-error bg-transparent", connector: "bg-system-error" },
    info: { completed: "bg-system-info text-white", active: "border-2 border-system-info text-system-info bg-transparent", connector: "bg-system-info" },
    neutral: { completed: "bg-gray-400 dark:bg-gray-500 text-white", active: "border-2 border-gray-400 dark:border-gray-500 text-gray-600 dark:text-gray-300 bg-transparent", connector: "bg-gray-400 dark:bg-gray-500" }
  };
  const accent = colorStepStyles[color2];
  const accentInsetOutline = {
    primary: "shadow-[inset_0_0_0_2px_#0d9488] dark:shadow-[inset_0_0_0_2px_#0d9488]",
    secondary: "shadow-[inset_0_0_0_2px_rgb(107_114_128)] dark:shadow-[inset_0_0_0_2px_rgb(156_163_175)]",
    success: "shadow-[inset_0_0_0_2px_#23C27D] dark:shadow-[inset_0_0_0_2px_#23C27D]",
    warning: "shadow-[inset_0_0_0_2px_#fbbf24] dark:shadow-[inset_0_0_0_2px_#f3c94f]",
    danger: "shadow-[inset_0_0_0_2px_#ba4335] dark:shadow-[inset_0_0_0_2px_#ba4335]",
    info: "shadow-[inset_0_0_0_2px_#3266d4] dark:shadow-[inset_0_0_0_2px_#3266d4]",
    neutral: "shadow-[inset_0_0_0_2px_rgb(156_163_175)] dark:shadow-[inset_0_0_0_2px_rgb(107_114_128)]"
  };
  const statusClasses = {
    completed: accent.completed,
    active: accent.active,
    future: "bg-bg-tertiary dark:bg-dark-bg-tertiary border-2 border-transparent text-text-secondary dark:text-dark-text-secondary",
    error: "bg-system-error text-white",
    warning: "bg-system-warning-light dark:bg-system-warning-dark-bg text-system-warning-dark dark:text-system-warning-light-text"
  };
  const isHorizontal = orientation === "horizontal";
  const showLine = stepNumber < totalSteps;
  const connectorActive = status === "completed";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: cn(
        "flex transition-opacity duration-200",
        isHorizontal ? "flex-1 min-w-0 flex-col items-start" : "items-start",
        isClickable && !isDisabled && "cursor-pointer",
        isDisabled && "opacity-50 cursor-not-allowed",
        !isDisabled && status === "future" && "opacity-60",
        className
      ),
      style,
      onClick: !isDisabled ? onClick : void 0,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn(
          "flex",
          isHorizontal ? "w-full flex-row items-center flex-1" : "flex-col items-center mr-4 shrink-0"
        ), children: [
          (() => {
            const isCircle = indicatorShape === "circle";
            const isSquare = indicatorShape === "square";
            const isTriangle = indicatorShape === "triangle";
            const isDiamond = indicatorShape === "diamond";
            const isFuture = status === "future";
            const isActiveOrCompleted = status === "active" || status === "completed";
            const outlineClass = (isTriangle || isDiamond) && isFuture ? "shadow-[inset_0_0_0_2px_rgb(203_213_225)] dark:shadow-[inset_0_0_0_2px_rgb(148_163_184)]" : (isTriangle || isDiamond) && isActiveOrCompleted ? accentInsetOutline[color2] : "";
            const shapeClasses = cn(
              "flex items-center justify-center font-bold transition-all duration-200 shrink-0",
              sizeConfig2.circle,
              statusClasses[status],
              isCircle && "rounded-full",
              isSquare && "rounded-md",
              isTriangle && "rounded-none",
              isDiamond && "rounded-none",
              outlineClass
            );
            const shapeStyle = { ...isTriangle ? { clipPath: "polygon(50% 0%, 100% 100%, 0% 100%)" } : isDiamond ? { clipPath: "polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)" } : {} };
            const contentNudge = isTriangle ? { transform: "translateY(8%)" } : {};
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: shapeClasses, style: shapeStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-flex items-center justify-center", style: contentNudge, children: status === "completed" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: size2 === "xs" ? "sm" : size2 === "sm" ? "md" : "lg", children: completedIcon ?? "check" }) : icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: size2 === "xs" ? "sm" : size2 === "sm" ? "md" : "lg", children: icon }) : stepNumber }) });
          })(),
          showLine && (() => {
            const isNextPendingConnector = !connectorActive && isActive && animateNextConnector;
            const connectorSizeClasses = isHorizontal ? "h-0.5 flex-1 min-w-0" : cn("w-0.5 mt-2", sizeConfig2.line);
            if (isNextPendingConnector) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: cn(
                    "relative overflow-hidden transition-colors duration-200 bg-border-color dark:bg-dark-border-color",
                    connectorSizeClasses
                  ),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: cn("absolute inset-0 w-full h-full", accent.connector),
                      style: {
                        transformOrigin: isHorizontal ? "left center" : "center top",
                        animation: isHorizontal ? "acutrack-stepper-draw-h 1.2s ease-out infinite" : "acutrack-stepper-draw-v 1.2s ease-out infinite"
                      }
                    }
                  )
                }
              );
            }
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: cn(
                  "transition-colors duration-200",
                  connectorActive ? accent.connector : "bg-border-color dark:bg-dark-border-color",
                  connectorSizeClasses
                )
              }
            );
          })()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn(
          isHorizontal ? "mt-2 text-left w-full" : "min-w-0 flex-1",
          !isHorizontal && "pt-0.5"
        ), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: cn(
            "font-semibold transition-colors duration-200",
            sizeConfig2.text,
            isActive || status === "completed" ? "text-text-primary dark:text-dark-text-primary" : "text-text-secondary dark:text-dark-text-secondary"
          ), children: [
            title,
            isRequired && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
          ] }),
          (description || badge != null) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn(
            "flex items-center gap-2 flex-wrap mt-0.5",
            size2 === "xs" || size2 === "sm" ? "text-xs" : "text-sm"
          ), children: [
            description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-text-secondary dark:text-dark-text-secondary m-0", children: description }),
            badge != null && (typeof badge === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { size: "sm", variant: "default", color: "primary", children: badge }) : badge)
          ] })
        ] })
      ]
    }
  );
};
const variantContainerClasses = {
  default: "",
  minimal: "bg-transparent",
  bordered: "p-6 rounded-lg border border-border-color dark:border-dark-border-color bg-bg-secondary dark:bg-dark-bg-tertiary",
  outlined: "p-6 rounded-lg border-2 border-border-color dark:border-dark-border-color bg-transparent"
};
const StepperRoot = ({
  currentStep,
  children,
  size: size2 = "md",
  orientation = "horizontal",
  color: color2 = "primary",
  variant = "default",
  indicatorShape = "circle",
  animateNextConnector = false,
  className = "",
  style,
  // Legacy props (ignored but accepted for backward compatibility)
  isDisabled: _isDisabled,
  hasBackground: _hasBackground,
  isBordered: _isBordered,
  isRounded: _isRounded,
  hasShadow: _hasShadow,
  hasHoverEffect: _hasHoverEffect,
  hasFocusEffect: _hasFocusEffect,
  hasActiveEffect: _hasActiveEffect,
  isTransparent: _isTransparent,
  hasPadding: _hasPadding,
  hasMargin: _hasMargin,
  isCentered: _isCentered,
  isResponsive: _isResponsive,
  hasContainer: _hasContainer,
  hasMaxWidth: _hasMaxWidth,
  hasMinWidth: _hasMinWidth,
  hasFixedHeight: _hasFixedHeight,
  hasFixedWidth: _hasFixedWidth,
  isFullWidth,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  hasStepNumbers: _hasStepNumbers,
  hasStepTitles: _hasStepTitles,
  hasStepDescriptions: _hasStepDescriptions,
  hasStepIcons: _hasStepIcons,
  hasStepLines: _hasStepLines,
  hasStepBadges: _hasStepBadges,
  hasStepProgress: _hasStepProgress,
  hasStepValidation: _hasStepValidation,
  hasStepErrors: _hasStepErrors,
  hasStepWarnings: _hasStepWarnings,
  hasStepSuccess: _hasStepSuccess,
  hasStepInfo: _hasStepInfo,
  hasStepNeutral: _hasStepNeutral,
  hasStepPrimary: _hasStepPrimary,
  hasStepSecondary: _hasStepSecondary,
  hasStepOutline: _hasStepOutline,
  hasStepGhost: _hasStepGhost,
  hasStepText: _hasStepText
}) => {
  const childArray = React__default.Children.toArray(children);
  const totalSteps = childArray.length;
  const childrenWithProps = React__default.Children.map(children, (child, index2) => {
    if (React__default.isValidElement(child)) {
      return React__default.cloneElement(child, {
        stepNumber: index2 + 1
      });
    }
    return child;
  });
  const isHorizontal = orientation === "horizontal";
  const effectiveVariant = variant && ["default", "minimal", "bordered", "outlined"].includes(variant) ? variant : "default";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(StepperContext.Provider, { value: { currentStep, totalSteps, orientation, size: size2, color: color2, variant: effectiveVariant, indicatorShape, animateNextConnector }, children: [
    animateNextConnector && STEPPER_DRAW_STYLES,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: cn(
          variantContainerClasses[effectiveVariant],
          "flex",
          isHorizontal ? "flex-row items-start w-full" : "flex-col space-y-0",
          isFullWidth && "w-full",
          className
        ),
        style,
        onClick,
        onFocus,
        onBlur,
        onMouseEnter,
        onMouseLeave,
        onMouseDown,
        onMouseUp,
        onDoubleClick,
        onKeyDown,
        onKeyUp,
        onKeyPress,
        children: childrenWithProps
      }
    )
  ] });
};
const Stepper = Object.assign(StepperRoot, { Step: StepperStep });
const SubSection = ({
  title,
  children,
  containerClassName = "",
  contentClassName = "",
  titleClassName = "",
  loadingClassName = "",
  statusClassName = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  isFullWidth = false,
  isCollapsed = false,
  isExpanded = false,
  isVisible = true,
  isHidden: isHidden3 = false,
  isTransparent = false,
  isOpaque = false,
  hasBackground = false,
  hasBorder = false,
  hasRoundedCorners = false,
  hasShadow = false,
  hasBackdropBlur = false,
  hasGlassEffect = false,
  hasGradient = false,
  hasFocusRing = false,
  hasMinHeight = false,
  hasHoverEffect = false,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isDisabled = false,
  isReadOnly = false,
  isRequired = false,
  isValid: isValid2 = true,
  isInvalid = false,
  isPending = false,
  isBusy = false,
  isReady = true,
  isMounted = true,
  isUnmounted = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  customColor,
  hasTooltip = false,
  tooltipText,
  hasLoadingText = false,
  loadingText = "Loading...",
  hasSuccessText = false,
  successText = "Success!",
  hasWarningText = false,
  warningText = "Warning!",
  hasErrorText = false,
  errorText = "Error!",
  hasInfoText = false,
  infoText = "Info",
  hasTitle = true,
  isTitleEmphasized = false,
  isTitleCentered = false,
  hasTitleUnderline = false,
  hasTitleIcon = false,
  titleIcon,
  hasPadding = true,
  hasMargin = true,
  isCollapsible = false,
  isInitiallyExpanded = true,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  onExpansionChange,
  onScroll,
  onResize,
  onMount,
  onUnmount,
  onStateChange,
  onVariantChange,
  onSizeChange,
  onColorChange,
  ...props
}) => {
  const sizeClasses2 = {
    xs: "max-w-xs",
    sm: "max-w-sm",
    md: "max-w-md",
    lg: "max-w-lg",
    xl: "max-w-xl",
    "2xl": "max-w-2xl",
    full: "max-w-full"
  };
  const variantClasses2 = {
    default: "",
    card: "bg-white dark:bg-dark-bg-primary rounded-lg shadow-md",
    panel: "bg-bg-secondary dark:bg-dark-bg-secondary rounded-lg border border-border-color dark:border-dark-border-color",
    bordered: "border-2 border-border-color dark:border-dark-border-color",
    elevated: "bg-white dark:bg-dark-bg-primary rounded-lg shadow-lg",
    minimal: "bg-transparent",
    accented: "bg-brand-orange/10 dark:bg-dark-brand-orange/10 border-l-4 border-brand-orange dark:border-dark-brand-orange"
  };
  const colorClasses2 = {
    primary: "border-brand-navy dark:border-dark-brand-orange",
    success: "border-system-success",
    warning: "border-system-warning-border dark:border-system-warning",
    danger: "border-system-error",
    info: "border-system-info"
  };
  const backgroundClass = hasBackground ? "bg-white dark:bg-gray-900" : "";
  const borderClass = hasBorder ? `border ${colorClasses2[color2]}` : "";
  const roundedClass = hasRoundedCorners ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const backdropClass = hasBackdropBlur ? "backdrop-blur-sm" : "";
  const glassClass = hasGlassEffect ? "bg-white/20 backdrop-blur-md" : "";
  const minHeightClass = hasMinHeight ? "min-h-32" : "";
  const fullWidthClass = isFullWidth ? "w-full" : "";
  const collapsedClass = isCollapsed ? "max-h-0 overflow-hidden" : "";
  const expandedClass = isExpanded ? "max-h-full" : "";
  const visibleClass = isVisible ? "opacity-100" : "opacity-0";
  const hiddenClass = isHidden3 ? "hidden" : "";
  const transparentClass = isTransparent ? "bg-transparent" : "";
  const opaqueClass = isOpaque ? "bg-opacity-100" : "";
  const gradientClass = hasGradient ? "bg-gradient-to-r from-blue-500 to-purple-600" : "";
  const focusRingClass = hasFocusRing ? "focus:ring-2 focus:ring-brand-orange focus:ring-offset-2" : "";
  const hoverClass = hasHoverEffect ? "hover:shadow-lg transition-shadow duration-200" : "";
  const focusEffectClass = hasFocusEffect ? "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange focus:outline-none" : "";
  const activeClass = hasActiveEffect ? "active:scale-95 transition-transform duration-100" : "";
  const disabledClass = isDisabled ? "opacity-50 cursor-not-allowed pointer-events-none" : "";
  const readOnlyClass = isReadOnly ? "opacity-80" : "";
  const requiredClass = isRequired ? "border-2 border-system-error" : "";
  const validClass = isValid2 ? "border-2 border-system-success" : "";
  const invalidClass = isInvalid ? "border-2 border-system-error" : "";
  const pendingClass = isPending ? "animate-pulse" : "";
  const busyClass = isBusy ? "animate-spin" : "";
  const readyClass = isReady ? "opacity-100" : "opacity-50";
  const mountedClass = isMounted ? "opacity-100" : "opacity-0";
  const unmountedClass = isUnmounted ? "hidden" : "";
  const paddingClass = hasPadding ? "p-6" : "";
  const marginClass = hasMargin ? "mb-12" : "";
  const stateClasses = [
    isLoading && "animate-pulse",
    isError && `border-2 ${colorClasses2.danger} bg-system-error/10`,
    isWarning && `border-2 ${colorClasses2.warning} bg-system-warning-light/50 dark:bg-system-warning-dark-bg/20`,
    isSuccess && `border-2 ${colorClasses2.success} bg-system-success/10`,
    isInfo && `border-2 ${colorClasses2.info} bg-system-info/10`
  ].filter(Boolean);
  const titleClasses = [
    "component-title",
    isTitleEmphasized && "font-bold text-xl",
    isTitleCentered && "text-center",
    hasTitleUnderline && "border-b-2 border-gray-300 pb-2",
    titleClassName
  ].filter(Boolean).join(" ");
  const combinedClasses = [
    sizeClasses2[size2],
    variantClasses2[variant],
    marginClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    backdropClass,
    glassClass,
    minHeightClass,
    fullWidthClass,
    collapsedClass,
    expandedClass,
    visibleClass,
    hiddenClass,
    transparentClass,
    opaqueClass,
    gradientClass,
    focusRingClass,
    hoverClass,
    focusEffectClass,
    activeClass,
    disabledClass,
    readOnlyClass,
    requiredClass,
    validClass,
    invalidClass,
    pendingClass,
    busyClass,
    readyClass,
    mountedClass,
    unmountedClass,
    paddingClass,
    ...stateClasses,
    containerClassName
  ].filter(Boolean).join(" ");
  const subSectionContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: combinedClasses,
      style: {
        ...style,
        ...customColor && { backgroundColor: customColor }
      },
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onKeyDown,
      onKeyUp,
      onKeyPress,
      onScroll,
      ...props,
      children: [
        hasTitle && title && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mb-4", children: [
          hasTitleIcon && titleIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mr-2 text-gray-600 dark:text-gray-400", children: titleIcon }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: titleClasses, children: title })
        ] }),
        isLoading && hasLoadingText && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center justify-center py-8 ${loadingClassName}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-2 border-current border-t-transparent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-gray-600 dark:text-gray-400", children: loadingText })
        ] }),
        isSuccess && hasSuccessText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `text-center py-4 text-green-600 dark:text-green-400 ${statusClassName}`, children: successText }),
        isWarning && hasWarningText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `text-center py-4 text-yellow-600 dark:text-yellow-400 ${statusClassName}`, children: warningText }),
        isError && hasErrorText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `text-center py-4 text-red-600 dark:text-red-400 ${statusClassName}`, children: errorText }),
        isInfo && hasInfoText && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `text-center py-4 text-blue-600 dark:text-blue-400 ${statusClassName}`, children: infoText }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: contentClassName, children })
      ]
    }
  );
  if (hasTooltip && tooltipText) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
      subSectionContent,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-sm text-white bg-gray-900 rounded opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none whitespace-nowrap z-10", children: tooltipText })
    ] });
  }
  return subSectionContent;
};
const MIN_TABLE_CELL_PX = 48;
const TableContext = React__default.createContext({
  striped: false,
  hoverable: false,
  cellPadding: "md",
  headerPadding: "md"
});
const useTableContext = () => React__default.useContext(TableContext);
const TableRoot = ({
  children,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  color: color2 = "primary",
  isStriped = false,
  isHoverable = false,
  isCompact = false,
  isBordered = true,
  isRounded = true,
  hasShadow = false,
  isResponsive = true,
  hasFixedWidth = false,
  isFullWidth = true,
  tableLayout = "fixed",
  allowHorizontalScroll = true,
  cellPadding = "md",
  headerPadding = "md"
}) => {
  const sizeClasses2 = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-sm",
    lg: "text-base",
    xl: "text-lg"
  };
  const colorClasses2 = {
    primary: "text-text-secondary dark:text-dark-text-secondary",
    success: "text-system-success-dark dark:text-system-success-light-text",
    warning: "text-system-warning-dark dark:text-system-warning-light-text",
    danger: "text-system-error-dark dark:text-system-error-light-text",
    info: "text-system-info-dark dark:text-system-info-light-text",
    neutral: "text-text-secondary dark:text-dark-text-secondary"
  };
  const combinedClasses = `
        relative overflow-x-auto w-full custom-scrollbar
        ${allowHorizontalScroll ? "min-w-0" : ""}
        ${isRounded ? "rounded-lg" : ""}
        ${isBordered ? "border border-border-color dark:border-dark-border-color" : ""}
        ${hasShadow ? "shadow-md" : ""}
        ${isResponsive ? "overflow-x-auto" : ""}
        ${hasFixedWidth ? "" : "w-full"}
        ${isFullWidth ? "w-full" : ""}
        ${containerClassName}
    `.trim().replace(/\s+/g, " ");
  const effectiveLayout = allowHorizontalScroll ? "auto" : tableLayout;
  const tableClasses = `
        text-left
        ${allowHorizontalScroll ? "w-full min-w-max" : "w-full"}
        ${effectiveLayout === "fixed" ? "table-fixed" : ""}
        ${sizeClasses2[size2]}
        ${colorClasses2[color2]}
        ${isCompact ? "text-xs" : ""}
        ${className}
    `.trim().replace(/\s+/g, " ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: combinedClasses, style, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableContext.Provider, { value: {
    striped: isStriped,
    hoverable: isHoverable,
    cellPadding,
    headerPadding
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: tableClasses, children }) }) });
};
TableRoot.displayName = "Table.Root";
const TableHeader = ({
  children,
  containerClassName = "",
  className = "",
  style,
  headerHeight,
  hasBorder = true,
  hasBackground = true,
  isRounded = false,
  isSticky = false,
  isCollapsible = false,
  isCollapsed = false,
  ...props
}) => {
  const headerClasses = `
        text-xs text-text-primary dark:text-dark-text-primary uppercase
        ${hasBackground ? "bg-table-header dark:bg-dark-table-header" : ""}
        ${hasBorder ? "border-b border-border-color dark:border-dark-border-color" : ""}
        ${isRounded ? "rounded-t-lg" : ""}
        ${isSticky ? "sticky top-0 z-10" : ""}
        ${isCollapsible && isCollapsed ? "hidden" : ""}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  const resolvedHeight = headerHeight != null ? typeof headerHeight === "number" ? `${headerHeight}px` : headerHeight : void 0;
  const headerStyle = resolvedHeight ? { ...style, height: resolvedHeight, minHeight: resolvedHeight } : style;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: headerClasses, style: headerStyle, ...props, children });
};
TableHeader.displayName = "Table.Header";
const TableBody = ({
  children,
  containerClassName = "",
  className = "",
  style,
  hasBorder = true,
  hasBackground = true,
  hasDividers = true,
  hasAlternatingColors = false,
  isScrollable = false,
  hasFixedHeight = false,
  ...props
}) => {
  const bodyClasses = `
        ${hasBackground ? "bg-bg-secondary dark:bg-dark-bg-secondary" : ""}
        ${hasDividers ? "divide-y divide-border-color dark:divide-dark-border-subtle" : ""}
        ${hasAlternatingColors ? "even:bg-bg-tertiary/50 dark:even:bg-dark-bg-tertiary/30" : ""}
        ${isScrollable ? "overflow-y-auto custom-scrollbar" : ""}
        ${hasFixedHeight ? "max-h-96" : ""}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { className: bodyClasses, style, ...props, children });
};
TableBody.displayName = "Table.Body";
const TableFooter = ({
  children,
  containerClassName = "",
  className = "",
  style,
  hasBorder = true,
  hasBackground = true,
  isRounded = false,
  isSticky = false,
  isCollapsible = false,
  isCollapsed = false,
  ...props
}) => {
  const footerClasses = `
        text-xs text-text-secondary dark:text-dark-text-secondary
        ${hasBackground ? "bg-table-header dark:bg-dark-table-header" : ""}
        ${hasBorder ? "border-t border-border-color dark:border-dark-border-color" : ""}
        ${isRounded ? "rounded-b-lg" : ""}
        ${isSticky ? "sticky bottom-0 z-10" : ""}
        ${isCollapsible && isCollapsed ? "hidden" : ""}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("tfoot", { className: footerClasses, style, ...props, children });
};
TableFooter.displayName = "Table.Footer";
const TableRow = ({
  children,
  containerClassName = "",
  className = "",
  style,
  isSelected = false,
  selectionColor = "primary",
  isHighlighted = false,
  highlightColor = "primary",
  isDisabled = false,
  hasHoverEffect = true,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isClickable = false,
  ...props
}) => {
  const { striped, hoverable } = useTableContext();
  const hoverClasses = hoverable && hasHoverEffect ? "hover:bg-bg-tertiary/80 dark:hover:bg-dark-bg-tertiary/60" : "";
  const stripedClasses = striped ? "even:bg-bg-tertiary/50 dark:even:bg-dark-bg-tertiary/30" : "";
  const selectionColorClasses = {
    primary: "!bg-brand-orange/10 dark:!bg-dark-brand-orange/10",
    secondary: "!bg-brand-navy/10 dark:!bg-dark-brand-navy/10",
    success: "!bg-system-success/10 dark:!bg-system-success/20",
    warning: "!bg-system-warning/10 dark:!bg-system-warning/20",
    error: "!bg-system-error/10 dark:!bg-system-error/20",
    info: "!bg-system-info/10 dark:!bg-system-info/20"
  };
  const selectedClasses = isSelected ? selectionColorClasses[selectionColor] : "";
  const disabledClasses = isDisabled ? "opacity-50 cursor-not-allowed" : "";
  const clickableClasses = isClickable ? "cursor-pointer" : "";
  const highlightClasses = isHighlighted ? {
    primary: "!bg-brand-orange/10 dark:!bg-dark-brand-orange/10",
    secondary: "!bg-brand-navy/10 dark:!bg-dark-brand-navy/10",
    success: "!bg-system-success/10 dark:!bg-system-success/20",
    warning: "!bg-system-warning/10 dark:!bg-system-warning/20",
    error: "!bg-system-error/10 dark:!bg-system-error/20",
    info: "!bg-system-info/10 dark:!bg-system-info/20"
  }[highlightColor] : "";
  const focusRingClasses = isClickable ? "outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange" : "";
  const combinedClasses = `
        transition-colors
        ${hoverClasses}
        ${stripedClasses}
        ${selectedClasses}
        ${highlightClasses}
        ${disabledClasses}
        ${clickableClasses}
        ${focusRingClasses}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  const handleRowKeyDown = (e2) => {
    if (isClickable && (e2.key === "Enter" || e2.key === " ")) {
      e2.preventDefault();
      props.onClick?.(e2);
    }
    props.onKeyDown?.(e2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "tr",
    {
      className: combinedClasses,
      style,
      ...isDisabled ? { "aria-disabled": true } : {},
      ...props,
      ...isClickable ? { role: "button", tabIndex: 0, onKeyDown: handleRowKeyDown } : {},
      children
    }
  );
};
TableRow.displayName = "Table.Row";
const TableHeadCell = ({
  children,
  containerClassName = "",
  className = "",
  style,
  scope = "col",
  isSortable = false,
  isSorted = false,
  sortDirection = null,
  isResizable = false,
  hasFixedWidth = false,
  width,
  isCentered = false,
  isRightAligned = false,
  headerActions,
  headerRender,
  headerIcon,
  headerText,
  showHeaderIcon = true,
  showHeaderText = true,
  ...props
}) => {
  const { headerPadding } = useTableContext();
  const paddingClasses = {
    none: "p-0",
    sm: "px-3 py-2",
    md: "px-6 py-4",
    lg: "px-8 py-6",
    xl: "px-10 py-8"
  };
  const focusRingClasses = isSortable ? "outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange" : "";
  const cellClasses = `
        ${paddingClasses[headerPadding]} font-bold
        ${isSortable ? "cursor-pointer select-none" : ""}
        ${isSorted ? "bg-table-header/50 dark:bg-dark-table-header/30" : ""}
        ${isResizable ? "resize-x overflow-hidden" : ""}
        ${hasFixedWidth ? "w-0" : ""}
        ${isCentered ? "text-center" : ""}
        ${isRightAligned ? "text-right" : ""}
        ${focusRingClasses}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  const widthStyle = width != null ? typeof width === "number" ? (() => {
    const px2 = Math.max(width, MIN_TABLE_CELL_PX);
    return { width: `${px2}px`, minWidth: `${px2}px` };
  })() : { width, minWidth: width } : void 0;
  const handleHeadCellKeyDown = (e2) => {
    if (isSortable && (e2.key === "Enter" || e2.key === " ")) {
      e2.preventDefault();
      props.onClick?.(e2);
    }
    props.onKeyDown?.(e2);
  };
  if (headerRender) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "th",
      {
        scope,
        className: cellClasses,
        style: widthStyle ? { ...style, ...widthStyle } : style,
        ...props,
        ...isSortable ? { role: "button", tabIndex: 0, onKeyDown: handleHeadCellKeyDown } : {},
        children: headerRender({
          headerIcon,
          headerText,
          showHeaderIcon,
          showHeaderText,
          headerActions,
          isSortable,
          sortDirection
        })
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "th",
    {
      scope,
      className: cellClasses,
      style: widthStyle ? { ...style, ...widthStyle } : style,
      ...props,
      ...isSortable ? { role: "button", tabIndex: 0, onKeyDown: handleHeadCellKeyDown } : {},
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between w-full min-w-0 overflow-hidden", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          showHeaderIcon && headerIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: headerIcon }),
          showHeaderText && headerText && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: headerText }),
          !headerText && children
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
          isSortable && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xs", children: sortDirection === "asc" ? "keyboard_arrow_up" : sortDirection === "desc" ? "keyboard_arrow_down" : "unfold_more" }),
          headerActions
        ] })
      ] })
    }
  );
};
TableHeadCell.displayName = "Table.HeadCell";
const TableCell = ({
  children,
  containerClassName = "",
  className = "",
  style,
  isHighlighted = false,
  highlightColor = "primary",
  isClickable = false,
  hasFixedWidth = false,
  width,
  isCentered = false,
  isRightAligned = false,
  isTruncated = false,
  hasTooltip = false,
  tooltipText,
  ...props
}) => {
  const { cellPadding } = useTableContext();
  const paddingClasses = {
    none: "p-0",
    sm: "px-3 py-2",
    md: "px-6 py-4",
    lg: "px-8 py-6",
    xl: "px-10 py-8"
  };
  const highlightClasses = isHighlighted ? {
    primary: "!bg-brand-orange/10 dark:!bg-dark-brand-orange/10",
    secondary: "!bg-brand-navy/10 dark:!bg-dark-brand-navy/10",
    success: "!bg-system-success/10 dark:!bg-system-success/20",
    warning: "!bg-system-warning/10 dark:!bg-system-warning/20",
    error: "!bg-system-error/10 dark:!bg-system-error/20",
    info: "!bg-system-info/10 dark:!bg-system-info/20"
  }[highlightColor] : "";
  const focusRingClasses = isClickable ? "outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-brand-orange dark:focus-visible:ring-dark-brand-orange" : "";
  const cellClasses = `
        ${paddingClasses[cellPadding]}
        ${highlightClasses}
        ${isClickable ? "cursor-pointer" : ""}
        ${focusRingClasses}
        ${hasFixedWidth ? "w-0" : ""}
        ${isCentered ? "text-center" : ""}
        ${isRightAligned ? "text-right" : ""}
        ${isTruncated ? "truncate" : ""}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  const cellWidthStyle = width != null ? typeof width === "number" ? (() => {
    const px2 = Math.max(width, MIN_TABLE_CELL_PX);
    return { width: `${px2}px`, minWidth: `${px2}px` };
  })() : { width, minWidth: width } : void 0;
  const handleCellKeyDown = (e2) => {
    if (isClickable && (e2.key === "Enter" || e2.key === " ")) {
      e2.preventDefault();
      props.onClick?.(e2);
    }
    props.onKeyDown?.(e2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "td",
    {
      className: cellClasses,
      style: cellWidthStyle ? { ...style, ...cellWidthStyle } : style,
      ...hasTooltip && tooltipText ? { title: tooltipText } : {},
      ...props,
      ...isClickable ? { role: "button", tabIndex: 0, onKeyDown: handleCellKeyDown } : {},
      children
    }
  );
};
TableCell.displayName = "Table.Cell";
const TableCheckbox = ({
  id: id2,
  label,
  containerClassName = "",
  className = "",
  style,
  isHeader = false,
  isDisabled = false,
  isChecked = false,
  isIndeterminate = false,
  hasLabel = true,
  hasTooltip = false,
  tooltipText,
  ...props
}) => {
  const { cellPadding, headerPadding } = useTableContext();
  const CellComponent = isHeader ? "th" : "td";
  const paddingClasses = {
    none: "p-0",
    sm: "px-3 py-2",
    md: "px-6 py-4",
    lg: "px-8 py-6",
    xl: "px-10 py-8"
  };
  const cellClasses = `
        ${isHeader ? paddingClasses[headerPadding] : paddingClasses[cellPadding]} w-4
        ${isDisabled ? "opacity-50" : ""}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    CellComponent,
    {
      scope: isHeader ? "col" : void 0,
      className: cellClasses,
      style,
      ...hasTooltip && tooltipText ? { title: tooltipText } : {},
      children: [
        hasLabel && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, className: "sr-only", children: label }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RawCheckbox,
          {
            id: id2,
            checked: isChecked,
            disabled: isDisabled,
            ...props
          }
        )
      ]
    }
  );
};
TableCheckbox.displayName = "Table.Checkbox";
const Table = Object.assign(TableRoot, {
  Header: TableHeader,
  Body: TableBody,
  Footer: TableFooter,
  Row: TableRow,
  HeadCell: TableHeadCell,
  Cell: TableCell,
  Checkbox: TableCheckbox
});
const TabsContext = createContext(null);
const useTabsContext = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error("Tabs components must be used within a Tabs component");
  }
  return context;
};
const getColorClasses = (colorPalette, variant) => {
  const colorMap = {
    primary: {
      line: {
        active: "text-brand-orange border-brand-orange dark:text-dark-brand-orange dark:border-dark-brand-orange",
        inactive: "text-text-secondary hover:text-brand-orange hover:border-brand-orange dark:text-dark-text-secondary dark:hover:text-dark-brand-orange-hover dark:hover:border-dark-brand-orange-hover",
        indicator: "bg-brand-orange dark:bg-dark-brand-orange"
      },
      subtle: {
        active: "text-brand-orange bg-brand-orange/10 dark:text-dark-brand-orange dark:bg-dark-brand-orange/20",
        inactive: "text-text-secondary hover:text-brand-orange hover:bg-brand-orange/5 dark:text-dark-text-secondary dark:hover:text-dark-brand-orange-hover dark:hover:bg-dark-brand-orange-hover/10",
        indicator: "bg-brand-orange/10 dark:bg-dark-brand-orange/20"
      },
      enclosed: {
        active: "text-brand-orange bg-bg-secondary border border-brand-orange border-b-bg-secondary dark:text-dark-brand-orange dark:bg-dark-bg-secondary dark:border-dark-brand-orange dark:border-b-dark-bg-secondary",
        inactive: "text-text-secondary hover:text-brand-orange bg-bg-tertiary border border-border-color border-b-border-color dark:text-dark-text-secondary dark:hover:text-dark-brand-orange-hover dark:bg-dark-bg-tertiary dark:border-dark-border-color dark:border-b-dark-border-color",
        indicator: "bg-bg-secondary dark:bg-dark-bg-secondary"
      },
      outline: {
        active: "text-brand-orange border-brand-orange dark:text-dark-brand-orange dark:border-dark-brand-orange",
        inactive: "text-text-secondary hover:text-brand-orange border-border-color dark:text-dark-text-secondary dark:hover:text-dark-brand-orange-hover dark:border-dark-border-color",
        indicator: "bg-brand-orange dark:bg-dark-brand-orange"
      },
      plain: {
        active: "text-brand-orange dark:text-dark-brand-orange",
        inactive: "text-text-secondary hover:text-brand-orange dark:text-dark-text-secondary dark:hover:text-dark-brand-orange-hover",
        indicator: "bg-brand-orange dark:bg-dark-brand-orange"
      }
    },
    secondary: {
      line: {
        active: "text-text-primary border-text-primary dark:text-dark-text-primary dark:border-dark-text-primary",
        inactive: "text-text-secondary hover:text-text-primary hover:border-border-strong dark:text-dark-text-secondary dark:hover:text-dark-text-primary dark:hover:border-dark-border-strong",
        indicator: "bg-text-primary dark:bg-dark-text-primary"
      },
      subtle: {
        active: "text-text-primary bg-bg-tertiary dark:text-dark-text-primary dark:bg-dark-bg-tertiary",
        inactive: "text-text-secondary hover:text-text-primary hover:bg-bg-tertiary/50 dark:text-dark-text-secondary dark:hover:text-dark-text-primary dark:hover:bg-dark-bg-tertiary/50",
        indicator: "bg-bg-tertiary dark:bg-dark-bg-tertiary"
      },
      enclosed: {
        active: "text-text-primary bg-bg-secondary border border-border-color border-b-bg-secondary dark:text-dark-text-primary dark:bg-dark-bg-secondary dark:border-dark-border-color dark:border-b-dark-bg-secondary",
        inactive: "text-text-secondary hover:text-text-primary bg-bg-tertiary border border-border-color border-b-border-color dark:text-dark-text-secondary dark:hover:text-dark-text-primary dark:bg-dark-bg-tertiary dark:border-dark-border-color dark:border-b-dark-border-color",
        indicator: "bg-bg-secondary dark:bg-dark-bg-secondary"
      },
      outline: {
        active: "text-text-primary border-text-primary dark:text-dark-text-primary dark:border-dark-text-primary",
        inactive: "text-text-secondary hover:text-text-primary border-border-color dark:text-dark-text-secondary dark:hover:text-dark-text-primary dark:border-dark-border-color",
        indicator: "bg-text-primary dark:bg-dark-text-primary"
      },
      plain: {
        active: "text-text-primary dark:text-dark-text-primary",
        inactive: "text-text-secondary hover:text-text-primary dark:text-dark-text-secondary dark:hover:text-dark-text-primary",
        indicator: "bg-text-primary dark:bg-dark-text-primary"
      }
    },
    success: {
      line: {
        active: "text-system-success border-system-success",
        inactive: "text-text-secondary hover:text-system-success hover:border-system-success/30 dark:text-dark-text-secondary dark:hover:text-system-success",
        indicator: "bg-system-success"
      },
      subtle: {
        active: "text-system-success bg-system-success-light dark:bg-system-success/20",
        inactive: "text-text-secondary hover:text-system-success hover:bg-system-success-light/50 dark:text-dark-text-secondary dark:hover:text-system-success dark:hover:bg-system-success/10",
        indicator: "bg-system-success-light dark:bg-system-success/20"
      },
      enclosed: {
        active: "text-system-success bg-bg-secondary border border-system-success border-b-bg-secondary dark:bg-dark-bg-secondary dark:border-system-success dark:border-b-dark-bg-secondary",
        inactive: "text-text-secondary hover:text-system-success bg-bg-tertiary border border-border-color border-b-border-color dark:text-dark-text-secondary dark:hover:text-system-success dark:bg-dark-bg-tertiary dark:border-dark-border-color dark:border-b-dark-border-color",
        indicator: "bg-bg-secondary dark:bg-dark-bg-secondary"
      },
      outline: {
        active: "text-system-success border-system-success",
        inactive: "text-text-secondary hover:text-system-success border-border-color dark:text-dark-text-secondary dark:hover:text-system-success dark:border-dark-border-color",
        indicator: "bg-system-success"
      },
      plain: {
        active: "text-system-success",
        inactive: "text-text-secondary hover:text-system-success dark:text-dark-text-secondary dark:hover:text-system-success",
        indicator: "bg-system-success"
      }
    },
    warning: {
      line: {
        active: "text-system-warning-dark dark:text-system-warning-light-text border-system-warning-border dark:border-system-warning",
        inactive: "text-text-secondary hover:text-system-warning-dark hover:border-system-warning-border/30 dark:text-dark-text-secondary dark:hover:text-system-warning-light-text dark:hover:border-system-warning",
        indicator: "bg-system-warning-border dark:bg-system-warning"
      },
      subtle: {
        active: "text-system-warning-dark bg-system-warning-light dark:text-system-warning-light-text dark:bg-system-warning/20",
        inactive: "text-text-secondary hover:text-system-warning-dark hover:bg-system-warning-light/50 dark:text-dark-text-secondary dark:hover:text-system-warning-light-text dark:hover:bg-system-warning/10",
        indicator: "bg-system-warning-light dark:bg-system-warning/20"
      },
      enclosed: {
        active: "text-system-warning-dark bg-bg-secondary border border-system-warning-border border-b-bg-secondary dark:text-system-warning-light-text dark:bg-dark-bg-secondary dark:border-system-warning dark:border-b-dark-bg-secondary",
        inactive: "text-text-secondary hover:text-system-warning-dark bg-bg-tertiary border border-border-color border-b-border-color dark:text-dark-text-secondary dark:hover:text-system-warning-light-text dark:bg-dark-bg-tertiary dark:border-dark-border-color dark:border-b-dark-border-color",
        indicator: "bg-bg-secondary dark:bg-dark-bg-secondary"
      },
      outline: {
        active: "text-system-warning-dark border-system-warning-border dark:text-system-warning-light-text dark:border-system-warning",
        inactive: "text-text-secondary hover:text-system-warning-dark border-border-color dark:text-dark-text-secondary dark:hover:text-system-warning-light-text dark:border-dark-border-color",
        indicator: "bg-system-warning-border dark:bg-system-warning"
      },
      plain: {
        active: "text-system-warning-dark dark:text-system-warning-light-text",
        inactive: "text-text-secondary hover:text-system-warning-dark dark:text-dark-text-secondary dark:hover:text-system-warning-light-text",
        indicator: "bg-system-warning-border dark:bg-system-warning"
      }
    },
    danger: {
      line: {
        active: "text-system-error border-system-error",
        inactive: "text-text-secondary hover:text-system-error hover:border-system-error/30 dark:text-dark-text-secondary dark:hover:text-system-error",
        indicator: "bg-system-error"
      },
      subtle: {
        active: "text-system-error bg-system-error-light dark:bg-system-error/20",
        inactive: "text-text-secondary hover:text-system-error hover:bg-system-error-light/50 dark:text-dark-text-secondary dark:hover:text-system-error dark:hover:bg-system-error/10",
        indicator: "bg-system-error-light dark:bg-system-error/20"
      },
      enclosed: {
        active: "text-system-error bg-bg-secondary border border-system-error border-b-bg-secondary dark:bg-dark-bg-secondary dark:border-system-error dark:border-b-dark-bg-secondary",
        inactive: "text-text-secondary hover:text-system-error bg-bg-tertiary border border-border-color border-b-border-color dark:text-dark-text-secondary dark:hover:text-system-error dark:bg-dark-bg-tertiary dark:border-dark-border-color dark:border-b-dark-border-color",
        indicator: "bg-bg-secondary dark:bg-dark-bg-secondary"
      },
      outline: {
        active: "text-system-error border-system-error",
        inactive: "text-text-secondary hover:text-system-error border-border-color dark:text-dark-text-secondary dark:hover:text-system-error dark:border-dark-border-color",
        indicator: "bg-system-error"
      },
      plain: {
        active: "text-system-error",
        inactive: "text-text-secondary hover:text-system-error dark:text-dark-text-secondary dark:hover:text-system-error",
        indicator: "bg-system-error"
      }
    },
    info: {
      line: {
        active: "text-system-info border-system-info",
        inactive: "text-text-secondary hover:text-system-info hover:border-system-info/30 dark:text-dark-text-secondary dark:hover:text-system-info",
        indicator: "bg-system-info"
      },
      subtle: {
        active: "text-system-info bg-system-info-light dark:bg-system-info/20",
        inactive: "text-text-secondary hover:text-system-info hover:bg-system-info-light/50 dark:text-dark-text-secondary dark:hover:text-system-info dark:hover:bg-system-info/10",
        indicator: "bg-system-info-light dark:bg-system-info/20"
      },
      enclosed: {
        active: "text-system-info bg-bg-secondary border border-system-info border-b-bg-secondary dark:bg-dark-bg-secondary dark:border-system-info dark:border-b-dark-bg-secondary",
        inactive: "text-text-secondary hover:text-system-info bg-bg-tertiary border border-border-color border-b-border-color dark:text-dark-text-secondary dark:hover:text-system-info dark:bg-dark-bg-tertiary dark:border-dark-border-color dark:border-b-dark-border-color",
        indicator: "bg-bg-secondary dark:bg-dark-bg-secondary"
      },
      outline: {
        active: "text-system-info border-system-info",
        inactive: "text-text-secondary hover:text-system-info border-border-color dark:text-dark-text-secondary dark:hover:text-system-info dark:border-dark-border-color",
        indicator: "bg-system-info"
      },
      plain: {
        active: "text-system-info",
        inactive: "text-text-secondary hover:text-system-info dark:text-dark-text-secondary dark:hover:text-system-info",
        indicator: "bg-system-info"
      }
    }
  };
  return colorMap[colorPalette]?.[variant] || colorMap.primary[variant];
};
const getSizeClasses = (size2) => {
  const sizeMap2 = {
    sm: {
      tab: "px-3 py-2 text-sm font-medium",
      panel: "p-3 text-sm"
    },
    md: {
      tab: "px-4 py-2.5 text-sm font-medium",
      panel: "p-4 text-sm"
    },
    lg: {
      tab: "px-6 py-3 text-base font-medium",
      panel: "p-6 text-base"
    }
  };
  return sizeMap2[size2];
};
const TabsRoot = ({
  defaultValue,
  value: controlledValue,
  onValueChange,
  orientation = "horizontal",
  activationMode = "automatic",
  lazyMount = false,
  unmountOnExit = false,
  loopFocus = true,
  deselectable = false,
  variant = "line",
  size: size2 = "md",
  colorPalette = "primary",
  fitted = false,
  justify = "start",
  as: Component2 = "div",
  asChild = false,
  unstyled = false,
  onFocusChange,
  id: id2,
  ids = {},
  className,
  children,
  ...htmlProps
}) => {
  const [internalValue, setInternalValue] = useState(defaultValue || null);
  const [mountedTabs, setMountedTabs] = useState(/* @__PURE__ */ new Set());
  const [focusedValue, setFocusedValue] = useState(null);
  const indicatorRef = useRef(null);
  const tabRefs = useRef(/* @__PURE__ */ new Map());
  const isControlled = controlledValue !== void 0;
  const currentValue = isControlled ? controlledValue : internalValue;
  const setValue = useCallback((newValue) => {
    if (!isControlled) {
      setInternalValue(newValue);
    }
    if (newValue && onValueChange) {
      onValueChange({ value: newValue });
    }
  }, [isControlled, onValueChange]);
  const setMountedTab = useCallback((tabValue) => {
    setMountedTabs((prev) => new Set(prev).add(tabValue));
  }, []);
  const registerTab = useCallback((tabValue, ref) => {
    tabRefs.current.set(tabValue, ref);
  }, []);
  const unregisterTab = useCallback((tabValue) => {
    tabRefs.current.delete(tabValue);
  }, []);
  const handleKeyDown = useCallback((event) => {
    const tabValues = Array.from(tabRefs.current.keys());
    const currentIndex = tabValues.indexOf(focusedValue || "");
    if (currentIndex === -1) return;
    let newIndex = currentIndex;
    const isVertical = orientation === "vertical";
    switch (event.key) {
      case (isVertical ? "ArrowUp" : "ArrowLeft"):
        event.preventDefault();
        newIndex = loopFocus && currentIndex === 0 ? tabValues.length - 1 : Math.max(0, currentIndex - 1);
        break;
      case (isVertical ? "ArrowDown" : "ArrowRight"):
        event.preventDefault();
        newIndex = loopFocus && currentIndex === tabValues.length - 1 ? 0 : Math.min(tabValues.length - 1, currentIndex + 1);
        break;
      case "Home":
        event.preventDefault();
        newIndex = 0;
        break;
      case "End":
        event.preventDefault();
        newIndex = tabValues.length - 1;
        break;
      case "Enter":
      case " ":
        event.preventDefault();
        if (activationMode === "manual" && focusedValue) {
          if (deselectable && currentValue === focusedValue) {
            setValue(null);
          } else {
            setValue(focusedValue);
          }
        }
        return;
      default:
        return;
    }
    while (newIndex !== currentIndex) {
      const newValue2 = tabValues[newIndex];
      const tabRef = tabRefs.current.get(newValue2);
      if (tabRef?.current && !tabRef.current.disabled) {
        break;
      }
      newIndex = loopFocus ? (newIndex + (newIndex > currentIndex ? 1 : -1) + tabValues.length) % tabValues.length : newIndex + (newIndex > currentIndex ? 1 : -1);
      if (newIndex < 0 || newIndex >= tabValues.length) break;
    }
    const newValue = tabValues[newIndex];
    if (newValue && newValue !== focusedValue) {
      setFocusedValue(newValue);
      onFocusChange?.({ value: newValue });
      if (activationMode === "automatic") {
        if (deselectable && currentValue === newValue) {
          setValue(null);
        } else {
          setValue(newValue);
        }
      }
    }
  }, [orientation, activationMode, loopFocus, deselectable, currentValue, focusedValue, setValue, onFocusChange]);
  const contextValue = {
    value: currentValue,
    setValue,
    orientation,
    activationMode,
    lazyMount,
    unmountOnExit,
    loopFocus,
    deselectable,
    variant,
    size: size2,
    colorPalette,
    fitted,
    justify,
    onValueChange: onValueChange || (() => {
    }),
    onFocusChange: onFocusChange || (() => {
    }),
    mountedTabs,
    setMountedTab,
    indicatorRef,
    tabRefs: tabRefs.current,
    registerTab,
    unregisterTab
  };
  const baseClasses = unstyled ? "" : "tabs-root font-body";
  const orientationClasses = unstyled ? "" : orientation === "vertical" ? "flex" : "block";
  const justifyClasses = unstyled ? "" : {
    start: "justify-start",
    center: "justify-center",
    end: "justify-end"
  }[justify];
  const classes = cn(
    baseClasses,
    orientationClasses,
    justifyClasses,
    className
  );
  const rootId = id2 || ids.root || `tabs-${Math.random().toString(36).substr(2, 9)}`;
  if (asChild && React__default.isValidElement(children)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContext.Provider, { value: contextValue, children: React__default.cloneElement(children, {
      ...htmlProps,
      className: cn(classes, children.props?.className),
      id: rootId,
      onKeyDown: handleKeyDown
    }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Component2,
    {
      ...htmlProps,
      className: classes,
      id: rootId,
      onKeyDown: handleKeyDown,
      children
    }
  ) });
};
const TabList = ({
  className,
  children,
  ...htmlProps
}) => {
  const { orientation, variant, fitted } = useTabsContext();
  const baseClasses = "tabs-list relative";
  const orientationClasses = orientation === "vertical" ? "flex-col space-y-1" : "flex space-x-1";
  const variantClasses2 = {
    line: "border-b border-border-color dark:border-dark-border-subtle",
    subtle: "space-x-1",
    enclosed: "border border-border-color dark:border-dark-border-color rounded-t-lg",
    outline: "space-x-1",
    plain: "space-x-1"
  }[variant];
  const fittedClasses = fitted ? "w-full" : "";
  const classes = cn(
    baseClasses,
    orientationClasses,
    variantClasses2,
    fittedClasses,
    className
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ...htmlProps,
      className: classes,
      role: "tablist",
      "aria-orientation": orientation,
      children
    }
  );
};
const Tab = ({
  value,
  disabled = false,
  asChild = false,
  className,
  children,
  onClick,
  onFocus,
  ...htmlProps
}) => {
  const {
    value: currentValue,
    setValue,
    variant,
    size: size2,
    colorPalette,
    fitted,
    deselectable,
    registerTab,
    unregisterTab
  } = useTabsContext();
  const tabRef = useRef(null);
  const isActive = currentValue === value;
  const isDisabled = disabled;
  useEffect(() => {
    registerTab(value, tabRef);
    return () => unregisterTab(value);
  }, [value, registerTab, unregisterTab]);
  const handleClick = (event) => {
    if (isDisabled) return;
    if (deselectable && isActive) {
      setValue(null);
    } else {
      setValue(value);
    }
    onClick?.(event);
  };
  const handleFocus = (event) => {
    if (isDisabled) return;
    onFocus?.(event);
  };
  const colorClasses2 = getColorClasses(colorPalette, variant);
  const sizeClasses2 = getSizeClasses(size2);
  const variantClasses2 = {
    line: `border-b-2 ${isActive ? colorClasses2.active : colorClasses2.inactive}`,
    subtle: `rounded-md ${isActive ? colorClasses2.active : colorClasses2.inactive}`,
    enclosed: `border-b-2 rounded-t-md ${isActive ? colorClasses2.active : colorClasses2.inactive}`,
    outline: `border rounded-md ${isActive ? colorClasses2.active : colorClasses2.inactive}`,
    plain: `${isActive ? colorClasses2.active : colorClasses2.inactive}`
  }[variant];
  const baseClasses = "tabs-tab font-body transition-all duration-200 ease-in-out focus:outline-none focus-visible:ring-2 focus-visible:ring-brand-orange/20 dark:focus-visible:ring-dark-brand-orange/20";
  const disabledClasses = isDisabled ? "opacity-50 cursor-not-allowed" : "cursor-pointer hover:transition-all hover:duration-200 hover:ease-in-out";
  const fittedClasses = fitted ? "flex-1" : "";
  const classes = cn(
    baseClasses,
    sizeClasses2.tab,
    variantClasses2,
    disabledClasses,
    fittedClasses,
    className
  );
  if (asChild && React__default.isValidElement(children)) {
    return React__default.cloneElement(children, {
      ...htmlProps,
      ref: tabRef,
      className: cn(classes, children.props?.className),
      role: "tab",
      "aria-selected": isActive,
      "aria-disabled": isDisabled,
      "aria-controls": `tabpanel-${value}`,
      tabIndex: isActive ? 0 : -1,
      onClick: handleClick,
      onFocus: handleFocus
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      ...htmlProps,
      ref: tabRef,
      className: classes,
      role: "tab",
      "aria-selected": isActive,
      "aria-disabled": isDisabled,
      "aria-controls": `tabpanel-${value}`,
      tabIndex: isActive ? 0 : -1,
      onClick: handleClick,
      onFocus: handleFocus,
      children
    }
  );
};
const TabPanels = ({
  className,
  children,
  ...htmlProps
}) => {
  const baseClasses = "tabs-panels font-body";
  const classes = cn(
    baseClasses,
    className
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ...htmlProps,
      className: classes,
      children
    }
  );
};
const TabPanel = ({
  value,
  asChild = false,
  className,
  children,
  ...htmlProps
}) => {
  const {
    value: currentValue,
    lazyMount,
    unmountOnExit,
    mountedTabs,
    setMountedTab,
    size: size2
  } = useTabsContext();
  const isActive = currentValue === value;
  const shouldMount = !lazyMount || mountedTabs.has(value) || isActive;
  const shouldUnmount = unmountOnExit && !isActive;
  useEffect(() => {
    if (isActive && lazyMount) {
      setMountedTab(value);
    }
  }, [isActive, lazyMount, value, setMountedTab]);
  if (shouldUnmount) {
    return null;
  }
  if (!shouldMount) {
    return null;
  }
  const sizeClasses2 = getSizeClasses(size2);
  const baseClasses = "tabs-panel font-body";
  const classes = cn(
    baseClasses,
    sizeClasses2.panel,
    className
  );
  if (asChild && React__default.isValidElement(children)) {
    return React__default.cloneElement(children, {
      ...htmlProps,
      className: cn(classes, children.props?.className),
      role: "tabpanel",
      "aria-labelledby": `tab-${value}`,
      id: `tabpanel-${value}`,
      hidden: !isActive
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ...htmlProps,
      className: classes,
      role: "tabpanel",
      "aria-labelledby": `tab-${value}`,
      id: `tabpanel-${value}`,
      hidden: !isActive,
      children
    }
  );
};
const TabIndicator = ({
  className,
  ...htmlProps
}) => {
  const {
    value: currentValue,
    orientation,
    variant,
    colorPalette,
    indicatorRef,
    tabRefs
  } = useTabsContext();
  const [indicatorStyle, setIndicatorStyle] = useState({});
  useEffect(() => {
    if (!currentValue || !indicatorRef.current) return;
    const activeTabRef = tabRefs.get(currentValue);
    if (!activeTabRef?.current) return;
    const tabElement = activeTabRef.current;
    const tabListElement = tabElement.closest('[role="tablist"]');
    if (!tabListElement) return;
    const tabRect = tabElement.getBoundingClientRect();
    const listRect = tabListElement.getBoundingClientRect();
    const isVertical = orientation === "vertical";
    const newStyle = {
      position: "absolute",
      transition: "all 0.2s ease-in-out",
      ...isVertical ? {
        top: tabRect.top - listRect.top,
        left: 0,
        width: "2px",
        height: tabRect.height
      } : {
        left: tabRect.left - listRect.left,
        top: tabRect.bottom - listRect.top - 2,
        width: tabRect.width,
        height: "2px",
        zIndex: 1
      }
    };
    setIndicatorStyle(newStyle);
  }, [currentValue, orientation, tabRefs]);
  if (variant !== "line" && variant !== "outline" || !currentValue) {
    return null;
  }
  const colorClasses2 = getColorClasses(colorPalette, variant);
  const baseClasses = "tabs-indicator";
  const classes = cn(
    baseClasses,
    colorClasses2.indicator,
    className
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ...htmlProps,
      ref: indicatorRef,
      className: classes,
      style: indicatorStyle
    }
  );
};
const Tabs = Object.assign(TabsRoot, {
  List: TabList,
  Tab,
  Panels: TabPanels,
  Panel: TabPanel,
  Indicator: TabIndicator
});
function VirtualizedTable({
  data,
  columns,
  height,
  rowHeight,
  // Standardized Props
  containerClassName = "",
  style,
  size: size2 = "md",
  color: color2 = "primary",
  // Header Section Props
  showHeader = true,
  showControls = false,
  headerContent,
  headerClassName = "",
  headerBordered = true,
  showColumnIcons = true,
  showColumnText = true,
  headerPadding = "md",
  // Body Section Props
  bodyClassName = "",
  bodyBordered = true,
  // Footer Section Props
  showFooter = true,
  footerClassName = "",
  footerBordered = true,
  // Table-wide Props
  bordered = true,
  className = "",
  // Feature Props
  searchable = false,
  searchPlaceholder = "Search table...",
  filterable = false,
  filters = [],
  onFilterChange,
  activeFilter = "all",
  selectable = false,
  selectionColor = "primary",
  onSelectionChange,
  showSelectionInfo = false,
  showVirtualizationInfo = false,
  striped = true,
  hoverable = true,
  title,
  description,
  showRowNumbers = false,
  onRowClick,
  loading = false,
  onError,
  emptyState,
  // Enhanced sorting props
  multiSort = false,
  defaultSort = [],
  onSortChange,
  sortable = true,
  // Highlighting props
  highlightedRows = [],
  highlightedColumns = [],
  highlightColor = "primary",
  // Additional Standardized Props
  hasBackground = true,
  isRounded = true,
  hasShadow = false,
  isResponsive = true,
  hasFixedWidth = false,
  isFullWidth = true,
  hasFixedHeight = true,
  isScrollable = true,
  hasStickyHeader = false,
  hasStickyFooter = false,
  // Content-aware sizing
  autoSizeColumns = false,
  minColumnWidth = 80,
  maxColumnWidth = 400,
  cellPadding = "md",
  checkboxColumnWidth = "auto",
  rowNumberColumnWidth = "auto"
}) {
  const [selectedIds, setSelectedIds] = useState([]);
  const [sortConfigs, setSortConfigs] = useState(defaultSort || []);
  const [visibleColumns, setVisibleColumns] = useState(new Set(columns.map((col) => col.key)));
  const [searchTerm, setSearchTerm] = useState("");
  const [scrollTop, setScrollTop] = useState(0);
  const [error2, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(loading);
  const containerRef = useRef(null);
  const scrollRef = useRef(null);
  const headerScrollRef = useRef(null);
  useEffect(() => {
    try {
      if (!Array.isArray(data)) {
        throw new Error("Data must be an array");
      }
      if (!Array.isArray(columns)) {
        throw new Error("Columns must be an array");
      }
      if (columns.length === 0) {
        throw new Error("At least one column is required");
      }
      columns.forEach((column, index2) => {
        if (!column.key) {
          throw new Error(`Column at index ${index2} must have a key`);
        }
        if (!column.header) {
          throw new Error(`Column at index ${index2} must have a header`);
        }
      });
      setError(null);
    } catch (error22) {
      const errorMessage = error22 instanceof Error ? error22.message : "Invalid data or columns";
      setError(errorMessage);
      console.error("VirtualizedTable validation error:", error22);
      onError?.(errorMessage);
    }
  }, [data, columns]);
  useEffect(() => {
    setIsLoading(loading);
  }, [loading]);
  const sizeClasses2 = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-sm",
    lg: "text-base",
    xl: "text-lg"
  };
  const colorClasses2 = {
    primary: "text-text-secondary dark:text-dark-text-secondary",
    success: "text-green-700 dark:text-green-300",
    warning: "text-yellow-700 dark:text-yellow-300",
    danger: "text-red-700 dark:text-red-300",
    info: "text-blue-700 dark:text-blue-300",
    neutral: "text-gray-700 dark:text-gray-300"
  };
  const paddingClasses = {
    none: "",
    xs: "px-2 py-1",
    sm: "px-4 py-2",
    md: "px-6 py-3",
    lg: "px-8 py-4",
    xl: "px-10 py-5"
  };
  const getColumnWidth = (column) => {
    if (column.width === "auto") {
      return autoSizeColumns ? "auto" : minColumnWidth;
    }
    if (column.width === "fit-content") {
      return "fit-content";
    }
    if (typeof column.width === "number") {
      return Math.max(minColumnWidth, Math.min(maxColumnWidth, column.width));
    }
    return autoSizeColumns ? "auto" : minColumnWidth;
  };
  const getCheckboxColumnWidth = () => {
    if (checkboxColumnWidth === "auto") {
      return "w-auto";
    }
    return `w-[${checkboxColumnWidth}px]`;
  };
  const getRowNumberColumnWidth = () => {
    if (rowNumberColumnWidth === "auto") {
      return "w-auto";
    }
    return `w-[${rowNumberColumnWidth}px]`;
  };
  const containerClasses = `
        ${hasBackground ? "bg-bg-primary dark:bg-dark-bg-primary" : ""}
        ${isRounded ? "rounded-lg" : ""}
        ${hasShadow ? "shadow-md" : ""}
        ${isResponsive ? "overflow-hidden" : ""}
        ${hasFixedWidth ? "" : "w-full"}
        ${isFullWidth ? "w-full" : ""}
        ${hasFixedHeight ? "" : "min-h-0"}
        ${isScrollable ? "overflow-auto" : "overflow-hidden"}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  const filteredData = useMemo(() => {
    let filtered = data;
    if (filterable && activeFilter && activeFilter !== "all") {
      filtered = filtered.filter((row) => {
        const categoryValue = row["category"];
        return categoryValue === activeFilter;
      });
    }
    if (searchTerm) {
      console.log("🔍 Searching for:", searchTerm, "in", data.length, "rows");
      filtered = filtered.filter(
        (row) => columns.some((column) => {
          const value = row[column.key];
          const matches2 = String(value).toLowerCase().includes(searchTerm.toLowerCase());
          if (matches2) {
            console.log("✅ Match found in column", column.key, ":", value);
          }
          return matches2;
        })
      );
      console.log("🔍 Search results:", filtered.length, "rows remaining");
    }
    return filtered;
  }, [data, columns, searchTerm, filterable, activeFilter]);
  const sortedData = useMemo(() => {
    if (!sortConfigs.length) return filteredData;
    return [...filteredData].sort((a3, b2) => {
      for (const sortConfig of sortConfigs.sort((x2, y2) => x2.priority - y2.priority)) {
        const column = columns.find((col) => col.key === sortConfig.key);
        if (!column) continue;
        const valA = a3[sortConfig.key];
        const valB = b2[sortConfig.key];
        let comparison = 0;
        if (column.customSort) {
          comparison = column.customSort(a3, b2, sortConfig.direction);
        } else {
          if (typeof valA === "string" && typeof valB === "string") {
            comparison = valA.localeCompare(valB);
          } else if (typeof valA === "number" && typeof valB === "number") {
            comparison = valA - valB;
          } else {
            comparison = String(valA).localeCompare(String(valB));
          }
        }
        if (sortConfig.direction === "desc") {
          comparison = -comparison;
        }
        if (comparison !== 0) {
          return comparison;
        }
      }
      return 0;
    });
  }, [filteredData, sortConfigs, columns]);
  const totalHeight = sortedData.length * rowHeight;
  const visibleRows = Math.ceil(height / rowHeight) + 2;
  const startIndex = Math.max(0, Math.floor(scrollTop / rowHeight));
  const endIndex = Math.min(sortedData.length, startIndex + visibleRows);
  const visibleData = useMemo(() => {
    const start = startIndex;
    const end = Math.min(start + Math.ceil(height / rowHeight), sortedData.length);
    return sortedData.slice(start, end);
  }, [sortedData, startIndex, height, rowHeight]);
  const offsetY = startIndex * rowHeight;
  const visibleColumnsArray = columns.filter((col) => visibleColumns.has(col.key));
  const totalTableWidth = useMemo(() => {
    let width = 0;
    if (selectable) width += 16;
    if (showRowNumbers) width += 64;
    visibleColumnsArray.forEach((column) => {
      const columnWidth = typeof column.width === "number" ? column.width : 150;
      width += columnWidth;
    });
    return width;
  }, [visibleColumnsArray, selectable, showRowNumbers]);
  const handleHeaderScroll = useCallback((e2) => {
    const scrollLeft = e2.currentTarget.scrollLeft;
    if (scrollRef.current) {
      scrollRef.current.scrollLeft = scrollLeft;
    }
  }, []);
  const handleBodyScroll = useCallback((e2) => {
    setScrollTop(e2.currentTarget.scrollTop);
    const scrollLeft = e2.currentTarget.scrollLeft;
    if (headerScrollRef.current) {
      headerScrollRef.current.scrollLeft = scrollLeft;
    }
  }, []);
  const handleSort = useCallback((columnKey, direction) => {
    if (!sortable) return;
    let newSortConfigs;
    if (multiSort) {
      const existingIndex = sortConfigs.findIndex((config) => config.key === columnKey);
      if (existingIndex >= 0) {
        newSortConfigs = [...sortConfigs];
        if (direction === sortConfigs[existingIndex].direction) {
          newSortConfigs.splice(existingIndex, 1);
        } else {
          newSortConfigs[existingIndex] = { ...newSortConfigs[existingIndex], direction };
        }
      } else {
        const nextPriority = sortConfigs.length + 1;
        if (nextPriority <= 3) {
          newSortConfigs = [...sortConfigs, { key: columnKey, direction, priority: nextPriority }];
        } else {
          newSortConfigs = [...sortConfigs.slice(1), { key: columnKey, direction, priority: 3 }];
        }
      }
    } else {
      newSortConfigs = [{ key: columnKey, direction, priority: 1 }];
    }
    setSortConfigs(newSortConfigs);
    onSortChange?.(newSortConfigs);
  }, [sortable, multiSort, sortConfigs, onSortChange]);
  const handleSelectAll = useCallback((checked) => {
    const newSelectedIds = checked ? visibleData.map((row) => String(row.id)) : [];
    setSelectedIds(newSelectedIds);
    onSelectionChange?.(newSelectedIds);
  }, [visibleData, onSelectionChange]);
  const handleSelectRow = useCallback((id2, checked) => {
    const newSelectedIds = checked ? [...selectedIds, id2] : selectedIds.filter((selectedId) => selectedId !== id2);
    setSelectedIds(newSelectedIds);
    onSelectionChange?.(newSelectedIds);
  }, [selectedIds, onSelectionChange]);
  const toggleColumnVisibility = useCallback((columnKey) => {
    const newVisibleColumns = new Set(visibleColumns);
    if (newVisibleColumns.has(columnKey)) {
      newVisibleColumns.delete(columnKey);
    } else {
      newVisibleColumns.add(columnKey);
    }
    setVisibleColumns(newVisibleColumns);
  }, [visibleColumns]);
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = 0;
      setScrollTop(0);
    }
  }, [data.length, searchTerm, activeFilter]);
  if (loading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `space-y-4 ${className}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-64", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-brand-orange mx-auto mb-2" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-text-secondary dark:text-dark-text-secondary", children: "Loading data..." })
    ] }) }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `space-y-4 ${containerClasses}`, style, children: [
    showHeader && (headerContent || title || description || showControls) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `
                    ${headerBordered ? "border-b border-border-color dark:border-dark-border-color" : ""}
                    ${hasStickyHeader ? "sticky top-0 z-20 bg-bg-primary dark:bg-dark-bg-primary" : ""}
                    ${headerClassName}
                `.trim().replace(/\s+/g, " "), children: headerContent || /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      (title || description) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
        title && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-text-primary dark:text-dark-text-primary", children: title }),
        description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary mt-1", children: description })
      ] }),
      showControls && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col lg:flex-row gap-4 items-start lg:items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-4 items-start sm:items-center", children: [
          searchable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full sm:w-80", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                id: "virtualized-table-search",
                type: "text",
                placeholder: searchPlaceholder || "Search table...",
                value: searchTerm,
                onChange: (e2) => setSearchTerm(e2.target.value),
                className: "w-full pl-4 pr-10 py-2 text-sm bg-bg-tertiary dark:bg-dark-bg-primary rounded-lg border border-border-color dark:border-dark-border-color focus:outline-none focus:ring-2 focus:ring-brand-orange focus:border-transparent placeholder:text-text-secondary/60 dark:placeholder:text-dark-text-secondary/60"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "absolute right-3 top-1/2 -translate-y-1/2 text-text-secondary/60 pointer-events-none", children: "search" })
          ] }) }),
          filterable && filters.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm font-medium text-text-secondary dark:text-dark-text-secondary", children: "Filter:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2", children: filters.map((filter2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button$1,
              {
                variant: activeFilter === filter2.value ? "primary" : "ghost",
                size: "sm",
                onClick: () => onFilterChange?.(filter2.key, filter2.value),
                className: "whitespace-nowrap",
                children: filter2.label
              },
              filter2.key
            )) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row items-start sm:items-center gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Dropdown, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Trigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button$1, { variant: "outline", size: "sm", className: "whitespace-nowrap", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "view_column" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hidden sm:inline", children: "Columns" })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Dropdown.Content, { children: columns.map((column) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Dropdown.Item,
              {
                onSelect: () => toggleColumnVisibility(column.key),
                className: "flex gap-2",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RawCheckbox,
                    {
                      id: `col-${String(column.key)}`,
                      checked: visibleColumns.has(column.key),
                      onChange: () => {
                      }
                    }
                  ),
                  column.header
                ]
              },
              String(column.key)
            )) })
          ] }),
          selectable && showSelectionInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              RawCheckbox,
              {
                id: "select-all-virtualized",
                checked: selectedIds.length === visibleData.length && visibleData.length > 0,
                isIndeterminate: selectedIds.length > 0 && selectedIds.length < visibleData.length,
                onChange: (e2) => handleSelectAll(e2.target.checked)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-text-secondary dark:text-dark-text-secondary whitespace-nowrap", children: [
              selectedIds.length,
              " of ",
              sortedData.length,
              " selected"
            ] })
          ] }),
          showVirtualizationInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "px-3 py-1 rounded-full bg-brand-orange/10 dark:bg-dark-brand-orange/10 text-xs font-medium text-brand-orange dark:text-dark-brand-orange whitespace-nowrap", children: [
            "Virtualized (",
            visibleData.length,
            "/",
            sortedData.length,
            ")"
          ] })
        ] })
      ] })
    ] }) }),
    error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 p-4 bg-red-50 border border-red-200 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-5 w-5 text-red-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium text-red-800", children: "Table Error" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600", children: error2 })
      ] })
    ] }) }),
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-5 w-5 border-2 border-blue-600 border-t-transparent" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-blue-800", children: "Loading table data..." }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: containerRef,
        className: `border border-border-color dark:border-dark-border-color rounded-lg overflow-hidden ${bordered ? "border-t-0" : ""}`,
        style: { height },
        children: [
          showHeader && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              ref: headerScrollRef,
              className: `
                            bg-table-header dark:bg-dark-table-header 
                            border-b border-border-color dark:border-dark-border-color 
                            overflow-x-auto custom-scrollbar 
                            ${headerBordered ? "border-b border-border-color dark:border-dark-border-color" : ""}
                            ${sizeClasses2[size2]}
                            ${colorClasses2[color2]}
                            ${headerClassName}
                        `.trim().replace(/\s+/g, " "),
              onScroll: handleHeaderScroll,
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", style: { minWidth: totalTableWidth }, children: [
                selectable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${paddingClasses[headerPadding]} ${getCheckboxColumnWidth()} flex items-center flex-shrink-0`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  RawCheckbox,
                  {
                    id: "header-select-all-virtualized",
                    checked: selectedIds.length === visibleData.length && visibleData.length > 0,
                    isIndeterminate: selectedIds.length > 0 && selectedIds.length < visibleData.length,
                    onChange: (e2) => handleSelectAll(e2.target.checked)
                  }
                ) }),
                showRowNumbers && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${paddingClasses[headerPadding]} ${getRowNumberColumnWidth()} flex items-center flex-shrink-0`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-sm text-text-primary dark:text-dark-text-primary uppercase", children: "#" }) }),
                visibleColumnsArray.map((column) => {
                  const columnWidth = getColumnWidth(column);
                  const headerText = column.headerText || column.header;
                  const showIcon = (column.showHeaderIcon !== void 0 ? column.showHeaderIcon : showColumnIcons) && column.headerIcon;
                  const showText = column.showHeaderText !== void 0 ? column.showHeaderText : showColumnText;
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      className: `${paddingClasses[headerPadding]} text-left font-bold text-sm text-text-primary dark:text-dark-text-primary uppercase flex-shrink-0 whitespace-nowrap ${column.sortable ? "cursor-pointer hover:bg-bg-tertiary/50 dark:hover:bg-dark-bg-tertiary/50 transition-colors" : ""} ${column.headerClassName || column.className || ""}`,
                      style: {
                        width: typeof columnWidth === "number" ? `${columnWidth}px` : columnWidth,
                        minWidth: typeof columnWidth === "number" ? columnWidth : void 0
                      },
                      children: column.headerRender ? column.headerRender(column) : /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex items-center gap-2 font-bold group", onClick: () => {
                        if (column.sortable) {
                          const existingSort = sortConfigs.find((config) => config.key === column.key);
                          const newDirection = existingSort?.direction === "asc" ? "desc" : "asc";
                          handleSort(column.key, newDirection);
                        }
                      }, children: [
                        showIcon && column.headerIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: "text-brand-navy dark:text-dark-text-primary", children: column.headerIcon }),
                        showText && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-sm text-text-primary dark:text-dark-text-primary uppercase whitespace-nowrap", children: headerText }),
                        column.headerActions,
                        column.sortable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1 flex-shrink-0", children: [
                          sortConfigs.map((sortConfig, index2) => {
                            if (sortConfig.key === column.key) {
                              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-1", children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: "text-brand-navy dark:text-dark-text-primary", children: sortConfig.direction === "asc" ? "arrow_upward" : "arrow_downward" }),
                                multiSort && sortConfig.priority > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-brand-navy dark:text-dark-text-primary font-bold", children: sortConfig.priority })
                              ] }, index2);
                            }
                            return null;
                          }),
                          !sortConfigs.some((config) => config.key === column.key) && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: "opacity-0 group-hover:opacity-50 transition-opacity", children: "unfold_more" })
                        ] })
                      ] })
                    },
                    String(column.key)
                  );
                })
              ] })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              ref: scrollRef,
              className: `
                        overflow-x-auto custom-scrollbar bg-bg-secondary dark:bg-dark-bg-secondary
                        ${bodyBordered ? "border-b border-border-color dark:border-dark-border-color" : ""}
                        ${sizeClasses2[size2]}
                        ${colorClasses2[color2]}
                        ${bodyClassName}
                    `.trim().replace(/\s+/g, " "),
              style: { height: showHeader ? height - 60 : height, minWidth: "100%" },
              onScroll: handleBodyScroll,
              children: (() => {
                if (error2) {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-full min-h-[200px] bg-red-50 dark:bg-red-900/20", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 mx-auto mb-4 flex items-center justify-center rounded-full bg-red-100 dark:bg-red-800", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-2xl text-red-600 dark:text-red-400", children: "error" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-red-800 dark:text-red-200 mb-2", children: "Table Error" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600 dark:text-red-300 mb-4 max-w-md", children: error2 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: () => setError(null),
                        className: "text-sm text-red-700 hover:text-red-800 dark:text-red-300 dark:hover:text-red-200 transition-colors font-medium",
                        children: "Dismiss Error"
                      }
                    )
                  ] }) });
                }
                if (isLoading) {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-full min-h-[200px] bg-blue-50 dark:bg-blue-900/20", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 mx-auto mb-4 flex items-center justify-center rounded-full bg-blue-100 dark:bg-blue-800", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-2 border-blue-600 border-t-transparent" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-blue-800 dark:text-blue-200 mb-2", children: "Loading Data" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-blue-600 dark:text-blue-300", children: "Please wait while we load your data..." })
                  ] }) });
                }
                console.log("🔍 Render check:", {
                  sortedDataLength: sortedData.length,
                  searchTerm,
                  activeFilter,
                  dataLength: data.length,
                  error: error2,
                  isLoading
                });
                return sortedData.length > 0 ? (
                  // Show data when available
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: totalHeight, position: "relative", minWidth: "100%", width: "max-content" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { transform: `translateY(${offsetY}px)`, minWidth: "100%", width: "100%" }, children: visibleData.map((row, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      className: `flex items-center border-b border-border-color dark:border-dark-border-color transition-colors ${striped && (startIndex + index2) % 2 === 1 ? "bg-bg-tertiary/50 dark:bg-dark-bg-tertiary/30" : "bg-bg-secondary dark:bg-dark-bg-secondary"} ${hoverable ? "hover:bg-bg-tertiary/80 dark:hover:bg-dark-bg-tertiary/60" : ""} ${selectedIds.includes(String(row.id)) ? {
                        primary: "!bg-brand-orange/10 dark:!bg-dark-brand-orange/10",
                        secondary: "!bg-brand-navy/10 dark:!bg-dark-brand-navy/10",
                        success: "!bg-system-success/10 dark:!bg-system-success/20",
                        warning: "!bg-system-warning/10 dark:!bg-system-warning/20",
                        error: "!bg-system-error/10 dark:!bg-system-error/20",
                        info: "!bg-system-info/10 dark:!bg-system-info/20"
                      }[selectionColor] : ""} ${highlightedRows.includes(row.id) ? {
                        primary: "!bg-brand-orange/10 dark:!bg-dark-brand-orange/10",
                        secondary: "!bg-brand-navy/10 dark:!bg-dark-brand-navy/10",
                        success: "!bg-system-success-light dark:!bg-system-success-dark-bg/40",
                        warning: "!bg-system-warning-light dark:!bg-system-warning-dark-bg/40",
                        error: "!bg-system-error-light dark:!bg-system-error-dark-bg/40",
                        info: "!bg-system-info-light dark:!bg-system-info-dark-bg/40"
                      }[highlightColor] : ""} ${onRowClick ? "cursor-pointer" : ""}`,
                      style: { height: rowHeight, minWidth: "100%", width: "100%" },
                      onClick: onRowClick ? () => onRowClick(row) : void 0,
                      children: [
                        selectable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${paddingClasses[cellPadding]} ${getCheckboxColumnWidth()} flex items-center flex-shrink-0`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          RawCheckbox,
                          {
                            id: `row-${row.id}`,
                            checked: selectedIds.includes(String(row.id)),
                            onChange: (e2) => handleSelectRow(String(row.id), e2.target.checked)
                          }
                        ) }),
                        showRowNumbers && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${paddingClasses[cellPadding]} ${getRowNumberColumnWidth()} text-sm text-text-secondary dark:text-dark-text-secondary font-mono flex items-center flex-shrink-0`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: startIndex + index2 + 1 }) }),
                        visibleColumnsArray.map((column) => {
                          const isColumnHighlighted = highlightedColumns.includes(column.key);
                          const columnHighlightClass = isColumnHighlighted ? {
                            primary: "!bg-brand-orange/10 dark:!bg-dark-brand-orange/10",
                            secondary: "!bg-brand-navy/10 dark:!bg-dark-brand-navy/10",
                            success: "!bg-system-success-light dark:!bg-system-success-dark-bg/40",
                            warning: "!bg-system-warning-light dark:!bg-system-warning-dark-bg/40",
                            error: "!bg-system-error-light dark:!bg-system-error-dark-bg/40",
                            info: "!bg-system-info-light dark:!bg-system-info-dark-bg/40"
                          }[highlightColor] : "";
                          const cellValue = row[column.key];
                          const displayValue = cellValue !== void 0 && cellValue !== null ? cellValue : "—";
                          const columnWidth = getColumnWidth(column);
                          return /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "div",
                            {
                              className: `${paddingClasses[cellPadding]} text-sm text-text-secondary dark:text-dark-text-secondary flex items-center flex-shrink-0 ${column.textWrap === "wrap" ? "break-words" : column.textWrap === "nowrap" ? "whitespace-nowrap" : "truncate"} ${columnHighlightClass} ${column.className || ""}`,
                              style: {
                                width: typeof columnWidth === "number" ? `${columnWidth}px` : columnWidth,
                                minWidth: typeof columnWidth === "number" ? columnWidth : void 0
                              },
                              children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `w-full ${column.textWrap === "wrap" ? "break-words" : column.textWrap === "nowrap" ? "whitespace-nowrap" : "truncate"}`, children: column.render ? column.render(displayValue, row) : String(displayValue) })
                            },
                            String(column.key)
                          );
                        }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 min-w-0 bg-inherit" })
                      ]
                    },
                    row.id
                  )) }) })
                ) : (
                  // Show empty state when no data, but maintain table structure
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center h-full min-h-[200px] bg-bg-secondary dark:bg-dark-bg-secondary", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-16 h-16 mx-auto mb-4 flex items-center justify-center rounded-full bg-bg-tertiary dark:bg-dark-bg-tertiary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-2xl text-text-secondary dark:text-dark-text-secondary", children: emptyState?.icon || "search_off" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-text-primary dark:text-dark-text-primary mb-2", children: emptyState?.title || "No Data Found" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary mb-4 max-w-md", children: emptyState?.description || (searchTerm ? `No results found for "${searchTerm}". Try adjusting your search terms or filters.` : "No data available. Please check your filters or try a different search.") }),
                    searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        onClick: () => setSearchTerm(""),
                        className: "text-sm text-brand-orange hover:text-brand-orange/80 transition-colors font-medium",
                        children: "Clear search"
                      }
                    )
                  ] }) })
                );
              })()
            }
          )
        ]
      }
    ),
    showFooter && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `
                    flex items-center justify-between text-sm text-text-secondary dark:text-dark-text-secondary 
                    ${footerBordered ? "border-t border-border-color dark:border-dark-border-color" : ""}
                    ${hasStickyFooter ? "sticky bottom-0 z-20 bg-bg-primary dark:bg-dark-bg-primary" : ""}
                    ${sizeClasses2[size2]}
                    ${colorClasses2[color2]}
                    ${footerClassName}
                `.trim().replace(/\s+/g, " "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-4", children: [
        sortedData.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          "Showing ",
          startIndex + 1,
          " to ",
          endIndex,
          " of ",
          sortedData.length,
          " results",
          searchTerm && ` (filtered from ${data.length} total)`
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          searchTerm ? `No results found for "${searchTerm}"` : "No data available",
          searchTerm && ` (from ${data.length} total items)`
        ] }),
        sortConfigs.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => {
              setSortConfigs([]);
              onSortChange?.([]);
            },
            className: "text-xs text-brand-orange hover:text-brand-orange/80 transition-colors",
            children: "Clear sorting"
          }
        ),
        sortedData.length === 0 && searchTerm && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: () => setSearchTerm(""),
            className: "text-xs text-brand-orange hover:text-brand-orange/80 transition-colors",
            children: "Clear search"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs", children: [
        "Row height: ",
        rowHeight,
        "px • Container: ",
        height,
        "px • Performance optimized",
        multiSort && sortConfigs.length > 0 && ` • ${sortConfigs.length} sort level${sortConfigs.length > 1 ? "s" : ""}`,
        sortedData.length === 0 && ` • No data to display`
      ] })
    ] })
  ] });
}
class VirtualizedTableErrorBoundary extends React__default.Component {
  constructor(props) {
    super(props);
    this.resetError = () => {
      this.setState({ hasError: false, error: void 0 });
    };
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error2) {
    return { hasError: true, error: error2 };
  }
  componentDidCatch(error2, errorInfo) {
    console.error("VirtualizedTable error:", error2, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        const FallbackComponent = this.props.fallback;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(FallbackComponent, { error: this.state.error, resetError: this.resetError });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-6 bg-red-50 border border-red-200 rounded-lg", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-6 w-6 text-red-400", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium text-red-800", children: "VirtualizedTable Error" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-red-600", children: "An error occurred while rendering the table" })
          ] })
        ] }),
        this.state.error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 p-3 bg-red-100 border border-red-300 rounded text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium text-red-800 mb-1", children: "Error Details:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-red-700 font-mono text-xs break-all", children: this.state.error.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: this.resetError,
              className: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange transition-colors",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-4 w-4 mr-2", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" }) }),
                "Retry"
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => window.location.reload(),
              className: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange transition-colors",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-4 w-4 mr-2", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" }) }),
                "Reload Page"
              ]
            }
          )
        ] })
      ] });
    }
    return this.props.children;
  }
}
const Textarea = ({
  label,
  id: id2,
  error: error2,
  className = "",
  containerClassName = "",
  labelClassName = "",
  textareaClassName = "",
  disabled = false,
  required = false,
  loading = false,
  fullWidth = true,
  isSuccess = false,
  isWarning = false,
  hasBackground = true,
  hasBorder = true,
  hasFocusRing = true,
  hasRoundedCorners = true,
  hasShadow = false,
  showLabel = true,
  labelMode = "top",
  showHelperText = true,
  showErrorText = true,
  showRequiredIndicator = true,
  showCharacterCount = false,
  isResizable = true,
  isReadOnly = false,
  hasAutoResize = false,
  hasSpellCheck = true,
  helperText,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  align = "left",
  radius = "md",
  maxCharacters,
  placeholder,
  rows = 4,
  minRows,
  maxRows,
  leftIcon,
  rightIcon,
  ...props
}) => {
  const sizeClasses2 = {
    xs: "p-2 text-xs min-h-[4rem]",
    sm: "p-3 text-sm min-h-[5rem]",
    md: "p-4 text-base min-h-[6rem]",
    lg: "p-5 text-lg min-h-[7rem]",
    xl: "p-6 text-xl min-h-[8rem]"
  };
  const variantClasses2 = {
    primary: "bg-bg-secondary dark:bg-dark-bg-secondary text-text-primary dark:text-dark-text-primary",
    secondary: "bg-bg-tertiary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary",
    outline: "bg-transparent border-2 text-text-primary dark:text-dark-text-primary",
    ghost: "bg-transparent text-text-primary dark:text-dark-text-primary",
    filled: "bg-bg-primary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary"
  };
  const focusBorderByColor = {
    primary: "focus:border-brand-navy dark:focus:border-dark-brand-orange",
    success: "focus:border-system-success dark:focus:border-system-success",
    warning: "focus:border-system-warning-dark dark:focus:border-system-warning",
    danger: "focus:border-system-error dark:focus:border-system-error",
    info: "focus:border-system-info dark:focus:border-system-info"
  };
  const focusRingByColor = {
    primary: "focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    success: "focus:ring-system-success dark:focus:ring-system-success",
    warning: "focus:ring-system-warning dark:focus:ring-system-warning",
    danger: "focus:ring-system-error dark:focus:ring-system-error",
    info: "focus:ring-system-info dark:focus:ring-system-info"
  };
  const stateClasses = {
    default: hasBorder ? "border-border-color dark:border-dark-border-color" : "border-transparent",
    error: "border-2 border-system-error dark:border-system-error",
    success: "border-2 border-system-success dark:border-system-success",
    warning: "border-2 border-system-warning-dark dark:border-system-warning"
  };
  const baseClasses = "focus:outline-none";
  const backgroundClasses = hasBackground ? variantClasses2[variant] : "bg-transparent";
  const getRadiusClass2 = () => {
    switch (radius) {
      case "none":
        return "rounded-none";
      case "sm":
        return "rounded-sm";
      case "md":
        return "rounded";
      case "lg":
        return "rounded-lg";
      case "xl":
        return "rounded-xl";
      case "full":
        return "rounded-full";
      default:
        return "rounded";
    }
  };
  const roundedClasses = getRadiusClass2();
  const shadowClasses = hasShadow ? "shadow-md" : "";
  const focusClasses = `${focusBorderByColor[color2]} ${hasFocusRing ? `focus:ring-2 focus:ring-offset-2 ${focusRingByColor[color2]}` : ""}`.trim();
  const widthClass = fullWidth ? "w-full" : "w-auto";
  const disabledClasses = disabled || loading ? "opacity-60 cursor-not-allowed" : "cursor-text";
  const readOnlyClasses = isReadOnly ? "bg-gray-100 dark:bg-gray-800 cursor-default" : "";
  const loadingClasses = loading ? "animate-pulse" : "";
  const resizeClass = isResizable ? "resize" : "resize-none";
  const autoResizeClass = hasAutoResize ? "overflow-hidden" : "";
  const getStateClass = () => {
    if (error2) return stateClasses.error;
    if (isSuccess) return stateClasses.success;
    if (isWarning) return stateClasses.warning;
    if (variant === "ghost" && hasBorder) return "border border-transparent hover:border-border-color dark:hover:border-dark-border-color focus:border-border-color dark:focus:border-dark-border-color";
    return hasBorder ? "border " + stateClasses.default : "border-transparent";
  };
  const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
  const isFloatingLabel = labelMode === "floating";
  const [isFocused, setIsFocused] = useState(false);
  const hasValue = props.value != null && String(props.value).trim() !== "";
  const shouldFloatLabel = isFloatingLabel && (hasValue || isFocused);
  const combinedClasses = `${baseClasses} ${sizeClasses2[size2]} ${widthClass} ${backgroundClasses} ${getStateClass()} ${roundedClasses} ${shadowClasses} ${focusClasses} ${disabledClasses} ${readOnlyClasses} ${loadingClasses} ${resizeClass} ${autoResizeClass} ${alignmentClass} ${textareaClassName} ${className}`;
  const currentLength = props.value?.length || 0;
  const isOverLimit = maxCharacters && currentLength > maxCharacters;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${widthClass} ${containerClassName}`, children: [
    showLabel && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: `block text-sm font-semibold text-text-primary dark:text-dark-text-primary mb-2 ${alignmentClass} ${labelClassName}`, children: [
      label,
      required && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      showLabel && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "span",
        {
          className: [
            "absolute transition-all duration-200 pointer-events-none z-10",
            leftIcon ? "left-12" : "left-3",
            "text-text-secondary dark:text-dark-text-secondary",
            shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-3 -translate-y-0",
            error2 && "text-system-error-dark",
            isSuccess && "text-green-600 dark:text-green-400"
          ].filter(Boolean).join(" "),
          children: [
            label,
            required && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
          ]
        }
      ),
      leftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-3 top-3 text-text-secondary dark:text-dark-text-secondary z-0", children: leftIcon }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          id: id2,
          className: combinedClasses,
          style: {
            paddingLeft: leftIcon ? "2.5rem" : void 0,
            paddingRight: rightIcon || loading ? "2.5rem" : void 0
          },
          disabled: disabled || loading,
          required,
          readOnly: isReadOnly,
          spellCheck: hasSpellCheck,
          maxLength: maxCharacters,
          placeholder: isFloatingLabel ? void 0 : placeholder,
          rows,
          onFocus: (e2) => {
            setIsFocused(true);
            props.onFocus?.(e2);
          },
          onBlur: (e2) => {
            setIsFocused(false);
            props.onBlur?.(e2);
          },
          ...minRows && { minRows },
          ...maxRows && { maxRows },
          ...(() => {
            const { isSuccess: isSuccess2, isWarning: isWarning2, loading: loading2, placeholder: _p, onFocus, onBlur, ...restProps } = props;
            return restProps;
          })()
        }
      ),
      loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-3 top-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) }),
      rightIcon && !loading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-3 top-3 text-text-secondary dark:text-dark-text-secondary", children: rightIcon })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 space-y-1", children: [
      showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
      showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText }),
      showCharacterCount && maxCharacters && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: `text-xs ${isOverLimit ? "text-system-error" : "text-text-secondary dark:text-dark-text-secondary"}`, children: [
        currentLength,
        " / ",
        maxCharacters,
        " characters"
      ] })
    ] })
  ] });
};
const ToastContext = createContext(null);
const useToast = () => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
};
const Toast = ({
  toast,
  onDismiss,
  size: size2 = "md",
  hasIcon = true,
  hasCloseButton = true,
  hasTitle = true,
  hasDescription = true,
  customColor,
  autoDismissDelay = 5e3,
  hasAutoDismiss = true
}) => {
  const [isExiting, setIsExiting] = useState(false);
  useEffect(() => {
    if (hasAutoDismiss) {
      const timer = setTimeout(() => {
        handleDismiss();
      }, autoDismissDelay);
      return () => clearTimeout(timer);
    }
  }, [hasAutoDismiss, autoDismissDelay]);
  const handleDismiss = () => {
    setIsExiting(true);
    setTimeout(() => {
      onDismiss(toast.id);
    }, 300);
  };
  const sizeClasses2 = {
    xs: "p-2 text-xs gap-2 min-w-64 max-w-sm",
    sm: "p-3 text-sm gap-3 min-w-72 max-w-sm",
    md: "p-4 text-base gap-4 min-w-80 max-w-sm",
    lg: "p-5 text-lg gap-4 min-w-96 max-w-sm",
    xl: "p-6 text-xl gap-5 min-w-[28rem] max-w-sm"
  };
  const variantStyles = {
    success: {
      icon: "check_circle",
      containerClasses: "bg-system-success-light dark:bg-system-success-dark-bg border-system-success dark:border-system-success text-system-success-dark dark:text-system-success-light-text",
      textClasses: "text-system-success-dark dark:text-system-success-light-text"
    },
    error: {
      icon: "cancel",
      containerClasses: "bg-system-error-light dark:bg-system-error-dark-bg border-system-error dark:border-system-error text-system-error-dark dark:text-system-error-light-text",
      textClasses: "text-system-error-dark dark:text-system-error-light-text"
    },
    warning: {
      icon: "warning",
      containerClasses: "bg-system-warning-light dark:bg-system-warning-dark-bg border-system-warning-border dark:border-system-warning text-system-warning-dark dark:text-system-warning-light-text",
      textClasses: "text-system-warning-dark dark:text-system-warning-light-text"
    },
    danger: {
      icon: "error",
      containerClasses: "bg-system-error dark:bg-system-error text-white border-system-error dark:border-system-error",
      textClasses: "text-white dark:text-white"
    },
    info: {
      icon: "info",
      containerClasses: "bg-system-info-light dark:bg-system-info-dark-bg border-system-info dark:border-system-info text-system-info-dark dark:text-system-info-light-text",
      textClasses: "text-system-info-dark dark:text-system-info-light-text"
    }
  };
  const styles = variantStyles[toast.variant];
  const toastClasses = [
    "flex items-start w-full max-w-full rounded-xl transition-all duration-300 ease-in-out transform shadow-lg border",
    sizeClasses2[size2],
    styles.containerClasses,
    // Animation classes
    isExiting ? "opacity-0 translate-x-full scale-95" : "opacity-100 translate-x-0 scale-100"
  ].filter(Boolean).join(" ");
  const toastStyles = {
    ...customColor && { backgroundColor: customColor }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: toastClasses,
      style: toastStyles,
      role: "status",
      "aria-live": "polite",
      children: [
        hasIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "2xl", className: `shrink-0 self-start ${styles.textClasses}`, children: styles.icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex-grow ${styles.textClasses}`, children: [
          hasTitle && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-bold", children: toast.title }),
          hasDescription && toast.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm mt-1 opacity-80", children: toast.description })
        ] }),
        hasCloseButton && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleDismiss,
            "aria-label": "Dismiss notification",
            className: `p-1 rounded-full transition-opacity self-start ${styles.textClasses} opacity-70 hover:opacity-100 hover:bg-black/10 dark:hover:bg-white/10`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { children: "close" })
          }
        )
      ]
    }
  );
};
const ToastProvider = ({
  children,
  defaultPosition = "top-right",
  defaultSize = "md",
  autoDismissDelay = 5e3,
  hasAutoDismiss = true,
  hasIcon = true,
  hasCloseButton = true,
  hasTitle = true,
  hasDescription = true,
  customColor
}) => {
  const [toasts, setToasts] = useState([]);
  const [currentPosition, setCurrentPosition] = useState(defaultPosition);
  const showToast = (options) => {
    const id2 = crypto.randomUUID();
    setToasts((prev) => [...prev, { id: id2, ...options }]);
  };
  const dismissToast = (id2) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id2));
  };
  const updatePosition = (position) => {
    console.log("ToastProvider: Updating position to", position);
    setCurrentPosition(position);
  };
  const positionClasses = {
    "top-left": "top-0 left-0 w-auto items-start justify-start",
    "top-center": "top-0 left-0 right-0 w-full items-start justify-center",
    "top-right": "top-0 right-0 w-auto items-start justify-end",
    "bottom-left": "bottom-0 left-0 w-auto items-end justify-start",
    "bottom-center": "bottom-0 left-0 right-0 w-full items-end justify-center",
    "bottom-right": "bottom-0 right-0 w-auto items-end justify-end"
  };
  const containerClasses = [
    "fixed",
    "z-[9998]",
    "p-4",
    // Use padding on the container to ensure toasts don't touch the edge
    "flex",
    // Enable flexbox
    "flex-col",
    // Stack toasts vertically
    "space-y-3",
    // Add space between toasts
    "pointer-events-none",
    // Allow clicks to pass through the container
    positionClasses[currentPosition]
  ].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastContext.Provider, { value: { showToast, updatePosition }, children: [
    children,
    typeof window === "object" && ReactDOM__default.createPortal(
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          id: "toast-container",
          className: containerClasses,
          children: toasts.map((toast) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `pointer-events-auto ${currentPosition.includes("center") ? "w-full flex justify-center" : "w-auto"}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Toast,
            {
              toast,
              onDismiss: dismissToast,
              size: toast.size || defaultSize,
              hasIcon,
              hasCloseButton,
              hasTitle,
              hasDescription,
              customColor,
              autoDismissDelay,
              hasAutoDismiss
            }
          ) }, toast.id))
        }
      ),
      document.body
    )
  ] });
};
const ToggleSwitch = ({
  label,
  id: id2,
  containerClassName = "",
  labelClassName = "",
  toggleClassName = "",
  isDisabled = false,
  isRequired = false,
  isLoading = false,
  isReadOnly = false,
  hasBorder = true,
  hasRoundedCorners = true,
  hasFocusRing = true,
  hasShadow = false,
  hasBackground = true,
  showLabel = true,
  showHelperText = true,
  showErrorText = true,
  showRequiredIndicator = true,
  showDescription = false,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  isLabelLeft = false,
  labelPosition,
  isFullWidth = false,
  helperText,
  helperTextPosition = "bottom",
  error: error2,
  description,
  isChecked = false,
  onChange,
  isAnimated = true,
  showLoadingSpinner = false,
  showValue = false,
  onLabel = "ON",
  offLabel = "OFF",
  ...props
}) => {
  const sizeClasses2 = {
    xs: "w-8 h-5",
    sm: "w-10 h-6",
    md: "w-12 h-7",
    lg: "w-14 h-8",
    xl: "w-16 h-9"
  };
  const baseColorClasses = {
    primary: "border-gray-300 dark:border-gray-600 focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    success: "border-gray-300 dark:border-gray-600 focus:ring-system-success dark:focus:ring-system-success",
    warning: "border-gray-300 dark:border-gray-600 focus:ring-system-warning dark:focus:ring-system-warning",
    danger: "border-gray-300 dark:border-gray-600 focus:ring-system-error dark:focus:ring-system-error",
    info: "border-gray-300 dark:border-gray-600 focus:ring-system-info dark:focus:ring-system-info"
  };
  const checkedStateClasses = {
    primary: {
      primary: "peer-checked:bg-brand-orange peer-checked:border-brand-orange dark:peer-checked:bg-dark-brand-orange dark:peer-checked:border-dark-brand-orange",
      success: "peer-checked:bg-green-500 peer-checked:border-green-500",
      warning: "peer-checked:bg-yellow-500 peer-checked:border-yellow-500",
      danger: "peer-checked:bg-red-500 peer-checked:border-red-500",
      info: "peer-checked:bg-blue-500 peer-checked:border-blue-500"
    },
    secondary: {
      primary: "peer-checked:!bg-brand-navy peer-checked:!border-brand-navy dark:peer-checked:!bg-dark-brand-navy dark:peer-checked:!border-dark-brand-navy",
      success: "peer-checked:!bg-brand-navy peer-checked:!border-brand-navy dark:peer-checked:!bg-dark-brand-navy dark:peer-checked:!border-dark-brand-navy",
      warning: "peer-checked:!bg-brand-navy peer-checked:!border-brand-navy dark:peer-checked:!bg-dark-brand-navy dark:peer-checked:!border-dark-brand-navy",
      danger: "peer-checked:!bg-brand-navy peer-checked:!border-brand-navy dark:peer-checked:!bg-dark-brand-navy dark:peer-checked:!border-dark-brand-navy",
      info: "peer-checked:!bg-brand-navy peer-checked:!border-brand-navy dark:peer-checked:!bg-dark-brand-navy dark:peer-checked:!border-dark-brand-navy"
    },
    outline: {
      primary: "peer-checked:bg-transparent peer-checked:border-2 peer-checked:border-brand-orange dark:peer-checked:border-dark-brand-orange",
      success: "peer-checked:bg-transparent peer-checked:border-2 peer-checked:border-green-500",
      warning: "peer-checked:bg-transparent peer-checked:border-2 peer-checked:border-yellow-500",
      danger: "peer-checked:bg-transparent peer-checked:border-2 peer-checked:border-red-500",
      info: "peer-checked:bg-transparent peer-checked:border-2 peer-checked:border-blue-500"
    },
    ghost: {
      primary: "peer-checked:bg-brand-orange/10 peer-checked:border peer-checked:border-brand-orange/40 dark:peer-checked:bg-dark-brand-orange/10 dark:peer-checked:border-dark-brand-orange/40",
      success: "peer-checked:bg-green-500/10 peer-checked:border peer-checked:border-green-500/40",
      warning: "peer-checked:bg-yellow-500/10 peer-checked:border peer-checked:border-yellow-500/40",
      danger: "peer-checked:bg-red-500/10 peer-checked:border peer-checked:border-red-500/40",
      info: "peer-checked:bg-blue-500/10 peer-checked:border peer-checked:border-blue-500/40"
    },
    filled: {
      primary: "peer-checked:bg-bg-tertiary peer-checked:border-border-color dark:peer-checked:bg-dark-bg-tertiary dark:peer-checked:border-dark-border-color",
      success: "peer-checked:bg-bg-tertiary peer-checked:border-border-color dark:peer-checked:bg-dark-bg-tertiary dark:peer-checked:border-dark-border-color",
      warning: "peer-checked:bg-bg-tertiary peer-checked:border-border-color dark:peer-checked:bg-dark-bg-tertiary dark:peer-checked:border-dark-border-color",
      danger: "peer-checked:bg-bg-tertiary peer-checked:border-border-color dark:peer-checked:bg-dark-bg-tertiary dark:peer-checked:border-dark-border-color",
      info: "peer-checked:bg-bg-tertiary peer-checked:border-border-color dark:peer-checked:bg-dark-bg-tertiary dark:peer-checked:border-dark-border-color"
    }
  };
  const backgroundClasses = hasBackground ? "bg-gray-200 dark:bg-gray-700" : "bg-transparent";
  const baseColorClass = baseColorClasses[color2];
  const checkedClass = checkedStateClasses[variant][color2];
  const borderClass = hasBorder ? "border" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const disabledClass = isDisabled || isLoading ? "opacity-60 cursor-not-allowed" : "cursor-pointer";
  const readOnlyClass = isReadOnly ? "opacity-80 cursor-default" : "";
  const labelContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `text-sm font-semibold text-text-primary dark:text-dark-text-primary ${labelClassName}`, children: [
      label,
      isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
    ] }),
    showDescription && description && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-text-secondary dark:text-dark-text-secondary mt-1", children: description })
  ] });
  const isControlled = typeof onChange === "function";
  const focusWithinClass = hasFocusRing ? "focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-brand-orange dark:focus-within:ring-dark-brand-orange" : "";
  const toggleContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `relative rounded-full ${focusWithinClass}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        id: id2,
        className: "sr-only peer",
        disabled: isDisabled || isLoading,
        required: isRequired,
        readOnly: isReadOnly,
        ...isControlled ? { checked: isChecked, onChange } : { defaultChecked: isChecked },
        ...(() => {
          const { isSuccess, isWarning, loading, ...restProps } = props;
          return restProps;
        })()
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${sizeClasses2[size2]} ${backgroundClasses} ${borderClass} ${shadowClass} ${disabledClass} ${readOnlyClass} ${toggleClassName} ${baseColorClass} ${checkedClass} relative rounded-full transition-colors duration-200 ease-in-out`, children: [
      showLoadingSpinner && isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-3 w-3 border-2 border-current border-t-transparent" }) }),
      showValue && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `absolute inset-0 flex items-center justify-center text-xs font-medium peer-checked:text-white text-text-secondary dark:text-dark-text-secondary`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "peer-checked:hidden", children: offLabel }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hidden peer-checked:inline", children: onLabel })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `absolute top-0.5 left-0.5 bg-white rounded-full shadow-md transition-transform duration-200 ease-in-out ${size2 === "xs" ? "w-4 h-4 peer-checked:translate-x-3" : (
      // 8px (w-8) - 4px (knob) - 1px (padding) = 3px
      size2 === "sm" ? "w-5 h-5 peer-checked:translate-x-4" : (
        // 10px (w-10) - 5px (knob) - 1px (padding) = 4px
        size2 === "md" ? "w-6 h-6 peer-checked:translate-x-5" : (
          // 12px (w-12) - 6px (knob) - 1px (padding) = 5px
          size2 === "lg" ? "w-7 h-7 peer-checked:translate-x-6" : (
            // 14px (w-14) - 7px (knob) - 1px (padding) = 6px
            "w-8 h-8 peer-checked:translate-x-7"
          )
        )
      )
    )}` })
  ] });
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const effectiveLabelPosition = labelPosition || (isLabelLeft ? "left" : "right");
  if (effectiveLabelPosition === "top") {
    const helperTextAbove = (helperText || error2) && helperTextPosition === "top";
    const helperTextBelow = (helperText || error2) && helperTextPosition === "bottom";
    const helperTextRight = (helperText || error2) && helperTextPosition === "right";
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-col gap-2 ${widthClass} ${containerClassName}`, children: [
      labelContent,
      helperTextAbove && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-1", children: [
        showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
        showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: helperTextRight ? "flex items-start gap-3" : "", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: `flex items-center ${isDisabled ? "cursor-not-allowed" : "cursor-pointer"}`, children: toggleContent }),
        helperTextRight && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1", children: [
          showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
          showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
        ] })
      ] }),
      helperTextBelow && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1", children: [
        showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
        showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex items-center gap-3 ${widthClass} ${containerClassName}`, children: [
    effectiveLabelPosition === "left" && labelContent,
    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: `flex items-center ${isDisabled ? "cursor-not-allowed" : "cursor-pointer"}`, children: toggleContent }),
    effectiveLabelPosition === "right" && labelContent,
    (helperText || error2) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "ml-8 mt-1", children: [
      showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-system-error", children: error2 }),
      showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText })
    ] })
  ] });
};
const Tooltip = forwardRef(({
  children,
  label,
  icon,
  placement,
  position,
  // Legacy prop
  variant,
  color: color2,
  // Legacy prop
  size: size2 = "md",
  isDisabled = false,
  openDelay,
  delay: delay3,
  // Legacy prop
  closeDelay = 0,
  isOpen: controlledIsOpen,
  isControlled = false,
  onOpen,
  onClose,
  className,
  style,
  hasArrow = true,
  maxWidth = "200px",
  isInteractive = false,
  followCursor = false,
  portalContainer,
  usePortal = true,
  enableCollisionDetection = true,
  animation = "fade",
  enableKeyboard = true,
  enableTouch = true,
  offset: offset2 = 8,
  onMouseEnter,
  onMouseLeave,
  onFocus,
  onBlur,
  hasDelay,
  // Legacy prop
  hasBackground,
  // Legacy prop
  isBordered,
  // Legacy prop
  isRounded,
  // Legacy prop
  hasShadow,
  // Legacy prop
  hasFadeEffect,
  // Legacy prop
  hasFollowCursor,
  // Legacy prop
  ...props
}, ref) => {
  const finalPlacement = placement || position || "top";
  const finalVariant = variant || color2 || "default";
  const finalOpenDelay = openDelay !== void 0 ? openDelay : delay3 || 0;
  const finalFollowCursor = followCursor || hasFollowCursor || false;
  const [internalState, setInternalState] = useState({
    isOpen: false,
    showTimeout: null,
    hideTimeout: null
  });
  const [triggerRect, setTriggerRect] = useState(null);
  const [cursorPosition, setCursorPosition] = useState(null);
  const triggerRef = useRef(null);
  const tooltipRef = useRef(null);
  const portalRef = useRef(null);
  const interactiveHideTimeoutRef = useRef(null);
  const isOpen = isControlled ? controlledIsOpen : internalState.isOpen;
  const clearTimeouts = useCallback(() => {
    if (internalState.showTimeout) {
      clearTimeout(internalState.showTimeout);
    }
    if (internalState.hideTimeout) {
      clearTimeout(internalState.hideTimeout);
    }
  }, [internalState.showTimeout, internalState.hideTimeout]);
  const showTooltip = useCallback(() => {
    if (isDisabled || !label) return;
    if (usePortal && triggerRef.current) {
      setTriggerRect(triggerRef.current.getBoundingClientRect());
    }
    clearTimeouts();
    const timeout = setTimeout(() => {
      if (!isControlled) {
        setInternalState((prev) => ({ ...prev, isOpen: true }));
      }
      onOpen?.();
    }, finalOpenDelay);
    if (!isControlled) {
      setInternalState((prev) => ({ ...prev, showTimeout: timeout }));
    }
  }, [isDisabled, label, clearTimeouts, finalOpenDelay, isControlled, onOpen, usePortal]);
  const hideTooltip = useCallback(() => {
    clearTimeouts();
    const timeout = setTimeout(() => {
      if (!isControlled) {
        setInternalState((prev) => ({ ...prev, isOpen: false }));
      }
      onClose?.();
      setTimeout(() => {
        setTriggerRect(null);
      }, 200);
    }, closeDelay);
    if (!isControlled) {
      setInternalState((prev) => ({ ...prev, hideTimeout: timeout }));
    }
  }, [clearTimeouts, closeDelay, isControlled, onClose]);
  const handleMouseEnter = useCallback((e2) => {
    e2.stopPropagation();
    showTooltip();
    onMouseEnter?.(e2);
  }, [showTooltip, onMouseEnter]);
  const handleMouseLeave = useCallback((e2) => {
    e2.stopPropagation();
    const relatedTarget = e2.relatedTarget;
    if (isInteractive) {
      if (relatedTarget?.closest('[role="tooltip"]')) {
        return;
      }
      setTimeout(() => {
        if (!tooltipRef.current?.matches(":hover") && !triggerRef.current?.matches(":hover")) {
          hideTooltip();
        }
      }, 100);
    } else {
      hideTooltip();
    }
    onMouseLeave?.(e2);
  }, [hideTooltip, isInteractive, onMouseLeave]);
  const handleMouseMove = useCallback((e2) => {
    if (finalFollowCursor && isOpen) {
      setCursorPosition({ x: e2.clientX, y: e2.clientY });
    }
  }, [finalFollowCursor, isOpen]);
  const handleFocus = useCallback((e2) => {
    e2.stopPropagation();
    if (enableKeyboard) {
      showTooltip();
    }
    onFocus?.(e2);
  }, [showTooltip, enableKeyboard, onFocus]);
  const handleBlur = useCallback((e2) => {
    e2.stopPropagation();
    if (enableKeyboard) {
      hideTooltip();
    }
    onBlur?.(e2);
  }, [hideTooltip, enableKeyboard, onBlur]);
  const handleTouchStart = useCallback((e2) => {
    if (enableTouch) {
      e2.stopPropagation();
      showTooltip();
    }
  }, [showTooltip, enableTouch]);
  const handleTouchEnd = useCallback((e2) => {
    if (enableTouch) {
      e2.stopPropagation();
      setTimeout(() => hideTooltip(), 1e3);
    }
  }, [hideTooltip, enableTouch]);
  const handleKeyDown = useCallback((e2) => {
    if (enableKeyboard) {
      if (e2.key === "Escape" && isOpen) {
        hideTooltip();
      } else if (e2.key === "Enter" || e2.key === " ") {
        e2.preventDefault();
        if (isOpen) {
          hideTooltip();
        } else {
          showTooltip();
        }
      }
    }
  }, [enableKeyboard, isOpen, showTooltip, hideTooltip]);
  useEffect(() => {
    return () => {
      clearTimeouts();
      if (interactiveHideTimeoutRef.current) {
        clearTimeout(interactiveHideTimeoutRef.current);
      }
    };
  }, [clearTimeouts]);
  useEffect(() => {
    if (usePortal && !portalContainer && typeof document !== "undefined") {
      const portal = document.createElement("div");
      portal.style.position = "fixed";
      portal.style.top = "0";
      portal.style.left = "0";
      portal.style.pointerEvents = "none";
      portal.style.zIndex = "9999";
      document.body.appendChild(portal);
      portalRef.current = portal;
      return () => {
        if (portalRef.current) {
          document.body.removeChild(portalRef.current);
        }
      };
    }
  }, [usePortal, portalContainer]);
  const variantStyles = {
    default: {
      bg: "bg-grey-700 dark:bg-grey-100",
      text: "text-white dark:text-grey-800",
      arrow: "border-grey-700 dark:border-grey-100"
    },
    primary: {
      bg: "bg-brand-navy dark:bg-brand-navy-300",
      text: "text-white dark:text-brand-navy-900",
      arrow: "border-brand-navy dark:border-brand-navy-300"
    },
    success: {
      bg: "bg-system-success dark:bg-system-success-dark-bg",
      text: "text-white dark:text-system-success-light-text",
      arrow: "border-system-success dark:border-system-success-dark-bg"
    },
    warning: {
      bg: "bg-system-warning-light dark:bg-system-warning-dark-bg",
      text: "text-system-warning-dark dark:text-system-warning-light-text",
      arrow: "border-system-warning-border dark:border-system-warning-dark-bg"
    },
    error: {
      bg: "bg-system-error dark:bg-system-error-dark-bg",
      text: "text-white dark:text-system-error-light-text",
      arrow: "border-system-error dark:border-system-error-dark-bg"
    },
    info: {
      bg: "bg-system-info dark:bg-system-info-dark-bg",
      text: "text-white dark:text-system-info-light-text",
      arrow: "border-system-info dark:border-system-info-dark-bg"
    },
    accent: {
      bg: "bg-brand-orange dark:bg-brand-orange",
      text: "text-white dark:text-white",
      arrow: "border-brand-orange dark:border-brand-orange"
    }
  };
  const sizeStyles = {
    sm: {
      classes: "text-xs px-2 py-1",
      fontSize: "0.75rem",
      // 12px
      lineHeight: "1rem",
      // 16px
      minWidth: "60px",
      maxWidth: "120px",
      // Reduced for better wrapping
      arrowSize: "border-2 border-solid"
      // Smaller arrow for small tooltip
    },
    md: {
      classes: "text-sm px-3 py-2",
      fontSize: "0.875rem",
      // 14px
      lineHeight: "1.25rem",
      // 20px
      minWidth: "80px",
      maxWidth: "180px",
      // Reduced for better wrapping
      arrowSize: "border-[3px] border-solid"
      // Medium arrow for medium tooltip
    },
    lg: {
      classes: "text-base px-4 py-3",
      fontSize: "1rem",
      // 16px
      lineHeight: "1.5rem",
      // 24px
      minWidth: "100px",
      maxWidth: "220px",
      // Reduced for better wrapping
      arrowSize: "border-4 border-solid"
      // Larger arrow for large tooltip
    }
  };
  const placementStyles = {
    top: "bottom-full left-1/2 -translate-x-1/2 mb-4",
    // Further increased spacing
    "top-start": "bottom-full left-0 mb-4",
    // Further increased spacing
    "top-end": "bottom-full right-0 mb-4",
    // Further increased spacing
    bottom: "top-full left-1/2 -translate-x-1/2 mt-2",
    "bottom-start": "top-full left-0 mt-2",
    "bottom-end": "top-full right-0 mt-2",
    left: "right-full top-1/2 -translate-y-1/2 mr-2",
    "left-start": "right-full top-0 mr-2",
    "left-end": "right-full bottom-0 mr-2",
    right: "left-full top-1/2 -translate-y-1/2 ml-2",
    "right-start": "left-full top-0 ml-2",
    "right-end": "left-full bottom-0 ml-2"
  };
  const getArrowStyles = (placement2, size22) => {
    const offsetClasses = {
      sm: {
        top: "bottom-[-2px]",
        bottom: "top-[-2px]",
        left: "right-[-2px]",
        right: "left-[-2px]"
      },
      md: {
        top: "bottom-[-3px]",
        bottom: "top-[-3px]",
        left: "right-[-3px]",
        right: "left-[-3px]"
      },
      lg: {
        top: "bottom-[-4px]",
        bottom: "top-[-4px]",
        left: "right-[-4px]",
        right: "left-[-4px]"
      }
    };
    const offsets = offsetClasses[size22];
    const basePositions = {
      top: `${offsets.top} left-1/2 -translate-x-1/2`,
      "top-start": `${offsets.top} left-3`,
      "top-end": `${offsets.top} right-3`,
      bottom: `${offsets.bottom} left-1/2 -translate-x-1/2`,
      "bottom-start": `${offsets.bottom} left-3`,
      "bottom-end": `${offsets.bottom} right-3`,
      left: `${offsets.left} top-1/2 -translate-y-1/2`,
      "left-start": `${offsets.left} top-3`,
      "left-end": `${offsets.left} bottom-3`,
      right: `${offsets.right} top-1/2 -translate-y-1/2`,
      "right-start": `${offsets.right} top-3`,
      "right-end": `${offsets.right} bottom-3`
    };
    return basePositions[placement2];
  };
  const currentVariant = variantStyles[finalVariant];
  const currentSize = sizeStyles[size2];
  const currentPlacement = placementStyles[finalPlacement];
  const currentArrow = getArrowStyles(finalPlacement, size2);
  const getArrowColorClasses = (variant2, placement2, size22) => {
    const arrowColors = {
      sm: {
        default: {
          top: "border-2 border-b-grey-700 dark:border-b-grey-100 border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-2 border-t-grey-700 dark:border-t-grey-100 border-l-transparent border-r-transparent border-b-transparent",
          left: "border-2 border-r-grey-700 dark:border-r-grey-100 border-t-transparent border-b-transparent border-l-transparent",
          right: "border-2 border-l-grey-700 dark:border-l-grey-100 border-t-transparent border-b-transparent border-r-transparent"
        },
        primary: {
          top: "border-2 border-b-brand-navy dark:border-b-brand-navy-300 border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-2 border-t-brand-navy dark:border-t-brand-navy-300 border-l-transparent border-r-transparent border-b-transparent",
          left: "border-2 border-r-brand-navy dark:border-r-brand-navy-300 border-t-transparent border-b-transparent border-l-transparent",
          right: "border-2 border-l-brand-navy dark:border-l-brand-navy-300 border-t-transparent border-b-transparent border-r-transparent"
        },
        success: {
          top: "border-2 border-b-system-success dark:border-b-system-success-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-2 border-t-system-success dark:border-t-system-success-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-2 border-r-system-success dark:border-r-system-success-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-2 border-l-system-success dark:border-l-system-success-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        warning: {
          top: "border-2 border-b-system-warning-border dark:border-b-system-warning-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-2 border-t-system-warning-border dark:border-t-system-warning-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-2 border-r-system-warning-border dark:border-r-system-warning-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-2 border-l-system-warning-border dark:border-l-system-warning-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        error: {
          top: "border-2 border-b-system-error dark:border-b-system-error-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-2 border-t-system-error dark:border-t-system-error-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-2 border-r-system-error dark:border-r-system-error-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-2 border-l-system-error dark:border-l-system-error-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        info: {
          top: "border-2 border-b-system-info dark:border-b-system-info-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-2 border-t-system-info dark:border-t-system-info-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-2 border-r-system-info dark:border-r-system-info-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-2 border-l-system-info dark:border-l-system-info-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        accent: {
          top: "border-2 border-b-brand-orange dark:border-b-brand-orange border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-2 border-t-brand-orange dark:border-t-brand-orange border-l-transparent border-r-transparent border-b-transparent",
          left: "border-2 border-r-brand-orange dark:border-r-brand-orange border-t-transparent border-b-transparent border-l-transparent",
          right: "border-2 border-l-brand-orange dark:border-l-brand-orange border-t-transparent border-b-transparent border-r-transparent"
        }
      },
      md: {
        default: {
          top: "border-[3px] border-b-grey-700 dark:border-b-grey-100 border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-[3px] border-t-grey-700 dark:border-t-grey-100 border-l-transparent border-r-transparent border-b-transparent",
          left: "border-[3px] border-r-grey-700 dark:border-r-grey-100 border-t-transparent border-b-transparent border-l-transparent",
          right: "border-[3px] border-l-grey-700 dark:border-l-grey-100 border-t-transparent border-b-transparent border-r-transparent"
        },
        primary: {
          top: "border-[3px] border-b-brand-navy dark:border-b-brand-navy-300 border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-[3px] border-t-brand-navy dark:border-t-brand-navy-300 border-l-transparent border-r-transparent border-b-transparent",
          left: "border-[3px] border-r-brand-navy dark:border-r-brand-navy-300 border-t-transparent border-b-transparent border-l-transparent",
          right: "border-[3px] border-l-brand-navy dark:border-l-brand-navy-300 border-t-transparent border-b-transparent border-r-transparent"
        },
        success: {
          top: "border-[3px] border-b-system-success dark:border-b-system-success-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-[3px] border-t-system-success dark:border-t-system-success-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-[3px] border-r-system-success dark:border-r-system-success-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-[3px] border-l-system-success dark:border-l-system-success-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        warning: {
          top: "border-[3px] border-b-system-warning-border dark:border-b-system-warning-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-[3px] border-t-system-warning-border dark:border-t-system-warning-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-[3px] border-r-system-warning-border dark:border-r-system-warning-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-[3px] border-l-system-warning-border dark:border-l-system-warning-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        error: {
          top: "border-[3px] border-b-system-error dark:border-b-system-error-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-[3px] border-t-system-error dark:border-t-system-error-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-[3px] border-r-system-error dark:border-r-system-error-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-[3px] border-l-system-error dark:border-l-system-error-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        info: {
          top: "border-[3px] border-b-system-info dark:border-b-system-info-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-[3px] border-t-system-info dark:border-t-system-info-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-[3px] border-r-system-info dark:border-r-system-info-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-[3px] border-l-system-info dark:border-l-system-info-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        accent: {
          top: "border-[3px] border-b-brand-orange dark:border-b-brand-orange border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-[3px] border-t-brand-orange dark:border-t-brand-orange border-l-transparent border-r-transparent border-b-transparent",
          left: "border-[3px] border-r-brand-orange dark:border-r-brand-orange border-t-transparent border-b-transparent border-l-transparent",
          right: "border-[3px] border-l-brand-orange dark:border-l-brand-orange border-t-transparent border-b-transparent border-r-transparent"
        }
      },
      lg: {
        default: {
          top: "border-4 border-b-grey-700 dark:border-b-grey-100 border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-4 border-t-grey-700 dark:border-t-grey-100 border-l-transparent border-r-transparent border-b-transparent",
          left: "border-4 border-r-grey-700 dark:border-r-grey-100 border-t-transparent border-b-transparent border-l-transparent",
          right: "border-4 border-l-grey-700 dark:border-l-grey-100 border-t-transparent border-b-transparent border-r-transparent"
        },
        primary: {
          top: "border-4 border-b-brand-navy dark:border-b-brand-navy-300 border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-4 border-t-brand-navy dark:border-t-brand-navy-300 border-l-transparent border-r-transparent border-b-transparent",
          left: "border-4 border-r-brand-navy dark:border-r-brand-navy-300 border-t-transparent border-b-transparent border-l-transparent",
          right: "border-4 border-l-brand-navy dark:border-l-brand-navy-300 border-t-transparent border-b-transparent border-r-transparent"
        },
        success: {
          top: "border-4 border-b-system-success dark:border-b-system-success-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-4 border-t-system-success dark:border-t-system-success-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-4 border-r-system-success dark:border-r-system-success-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-4 border-l-system-success dark:border-l-system-success-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        warning: {
          top: "border-4 border-b-system-warning-border dark:border-b-system-warning-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-4 border-t-system-warning-border dark:border-t-system-warning-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-4 border-r-system-warning-border dark:border-r-system-warning-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-4 border-l-system-warning-border dark:border-l-system-warning-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        error: {
          top: "border-4 border-b-system-error dark:border-b-system-error-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-4 border-t-system-error dark:border-t-system-error-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-4 border-r-system-error dark:border-r-system-error-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-4 border-l-system-error dark:border-l-system-error-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        info: {
          top: "border-4 border-b-system-info dark:border-b-system-info-dark-bg border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-4 border-t-system-info dark:border-t-system-info-dark-bg border-l-transparent border-r-transparent border-b-transparent",
          left: "border-4 border-r-system-info dark:border-r-system-info-dark-bg border-t-transparent border-b-transparent border-l-transparent",
          right: "border-4 border-l-system-info dark:border-l-system-info-dark-bg border-t-transparent border-b-transparent border-r-transparent"
        },
        accent: {
          top: "border-4 border-b-brand-orange dark:border-b-brand-orange border-l-transparent border-r-transparent border-t-transparent",
          bottom: "border-4 border-t-brand-orange dark:border-t-brand-orange border-l-transparent border-r-transparent border-b-transparent",
          left: "border-4 border-r-brand-orange dark:border-r-brand-orange border-t-transparent border-b-transparent border-l-transparent",
          right: "border-4 border-l-brand-orange dark:border-l-brand-orange border-t-transparent border-b-transparent border-r-transparent"
        }
      }
    };
    const direction = placement2.startsWith("top") ? "top" : placement2.startsWith("bottom") ? "bottom" : placement2.startsWith("left") ? "left" : "right";
    return arrowColors[size22][variant2][direction];
  };
  const getSmartPlacement = (preferredPlacement) => {
    if (!enableCollisionDetection || !triggerRect || !tooltipRef.current) {
      return preferredPlacement;
    }
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    const viewport = {
      width: window.innerWidth,
      height: window.innerHeight
    };
    const placements = [
      preferredPlacement,
      ...getFallbackPlacements(preferredPlacement)
    ];
    for (const placement2 of placements) {
      const position2 = calculatePosition(placement2, triggerRect, tooltipRect);
      if (isPositionValid(position2, tooltipRect, viewport)) {
        return placement2;
      }
    }
    return preferredPlacement;
  };
  const getFallbackPlacements = (placement2) => {
    const fallbacks = {
      "top": ["bottom", "right", "left"],
      "top-start": ["bottom-start", "top-end", "bottom"],
      "top-end": ["bottom-end", "top-start", "bottom"],
      "bottom": ["top", "right", "left"],
      "bottom-start": ["top-start", "bottom-end", "top"],
      "bottom-end": ["top-end", "bottom-start", "top"],
      "left": ["right", "top", "bottom"],
      "left-start": ["right-start", "left-end", "right"],
      "left-end": ["right-end", "left-start", "right"],
      "right": ["left", "top", "bottom"],
      "right-start": ["left-start", "right-end", "left"],
      "right-end": ["left-end", "right-start", "left"]
    };
    return fallbacks[placement2] || [];
  };
  const calculatePosition = (placement2, triggerRect2, tooltipRect) => {
    const margin = offset2;
    switch (placement2) {
      case "top":
        return {
          x: triggerRect2.left + triggerRect2.width / 2 - tooltipRect.width / 2,
          y: triggerRect2.top - tooltipRect.height - margin
        };
      case "bottom":
        return {
          x: triggerRect2.left + triggerRect2.width / 2 - tooltipRect.width / 2,
          y: triggerRect2.bottom + margin
        };
      case "left":
        return {
          x: triggerRect2.left - tooltipRect.width - margin,
          y: triggerRect2.top + triggerRect2.height / 2 - tooltipRect.height / 2
        };
      case "right":
        return {
          x: triggerRect2.right + margin,
          y: triggerRect2.top + triggerRect2.height / 2 - tooltipRect.height / 2
        };
      default:
        return calculatePosition(placement2.split("-")[0], triggerRect2, tooltipRect);
    }
  };
  const isPositionValid = (position2, tooltipRect, viewport) => {
    return position2.x >= 0 && position2.y >= 0 && position2.x + tooltipRect.width <= viewport.width && position2.y + tooltipRect.height <= viewport.height;
  };
  const smartPlacement = getSmartPlacement(finalPlacement);
  const getPortalPosition = (placement2) => {
    if (!triggerRect || !tooltipRef.current) return {};
    const tooltipRect = tooltipRef.current.getBoundingClientRect();
    const tooltipWidth = tooltipRect.width || Math.min(parseInt(currentSize.maxWidth), 200);
    const tooltipHeight = tooltipRect.height || 60;
    const offset22 = 16;
    switch (placement2) {
      case "top":
        return {
          left: triggerRect.left + triggerRect.width / 2 - tooltipWidth / 2,
          top: triggerRect.top - tooltipHeight - offset22
        };
      case "top-start":
        return {
          left: triggerRect.left,
          top: triggerRect.top - tooltipHeight - offset22
        };
      case "top-end":
        return {
          left: triggerRect.right - tooltipWidth,
          top: triggerRect.top - tooltipHeight - offset22
        };
      case "bottom":
        return {
          left: triggerRect.left + triggerRect.width / 2 - tooltipWidth / 2,
          top: triggerRect.bottom + offset22
        };
      case "bottom-start":
        return {
          left: triggerRect.left,
          top: triggerRect.bottom + offset22
        };
      case "bottom-end":
        return {
          left: triggerRect.right - tooltipWidth,
          top: triggerRect.bottom + offset22
        };
      case "left":
        return {
          left: triggerRect.left - tooltipWidth - offset22,
          top: triggerRect.top + triggerRect.height / 2 - tooltipHeight / 2
        };
      case "left-start":
        return {
          left: triggerRect.left - tooltipWidth - offset22,
          top: triggerRect.top
        };
      case "left-end":
        return {
          left: triggerRect.left - tooltipWidth - offset22,
          top: triggerRect.bottom - tooltipHeight
        };
      case "right":
        return {
          left: triggerRect.right + offset22,
          top: triggerRect.top + triggerRect.height / 2 - tooltipHeight / 2
        };
      case "right-start":
        return {
          left: triggerRect.right + offset22,
          top: triggerRect.top
        };
      case "right-end":
        return {
          left: triggerRect.right + offset22,
          top: triggerRect.bottom - tooltipHeight
        };
      default:
        return {};
    }
  };
  const tooltipContent = /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: tooltipRef,
      role: "tooltip",
      "aria-hidden": !isOpen,
      className: cn(
        // Base styles
        usePortal ? "fixed" : "absolute",
        "z-[9999] font-medium",
        !isInteractive && "pointer-events-none",
        // Only no pointer events when not interactive
        isInteractive && "pointer-events-auto",
        // Enable pointer events for interactive mode
        // Smart text wrapping - allow wrapping for long content
        "whitespace-normal break-words",
        // Legacy styling props
        hasBackground !== false && currentVariant.bg,
        // Default to true
        currentVariant.text,
        isBordered && "border border-border-color dark:border-dark-border-color",
        isRounded !== false && "rounded-lg",
        // Default to true
        hasShadow !== false && "shadow-lg",
        // Default to true
        hasFadeEffect !== false && "transition-opacity duration-200",
        // Default to true
        // Size
        currentSize.classes,
        // Position (only apply when not using portal)
        !usePortal && currentPlacement,
        // Visibility with animation variants
        isOpen ? "opacity-100" : "opacity-0",
        // Animation variants
        animation === "fade" && "transition-opacity duration-200",
        animation === "scale" && "transition-all duration-200 transform",
        animation === "scale" && (isOpen ? "scale-100" : "scale-95"),
        animation === "slide" && "transition-all duration-200 transform",
        className
      ),
      onMouseEnter: (e2) => {
        if (isInteractive) {
          e2.stopPropagation();
          showTooltip();
        }
      },
      onMouseLeave: (e2) => {
        if (isInteractive) {
          e2.stopPropagation();
          const relatedTarget = e2.relatedTarget;
          if (relatedTarget?.closest("[data-tooltip-trigger]")) {
            return;
          }
          if (interactiveHideTimeoutRef.current) {
            clearTimeout(interactiveHideTimeoutRef.current);
          }
          interactiveHideTimeoutRef.current = setTimeout(() => {
            const tooltipElement = tooltipRef.current;
            const triggerElement = triggerRef.current;
            if (tooltipElement && triggerElement) {
              const mouseX = e2.clientX;
              const mouseY = e2.clientY;
              const elementAtPoint = document.elementFromPoint(mouseX, mouseY);
              const tooltipHover = tooltipElement.contains(elementAtPoint) || tooltipElement === elementAtPoint;
              const triggerHover = triggerElement.contains(elementAtPoint) || triggerElement === elementAtPoint;
              if (!tooltipHover && !triggerHover) {
                hideTooltip();
              }
            } else {
              hideTooltip();
            }
            interactiveHideTimeoutRef.current = null;
          }, 150);
        }
      },
      style: {
        // Smart width adaptation based on content and size
        minWidth: currentSize.minWidth,
        maxWidth: maxWidth || currentSize.maxWidth,
        width: "auto",
        // Let content determine width
        fontSize: currentSize.fontSize,
        lineHeight: currentSize.lineHeight,
        // Ensure proper text wrapping
        wordWrap: "break-word",
        overflowWrap: "break-word",
        ...usePortal && triggerRect && {
          // Calculate position for portal rendering with smart placement
          ...finalFollowCursor && cursorPosition ? {
            left: cursorPosition.x + 10,
            top: cursorPosition.y - 10
          } : getPortalPosition(smartPlacement)
        },
        ...style
      },
      ...props,
      children: [
        icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", className: "mr-1.5 inline-block align-middle", children: icon }),
        label,
        hasArrow && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: cn(
              "absolute w-0 h-0",
              currentArrow,
              // Smart positioning
              getArrowColorClasses(finalVariant, finalPlacement, size2)
              // Variant, placement, and size-aware arrow colors
            )
          }
        )
      ]
    }
  );
  const renderTooltip = () => {
    if (usePortal && portalRef.current) {
      return ReactDOM__default.createPortal(tooltipContent, portalRef.current);
    }
    return tooltipContent;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: (node) => {
        triggerRef.current = node;
        if (typeof ref === "function") {
          ref(node);
        } else if (ref) {
          ref.current = node;
        }
      },
      "data-tooltip-trigger": true,
      className: "relative inline-block w-fit",
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      onMouseMove: handleMouseMove,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      onTouchStart: handleTouchStart,
      onTouchEnd: handleTouchEnd,
      children: [
        children,
        renderTooltip()
      ]
    }
  );
});
Tooltip.displayName = "Tooltip";
const TooltipTrigger = forwardRef(
  ({ children, className }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn("inline-block", className), children });
  }
);
TooltipTrigger.displayName = "TooltipTrigger";
const TooltipContent = forwardRef(({ children, className, side = "top" }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      className: cn(
        "z-[9999] overflow-hidden rounded-lg border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md",
        className
      ),
      style: {
        transformOrigin: side === "top" || side === "bottom" ? "center" : "center"
      },
      children
    }
  );
});
TooltipContent.displayName = "TooltipContent";
const TooltipArrow = forwardRef(
  ({ className }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref,
        className: cn("fill-popover", className)
      }
    );
  }
);
TooltipArrow.displayName = "TooltipArrow";
const TreeItem = ({
  node,
  level = 0,
  isExpanded = false,
  isSelected = false,
  isDisabled = false,
  hasTreeLines = true,
  hasExpandIcons = true,
  hasNodeIcons = true,
  hasNodeLabels = true,
  hasNodeDescriptions = false,
  hasNodeBadges = false,
  hasNodeActions = false,
  hasNodeCheckboxes = false,
  hasNodeRadioButtons = false,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  onNodeSelect,
  onNodeToggle,
  onNodeClick,
  onNodeDoubleClick,
  onNodeRightClick
}) => {
  const [expanded, setExpanded] = useState(isExpanded);
  const [selected, setSelected] = useState(isSelected);
  const hasChildren = node.children && node.children.length > 0;
  const sizeClasses2 = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-sm",
    lg: "text-base",
    xl: "text-lg"
  };
  const variantClasses2 = {
    primary: "border-l-2 border-l-primary-500",
    secondary: "border-l-2 border-l-secondary-500",
    outline: "border border-gray-300 dark:border-gray-600",
    ghost: "hover:bg-gray-50 dark:hover:bg-gray-800",
    text: "border-none"
  };
  const colorClasses2 = {
    primary: "text-gray-900 dark:text-gray-100",
    secondary: "text-gray-700 dark:text-gray-300",
    success: "text-green-700 dark:text-green-300",
    warning: "text-yellow-700 dark:text-yellow-300",
    danger: "text-red-700 dark:text-red-300",
    info: "text-blue-700 dark:text-blue-300",
    neutral: "text-gray-600 dark:text-gray-400"
  };
  const handleToggle = () => {
    if (hasChildren && !isDisabled) {
      const newExpanded = !expanded;
      setExpanded(newExpanded);
      onNodeToggle?.(node, newExpanded);
    }
  };
  const handleSelect = () => {
    if (!isDisabled) {
      const newSelected = !selected;
      setSelected(newSelected);
      onNodeSelect?.(node);
    }
  };
  const handleClick = () => {
    if (!isDisabled) {
      onNodeClick?.(node);
    }
  };
  const handleDoubleClick = () => {
    if (!isDisabled) {
      onNodeDoubleClick?.(node);
    }
  };
  const handleRightClick = (event) => {
    event.preventDefault();
    if (!isDisabled) {
      onNodeRightClick?.(node);
    }
  };
  const itemClasses = `
        flex items-center gap-2 px-3 py-2 rounded-md transition-colors
        ${sizeClasses2[size2]}
        ${colorClasses2[color2]}
        ${variantClasses2[variant]}
        ${isDisabled ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}
        ${selected ? "bg-primary-100 dark:bg-primary-900/20" : "hover:bg-gray-50 dark:hover:bg-gray-800"}
        ${level > 0 ? "ml-6" : ""}
    `.trim().replace(/\s+/g, " ");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: "list-none", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: itemClasses, children: [
      hasTreeLines && level > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-0 w-6 h-px bg-gray-300 dark:bg-gray-600" }),
      hasExpandIcons && hasChildren && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: handleToggle,
          className: "flex-shrink-0 w-4 h-4 flex items-center justify-center",
          disabled: isDisabled,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `w-3 h-3 transition-transform ${expanded ? "rotate-90" : ""}`, children: expanded ? "expand_less" : "expand_more" })
        }
      ),
      hasNodeIcons && node.icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "flex-shrink-0 w-4 h-4", children: node.icon }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 min-w-0", onClick: handleClick, onDoubleClick: handleDoubleClick, onContextMenu: handleRightClick, children: hasNodeLabels && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium truncate", children: node.label }) }),
      hasNodeCheckboxes && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "checkbox",
          checked: selected,
          onChange: handleSelect,
          disabled: isDisabled,
          className: "flex-shrink-0 w-4 h-4"
        }
      ),
      hasNodeRadioButtons && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "radio",
          checked: selected,
          onChange: handleSelect,
          disabled: isDisabled,
          name: `tree-radio-${node.id}`,
          className: "flex-shrink-0 w-4 h-4"
        }
      )
    ] }),
    hasChildren && expanded && /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "relative", children: node.children.map((childNode) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      TreeItem,
      {
        node: childNode,
        level: level + 1,
        isExpanded,
        isSelected,
        isDisabled,
        hasTreeLines,
        hasExpandIcons,
        hasNodeIcons,
        hasNodeLabels,
        hasNodeDescriptions,
        hasNodeBadges,
        hasNodeActions,
        hasNodeCheckboxes,
        hasNodeRadioButtons,
        size: size2,
        variant,
        color: color2,
        onNodeSelect,
        onNodeToggle,
        onNodeClick,
        onNodeDoubleClick,
        onNodeRightClick
      },
      childNode.id
    )) })
  ] });
};
const TreeView = ({
  data,
  containerClassName = "",
  className = "",
  style,
  size: size2 = "md",
  variant = "default",
  color: color2 = "primary",
  // State Props
  isDisabled = false,
  isLoading = false,
  isExpanded = false,
  isCollapsible = true,
  isSelectable = false,
  isMultiSelect = false,
  isSearchable = false,
  isFilterable = false,
  isSortable = false,
  isDraggable = false,
  isDroppable = false,
  // Feature Props
  hasBackground = true,
  hasBorder = false,
  isRounded = true,
  hasShadow = false,
  hasHoverEffect = true,
  hasFocusEffect = false,
  hasActiveEffect = false,
  hasTreeLines = true,
  hasExpandIcons = true,
  hasNodeIcons = true,
  hasNodeLabels = true,
  hasNodeDescriptions = false,
  hasNodeBadges = false,
  hasNodeActions = false,
  hasNodeCheckboxes = false,
  hasNodeRadioButtons = false,
  // Layout Props
  isResponsive = true,
  hasFixedWidth = false,
  isFullWidth = true,
  hasFixedHeight = false,
  isScrollable = false,
  hasPadding = true,
  hasMargin = false,
  isCentered = false,
  // Event Handlers
  onNodeSelect,
  onNodeToggle,
  onNodeClick,
  onNodeDoubleClick,
  onNodeRightClick,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onKeyDown,
  ...props
}) => {
  const sizeClasses2 = {
    xs: "text-xs",
    sm: "text-sm",
    md: "text-sm",
    lg: "text-base",
    xl: "text-lg"
  };
  const variantClasses2 = {
    primary: "border-l-2 border-l-primary-500",
    secondary: "border-l-2 border-l-secondary-500",
    outline: "border border-gray-300 dark:border-gray-600",
    ghost: "hover:bg-gray-50 dark:hover:bg-gray-800",
    text: "border-none"
  };
  const colorClasses2 = {
    primary: "text-gray-900 dark:text-gray-100",
    secondary: "text-gray-700 dark:text-gray-300",
    success: "text-green-700 dark:text-green-300",
    warning: "text-yellow-700 dark:text-yellow-300",
    danger: "text-red-700 dark:text-red-300",
    info: "text-blue-700 dark:text-blue-300",
    neutral: "text-gray-600 dark:text-gray-400"
  };
  const containerClasses = `
        ${hasBackground ? "bg-white dark:bg-gray-900" : ""}
        ${hasBorder ? "border border-gray-300 dark:border-gray-600" : ""}
        ${isRounded ? "rounded-lg" : ""}
        ${hasShadow ? "shadow-md" : ""}
        ${isResponsive ? "w-full" : ""}
        ${hasFixedWidth ? "" : "w-full"}
        ${isFullWidth ? "w-full" : ""}
        ${hasFixedHeight ? "" : "min-h-0"}
        ${isScrollable ? "overflow-auto" : "overflow-hidden"}
        ${hasPadding ? "p-4" : ""}
        ${hasMargin ? "m-4" : ""}
        ${isCentered ? "mx-auto" : ""}
        ${containerClassName}
        ${className}
    `.trim().replace(/\s+/g, " ");
  if (isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClasses, style, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center h-32", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-primary-500" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-gray-500", children: "Loading..." })
    ] }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClasses, style, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "ul",
    {
      className: `
                    space-y-1
                    ${sizeClasses2[size2]}
                    ${colorClasses2[color2]}
                    ${variantClasses2[variant]}
                    ${hasHoverEffect ? "hover:bg-gray-50 dark:hover:bg-gray-800" : ""}
                    ${hasFocusEffect ? "focus:ring-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange" : ""}
                    ${hasActiveEffect ? "active:bg-gray-100 dark:active:bg-gray-700" : ""}
                `.trim().replace(/\s+/g, " "),
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onKeyDown,
      ...props,
      children: data.map((node) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        TreeItem,
        {
          node,
          level: 0,
          isExpanded,
          isSelected: false,
          isDisabled,
          hasTreeLines,
          hasExpandIcons,
          hasNodeIcons,
          hasNodeLabels,
          hasNodeDescriptions,
          hasNodeBadges,
          hasNodeActions,
          hasNodeCheckboxes,
          hasNodeRadioButtons,
          size: size2,
          variant,
          color: color2,
          onNodeSelect,
          onNodeToggle,
          onNodeClick,
          onNodeDoubleClick,
          onNodeRightClick
        },
        node.id
      ))
    }
  ) });
};
const PasswordInput = ({
  id: id2,
  label,
  value,
  onChange,
  onBlur,
  placeholder = "Enter password",
  isDisabled = false,
  error: error2 = "",
  className = "",
  inputClassName = "",
  labelClassName = "",
  autoComplete = "current-password",
  isRequired = false,
  isLoading = false,
  isFullWidth = false,
  width,
  minWidth,
  maxWidth,
  isSuccess = false,
  isWarning = false,
  hasBackground = true,
  hasBorder = true,
  hasFocusRing = true,
  hasShadow = false,
  showLabel = true,
  labelMode = "top",
  showHelperText = true,
  showErrorText = true,
  showPasswordStrength = false,
  showRequiredIndicator = true,
  showPasswordToggle = true,
  isPasswordVisibleByDefault = false,
  isReadOnly = false,
  hasSpellCheck = false,
  helperText,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  align = "left",
  radius = "md",
  minLength,
  maxLength,
  leftIcon,
  showCharacterCount = false,
  style
  // validatePassword, // Currently unused
}) => {
  const [isPasswordVisible, setIsPasswordVisible] = useState(isPasswordVisibleByDefault);
  const [isFocused, setIsFocused] = useState(false);
  const togglePasswordVisibility = () => {
    setIsPasswordVisible(!isPasswordVisible);
  };
  const sizeClasses2 = {
    xs: "h-8 text-xs px-2",
    sm: "h-10 text-sm px-3",
    md: "h-12 text-base px-4",
    lg: "h-14 text-lg px-5",
    xl: "h-16 text-xl px-6"
  };
  const variantClasses2 = {
    primary: "bg-bg-secondary dark:bg-dark-bg-secondary text-text-primary dark:text-dark-text-primary",
    secondary: "bg-bg-tertiary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary",
    outline: "bg-transparent border-2 text-text-primary dark:text-dark-text-primary",
    ghost: "bg-transparent text-text-primary dark:text-dark-text-primary",
    filled: "bg-bg-primary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary"
  };
  const focusBorderByColor = {
    primary: "focus:border-brand-navy dark:focus:border-dark-brand-orange",
    success: "focus:border-system-success dark:focus:border-system-success",
    warning: "focus:border-system-warning-dark dark:focus:border-system-warning",
    danger: "focus:border-system-error dark:focus:border-system-error",
    info: "focus:border-system-info dark:focus:border-system-info"
  };
  const focusRingByColor = {
    primary: "focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    success: "focus:ring-system-success dark:focus:ring-system-success",
    warning: "focus:ring-system-warning dark:focus:ring-system-warning",
    danger: "focus:ring-system-error dark:focus:ring-system-error",
    info: "focus:ring-system-info dark:focus:ring-system-info"
  };
  const stateClasses = {
    default: hasBorder ? "border-border-color dark:border-dark-border-color" : "border-transparent",
    error: "border-2 border-system-error dark:border-system-error focus:border-system-error dark:focus:border-system-error focus:ring-system-error dark:focus:ring-system-error",
    success: "border-2 border-system-success dark:border-system-success",
    warning: "border-2 border-system-warning-dark dark:border-system-warning"
  };
  const baseClasses = "transition-colors duration-200 focus:outline-none";
  const backgroundClasses = hasBackground ? variantClasses2[variant] : "bg-transparent";
  const getRadiusClass2 = () => {
    switch (radius) {
      case "none":
        return "rounded-none";
      case "sm":
        return "rounded-sm";
      case "md":
        return "rounded";
      case "lg":
        return "rounded-lg";
      case "xl":
        return "rounded-xl";
      case "full":
        return "rounded-full";
      default:
        return "rounded";
    }
  };
  const roundedClasses = getRadiusClass2();
  const shadowClasses = hasShadow ? "shadow-md" : "";
  const focusClasses = `${focusBorderByColor[color2]} ${hasFocusRing ? `focus:ring-2 focus:ring-offset-2 ${focusRingByColor[color2]}` : ""}`.trim();
  const getWidthClass = () => {
    if (isFullWidth) return "w-full";
    switch (width) {
      case "sm":
        return "w-sm";
      case "md":
        return "w-md";
      case "lg":
        return "w-lg";
      case "full":
        return "w-full";
      case "auto":
        return "w-auto";
      case "none":
        return "w-full";
      // 'none' behaves like default (full width)
      default:
        return "w-full";
    }
  };
  const widthClass = getWidthClass();
  const disabledClasses = isDisabled || isLoading ? "opacity-60 cursor-not-allowed" : "cursor-text";
  const loadingClasses = isLoading ? "animate-pulse" : "";
  const readOnlyClasses = isReadOnly ? "bg-gray-100 dark:bg-gray-800 cursor-default" : "";
  const getStateClass = () => {
    if (error2) return stateClasses.error;
    if (isSuccess) return stateClasses.success;
    if (isWarning) return stateClasses.warning;
    if (variant === "ghost" && hasBorder) return "border border-transparent hover:border-border-color dark:hover:border-dark-border-color focus:border-border-color dark:focus:border-dark-border-color";
    return hasBorder ? "border " + stateClasses.default : "border-transparent";
  };
  const alignmentClass = align === "center" ? "acutrack-text-center" : align === "right" ? "acutrack-text-right" : "acutrack-text-left";
  const inputClasses = [
    baseClasses,
    sizeClasses2[size2],
    "w-full",
    // Always fill the container width
    backgroundClasses,
    getStateClass(),
    roundedClasses,
    shadowClasses,
    focusClasses,
    disabledClasses,
    loadingClasses,
    readOnlyClasses,
    alignmentClass,
    "pr-16",
    inputClassName
  ].filter(Boolean).join(" ");
  const getPasswordStrength = () => {
    if (!showPasswordStrength) return null;
    if (!isFocused && !value) return null;
    const requirements = {
      length: value.length >= 8,
      lowercase: /[a-z]/.test(value),
      uppercase: /[A-Z]/.test(value),
      number: /[0-9]/.test(value),
      special: /[^A-Za-z0-9]/.test(value)
    };
    const metCount = Object.values(requirements).filter(Boolean).length;
    const totalCount = Object.keys(requirements).length;
    let message2 = "";
    if (value.length === 0 && isFocused) message2 = "Start typing to see requirements";
    else if (value.length === 0) message2 = "Enter password";
    else if (metCount <= 2) message2 = "Weak";
    else if (metCount <= 3) message2 = "Fair";
    else if (metCount <= 4) message2 = "Good";
    else message2 = "Strong";
    const strengthColors = {
      "Enter password": "text-text-secondary dark:text-dark-text-secondary",
      "Start typing to see requirements": "text-brand-orange dark:text-dark-brand-orange",
      "Weak": "text-system-error",
      "Fair": "text-system-warning",
      "Good": "text-system-info",
      "Strong": "text-system-success"
    };
    return {
      strength: metCount,
      total: totalCount,
      message: message2,
      color: strengthColors[message2],
      requirements
    };
  };
  const passwordStrength = getPasswordStrength();
  const isFloatingLabel = labelMode === "floating";
  const hasValue = value.trim() !== "";
  const shouldFloatLabel = isFloatingLabel && (hasValue || isFocused);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${widthClass} ${className}`, style, children: [
    showLabel && label && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: `block text-sm font-semibold text-text-primary dark:text-dark-text-primary mb-2 ${alignmentClass} ${labelClassName}`, children: [
      label,
      isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      showLabel && label && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "span",
        {
          className: [
            "absolute transition-all duration-200 pointer-events-none z-10",
            leftIcon ? "left-12" : "left-3",
            "text-text-secondary dark:text-dark-text-secondary",
            shouldFloatLabel ? "-top-2.5 text-xs bg-bg-primary dark:bg-dark-bg-primary px-1" : "top-1/2 -translate-y-1/2",
            error2 && "text-system-error-dark",
            isSuccess && "text-green-600 dark:text-green-400"
          ].filter(Boolean).join(" "),
          children: [
            label,
            isRequired && showRequiredIndicator && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-system-error ml-1", children: "*" })
          ]
        }
      ),
      leftIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-text-secondary dark:text-dark-text-secondary z-0", children: leftIcon }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: id2,
          type: isPasswordVisible ? "text" : "password",
          value,
          onChange: (e2) => onChange(e2.target.value),
          onFocus: () => setIsFocused(true),
          onBlur: (e2) => {
            setIsFocused(false);
            onBlur?.(e2);
          },
          placeholder: isFloatingLabel ? void 0 : placeholder,
          autoComplete,
          disabled: isDisabled || isLoading,
          required: isRequired,
          readOnly: isReadOnly,
          spellCheck: hasSpellCheck,
          minLength,
          maxLength,
          className: inputClasses,
          style: {
            paddingLeft: leftIcon ? "2.5rem" : void 0,
            ...minWidth && { minWidth },
            ...maxWidth && { maxWidth }
          }
        }
      ),
      showPasswordToggle && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: togglePasswordVisibility,
          disabled: isDisabled || isLoading,
          className: "absolute right-3 top-1/2 -translate-y-1/2 p-1.5 rounded-md text-text-secondary/80 hover:text-text-secondary hover:bg-bg-tertiary dark:hover:bg-dark-bg-primary transition-colors focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed",
          "aria-label": isPasswordVisible ? "Hide password" : "Show password",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "xl", children: isPasswordVisible ? "visibility_off" : "visibility" })
        }
      ),
      isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-12 top-1/2 -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-2 border-current border-t-transparent" }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 space-y-1", children: [
      showErrorText && error2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-system-error flex items-center gap-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { size: "sm", children: "error" }),
        error2
      ] }),
      showHelperText && helperText && !error2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary", children: helperText }),
      passwordStrength && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 space-y-2 animate-in fade-in-0 slide-in-from-top-1 duration-200", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 bg-bg-tertiary dark:bg-dark-bg-tertiary rounded-full h-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `h-2 rounded-full transition-all duration-300 ${passwordStrength.message === "Enter password" || passwordStrength.message === "Start typing to see requirements" ? "bg-bg-tertiary dark:bg-dark-bg-tertiary" : passwordStrength.strength <= 2 ? "bg-system-error" : passwordStrength.strength <= 3 ? "bg-system-warning" : passwordStrength.strength <= 4 ? "bg-system-info" : "bg-system-success"}`,
              style: { width: `${passwordStrength.message === "Enter password" || passwordStrength.message === "Start typing to see requirements" ? 0 : passwordStrength.strength / passwordStrength.total * 100}%` }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-xs font-medium ${passwordStrength.color}`, children: passwordStrength.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `w-4 h-4 ${passwordStrength.requirements.length ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: passwordStrength.requirements.length ? "check_circle" : "radio_button_unchecked" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-xs ${passwordStrength.requirements.length ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: "At least 8 characters" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `w-4 h-4 ${passwordStrength.requirements.lowercase ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: passwordStrength.requirements.lowercase ? "check_circle" : "radio_button_unchecked" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-xs ${passwordStrength.requirements.lowercase ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: "One lowercase letter" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `w-4 h-4 ${passwordStrength.requirements.uppercase ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: passwordStrength.requirements.uppercase ? "check_circle" : "radio_button_unchecked" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-xs ${passwordStrength.requirements.uppercase ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: "One uppercase letter" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `w-4 h-4 ${passwordStrength.requirements.number ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: passwordStrength.requirements.number ? "check_circle" : "radio_button_unchecked" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-xs ${passwordStrength.requirements.number ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: "One number" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: `w-4 h-4 ${passwordStrength.requirements.special ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: passwordStrength.requirements.special ? "check_circle" : "radio_button_unchecked" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `text-xs ${passwordStrength.requirements.special ? "text-system-success" : "text-text-secondary dark:text-dark-text-secondary"}`, children: "One special character" })
          ] })
        ] })
      ] }),
      showCharacterCount && maxLength && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs text-text-secondary dark:text-dark-text-secondary text-right", children: [
        value.length,
        "/",
        maxLength
      ] })
    ] })
  ] });
};
const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? React__default.useLayoutEffect : () => {
};
const $431fbd86ca7dc216$export$b204af158042fbac = (el) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el === null || el === void 0 ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
const $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => {
  if (el && "window" in el && el.window === el) return el;
  const doc = $431fbd86ca7dc216$export$b204af158042fbac(el);
  return doc.defaultView || window;
};
function $431fbd86ca7dc216$var$isNode(value) {
  return value !== null && typeof value === "object" && "nodeType" in value && typeof value.nodeType === "number";
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(node) {
  return $431fbd86ca7dc216$var$isNode(node) && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in node;
}
let $f4e2df6bd15f8569$var$_shadowDOM = false;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
  return $f4e2df6bd15f8569$var$_shadowDOM;
}
function $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return otherNode && node ? node.contains(otherNode) : false;
  if (!node || !otherNode) return false;
  let currentNode = otherNode;
  while (currentNode !== null) {
    if (currentNode === node) return true;
    if (currentNode.tagName === "SLOT" && currentNode.assignedSlot)
      currentNode = currentNode.assignedSlot.parentNode;
    else if ($431fbd86ca7dc216$export$af51f0f06c0f328a(currentNode))
      currentNode = currentNode.host;
    else currentNode = currentNode.parentNode;
  }
  return false;
}
const $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => {
  var _activeElement_shadowRoot;
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return doc.activeElement;
  let activeElement = doc.activeElement;
  while (activeElement && "shadowRoot" in activeElement && ((_activeElement_shadowRoot = activeElement.shadowRoot) === null || _activeElement_shadowRoot === void 0 ? void 0 : _activeElement_shadowRoot.activeElement)) activeElement = activeElement.shadowRoot.activeElement;
  return activeElement;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
  if ($f4e2df6bd15f8569$export$98658e8c59125e6a() && event.target.shadowRoot) {
    if (event.composedPath) return event.composedPath()[0];
  }
  return event.target;
}
function $7215afc6de606d6b$export$de79e2c695e052f3(element) {
  if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({
    preventScroll: true
  });
  else {
    let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);
    element.focus();
    $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);
  }
}
let $7215afc6de606d6b$var$supportsPreventScrollCached = null;
function $7215afc6de606d6b$var$supportsPreventScroll() {
  if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {
    $7215afc6de606d6b$var$supportsPreventScrollCached = false;
    try {
      let focusElem = document.createElement("div");
      focusElem.focus({
        get preventScroll() {
          $7215afc6de606d6b$var$supportsPreventScrollCached = true;
          return true;
        }
      });
    } catch {
    }
  }
  return $7215afc6de606d6b$var$supportsPreventScrollCached;
}
function $7215afc6de606d6b$var$getScrollableElements(element) {
  let parent = element.parentNode;
  let scrollableElements = [];
  let rootScrollingElement = document.scrollingElement || document.documentElement;
  while (parent instanceof HTMLElement && parent !== rootScrollingElement) {
    if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({
      element: parent,
      scrollTop: parent.scrollTop,
      scrollLeft: parent.scrollLeft
    });
    parent = parent.parentNode;
  }
  if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({
    element: rootScrollingElement,
    scrollTop: rootScrollingElement.scrollTop,
    scrollLeft: rootScrollingElement.scrollLeft
  });
  return scrollableElements;
}
function $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {
  for (let { element, scrollTop, scrollLeft } of scrollableElements) {
    element.scrollTop = scrollTop;
    element.scrollLeft = scrollLeft;
  }
}
function $c87311424ea30a05$var$testUserAgent(re2) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null) return false;
  let brands = (_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands;
  return Array.isArray(brands) && brands.some((brand) => re2.test(brand.brand)) || re2.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re2) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re2.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn) {
  if (process.env.NODE_ENV === "test") return fn;
  let res = null;
  return () => {
    if (res == null) res = fn();
    return res;
  };
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
const $c87311424ea30a05$export$186c6964ca17d99 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPhone/i);
});
const $c87311424ea30a05$export$7bef049ce92e4224 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;
});
const $c87311424ea30a05$export$fedb369cb70207f1 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();
});
$c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();
});
const $c87311424ea30a05$export$78551043582a6a98 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();
});
const $c87311424ea30a05$export$6446a186d09e379e = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Chrome/i);
});
const $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
const $c87311424ea30a05$export$b7d78993b74f766d = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Firefox/i);
});
function $ea8dcbcb9ea1b556$export$95185d699e05d4d7(target, modifiers, setOpening = true) {
  var _window_event_type, _window_event;
  let { metaKey, ctrlKey, altKey, shiftKey } = modifiers;
  if ($c87311424ea30a05$export$b7d78993b74f766d() && ((_window_event = window.event) === null || _window_event === void 0 ? void 0 : (_window_event_type = _window_event.type) === null || _window_event_type === void 0 ? void 0 : _window_event_type.startsWith("key")) && target.target === "_blank") {
    if ($c87311424ea30a05$export$9ac100e40613ea10()) metaKey = true;
    else ctrlKey = true;
  }
  let event = $c87311424ea30a05$export$78551043582a6a98() && $c87311424ea30a05$export$9ac100e40613ea10() && !$c87311424ea30a05$export$7bef049ce92e4224() && process.env.NODE_ENV !== "test" ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey,
    ctrlKey,
    altKey,
    shiftKey
  }) : new MouseEvent("click", {
    metaKey,
    ctrlKey,
    altKey,
    shiftKey,
    detail: 1,
    bubbles: true,
    cancelable: true
  });
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = setOpening;
  $7215afc6de606d6b$export$de79e2c695e052f3(target);
  target.dispatchEvent(event);
  $ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
}
$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening = false;
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = useRef(/* @__PURE__ */ new Map());
  let addGlobalListener = useCallback((eventTarget, type, listener, options) => {
    let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args) => {
      globalListeners.current.delete(listener);
      listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      fn,
      options
    });
    eventTarget.addEventListener(type, fn, options);
  }, []);
  let removeGlobalListener = useCallback((eventTarget, type, listener, options) => {
    var _globalListeners_current_get;
    let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type, fn, options);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = useCallback(() => {
    globalListeners.current.forEach((value, key) => {
      removeGlobalListener(value.eventTarget, value.type, key, value.options);
    });
  }, [
    removeGlobalListener
  ]);
  useEffect(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}
function $6a7db85432448f7f$export$60278871457622de(event) {
  if (event.pointerType === "" && event.isTrusted) return true;
  if ($c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType) return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
function $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {
  let event = nativeEvent;
  event.nativeEvent = nativeEvent;
  event.isDefaultPrevented = () => event.defaultPrevented;
  event.isPropagationStopped = () => event.cancelBubble;
  event.persist = () => {
  };
  return event;
}
function $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {
  Object.defineProperty(event, "target", {
    value: target
  });
  Object.defineProperty(event, "currentTarget", {
    value: target
  });
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = useRef({
    isFocused: false,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  return useCallback((e2) => {
    if (e2.target instanceof HTMLButtonElement || e2.target instanceof HTMLInputElement || e2.target instanceof HTMLTextAreaElement || e2.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e2.target;
      let onBlurHandler = (e3) => {
        stateRef.current.isFocused = false;
        if (target.disabled) {
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e3);
          onBlur === null || onBlur === void 0 ? void 0 : onBlur(event);
        }
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    onBlur
  ]);
}
let $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
let $507fabe10e71c6fb$var$currentModality = null;
const $507fabe10e71c6fb$export$901e90a13c50a14e = /* @__PURE__ */ new Set();
let $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
let $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
let $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e2) {
  for (let handler of $507fabe10e71c6fb$export$901e90a13c50a14e) handler(modality, e2);
}
function $507fabe10e71c6fb$var$isValidKey(e2) {
  return !(e2.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e2) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if (!$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening && $507fabe10e71c6fb$var$isValidKey(e2)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e2);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e2) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  "pointerType" in e2 ? e2.pointerType : "mouse";
  if (e2.type === "mousedown" || e2.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e2);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e2) {
  if (!$ea8dcbcb9ea1b556$export$95185d699e05d4d7.isOpening && $6a7db85432448f7f$export$60278871457622de(e2)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e2) {
  if (e2.target === window || e2.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !e2.isTrusted) return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e2);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
  if (typeof window === "undefined" || typeof document === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element))) return;
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let focus = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else if (process.env.NODE_ENV === "test") {
    documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
  }, {
    once: true
  });
  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  if (loadListener) documentObject.removeEventListener("DOMContentLoaded", loadListener);
  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
  documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else if (process.env.NODE_ENV === "test") {
    documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let loadListener;
  if (documentObject.readyState !== "loading") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
  else {
    loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
    };
    documentObject.addEventListener("DOMContentLoaded", loadListener);
  }
  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
if (typeof document !== "undefined") $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e2) {
  let document1 = $431fbd86ca7dc216$export$b204af158042fbac(e2 === null || e2 === void 0 ? void 0 : e2.target);
  const IHTMLInputElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLInputElement : HTMLInputElement;
  const IHTMLTextAreaElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLTextAreaElement : HTMLTextAreaElement;
  const IHTMLElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLElement : HTMLElement;
  const IKeyboardEvent = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).KeyboardEvent : KeyboardEvent;
  isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e2 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e2.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  useEffect(() => {
    if ((opts === null || opts === void 0 ? void 0 : opts.enabled) === false) return;
    let handler = (modality, e2) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e2)) return;
      fn($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$export$901e90a13c50a14e.add(handler);
    return () => {
      $507fabe10e71c6fb$export$901e90a13c50a14e.delete(handler);
    };
  }, deps);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = useCallback((e2) => {
    if (e2.target === e2.currentTarget) {
      if (onBlurProp) onBlurProp(e2);
      if (onFocusChange) onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
  const onFocus = useCallback((e2) => {
    const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e2.target);
    const activeElement = ownerDocument ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
    if (e2.target === e2.currentTarget && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      if (onFocusProp) onFocusProp(e2);
      if (onFocusChange) onFocusChange(true);
      onSyntheticFocus(e2);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = useRef({
    isFocusWithin: false
  });
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let onBlur = useCallback((e2) => {
    if (!$d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, e2.target)) return;
    if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, e2.relatedTarget)) {
      state.current.isFocusWithin = false;
      removeAllGlobalListeners();
      if (onBlurWithin) onBlurWithin(e2);
      if (onFocusWithinChange) onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state,
    removeAllGlobalListeners
  ]);
  let onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
  let onFocus = useCallback((e2) => {
    if (!$d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, e2.target)) return;
    const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e2.target);
    const activeElement = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument);
    if (!state.current.isFocusWithin && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      if (onFocusWithin) onFocusWithin(e2);
      if (onFocusWithinChange) onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e2);
      let currentTarget = e2.currentTarget;
      addGlobalListener(ownerDocument, "focus", (e3) => {
        if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(currentTarget, e3.target)) {
          let nativeEvent = new ownerDocument.defaultView.FocusEvent("blur", {
            relatedTarget: e3.target
          });
          $8a9cb279dc87e130$export$c2b7abe5d61ec696(nativeEvent, currentTarget);
          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent);
          onBlur(event);
        }
      }, {
        capture: true
      });
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus,
    addGlobalListener,
    onBlur
  ]);
  if (isDisabled) return {
    focusWithinProps: {
      // These cannot be null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
let $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e2) {
  if (e2.pointerType === "touch") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined") return;
  if ($6179b936705e76d3$var$hoverCount === 0) {
    if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else if (process.env.NODE_ENV === "test") document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  }
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0) return;
    if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else if (process.env.NODE_ENV === "test") document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;
  let [isHovered, setHovered] = useState(false);
  let state = useRef({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let { hoverProps, triggerHoverEnd } = useMemo(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled || pointerType === "touch" || state.isHovered || !$d4ee10de306f2510$export$4282f70798064fe0(event.currentTarget, event.target)) return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), "pointerover", (e2) => {
        if (state.isHovered && state.target && !$d4ee10de306f2510$export$4282f70798064fe0(state.target, e2.target)) triggerHoverEnd2(e2, e2.pointerType);
      }, {
        capture: true
      });
      if (onHoverStart) onHoverStart({
        type: "hoverstart",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      let target = state.target;
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered || !target) return;
      state.isHovered = false;
      removeAllGlobalListeners();
      if (onHoverEnd) onHoverEnd({
        type: "hoverend",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e2) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e2.pointerType === "mouse") return;
        triggerHoverStart(e2, e2.pointerType);
      };
      hoverProps2.onPointerLeave = (e2) => {
        if (!isDisabled && $d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, e2.target)) triggerHoverEnd2(e2, e2.pointerType);
      };
    } else if (process.env.NODE_ENV === "test") {
      hoverProps2.onTouchStart = () => {
        state.ignoreEmulatedMouseEvents = true;
      };
      hoverProps2.onMouseEnter = (e2) => {
        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e2, "mouse");
        state.ignoreEmulatedMouseEvents = false;
      };
      hoverProps2.onMouseLeave = (e2) => {
        if (!isDisabled && $d4ee10de306f2510$export$4282f70798064fe0(e2.currentTarget, e2.target)) triggerHoverEnd2(e2, "mouse");
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state,
    addGlobalListener,
    removeAllGlobalListeners
  ]);
  useEffect(() => {
    if (isDisabled) triggerHoverEnd({
      currentTarget: state.target
    }, state.pointerType);
  }, [
    isDisabled
  ]);
  return {
    hoverProps,
    isHovered
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = useRef({
    isFocused: false,
    isFocusVisible: autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  });
  let [isFocused, setFocused] = useState(false);
  let [isFocusVisibleState, setFocusVisible] = useState(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = useCallback(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = useCallback((isFocused2) => {
    state.current.isFocused = isFocused2;
    state.current.isFocusVisible = $507fabe10e71c6fb$export$b9b3dfddab17db27();
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible;
    updateState();
  }, [
    isTextInput,
    isFocused
  ], {
    enabled: isFocused,
    isTextInput
  });
  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}
var i$5 = Object.defineProperty;
var d$2 = (t2, e2, n2) => e2 in t2 ? i$5(t2, e2, { enumerable: true, configurable: true, writable: true, value: n2 }) : t2[e2] = n2;
var r$7 = (t2, e2, n2) => (d$2(t2, typeof e2 != "symbol" ? e2 + "" : e2, n2), n2);
let o$7 = class o {
  constructor() {
    r$7(this, "current", this.detect());
    r$7(this, "handoffState", "pending");
    r$7(this, "currentId", 0);
  }
  set(e2) {
    this.current !== e2 && (this.handoffState = "pending", this.currentId = 0, this.current = e2);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
let s$9 = new o$7();
function l$5(n2) {
  var u2;
  return s$9.isServer ? null : n2 == null ? document : (u2 = n2 == null ? void 0 : n2.ownerDocument) != null ? u2 : document;
}
function r$6(n2) {
  var u2, o4;
  return s$9.isServer ? null : n2 == null ? document : (o4 = (u2 = n2 == null ? void 0 : n2.getRootNode) == null ? void 0 : u2.call(n2)) != null ? o4 : document;
}
function e$4(n2) {
  var u2, o4;
  return (o4 = (u2 = r$6(n2)) == null ? void 0 : u2.activeElement) != null ? o4 : null;
}
function d$1(n2) {
  return e$4(n2) === n2;
}
function t$5(e2) {
  typeof queueMicrotask == "function" ? queueMicrotask(e2) : Promise.resolve().then(e2).catch((o4) => setTimeout(() => {
    throw o4;
  }));
}
function o$6() {
  let s2 = [], r2 = { addEventListener(e2, t2, n2, i2) {
    return e2.addEventListener(t2, n2, i2), r2.add(() => e2.removeEventListener(t2, n2, i2));
  }, requestAnimationFrame(...e2) {
    let t2 = requestAnimationFrame(...e2);
    return r2.add(() => cancelAnimationFrame(t2));
  }, nextFrame(...e2) {
    return r2.requestAnimationFrame(() => r2.requestAnimationFrame(...e2));
  }, setTimeout(...e2) {
    let t2 = setTimeout(...e2);
    return r2.add(() => clearTimeout(t2));
  }, microTask(...e2) {
    let t2 = { current: true };
    return t$5(() => {
      t2.current && e2[0]();
    }), r2.add(() => {
      t2.current = false;
    });
  }, style(e2, t2, n2) {
    let i2 = e2.style.getPropertyValue(t2);
    return Object.assign(e2.style, { [t2]: n2 }), this.add(() => {
      Object.assign(e2.style, { [t2]: i2 });
    });
  }, group(e2) {
    let t2 = o$6();
    return e2(t2), this.add(() => t2.dispose());
  }, add(e2) {
    return s2.includes(e2) || s2.push(e2), () => {
      let t2 = s2.indexOf(e2);
      if (t2 >= 0) for (let n2 of s2.splice(t2, 1)) n2();
    };
  }, dispose() {
    for (let e2 of s2.splice(0)) e2();
  } };
  return r2;
}
function p$6() {
  let [e2] = useState(o$6);
  return useEffect(() => () => e2.dispose(), [e2]), e2;
}
let n$6 = (e2, t2) => {
  s$9.isServer ? useEffect(e2, t2) : useLayoutEffect(e2, t2);
};
function s$8(e2) {
  let r2 = useRef(e2);
  return n$6(() => {
    r2.current = e2;
  }, [e2]), r2;
}
let o$5 = function(t2) {
  let e2 = s$8(t2);
  return React__default.useCallback((...r2) => e2.current(...r2), [e2]);
};
function E$3(e2) {
  let t2 = e2.width / 2, n2 = e2.height / 2;
  return { top: e2.clientY - n2, right: e2.clientX + t2, bottom: e2.clientY + n2, left: e2.clientX - t2 };
}
function P$2(e2, t2) {
  return !(!e2 || !t2 || e2.right < t2.left || e2.left > t2.right || e2.bottom < t2.top || e2.top > t2.bottom);
}
function w$4({ disabled: e2 = false } = {}) {
  let t2 = useRef(null), [n2, l2] = useState(false), r2 = p$6(), o4 = o$5(() => {
    t2.current = null, l2(false), r2.dispose();
  }), f2 = o$5((s2) => {
    if (r2.dispose(), t2.current === null) {
      t2.current = s2.currentTarget, l2(true);
      {
        let i2 = l$5(s2.currentTarget);
        r2.addEventListener(i2, "pointerup", o4, false), r2.addEventListener(i2, "pointermove", (c2) => {
          if (t2.current) {
            let p2 = E$3(c2);
            l2(P$2(p2, t2.current.getBoundingClientRect()));
          }
        }, false), r2.addEventListener(i2, "pointercancel", o4, false);
      }
    }
  });
  return { pressed: n2, pressProps: e2 ? {} : { onPointerDown: f2, onPointerUp: o4, onClick: o4 } };
}
function n$5(e2) {
  return useMemo(() => e2, Object.values(e2));
}
let e$3 = createContext(void 0);
function a$a() {
  return useContext(e$3);
}
function t$4(...r2) {
  return Array.from(new Set(r2.flatMap((n2) => typeof n2 == "string" ? n2.split(" ") : []))).filter(Boolean).join(" ");
}
function u$c(r2, n2, ...a3) {
  if (r2 in n2) {
    let e2 = n2[r2];
    return typeof e2 == "function" ? e2(...a3) : e2;
  }
  let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e2) => `"${e2}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$c), t2;
}
var A$2 = ((a3) => (a3[a3.None = 0] = "None", a3[a3.RenderStrategy = 1] = "RenderStrategy", a3[a3.Static = 2] = "Static", a3))(A$2 || {}), C$5 = ((e2) => (e2[e2.Unmount = 0] = "Unmount", e2[e2.Hidden = 1] = "Hidden", e2))(C$5 || {});
function K() {
  let n2 = $$1();
  return useCallback((r2) => U$1({ mergeRefs: n2, ...r2 }), [n2]);
}
function U$1({ ourProps: n2, theirProps: r2, slot: e2, defaultTag: a3, features: s2, visible: t2 = true, name: l2, mergeRefs: i2 }) {
  i2 = i2 != null ? i2 : I$5;
  let o4 = P$1(r2, n2);
  if (t2) return F$1(o4, e2, a3, l2, i2);
  let y2 = s2 != null ? s2 : 0;
  if (y2 & 2) {
    let { static: f2 = false, ...u2 } = o4;
    if (f2) return F$1(u2, e2, a3, l2, i2);
  }
  if (y2 & 1) {
    let { unmount: f2 = true, ...u2 } = o4;
    return u$c(f2 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return F$1({ ...u2, hidden: true, style: { display: "none" } }, e2, a3, l2, i2);
    } });
  }
  return F$1(o4, e2, a3, l2, i2);
}
function F$1(n2, r2 = {}, e2, a3, s2) {
  let { as: t2 = e2, children: l2, refName: i2 = "ref", ...o4 } = h$4(n2, ["unmount", "static"]), y2 = n2.ref !== void 0 ? { [i2]: n2.ref } : {}, f2 = typeof l2 == "function" ? l2(r2) : l2;
  "className" in o4 && o4.className && typeof o4.className == "function" && (o4.className = o4.className(r2)), o4["aria-labelledby"] && o4["aria-labelledby"] === o4.id && (o4["aria-labelledby"] = void 0);
  let u2 = {};
  if (r2) {
    let d2 = false, p2 = [];
    for (let [c2, T3] of Object.entries(r2)) typeof T3 == "boolean" && (d2 = true), T3 === true && p2.push(c2.replace(/([A-Z])/g, (g2) => `-${g2.toLowerCase()}`));
    if (d2) {
      u2["data-headlessui-state"] = p2.join(" ");
      for (let c2 of p2) u2[`data-${c2}`] = "";
    }
  }
  if (b$3(t2) && (Object.keys(m$4(o4)).length > 0 || Object.keys(m$4(u2)).length > 0)) if (!isValidElement(f2) || Array.isArray(f2) && f2.length > 1 || D$4(f2)) {
    if (Object.keys(m$4(o4)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${a3} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(o4)).concat(Object.keys(m$4(u2))).map((d2) => `  - ${d2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d2) => `  - ${d2}`).join(`
`)].join(`
`));
  } else {
    let d2 = f2.props, p2 = d2 == null ? void 0 : d2.className, c2 = typeof p2 == "function" ? (...R) => t$4(p2(...R), o4.className) : t$4(p2, o4.className), T3 = c2 ? { className: c2 } : {}, g2 = P$1(f2.props, m$4(h$4(o4, ["ref"])));
    for (let R in u2) R in g2 && delete u2[R];
    return cloneElement(f2, Object.assign({}, g2, u2, y2, { ref: s2(H$2(f2), y2.ref) }, T3));
  }
  return createElement$1(t2, Object.assign({}, h$4(o4, ["ref"]), !b$3(t2) && y2, !b$3(t2) && u2), f2);
}
function $$1() {
  let n2 = useRef([]), r2 = useCallback((e2) => {
    for (let a3 of n2.current) a3 != null && (typeof a3 == "function" ? a3(e2) : a3.current = e2);
  }, []);
  return (...e2) => {
    if (!e2.every((a3) => a3 == null)) return n2.current = e2, r2;
  };
}
function I$5(...n2) {
  return n2.every((r2) => r2 == null) ? void 0 : (r2) => {
    for (let e2 of n2) e2 != null && (typeof e2 == "function" ? e2(r2) : e2.current = r2);
  };
}
function P$1(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  if (r2.disabled || r2["aria-disabled"]) for (let s2 in e2) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s2) && (e2[s2] = [(t2) => {
    var l2;
    return (l2 = t2 == null ? void 0 : t2.preventDefault) == null ? void 0 : l2.call(t2);
  }]);
  for (let s2 in e2) Object.assign(r2, { [s2](t2, ...l2) {
    let i2 = e2[s2];
    for (let o4 of i2) {
      if ((t2 instanceof Event || (t2 == null ? void 0 : t2.nativeEvent) instanceof Event) && t2.defaultPrevented) return;
      o4(t2, ...l2);
    }
  } });
  return r2;
}
function V$2(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  for (let s2 in e2) Object.assign(r2, { [s2](...t2) {
    let l2 = e2[s2];
    for (let i2 of l2) i2 == null || i2(...t2);
  } });
  return r2;
}
function Y(n2) {
  var r2;
  return Object.assign(forwardRef(n2), { displayName: (r2 = n2.displayName) != null ? r2 : n2.name });
}
function m$4(n2) {
  let r2 = Object.assign({}, n2);
  for (let e2 in r2) r2[e2] === void 0 && delete r2[e2];
  return r2;
}
function h$4(n2, r2 = []) {
  let e2 = Object.assign({}, n2);
  for (let a3 of r2) a3 in e2 && delete e2[a3];
  return e2;
}
function H$2(n2) {
  return React__default.version.split(".")[0] >= "19" ? n2.props.ref : n2.ref;
}
function b$3(n2) {
  return n2 === Fragment || n2 === Symbol.for("react.fragment");
}
function D$4(n2) {
  return b$3(n2.type);
}
function b$2(l2, r2, c2) {
  let [i2, s2] = useState(c2), e2 = l2 !== void 0, t2 = useRef(e2), u2 = useRef(false), d2 = useRef(false);
  return e2 && !t2.current && !u2.current ? (u2.current = true, t2.current = e2, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e2 && t2.current && !d2.current && (d2.current = true, t2.current = e2, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e2 ? l2 : i2, o$5((n2) => (e2 || flushSync(() => s2(n2)), r2 == null ? void 0 : r2(n2)))];
}
function l$4(e2) {
  let [t2] = useState(e2);
  return t2;
}
function p$5(t2 = {}, i2 = null, n2 = []) {
  for (let [e2, o4] of Object.entries(t2)) s$7(n2, r$5(i2, e2), o4);
  return n2;
}
function r$5(t2, i2) {
  return t2 ? t2 + "[" + i2 + "]" : i2;
}
function s$7(t2, i2, n2) {
  if (Array.isArray(n2)) for (let [e2, o4] of n2.entries()) s$7(t2, r$5(i2, e2.toString()), o4);
  else n2 instanceof Date ? t2.push([i2, n2.toISOString()]) : typeof n2 == "boolean" ? t2.push([i2, n2 ? "1" : "0"]) : typeof n2 == "string" ? t2.push([i2, n2]) : typeof n2 == "number" ? t2.push([i2, `${n2}`]) : n2 == null ? t2.push([i2, ""]) : c$9(n2) && !isValidElement(n2) && p$5(n2, i2, t2);
}
function c$9(t2) {
  if (Object.prototype.toString.call(t2) !== "[object Object]") return false;
  let i2 = Object.getPrototypeOf(t2);
  return i2 === null || Object.getPrototypeOf(i2) === null;
}
let a$9 = "span";
var s$6 = ((e2) => (e2[e2.None = 1] = "None", e2[e2.Focusable = 2] = "Focusable", e2[e2.Hidden = 4] = "Hidden", e2))(s$6 || {});
function l$3(t2, r2) {
  var n2;
  let { features: d2 = 1, ...e2 } = t2, o4 = { ref: r2, "aria-hidden": (d2 & 2) === 2 ? true : (n2 = e2["aria-hidden"]) != null ? n2 : void 0, hidden: (d2 & 4) === 4 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(d2 & 4) === 4 && (d2 & 2) !== 2 && { display: "none" } } };
  return K()({ ourProps: o4, theirProps: e2, slot: {}, defaultTag: a$9, name: "Hidden" });
}
let f$a = Y(l$3);
let f$9 = createContext(null);
function c$8({ children: t2 }) {
  let e2 = useContext(f$9);
  if (!e2) return React__default.createElement(React__default.Fragment, null, t2);
  let { target: r2 } = e2;
  return r2 ? createPortal(React__default.createElement(React__default.Fragment, null, t2), r2) : null;
}
function j$5({ data: t2, form: e2, disabled: r2, onReset: n2, overrides: F2 }) {
  let [i2, a3] = useState(null), p2 = p$6();
  return useEffect(() => {
    if (n2 && i2) return p2.addEventListener(i2, "reset", n2);
  }, [i2, e2, n2]), React__default.createElement(c$8, null, React__default.createElement(C$4, { setForm: a3, formId: e2 }), p$5(t2).map(([s2, v2]) => React__default.createElement(f$a, { features: s$6.Hidden, ...m$4({ key: s2, as: "input", type: "hidden", hidden: true, readOnly: true, form: e2, disabled: r2, name: s2, value: v2, ...F2 }) })));
}
function C$4({ setForm: t2, formId: e2 }) {
  return useEffect(() => {
    if (e2) {
      let r2 = document.getElementById(e2);
      r2 && t2(r2);
    }
  }, [t2, e2]), e2 ? null : React__default.createElement(f$a, { features: s$6.Hidden, as: "input", type: "hidden", hidden: true, readOnly: true, ref: (r2) => {
    if (!r2) return;
    let n2 = r2.closest("form");
    n2 && t2(n2);
  } });
}
let e$2 = createContext(void 0);
function u$b() {
  return useContext(e$2);
}
function o$4(e2) {
  return typeof e2 != "object" || e2 === null ? false : "nodeType" in e2;
}
function t$3(e2) {
  return o$4(e2) && "tagName" in e2;
}
function n$4(e2) {
  return t$3(e2) && "accessKey" in e2;
}
function i$4(e2) {
  return t$3(e2) && "tabIndex" in e2;
}
function r$4(e2) {
  return t$3(e2) && "style" in e2;
}
function u$a(e2) {
  return n$4(e2) && e2.nodeName === "IFRAME";
}
function l$2(e2) {
  return n$4(e2) && e2.nodeName === "INPUT";
}
function m$3(e2) {
  return n$4(e2) && e2.nodeName === "LABEL";
}
function a$8(e2) {
  return n$4(e2) && e2.nodeName === "FIELDSET";
}
function E$2(e2) {
  return n$4(e2) && e2.nodeName === "LEGEND";
}
function L$2(e2) {
  return t$3(e2) ? e2.matches('a[href],audio[controls],button,details,embed,iframe,img[usemap],input:not([type="hidden"]),label,select,textarea,video[controls]') : false;
}
function s$5(l2) {
  let e2 = l2.parentElement, t2 = null;
  for (; e2 && !a$8(e2); ) E$2(e2) && (t2 = e2), e2 = e2.parentElement;
  let i2 = (e2 == null ? void 0 : e2.getAttribute("disabled")) === "";
  return i2 && r$3(t2) ? false : i2;
}
function r$3(l2) {
  if (!l2) return false;
  let e2 = l2.previousElementSibling;
  for (; e2 !== null; ) {
    if (E$2(e2)) return false;
    e2 = e2.previousElementSibling;
  }
  return true;
}
let u$9 = Symbol();
function T$3(t2, n2 = true) {
  return Object.assign(t2, { [u$9]: n2 });
}
function y$4(...t2) {
  let n2 = useRef(t2);
  useEffect(() => {
    n2.current = t2;
  }, [t2]);
  let c2 = o$5((e2) => {
    for (let o4 of n2.current) o4 != null && (typeof o4 == "function" ? o4(e2) : o4.current = e2);
  });
  return t2.every((e2) => e2 == null || (e2 == null ? void 0 : e2[u$9])) ? void 0 : c2;
}
let a$7 = createContext(null);
a$7.displayName = "DescriptionContext";
function f$8() {
  let r2 = useContext(a$7);
  if (r2 === null) {
    let e2 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(e2, f$8), e2;
  }
  return r2;
}
function w$3() {
  var r2, e2;
  return (e2 = (r2 = useContext(a$7)) == null ? void 0 : r2.value) != null ? e2 : void 0;
}
let I$4 = "p";
function C$3(r2, e2) {
  let c2 = useId$1(), t2 = a$a(), { id: i2 = `headlessui-description-${c2}`, ...l2 } = r2, n2 = f$8(), o4 = y$4(e2);
  n$6(() => n2.register(i2), [i2, n2.register]);
  let s2 = n$5({ ...n2.slot, disabled: t2 || false }), p2 = { ref: o4, ...n2.props, id: i2 };
  return K()({ ourProps: p2, theirProps: l2, slot: s2, defaultTag: I$4, name: n2.name || "Description" });
}
let _$2 = Y(C$3);
Object.assign(_$2, {});
var o$3 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(o$3 || {});
let L$1 = createContext(null);
L$1.displayName = "LabelContext";
function C$2() {
  let n2 = useContext(L$1);
  if (n2 === null) {
    let l2 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(l2, C$2), l2;
  }
  return n2;
}
function N$1(n2) {
  var a3, e2, o4;
  let l2 = (e2 = (a3 = useContext(L$1)) == null ? void 0 : a3.value) != null ? e2 : void 0;
  return ((o4 = n2 == null ? void 0 : n2.length) != null ? o4 : 0) > 0 ? [l2, ...n2].filter(Boolean).join(" ") : l2;
}
function V$1({ inherit: n2 = false } = {}) {
  let l2 = N$1(), [a3, e2] = useState([]), o4 = n2 ? [l2, ...a3].filter(Boolean) : a3;
  return [o4.length > 0 ? o4.join(" ") : void 0, useMemo(() => function(t2) {
    let p2 = o$5((i2) => (e2((u2) => [...u2, i2]), () => e2((u2) => {
      let d2 = u2.slice(), f2 = d2.indexOf(i2);
      return f2 !== -1 && d2.splice(f2, 1), d2;
    }))), b2 = useMemo(() => ({ register: p2, slot: t2.slot, name: t2.name, props: t2.props, value: t2.value }), [p2, t2.slot, t2.name, t2.props, t2.value]);
    return React__default.createElement(L$1.Provider, { value: b2 }, t2.children);
  }, [e2])];
}
let G$1 = "label";
function U(n2, l2) {
  var y2;
  let a3 = useId$1(), e2 = C$2(), o4 = u$b(), T3 = a$a(), { id: t2 = `headlessui-label-${a3}`, htmlFor: p2 = o4 != null ? o4 : (y2 = e2.props) == null ? void 0 : y2.htmlFor, passive: b2 = false, ...i2 } = n2, u2 = y$4(l2);
  n$6(() => e2.register(t2), [t2, e2.register]);
  let d2 = o$5((s2) => {
    let g2 = s2.currentTarget;
    if (!(s2.target !== s2.currentTarget && L$2(s2.target)) && (m$3(g2) && s2.preventDefault(), e2.props && "onClick" in e2.props && typeof e2.props.onClick == "function" && e2.props.onClick(s2), m$3(g2))) {
      let r2 = document.getElementById(g2.htmlFor);
      if (r2) {
        let E2 = r2.getAttribute("disabled");
        if (E2 === "true" || E2 === "") return;
        let x2 = r2.getAttribute("aria-disabled");
        if (x2 === "true" || x2 === "") return;
        (l$2(r2) && (r2.type === "file" || r2.type === "radio" || r2.type === "checkbox") || r2.role === "radio" || r2.role === "checkbox" || r2.role === "switch") && r2.click(), r2.focus({ preventScroll: true });
      }
    }
  }), f2 = n$5({ ...e2.slot, disabled: T3 || false }), c2 = { ref: u2, ...e2.props, id: t2, htmlFor: p2, onClick: d2 };
  return b2 && ("onClick" in c2 && (delete c2.htmlFor, delete c2.onClick), "onClick" in i2 && delete i2.onClick), K()({ ourProps: c2, theirProps: i2, slot: f2, defaultTag: p2 ? G$1 : "div", name: e2.name || "Label" });
}
let j$4 = Y(U), Z = Object.assign(j$4, {});
function memo(getDeps, fn, opts) {
  let deps = opts.initialDeps ?? [];
  let result;
  let isInitial = true;
  function memoizedFunction() {
    var _a, _b, _c;
    let depTime;
    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();
    const newDeps = getDeps();
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index2) => deps[index2] !== dep);
    if (!depsChanged) {
      return result;
    }
    deps = newDeps;
    let resultTime;
    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();
    result = fn(...newDeps);
    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {
      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;
      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;
      const resultFpsPercentage = resultEndTime / 16;
      const pad = (str, num) => {
        str = String(str);
        while (str.length < num) {
          str = " " + str;
        }
        return str;
      };
      console.info(
        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * resultFpsPercentage, 120)
        )}deg 100% 31%);`,
        opts == null ? void 0 : opts.key
      );
    }
    if ((opts == null ? void 0 : opts.onChange) && !(isInitial && opts.skipInitialOnChange)) {
      opts.onChange(result);
    }
    isInitial = false;
    return result;
  }
  memoizedFunction.updateDeps = (newDeps) => {
    deps = newDeps;
  };
  return memoizedFunction;
}
function notUndefined(value, msg) {
  if (value === void 0) {
    throw new Error(`Unexpected undefined${""}`);
  } else {
    return value;
  }
}
const approxEqual = (a3, b2) => Math.abs(a3 - b2) < 1.01;
const debounce = (targetWindow, fn, ms) => {
  let timeoutId;
  return function(...args) {
    targetWindow.clearTimeout(timeoutId);
    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);
  };
};
const getRect = (element) => {
  const { offsetWidth, offsetHeight } = element;
  return { width: offsetWidth, height: offsetHeight };
};
const defaultKeyExtractor = (index2) => index2;
const defaultRangeExtractor = (range) => {
  const start = Math.max(range.startIndex - range.overscan, 0);
  const end = Math.min(range.endIndex + range.overscan, range.count - 1);
  const arr = [];
  for (let i2 = start; i2 <= end; i2++) {
    arr.push(i2);
  }
  return arr;
};
const observeElementRect = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  const handler = (rect) => {
    const { width, height } = rect;
    cb({ width: Math.round(width), height: Math.round(height) });
  };
  handler(getRect(element));
  if (!targetWindow.ResizeObserver) {
    return () => {
    };
  }
  const observer = new targetWindow.ResizeObserver((entries) => {
    const run = () => {
      const entry = entries[0];
      if (entry == null ? void 0 : entry.borderBoxSize) {
        const box = entry.borderBoxSize[0];
        if (box) {
          handler({ width: box.inlineSize, height: box.blockSize });
          return;
        }
      }
      handler(getRect(element));
    };
    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
  });
  observer.observe(element, { box: "border-box" });
  return () => {
    observer.unobserve(element);
  };
};
const addEventListenerOptions = {
  passive: true
};
const supportsScrollend = typeof window == "undefined" ? true : "onscrollend" in window;
const observeElementOffset = (instance, cb) => {
  const element = instance.scrollElement;
  if (!element) {
    return;
  }
  const targetWindow = instance.targetWindow;
  if (!targetWindow) {
    return;
  }
  let offset2 = 0;
  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(
    targetWindow,
    () => {
      cb(offset2, false);
    },
    instance.options.isScrollingResetDelay
  );
  const createHandler = (isScrolling) => () => {
    const { horizontal, isRtl } = instance.options;
    offset2 = horizontal ? element["scrollLeft"] * (isRtl && -1 || 1) : element["scrollTop"];
    fallback();
    cb(offset2, isScrolling);
  };
  const handler = createHandler(true);
  const endHandler = createHandler(false);
  element.addEventListener("scroll", handler, addEventListenerOptions);
  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;
  if (registerScrollendEvent) {
    element.addEventListener("scrollend", endHandler, addEventListenerOptions);
  }
  return () => {
    element.removeEventListener("scroll", handler);
    if (registerScrollendEvent) {
      element.removeEventListener("scrollend", endHandler);
    }
  };
};
const measureElement = (element, entry, instance) => {
  if (entry == null ? void 0 : entry.borderBoxSize) {
    const box = entry.borderBoxSize[0];
    if (box) {
      const size2 = Math.round(
        box[instance.options.horizontal ? "inlineSize" : "blockSize"]
      );
      return size2;
    }
  }
  return element[instance.options.horizontal ? "offsetWidth" : "offsetHeight"];
};
const elementScroll = (offset2, {
  adjustments = 0,
  behavior
}, instance) => {
  var _a, _b;
  const toOffset = offset2 + adjustments;
  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {
    [instance.options.horizontal ? "left" : "top"]: toOffset,
    behavior
  });
};
class Virtualizer {
  constructor(opts) {
    this.unsubs = [];
    this.scrollElement = null;
    this.targetWindow = null;
    this.isScrolling = false;
    this.currentScrollToIndex = null;
    this.measurementsCache = [];
    this.itemSizeCache = /* @__PURE__ */ new Map();
    this.laneAssignments = /* @__PURE__ */ new Map();
    this.pendingMeasuredCacheIndexes = [];
    this.prevLanes = void 0;
    this.lanesChangedFlag = false;
    this.lanesSettling = false;
    this.scrollRect = null;
    this.scrollOffset = null;
    this.scrollDirection = null;
    this.scrollAdjustments = 0;
    this.elementsCache = /* @__PURE__ */ new Map();
    this.observer = /* @__PURE__ */ (() => {
      let _ro = null;
      const get = () => {
        if (_ro) {
          return _ro;
        }
        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {
          return null;
        }
        return _ro = new this.targetWindow.ResizeObserver((entries) => {
          entries.forEach((entry) => {
            const run = () => {
              this._measureElement(entry.target, entry);
            };
            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();
          });
        });
      };
      return {
        disconnect: () => {
          var _a;
          (_a = get()) == null ? void 0 : _a.disconnect();
          _ro = null;
        },
        observe: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.observe(target, { box: "border-box" });
        },
        unobserve: (target) => {
          var _a;
          return (_a = get()) == null ? void 0 : _a.unobserve(target);
        }
      };
    })();
    this.range = null;
    this.setOptions = (opts2) => {
      Object.entries(opts2).forEach(([key, value]) => {
        if (typeof value === "undefined") delete opts2[key];
      });
      this.options = {
        debug: false,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: false,
        getItemKey: defaultKeyExtractor,
        rangeExtractor: defaultRangeExtractor,
        onChange: () => {
        },
        measureElement,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        isScrollingResetDelay: 150,
        enabled: true,
        isRtl: false,
        useScrollendEvent: false,
        useAnimationFrameWithResizeObserver: false,
        ...opts2
      };
    };
    this.notify = (sync) => {
      var _a, _b;
      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);
    };
    this.maybeNotify = memo(
      () => {
        this.calculateRange();
        return [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ];
      },
      (isScrolling) => {
        this.notify(isScrolling);
      },
      {
        key: process.env.NODE_ENV !== "production" && "maybeNotify",
        debug: () => this.options.debug,
        initialDeps: [
          this.isScrolling,
          this.range ? this.range.startIndex : null,
          this.range ? this.range.endIndex : null
        ]
      }
    );
    this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((d2) => d2());
      this.unsubs = [];
      this.observer.disconnect();
      this.scrollElement = null;
      this.targetWindow = null;
    };
    this._didMount = () => {
      return () => {
        this.cleanup();
      };
    };
    this._willUpdate = () => {
      var _a;
      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;
      if (this.scrollElement !== scrollElement) {
        this.cleanup();
        if (!scrollElement) {
          this.maybeNotify();
          return;
        }
        this.scrollElement = scrollElement;
        if (this.scrollElement && "ownerDocument" in this.scrollElement) {
          this.targetWindow = this.scrollElement.ownerDocument.defaultView;
        } else {
          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;
        }
        this.elementsCache.forEach((cached) => {
          this.observer.observe(cached);
        });
        this.unsubs.push(
          this.options.observeElementRect(this, (rect) => {
            this.scrollRect = rect;
            this.maybeNotify();
          })
        );
        this.unsubs.push(
          this.options.observeElementOffset(this, (offset2, isScrolling) => {
            this.scrollAdjustments = 0;
            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset2 ? "forward" : "backward" : null;
            this.scrollOffset = offset2;
            this.isScrolling = isScrolling;
            this.maybeNotify();
          })
        );
        this._scrollToOffset(this.getScrollOffset(), {
          adjustments: void 0,
          behavior: void 0
        });
      }
    };
    this.getSize = () => {
      if (!this.options.enabled) {
        this.scrollRect = null;
        return 0;
      }
      this.scrollRect = this.scrollRect ?? this.options.initialRect;
      return this.scrollRect[this.options.horizontal ? "width" : "height"];
    };
    this.getScrollOffset = () => {
      if (!this.options.enabled) {
        this.scrollOffset = null;
        return 0;
      }
      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === "function" ? this.options.initialOffset() : this.options.initialOffset);
      return this.scrollOffset;
    };
    this.getFurthestMeasurement = (measurements, index2) => {
      const furthestMeasurementsFound = /* @__PURE__ */ new Map();
      const furthestMeasurements = /* @__PURE__ */ new Map();
      for (let m2 = index2 - 1; m2 >= 0; m2--) {
        const measurement = measurements[m2];
        if (furthestMeasurementsFound.has(measurement.lane)) {
          continue;
        }
        const previousFurthestMeasurement = furthestMeasurements.get(
          measurement.lane
        );
        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {
          furthestMeasurements.set(measurement.lane, measurement);
        } else if (measurement.end < previousFurthestMeasurement.end) {
          furthestMeasurementsFound.set(measurement.lane, true);
        }
        if (furthestMeasurementsFound.size === this.options.lanes) {
          break;
        }
      }
      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a3, b2) => {
        if (a3.end === b2.end) {
          return a3.index - b2.index;
        }
        return a3.end - b2.end;
      })[0] : void 0;
    };
    this.getMeasurementOptions = memo(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey,
        this.options.enabled,
        this.options.lanes
      ],
      (count2, paddingStart, scrollMargin, getItemKey, enabled, lanes) => {
        const lanesChanged = this.prevLanes !== void 0 && this.prevLanes !== lanes;
        if (lanesChanged) {
          this.lanesChangedFlag = true;
        }
        this.prevLanes = lanes;
        this.pendingMeasuredCacheIndexes = [];
        return {
          count: count2,
          paddingStart,
          scrollMargin,
          getItemKey,
          enabled,
          lanes
        };
      },
      {
        key: false
      }
    );
    this.getMeasurements = memo(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: count2, paddingStart, scrollMargin, getItemKey, enabled, lanes }, itemSizeCache) => {
        if (!enabled) {
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          this.laneAssignments.clear();
          return [];
        }
        if (this.laneAssignments.size > count2) {
          for (const index2 of this.laneAssignments.keys()) {
            if (index2 >= count2) {
              this.laneAssignments.delete(index2);
            }
          }
        }
        if (this.lanesChangedFlag) {
          this.lanesChangedFlag = false;
          this.lanesSettling = true;
          this.measurementsCache = [];
          this.itemSizeCache.clear();
          this.laneAssignments.clear();
          this.pendingMeasuredCacheIndexes = [];
        }
        if (this.measurementsCache.length === 0 && !this.lanesSettling) {
          this.measurementsCache = this.options.initialMeasurementsCache;
          this.measurementsCache.forEach((item) => {
            this.itemSizeCache.set(item.key, item.size);
          });
        }
        const min2 = this.lanesSettling ? 0 : this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        if (this.lanesSettling && this.measurementsCache.length === count2) {
          this.lanesSettling = false;
        }
        const measurements = this.measurementsCache.slice(0, min2);
        const laneLastIndex = new Array(lanes).fill(
          void 0
        );
        for (let m2 = 0; m2 < min2; m2++) {
          const item = measurements[m2];
          if (item) {
            laneLastIndex[item.lane] = m2;
          }
        }
        for (let i2 = min2; i2 < count2; i2++) {
          const key = getItemKey(i2);
          const cachedLane = this.laneAssignments.get(i2);
          let lane;
          let start;
          if (cachedLane !== void 0 && this.options.lanes > 1) {
            lane = cachedLane;
            const prevIndex = laneLastIndex[lane];
            const prevInLane = prevIndex !== void 0 ? measurements[prevIndex] : void 0;
            start = prevInLane ? prevInLane.end + this.options.gap : paddingStart + scrollMargin;
          } else {
            const furthestMeasurement = this.options.lanes === 1 ? measurements[i2 - 1] : this.getFurthestMeasurement(measurements, i2);
            start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;
            lane = furthestMeasurement ? furthestMeasurement.lane : i2 % this.options.lanes;
            if (this.options.lanes > 1) {
              this.laneAssignments.set(i2, lane);
            }
          }
          const measuredSize = itemSizeCache.get(key);
          const size2 = typeof measuredSize === "number" ? measuredSize : this.options.estimateSize(i2);
          const end = start + size2;
          measurements[i2] = {
            index: i2,
            start,
            size: size2,
            end,
            key,
            lane
          };
          laneLastIndex[lane] = i2;
        }
        this.measurementsCache = measurements;
        return measurements;
      },
      {
        key: process.env.NODE_ENV !== "production" && "getMeasurements",
        debug: () => this.options.debug
      }
    );
    this.calculateRange = memo(
      () => [
        this.getMeasurements(),
        this.getSize(),
        this.getScrollOffset(),
        this.options.lanes
      ],
      (measurements, outerSize, scrollOffset, lanes) => {
        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({
          measurements,
          outerSize,
          scrollOffset,
          lanes
        }) : null;
      },
      {
        key: process.env.NODE_ENV !== "production" && "calculateRange",
        debug: () => this.options.debug
      }
    );
    this.getVirtualIndexes = memo(
      () => {
        let startIndex = null;
        let endIndex = null;
        const range = this.calculateRange();
        if (range) {
          startIndex = range.startIndex;
          endIndex = range.endIndex;
        }
        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);
        return [
          this.options.rangeExtractor,
          this.options.overscan,
          this.options.count,
          startIndex,
          endIndex
        ];
      },
      (rangeExtractor, overscan, count2, startIndex, endIndex) => {
        return startIndex === null || endIndex === null ? [] : rangeExtractor({
          startIndex,
          endIndex,
          overscan,
          count: count2
        });
      },
      {
        key: process.env.NODE_ENV !== "production" && "getVirtualIndexes",
        debug: () => this.options.debug
      }
    );
    this.indexFromElement = (node) => {
      const attributeName = this.options.indexAttribute;
      const indexStr = node.getAttribute(attributeName);
      if (!indexStr) {
        console.warn(
          `Missing attribute name '${attributeName}={index}' on measured element.`
        );
        return -1;
      }
      return parseInt(indexStr, 10);
    };
    this._measureElement = (node, entry) => {
      const index2 = this.indexFromElement(node);
      const item = this.measurementsCache[index2];
      if (!item) {
        return;
      }
      const key = item.key;
      const prevNode = this.elementsCache.get(key);
      if (prevNode !== node) {
        if (prevNode) {
          this.observer.unobserve(prevNode);
        }
        this.observer.observe(node);
        this.elementsCache.set(key, node);
      }
      if (node.isConnected) {
        this.resizeItem(index2, this.options.measureElement(node, entry, this));
      }
    };
    this.resizeItem = (index2, size2) => {
      const item = this.measurementsCache[index2];
      if (!item) {
        return;
      }
      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;
      const delta = size2 - itemSize;
      if (delta !== 0) {
        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {
          if (process.env.NODE_ENV !== "production" && this.options.debug) {
            console.info("correction", delta);
          }
          this._scrollToOffset(this.getScrollOffset(), {
            adjustments: this.scrollAdjustments += delta,
            behavior: void 0
          });
        }
        this.pendingMeasuredCacheIndexes.push(item.index);
        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size2));
        this.notify(false);
      }
    };
    this.measureElement = (node) => {
      if (!node) {
        this.elementsCache.forEach((cached, key) => {
          if (!cached.isConnected) {
            this.observer.unobserve(cached);
            this.elementsCache.delete(key);
          }
        });
        return;
      }
      this._measureElement(node, void 0);
    };
    this.getVirtualItems = memo(
      () => [this.getVirtualIndexes(), this.getMeasurements()],
      (indexes, measurements) => {
        const virtualItems = [];
        for (let k2 = 0, len = indexes.length; k2 < len; k2++) {
          const i2 = indexes[k2];
          const measurement = measurements[i2];
          virtualItems.push(measurement);
        }
        return virtualItems;
      },
      {
        key: process.env.NODE_ENV !== "production" && "getVirtualItems",
        debug: () => this.options.debug
      }
    );
    this.getVirtualItemForOffset = (offset2) => {
      const measurements = this.getMeasurements();
      if (measurements.length === 0) {
        return void 0;
      }
      return notUndefined(
        measurements[findNearestBinarySearch(
          0,
          measurements.length - 1,
          (index2) => notUndefined(measurements[index2]).start,
          offset2
        )]
      );
    };
    this.getMaxScrollOffset = () => {
      if (!this.scrollElement) return 0;
      if ("scrollHeight" in this.scrollElement) {
        return this.options.horizontal ? this.scrollElement.scrollWidth - this.scrollElement.clientWidth : this.scrollElement.scrollHeight - this.scrollElement.clientHeight;
      } else {
        const doc = this.scrollElement.document.documentElement;
        return this.options.horizontal ? doc.scrollWidth - this.scrollElement.innerWidth : doc.scrollHeight - this.scrollElement.innerHeight;
      }
    };
    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {
      if (!this.scrollElement) return 0;
      const size2 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        align = toOffset >= scrollOffset + size2 ? "end" : "start";
      }
      if (align === "center") {
        toOffset += (itemSize - size2) / 2;
      } else if (align === "end") {
        toOffset -= size2;
      }
      const maxOffset = this.getMaxScrollOffset();
      return Math.max(Math.min(maxOffset, toOffset), 0);
    };
    this.getOffsetForIndex = (index2, align = "auto") => {
      index2 = Math.max(0, Math.min(index2, this.options.count - 1));
      const item = this.measurementsCache[index2];
      if (!item) {
        return void 0;
      }
      const size2 = this.getSize();
      const scrollOffset = this.getScrollOffset();
      if (align === "auto") {
        if (item.end >= scrollOffset + size2 - this.options.scrollPaddingEnd) {
          align = "end";
        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {
          align = "start";
        } else {
          return [scrollOffset, align];
        }
      }
      if (align === "end" && index2 === this.options.count - 1) {
        return [this.getMaxScrollOffset(), align];
      }
      const toOffset = align === "end" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;
      return [
        this.getOffsetForAlignment(toOffset, align, item.size),
        align
      ];
    };
    this.isDynamicMode = () => this.elementsCache.size > 0;
    this.scrollToOffset = (toOffset, { align = "start", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {
        adjustments: void 0,
        behavior
      });
    };
    this.scrollToIndex = (index2, { align: initialAlign = "auto", behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      index2 = Math.max(0, Math.min(index2, this.options.count - 1));
      this.currentScrollToIndex = index2;
      let attempts = 0;
      const maxAttempts = 10;
      const tryScroll = (currentAlign) => {
        if (!this.targetWindow) return;
        const offsetInfo = this.getOffsetForIndex(index2, currentAlign);
        if (!offsetInfo) {
          console.warn("Failed to get offset for index:", index2);
          return;
        }
        const [offset2, align] = offsetInfo;
        this._scrollToOffset(offset2, { adjustments: void 0, behavior });
        this.targetWindow.requestAnimationFrame(() => {
          const verify = () => {
            if (this.currentScrollToIndex !== index2) return;
            const currentOffset = this.getScrollOffset();
            const afterInfo = this.getOffsetForIndex(index2, align);
            if (!afterInfo) {
              console.warn("Failed to get offset for index:", index2);
              return;
            }
            if (!approxEqual(afterInfo[0], currentOffset)) {
              scheduleRetry(align);
            }
          };
          if (this.isDynamicMode()) {
            this.targetWindow.requestAnimationFrame(verify);
          } else {
            verify();
          }
        });
      };
      const scheduleRetry = (align) => {
        if (!this.targetWindow) return;
        if (this.currentScrollToIndex !== index2) return;
        attempts++;
        if (attempts < maxAttempts) {
          if (process.env.NODE_ENV !== "production" && this.options.debug) {
            console.info("Schedule retry", attempts, maxAttempts);
          }
          this.targetWindow.requestAnimationFrame(() => tryScroll(align));
        } else {
          console.warn(
            `Failed to scroll to index ${index2} after ${maxAttempts} attempts.`
          );
        }
      };
      tryScroll(initialAlign);
    };
    this.scrollBy = (delta, { behavior } = {}) => {
      if (behavior === "smooth" && this.isDynamicMode()) {
        console.warn(
          "The `smooth` scroll behavior is not fully supported with dynamic size."
        );
      }
      this._scrollToOffset(this.getScrollOffset() + delta, {
        adjustments: void 0,
        behavior
      });
    };
    this.getTotalSize = () => {
      var _a;
      const measurements = this.getMeasurements();
      let end;
      if (measurements.length === 0) {
        end = this.options.paddingStart;
      } else if (this.options.lanes === 1) {
        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;
      } else {
        const endByLane = Array(this.options.lanes).fill(null);
        let endIndex = measurements.length - 1;
        while (endIndex >= 0 && endByLane.some((val) => val === null)) {
          const item = measurements[endIndex];
          if (endByLane[item.lane] === null) {
            endByLane[item.lane] = item.end;
          }
          endIndex--;
        }
        end = Math.max(...endByLane.filter((val) => val !== null));
      }
      return Math.max(
        end - this.options.scrollMargin + this.options.paddingEnd,
        0
      );
    };
    this._scrollToOffset = (offset2, {
      adjustments,
      behavior
    }) => {
      this.options.scrollToFn(offset2, { behavior, adjustments }, this);
    };
    this.measure = () => {
      this.itemSizeCache = /* @__PURE__ */ new Map();
      this.laneAssignments = /* @__PURE__ */ new Map();
      this.notify(false);
    };
    this.setOptions(opts);
  }
}
const findNearestBinarySearch = (low, high, getCurrentValue, value) => {
  while (low <= high) {
    const middle = (low + high) / 2 | 0;
    const currentValue = getCurrentValue(middle);
    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }
  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};
function calculateRange({
  measurements,
  outerSize,
  scrollOffset,
  lanes
}) {
  const lastIndex = measurements.length - 1;
  const getOffset2 = (index2) => measurements[index2].start;
  if (measurements.length <= lanes) {
    return {
      startIndex: 0,
      endIndex: lastIndex
    };
  }
  let startIndex = findNearestBinarySearch(
    0,
    lastIndex,
    getOffset2,
    scrollOffset
  );
  let endIndex = startIndex;
  if (lanes === 1) {
    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {
      endIndex++;
    }
  } else if (lanes > 1) {
    const endPerLane = Array(lanes).fill(0);
    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {
      const item = measurements[endIndex];
      endPerLane[item.lane] = item.end;
      endIndex++;
    }
    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);
    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {
      const item = measurements[startIndex];
      startPerLane[item.lane] = item.start;
      startIndex--;
    }
    startIndex = Math.max(0, startIndex - startIndex % lanes);
    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));
  }
  return { startIndex, endIndex };
}
const useIsomorphicLayoutEffect = typeof document !== "undefined" ? React.useLayoutEffect : React.useEffect;
function useVirtualizerBase({
  useFlushSync = true,
  ...options
}) {
  const rerender = React.useReducer(() => ({}), {})[1];
  const resolvedOptions = {
    ...options,
    onChange: (instance2, sync) => {
      var _a;
      if (useFlushSync && sync) {
        flushSync(rerender);
      } else {
        rerender();
      }
      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);
    }
  };
  const [instance] = React.useState(
    () => new Virtualizer(resolvedOptions)
  );
  instance.setOptions(resolvedOptions);
  useIsomorphicLayoutEffect(() => {
    return instance._didMount();
  }, []);
  useIsomorphicLayoutEffect(() => {
    return instance._willUpdate();
  });
  return instance;
}
function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect,
    observeElementOffset,
    scrollToFn: elementScroll,
    ...options
  });
}
function l$1(e2, r2) {
  return e2 !== null && r2 !== null && typeof e2 == "object" && typeof r2 == "object" && "id" in e2 && "id" in r2 ? e2.id === r2.id : e2 === r2;
}
function u$8(e2 = l$1) {
  return useCallback((r2, t2) => {
    if (typeof e2 == "string") {
      let o4 = e2;
      return (r2 == null ? void 0 : r2[o4]) === (t2 == null ? void 0 : t2[o4]);
    }
    return e2(r2, t2);
  }, [e2]);
}
function h$3(i2) {
  if (i2 === null) return { width: 0, height: 0 };
  let { width: t2, height: e2 } = i2.getBoundingClientRect();
  return { width: t2, height: e2 };
}
function w$2(i2, t2, e2 = false) {
  let [r2, f2] = useState(() => h$3(t2));
  return n$6(() => {
    if (!t2 || !i2) return;
    let n2 = o$6();
    return n2.requestAnimationFrame(function s2() {
      n2.requestAnimationFrame(s2), f2((u2) => {
        let o4 = h$3(t2);
        return o4.width === u2.width && o4.height === u2.height ? u2 : o4;
      });
    }), () => {
      n2.dispose();
    };
  }, [t2, i2]), e2 ? { width: `${r2.width}px`, height: `${r2.height}px` } : r2;
}
var g$1 = ((f2) => (f2[f2.Left = 0] = "Left", f2[f2.Right = 2] = "Right", f2))(g$1 || {});
function s$4(t2) {
  let r2 = useRef(null), u2 = o$5((e2) => {
    r2.current = e2.pointerType, !s$5(e2.currentTarget) && e2.pointerType === "mouse" && e2.button === g$1.Left && (e2.preventDefault(), t2(e2));
  }), i2 = o$5((e2) => {
    r2.current !== "mouse" && (s$5(e2.currentTarget) || t2(e2));
  });
  return { onPointerDown: u2, onClick: i2 };
}
let a$6 = class a extends Map {
  constructor(t2) {
    super();
    this.factory = t2;
  }
  get(t2) {
    let e2 = super.get(t2);
    return e2 === void 0 && (e2 = this.factory(t2), this.set(t2, e2)), e2;
  }
};
var h$2 = Object.defineProperty;
var v$2 = (t2, e2, r2) => e2 in t2 ? h$2(t2, e2, { enumerable: true, configurable: true, writable: true, value: r2 }) : t2[e2] = r2;
var S$4 = (t2, e2, r2) => (v$2(t2, e2 + "", r2), r2), b$1 = (t2, e2, r2) => {
  if (!e2.has(t2)) throw TypeError("Cannot " + r2);
};
var i$3 = (t2, e2, r2) => (b$1(t2, e2, "read from private field"), r2 ? r2.call(t2) : e2.get(t2)), c$7 = (t2, e2, r2) => {
  if (e2.has(t2)) throw TypeError("Cannot add the same private member more than once");
  e2 instanceof WeakSet ? e2.add(t2) : e2.set(t2, r2);
}, u$7 = (t2, e2, r2, s2) => (b$1(t2, e2, "write to private field"), e2.set(t2, r2), r2);
var n$3, a$5, o$2;
let T$2 = class T {
  constructor(e2) {
    c$7(this, n$3, {});
    c$7(this, a$5, new a$6(() => /* @__PURE__ */ new Set()));
    c$7(this, o$2, /* @__PURE__ */ new Set());
    S$4(this, "disposables", o$6());
    u$7(this, n$3, e2), s$9.isServer && this.disposables.microTask(() => {
      this.dispose();
    });
  }
  dispose() {
    this.disposables.dispose();
  }
  get state() {
    return i$3(this, n$3);
  }
  subscribe(e2, r2) {
    if (s$9.isServer) return () => {
    };
    let s2 = { selector: e2, callback: r2, current: e2(i$3(this, n$3)) };
    return i$3(this, o$2).add(s2), this.disposables.add(() => {
      i$3(this, o$2).delete(s2);
    });
  }
  on(e2, r2) {
    return s$9.isServer ? () => {
    } : (i$3(this, a$5).get(e2).add(r2), this.disposables.add(() => {
      i$3(this, a$5).get(e2).delete(r2);
    }));
  }
  send(e2) {
    let r2 = this.reduce(i$3(this, n$3), e2);
    if (r2 !== i$3(this, n$3)) {
      u$7(this, n$3, r2);
      for (let s2 of i$3(this, o$2)) {
        let l2 = s2.selector(i$3(this, n$3));
        j$3(s2.current, l2) || (s2.current = l2, s2.callback(l2));
      }
      for (let s2 of i$3(this, a$5).get(e2.type)) s2(i$3(this, n$3), e2);
    }
  }
};
n$3 = /* @__PURE__ */ new WeakMap(), a$5 = /* @__PURE__ */ new WeakMap(), o$2 = /* @__PURE__ */ new WeakMap();
function j$3(t2, e2) {
  return Object.is(t2, e2) ? true : typeof t2 != "object" || t2 === null || typeof e2 != "object" || e2 === null ? false : Array.isArray(t2) && Array.isArray(e2) ? t2.length !== e2.length ? false : f$7(t2[Symbol.iterator](), e2[Symbol.iterator]()) : t2 instanceof Map && e2 instanceof Map || t2 instanceof Set && e2 instanceof Set ? t2.size !== e2.size ? false : f$7(t2.entries(), e2.entries()) : p$4(t2) && p$4(e2) ? f$7(Object.entries(t2)[Symbol.iterator](), Object.entries(e2)[Symbol.iterator]()) : false;
}
function f$7(t2, e2) {
  do {
    let r2 = t2.next(), s2 = e2.next();
    if (r2.done && s2.done) return true;
    if (r2.done || s2.done || !Object.is(r2.value, s2.value)) return false;
  } while (true);
}
function p$4(t2) {
  if (Object.prototype.toString.call(t2) !== "[object Object]") return false;
  let e2 = Object.getPrototypeOf(t2);
  return e2 === null || Object.getPrototypeOf(e2) === null;
}
var a$4 = Object.defineProperty;
var r$2 = (e2, c2, t2) => c2 in e2 ? a$4(e2, c2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[c2] = t2;
var p$3 = (e2, c2, t2) => (r$2(e2, typeof c2 != "symbol" ? c2 + "" : c2, t2), t2);
var k$2 = ((t2) => (t2[t2.Push = 0] = "Push", t2[t2.Pop = 1] = "Pop", t2))(k$2 || {});
let y$3 = { [0](e2, c2) {
  let t2 = c2.id, s2 = e2.stack, i2 = e2.stack.indexOf(t2);
  if (i2 !== -1) {
    let n2 = e2.stack.slice();
    return n2.splice(i2, 1), n2.push(t2), s2 = n2, { ...e2, stack: s2 };
  }
  return { ...e2, stack: [...e2.stack, t2] };
}, [1](e2, c2) {
  let t2 = c2.id, s2 = e2.stack.indexOf(t2);
  if (s2 === -1) return e2;
  let i2 = e2.stack.slice();
  return i2.splice(s2, 1), { ...e2, stack: i2 };
} };
let o$1 = class o2 extends T$2 {
  constructor() {
    super(...arguments);
    p$3(this, "actions", { push: (t2) => this.send({ type: 0, id: t2 }), pop: (t2) => this.send({ type: 1, id: t2 }) });
    p$3(this, "selectors", { isTop: (t2, s2) => t2.stack[t2.stack.length - 1] === s2, inStack: (t2, s2) => t2.stack.includes(s2) });
  }
  static new() {
    return new o2({ stack: [] });
  }
  reduce(t2, s2) {
    return u$c(s2.type, y$3, t2, s2);
  }
};
const x$1 = new a$6(() => o$1.new());
var withSelector = { exports: {} };
var useSyncExternalStoreWithSelector_production = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_production;
function requireUseSyncExternalStoreWithSelector_production() {
  if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;
  hasRequiredUseSyncExternalStoreWithSelector_production = 1;
  var React2 = React__default;
  function is(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore2 = React2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;
  useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef2(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo2(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
    useEffect2(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return useSyncExternalStoreWithSelector_production;
}
var useSyncExternalStoreWithSelector_development = {};
/**
 * @license React
 * use-sync-external-store-with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreWithSelector_development;
function requireUseSyncExternalStoreWithSelector_development() {
  if (hasRequiredUseSyncExternalStoreWithSelector_development) return useSyncExternalStoreWithSelector_development;
  hasRequiredUseSyncExternalStoreWithSelector_development = 1;
  "production" !== process.env.NODE_ENV && (function() {
    function is(x2, y2) {
      return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React2 = React__default, objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore2 = React2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;
    useSyncExternalStoreWithSelector_development.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
      var instRef = useRef2(null);
      if (null === instRef.current) {
        var inst = { hasValue: false, value: null };
        instRef.current = inst;
      } else inst = instRef.current;
      instRef = useMemo2(
        function() {
          function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              nextSnapshot = selector(nextSnapshot);
              if (void 0 !== isEqual && inst.hasValue) {
                var currentSelection = inst.value;
                if (isEqual(currentSelection, nextSnapshot))
                  return memoizedSelection = currentSelection;
              }
              return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot))
              return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
              return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
          }
          var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
          return [
            function() {
              return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            }
          ];
        },
        [getSnapshot, getServerSnapshot, selector, isEqual]
      );
      var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
      useEffect2(
        function() {
          inst.hasValue = true;
          inst.value = value;
        },
        [value]
      );
      useDebugValue(value);
      return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
  return useSyncExternalStoreWithSelector_development;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  if (process.env.NODE_ENV === "production") {
    withSelector.exports = requireUseSyncExternalStoreWithSelector_production();
  } else {
    withSelector.exports = requireUseSyncExternalStoreWithSelector_development();
  }
  return withSelector.exports;
}
var withSelectorExports = requireWithSelector();
function S$3(e2, n2, r2 = j$3) {
  return withSelectorExports.useSyncExternalStoreWithSelector(o$5((i2) => e2.subscribe(s$3, i2)), o$5(() => e2.state), o$5(() => e2.state), o$5(n2), r2);
}
function s$3(e2) {
  return e2;
}
function I$3(o4, s2) {
  let t2 = useId$1(), r2 = x$1.get(s2), [i2, c2] = S$3(r2, useCallback((e2) => [r2.selectors.isTop(e2, t2), r2.selectors.inStack(e2, t2)], [r2, t2]));
  return n$6(() => {
    if (o4) return r2.actions.push(t2), () => r2.actions.pop(t2);
  }, [r2, o4, t2]), o4 ? c2 ? i2 : true : false;
}
let f$6 = /* @__PURE__ */ new Map(), u$6 = /* @__PURE__ */ new Map();
function h$1(t2) {
  var e2;
  let r2 = (e2 = u$6.get(t2)) != null ? e2 : 0;
  return u$6.set(t2, r2 + 1), r2 !== 0 ? () => m$2(t2) : (f$6.set(t2, { "aria-hidden": t2.getAttribute("aria-hidden"), inert: t2.inert }), t2.setAttribute("aria-hidden", "true"), t2.inert = true, () => m$2(t2));
}
function m$2(t2) {
  var i2;
  let r2 = (i2 = u$6.get(t2)) != null ? i2 : 1;
  if (r2 === 1 ? u$6.delete(t2) : u$6.set(t2, r2 - 1), r2 !== 1) return;
  let e2 = f$6.get(t2);
  e2 && (e2["aria-hidden"] === null ? t2.removeAttribute("aria-hidden") : t2.setAttribute("aria-hidden", e2["aria-hidden"]), t2.inert = e2.inert, f$6.delete(t2));
}
function y$2(t2, { allowed: r2, disallowed: e2 } = {}) {
  let i2 = I$3(t2, "inert-others");
  n$6(() => {
    var d2, c2;
    if (!i2) return;
    let a3 = o$6();
    for (let n2 of (d2 = e2 == null ? void 0 : e2()) != null ? d2 : []) n2 && a3.add(h$1(n2));
    let s2 = (c2 = r2 == null ? void 0 : r2()) != null ? c2 : [];
    for (let n2 of s2) {
      if (!n2) continue;
      let l2 = l$5(n2);
      if (!l2) continue;
      let o4 = n2.parentElement;
      for (; o4 && o4 !== l2.body; ) {
        for (let p2 of o4.children) s2.some((E2) => p2.contains(E2)) || a3.add(h$1(p2));
        o4 = o4.parentElement;
      }
    }
    return a3.dispose;
  }, [i2, r2, e2]);
}
function p$2(s2, n2, o4) {
  let i2 = s$8((t2) => {
    let e2 = t2.getBoundingClientRect();
    e2.x === 0 && e2.y === 0 && e2.width === 0 && e2.height === 0 && o4();
  });
  useEffect(() => {
    if (!s2) return;
    let t2 = n2 === null ? null : n$4(n2) ? n2 : n2.current;
    if (!t2) return;
    let e2 = o$6();
    if (typeof ResizeObserver != "undefined") {
      let r2 = new ResizeObserver(() => i2.current(t2));
      r2.observe(t2), e2.add(() => r2.disconnect());
    }
    if (typeof IntersectionObserver != "undefined") {
      let r2 = new IntersectionObserver(() => i2.current(t2));
      r2.observe(t2), e2.add(() => r2.disconnect());
    }
    return () => e2.dispose();
  }, [n2, i2, s2]);
}
let E$1 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "details>summary", "textarea:not([disabled])"].map((e2) => `${e2}:not([tabindex='-1'])`).join(",");
var T$1 = ((o4) => (o4[o4.First = 1] = "First", o4[o4.Previous = 2] = "Previous", o4[o4.Next = 4] = "Next", o4[o4.Last = 8] = "Last", o4[o4.WrapAround = 16] = "WrapAround", o4[o4.NoScroll = 32] = "NoScroll", o4[o4.AutoFocus = 64] = "AutoFocus", o4))(T$1 || {}), A$1 = ((n2) => (n2[n2.Error = 0] = "Error", n2[n2.Overflow = 1] = "Overflow", n2[n2.Success = 2] = "Success", n2[n2.Underflow = 3] = "Underflow", n2))(A$1 || {}), O$1 = ((t2) => (t2[t2.Previous = -1] = "Previous", t2[t2.Next = 1] = "Next", t2))(O$1 || {});
var I$2 = ((t2) => (t2[t2.Strict = 0] = "Strict", t2[t2.Loose = 1] = "Loose", t2))(I$2 || {});
function H$1(e2, r2 = 0) {
  var t2;
  return e2 === ((t2 = l$5(e2)) == null ? void 0 : t2.body) ? false : u$c(r2, { [0]() {
    return e2.matches(E$1);
  }, [1]() {
    let l2 = e2;
    for (; l2 !== null; ) {
      if (l2.matches(E$1)) return true;
      l2 = l2.parentElement;
    }
    return false;
  } });
}
var g = ((t2) => (t2[t2.Keyboard = 0] = "Keyboard", t2[t2.Mouse = 1] = "Mouse", t2))(g || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e2) => {
  e2.metaKey || e2.altKey || e2.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e2) => {
  e2.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e2.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function G(e2, r2 = (t2) => t2) {
  return e2.slice().sort((t2, l2) => {
    let n2 = r2(t2), a3 = r2(l2);
    if (n2 === null || a3 === null) return 0;
    let u2 = n2.compareDocumentPosition(a3);
    return u2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : u2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function t$2() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$2() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$2() {
  return t$2() || i$2();
}
function i$1(t2, e2, o4, n2) {
  let u2 = s$8(o4);
  useEffect(() => {
    if (!t2) return;
    function r2(m2) {
      u2.current(m2);
    }
    return document.addEventListener(e2, r2, n2), () => document.removeEventListener(e2, r2, n2);
  }, [t2, e2, n2]);
}
function s$2(t2, e2, o4, n2) {
  let i2 = s$8(o4);
  useEffect(() => {
    if (!t2) return;
    function r2(d2) {
      i2.current(d2);
    }
    return window.addEventListener(e2, r2, n2), () => window.removeEventListener(e2, r2, n2);
  }, [t2, e2, n2]);
}
const C$1 = 30;
function k$1(o4, f2, h2) {
  let m2 = s$8(h2), s2 = useCallback(function(e2, c2) {
    if (e2.defaultPrevented) return;
    let r2 = c2(e2);
    if (r2 === null || !r2.getRootNode().contains(r2) || !r2.isConnected) return;
    let M2 = (function u2(n2) {
      return typeof n2 == "function" ? u2(n2()) : Array.isArray(n2) || n2 instanceof Set ? n2 : [n2];
    })(f2);
    for (let u2 of M2) if (u2 !== null && (u2.contains(r2) || e2.composed && e2.composedPath().includes(u2))) return;
    return !H$1(r2, I$2.Loose) && r2.tabIndex !== -1 && e2.preventDefault(), m2.current(e2, r2);
  }, [m2, f2]), i2 = useRef(null);
  i$1(o4, "pointerdown", (t2) => {
    var e2, c2;
    n$2() || (i2.current = ((c2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : c2[0]) || t2.target);
  }, true), i$1(o4, "pointerup", (t2) => {
    if (n$2() || !i2.current) return;
    let e2 = i2.current;
    return i2.current = null, s2(t2, () => e2);
  }, true);
  let l2 = useRef({ x: 0, y: 0 });
  i$1(o4, "touchstart", (t2) => {
    l2.current.x = t2.touches[0].clientX, l2.current.y = t2.touches[0].clientY;
  }, true), i$1(o4, "touchend", (t2) => {
    let e2 = { x: t2.changedTouches[0].clientX, y: t2.changedTouches[0].clientY };
    if (!(Math.abs(e2.x - l2.current.x) >= C$1 || Math.abs(e2.y - l2.current.y) >= C$1)) return s2(t2, () => i$4(t2.target) ? t2.target : null);
  }, true), s$2(o4, "blur", (t2) => s2(t2, () => u$a(window.document.activeElement) ? window.document.activeElement : null), true);
}
function u$5(...e2) {
  return useMemo(() => l$5(...e2), [...e2]);
}
var H = ((e2) => (e2[e2.Ignore = 0] = "Ignore", e2[e2.Select = 1] = "Select", e2[e2.Close = 2] = "Close", e2))(H || {});
const S$2 = { Ignore: { kind: 0 }, Select: (r2) => ({ kind: 1, target: r2 }), Close: { kind: 2 } }, M$2 = 200, f$5 = 5;
function L(r2, { trigger: n2, action: T3, close: e2, select: p2 }) {
  let l2 = useRef(null), i2 = useRef(null), u2 = useRef(null);
  i$1(r2 && n2 !== null, "pointerdown", (t2) => {
    o$4(t2 == null ? void 0 : t2.target) && n2 != null && n2.contains(t2.target) && (i2.current = t2.x, u2.current = t2.y, l2.current = t2.timeStamp);
  }), i$1(r2 && n2 !== null, "pointerup", (t2) => {
    var s2, m2;
    let c2 = l2.current;
    if (c2 === null || (l2.current = null, !i$4(t2.target)) || Math.abs(t2.x - ((s2 = i2.current) != null ? s2 : t2.x)) < f$5 && Math.abs(t2.y - ((m2 = u2.current) != null ? m2 : t2.y)) < f$5) return;
    let a3 = T3(t2);
    switch (a3.kind) {
      case 0:
        return;
      case 1: {
        t2.timeStamp - c2 > M$2 && (p2(a3.target), e2());
        break;
      }
      case 2: {
        e2();
        break;
      }
    }
  }, { capture: true });
}
function E(n2, e2, a3, t2) {
  let i2 = s$8(a3);
  useEffect(() => {
    n2 = n2 != null ? n2 : window;
    function r2(o4) {
      i2.current(o4);
    }
    return n2.addEventListener(e2, r2, t2), () => n2.removeEventListener(e2, r2, t2);
  }, [n2, e2, t2]);
}
function v$1(e2) {
  let l2 = useRef({ value: "", selectionStart: null, selectionEnd: null });
  return E(e2, "blur", (n2) => {
    let t2 = n2.target;
    l$2(t2) && (l2.current = { value: t2.value, selectionStart: t2.selectionStart, selectionEnd: t2.selectionEnd });
  }), o$5(() => {
    if (!d$1(e2) && l$2(e2) && e2.isConnected) {
      if (e2.focus({ preventScroll: true }), e2.value !== l2.current.value) e2.setSelectionRange(e2.value.length, e2.value.length);
      else {
        let { selectionStart: n2, selectionEnd: t2 } = l2.current;
        n2 !== null && t2 !== null && e2.setSelectionRange(n2, t2);
      }
      l2.current = { value: "", selectionStart: null, selectionEnd: null };
    }
  });
}
function e$1(t2, u2) {
  return useMemo(() => {
    var n2;
    if (t2.type) return t2.type;
    let r2 = (n2 = t2.as) != null ? n2 : "button";
    if (typeof r2 == "string" && r2.toLowerCase() === "button" || (u2 == null ? void 0 : u2.tagName) === "BUTTON" && !u2.hasAttribute("type")) return "button";
  }, [t2.type, t2.as, u2]);
}
function o3(t2) {
  return useSyncExternalStore(t2.subscribe, t2.getSnapshot, t2.getSnapshot);
}
function a$3(o4, r2) {
  let t2 = o4(), n2 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t2;
  }, subscribe(e2) {
    return n2.add(e2), () => n2.delete(e2);
  }, dispatch(e2, ...s2) {
    let i2 = r2[e2].call(t2, ...s2);
    i2 && (t2 = i2, n2.forEach((c2) => c2()));
  } };
}
function d() {
  let r2;
  return { before({ doc: e2 }) {
    var l2;
    let o4 = e2.documentElement, t2 = (l2 = e2.defaultView) != null ? l2 : window;
    r2 = Math.max(0, t2.innerWidth - o4.clientWidth);
  }, after({ doc: e2, d: o4 }) {
    let t2 = e2.documentElement, l2 = Math.max(0, t2.clientWidth - t2.offsetWidth), n2 = Math.max(0, r2 - l2);
    o4.style(t2, "paddingRight", `${n2}px`);
  } };
}
function w$1() {
  return t$2() ? { before({ doc: o4, d: r2, meta: m2 }) {
    function a3(s2) {
      for (let l2 of m2().containers) for (let c2 of l2()) if (c2.contains(s2)) return true;
      return false;
    }
    r2.microTask(() => {
      var c2;
      if (window.getComputedStyle(o4.documentElement).scrollBehavior !== "auto") {
        let t2 = o$6();
        t2.style(o4.documentElement, "scrollBehavior", "auto"), r2.add(() => r2.microTask(() => t2.dispose()));
      }
      let s2 = (c2 = window.scrollY) != null ? c2 : window.pageYOffset, l2 = null;
      r2.addEventListener(o4, "click", (t2) => {
        if (i$4(t2.target)) try {
          let e2 = t2.target.closest("a");
          if (!e2) return;
          let { hash: n2 } = new URL(e2.href), f2 = o4.querySelector(n2);
          i$4(f2) && !a3(f2) && (l2 = f2);
        } catch {
        }
      }, true), r2.group((t2) => {
        r2.addEventListener(o4, "touchstart", (e2) => {
          if (t2.dispose(), i$4(e2.target) && r$4(e2.target)) if (a3(e2.target)) {
            let n2 = e2.target;
            for (; n2.parentElement && a3(n2.parentElement); ) n2 = n2.parentElement;
            t2.style(n2, "overscrollBehavior", "contain");
          } else t2.style(e2.target, "touchAction", "none");
        });
      }), r2.addEventListener(o4, "touchmove", (t2) => {
        if (i$4(t2.target)) {
          if (l$2(t2.target)) return;
          if (a3(t2.target)) {
            let e2 = t2.target;
            for (; e2.parentElement && e2.dataset.headlessuiPortal !== "" && !(e2.scrollHeight > e2.clientHeight || e2.scrollWidth > e2.clientWidth); ) e2 = e2.parentElement;
            e2.dataset.headlessuiPortal === "" && t2.preventDefault();
          } else t2.preventDefault();
        }
      }, { passive: false }), r2.add(() => {
        var e2;
        let t2 = (e2 = window.scrollY) != null ? e2 : window.pageYOffset;
        s2 !== t2 && window.scrollTo(0, s2), l2 && l2.isConnected && (l2.scrollIntoView({ block: "nearest" }), l2 = null);
      });
    });
  } } : {};
}
function r$1() {
  return { before({ doc: e2, d: o4 }) {
    o4.style(e2.documentElement, "overflow", "hidden");
  } };
}
function r(e2) {
  let o4 = {};
  for (let t2 of e2) Object.assign(o4, t2(o4));
  return o4;
}
let c$6 = a$3(() => /* @__PURE__ */ new Map(), { PUSH(e2, o4) {
  var n2;
  let t2 = (n2 = this.get(e2)) != null ? n2 : { doc: e2, count: 0, d: o$6(), meta: /* @__PURE__ */ new Set(), computedMeta: {} };
  return t2.count++, t2.meta.add(o4), t2.computedMeta = r(t2.meta), this.set(e2, t2), this;
}, POP(e2, o4) {
  let t2 = this.get(e2);
  return t2 && (t2.count--, t2.meta.delete(o4), t2.computedMeta = r(t2.meta)), this;
}, SCROLL_PREVENT(e2) {
  let o4 = { doc: e2.doc, d: e2.d, meta() {
    return e2.computedMeta;
  } }, t2 = [w$1(), d(), r$1()];
  t2.forEach(({ before: n2 }) => n2 == null ? void 0 : n2(o4)), t2.forEach(({ after: n2 }) => n2 == null ? void 0 : n2(o4));
}, SCROLL_ALLOW({ d: e2 }) {
  e2.dispose();
}, TEARDOWN({ doc: e2 }) {
  this.delete(e2);
} });
c$6.subscribe(() => {
  let e2 = c$6.getSnapshot(), o4 = /* @__PURE__ */ new Map();
  for (let [t2] of e2) o4.set(t2, t2.documentElement.style.overflow);
  for (let t2 of e2.values()) {
    let n2 = o4.get(t2.doc) === "hidden", a3 = t2.count !== 0;
    (a3 && !n2 || !a3 && n2) && c$6.dispatch(t2.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t2), t2.count === 0 && c$6.dispatch("TEARDOWN", t2);
  }
});
function a$2(r2, e2, n2 = () => ({ containers: [] })) {
  let f2 = o3(c$6), o$12 = e2 ? f2.get(e2) : void 0, i2 = o$12 ? o$12.count > 0 : false;
  return n$6(() => {
    if (!(!e2 || !r2)) return c$6.dispatch("PUSH", e2, n2), () => c$6.dispatch("POP", e2, n2);
  }, [r2, e2]), i2;
}
function f$4(e2, c2, n2 = () => [document.body]) {
  let r2 = I$3(e2, "scroll-lock");
  a$2(r2, c2, (t2) => {
    var o4;
    return { containers: [...(o4 = t2.containers) != null ? o4 : [], n2] };
  });
}
function t$1(e2) {
  return [e2.screenX, e2.screenY];
}
function u$4() {
  let e2 = useRef([-1, -1]);
  return { wasMoved(r2) {
    let n2 = t$1(r2);
    return e2.current[0] === n2[0] && e2.current[1] === n2[1] ? false : (e2.current = n2, true);
  }, update(r2) {
    e2.current = t$1(r2);
  } };
}
function c$5(u2 = 0) {
  let [r2, a3] = useState(u2), g2 = useCallback((e2) => a3(e2), []), s2 = useCallback((e2) => a3((l2) => l2 | e2), []), m2 = useCallback((e2) => (r2 & e2) === e2, [r2]), n2 = useCallback((e2) => a3((l2) => l2 & ~e2), []), F2 = useCallback((e2) => a3((l2) => l2 ^ e2), []);
  return { flags: r2, setFlag: g2, addFlag: s2, hasFlag: m2, removeFlag: n2, toggleFlag: F2 };
}
var T2, S$1;
typeof process != "undefined" && typeof globalThis != "undefined" && typeof Element != "undefined" && ((T2 = process == null ? void 0 : process.env) == null ? void 0 : T2["NODE_ENV"]) === "test" && typeof ((S$1 = Element == null ? void 0 : Element.prototype) == null ? void 0 : S$1.getAnimations) == "undefined" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var A = ((i2) => (i2[i2.None = 0] = "None", i2[i2.Closed = 1] = "Closed", i2[i2.Enter = 2] = "Enter", i2[i2.Leave = 4] = "Leave", i2))(A || {});
function x(e2) {
  let r2 = {};
  for (let t2 in e2) e2[t2] === true && (r2[`data-${t2}`] = "");
  return r2;
}
function N(e2, r2, t2, n2) {
  let [i2, a3] = useState(t2), { hasFlag: s2, addFlag: o4, removeFlag: l2 } = c$5(e2 && i2 ? 3 : 0), u2 = useRef(false), f2 = useRef(false), E2 = p$6();
  return n$6(() => {
    var d2;
    if (e2) {
      if (t2 && a3(true), !r2) {
        t2 && o4(3);
        return;
      }
      return (d2 = n2 == null ? void 0 : n2.start) == null || d2.call(n2, t2), C(r2, { inFlight: u2, prepare() {
        f2.current ? f2.current = false : f2.current = u2.current, u2.current = true, !f2.current && (t2 ? (o4(3), l2(4)) : (o4(4), l2(2)));
      }, run() {
        f2.current ? t2 ? (l2(3), o4(4)) : (l2(4), o4(3)) : t2 ? l2(1) : o4(1);
      }, done() {
        var p2;
        f2.current && D$3(r2) || (u2.current = false, l2(7), t2 || a3(false), (p2 = n2 == null ? void 0 : n2.end) == null || p2.call(n2, t2));
      } });
    }
  }, [e2, t2, r2, E2]), e2 ? [i2, { closed: s2(1), enter: s2(2), leave: s2(4), transition: s2(2) || s2(4) }] : [t2, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C(e2, { prepare: r2, run: t2, done: n2, inFlight: i2 }) {
  let a3 = o$6();
  return j$2(e2, { prepare: r2, inFlight: i2 }), a3.nextFrame(() => {
    t2(), a3.requestAnimationFrame(() => {
      a3.add(M$1(e2, n2));
    });
  }), a3.dispose;
}
function M$1(e2, r2) {
  var a3, s2;
  let t2 = o$6();
  if (!e2) return t2.dispose;
  let n2 = false;
  t2.add(() => {
    n2 = true;
  });
  let i2 = (s2 = (a3 = e2.getAnimations) == null ? void 0 : a3.call(e2).filter((o4) => o4 instanceof CSSTransition)) != null ? s2 : [];
  return i2.length === 0 ? (r2(), t2.dispose) : (Promise.allSettled(i2.map((o4) => o4.finished)).then(() => {
    n2 || r2();
  }), t2.dispose);
}
function j$2(e2, { inFlight: r2, prepare: t2 }) {
  if (r2 != null && r2.current) {
    t2();
    return;
  }
  let n2 = e2.style.transition;
  e2.style.transition = "none", t2(), e2.offsetHeight, e2.style.transition = n2;
}
function D$3(e2) {
  var t2, n2;
  return ((n2 = (t2 = e2.getAnimations) == null ? void 0 : t2.call(e2)) != null ? n2 : []).some((i2) => i2 instanceof CSSTransition && i2.playState !== "finished");
}
function F(c2, { container: e2, accept: t2, walk: r2 }) {
  let o4 = useRef(t2), l2 = useRef(r2);
  useEffect(() => {
    o4.current = t2, l2.current = r2;
  }, [t2, r2]), n$6(() => {
    if (!e2 || !c2) return;
    let n2 = l$5(e2);
    if (!n2) return;
    let f2 = o4.current, p2 = l2.current, i2 = Object.assign((m2) => f2(m2), { acceptNode: f2 }), u2 = n2.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, i2, false);
    for (; u2.nextNode(); ) p2(u2.currentNode);
  }, [e2, c2, o4, l2]);
}
function m$1(u2, t2) {
  let e2 = useRef([]), r2 = o$5(u2);
  useEffect(() => {
    let o4 = [...e2.current];
    for (let [a3, l2] of t2.entries()) if (e2.current[a3] !== l2) {
      let n2 = r2(t2, o4);
      return e2.current = t2, n2;
    }
  }, [r2, ...t2]);
}
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    var _platform$detectOverf;
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: {
        ...platform2,
        detectOverflow: (_platform$detectOverf = platform2.detectOverflow) != null ? _platform$detectOverf : detectOverflow$1
      },
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d2) => getSideAxis(d2.placement) === initialSideAxis ? d2.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a3, b2) => a3.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        platform: platform2
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await platform2.detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
    y: rect.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html2 = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html2 = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html2);
  if (windowScrollbarX <= 0) {
    const doc = html2.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html2.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x2 = left * scale2.x;
  const y2 = top * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a3, b2) {
  return a3.x === b2.x && a3.y === b2.y && a3.width === b2.width && a3.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const detectOverflow = detectOverflow$1;
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index$1 = isClient ? useLayoutEffect : noop;
function deepEqual(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  if (typeof a3 !== typeof b2) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a3 && b2 && typeof a3 === "object") {
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length !== b2.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a3[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const SafeReact = {
  ...React
};
const useInsertionEffect = SafeReact.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React.useRef(() => {
    if (process.env.NODE_ENV !== "production") {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index = typeof document !== "undefined" ? useLayoutEffect : useEffect;
let serverHandoffComplete = false;
let count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id2, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id2 == null) {
      setId(genId());
    }
  }, []);
  React.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id2;
}
const useReactId = SafeReact.useId;
const useId = useReactId || useFloatingId;
let devMessageSet;
if (process.env.NODE_ENV !== "production") {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message2 = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message2))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message2);
    console.warn(message2);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message2 = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message2))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message2);
    console.error(message2);
  }
}
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ React.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => React.useContext(FloatingTreeContext);
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(options) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId();
  const dataRef = React.useRef({});
  const [events] = React.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  if (process.env.NODE_ENV !== "production") {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = React.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React.useState(null);
  const [positionReference, _setPositionReference] = React.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating$1({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = React.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
const ACTIVE_KEY = "active";
const SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _2,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
const inner = (props) => ({
  name: "inner",
  options: props,
  async fn(state) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index: index2 = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      scrollRef,
      ...detectOverflowOptions
    } = evaluate(props, state);
    const {
      rects,
      elements: {
        floating
      }
    } = state;
    const item = listRef.current[index2];
    const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;
    const clientTop = floating.clientTop || scrollEl.clientTop;
    const floatingIsBordered = floating.clientTop !== 0;
    const scrollElIsBordered = scrollEl.clientTop !== 0;
    const floatingIsScrollEl = floating === scrollEl;
    if (process.env.NODE_ENV !== "production") {
      if (!state.placement.startsWith("bottom")) {
        warn('`placement` side must be "bottom" when using the `inner`', "middleware.");
      }
    }
    if (!item) {
      return {};
    }
    const nextArgs = {
      ...state,
      ...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
    };
    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);
    const refOverflow = await detectOverflow(nextArgs, {
      ...detectOverflowOptions,
      elementContext: "reference"
    });
    const diffY = max(0, overflow.top);
    const nextY = nextArgs.y + diffY;
    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;
    const rounder = isScrollable ? (v2) => v2 : round;
    const maxHeight = rounder(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
    scrollEl.style.maxHeight = maxHeight + "px";
    scrollEl.scrollTop = diffY;
    if (onFallbackChange) {
      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
      ReactDOM.flushSync(() => onFallbackChange(shouldFallback));
    }
    if (overflowRef) {
      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({
        ...nextArgs,
        y: nextY
      }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);
    }
    return {
      y: nextY
    };
  }
});
function useInnerOffset(context, props) {
  const {
    open,
    elements
  } = context;
  const {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props;
  const onChange = useEffectEvent(unstable_onChange);
  const controlledScrollingRef = React.useRef(false);
  const prevScrollTopRef = React.useRef(null);
  const initialOverflowRef = React.useRef(null);
  React.useEffect(() => {
    if (!enabled) return;
    function onWheel(e2) {
      if (e2.ctrlKey || !el || overflowRef.current == null) {
        return;
      }
      const dY = e2.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el.scrollHeight - el.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? "max" : "min";
      if (el.scrollHeight <= el.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e2.preventDefault();
        ReactDOM.flushSync(() => {
          onChange((d2) => d2 + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        el.scrollTop += dY;
      }
    }
    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el) {
      el.addEventListener("wheel", onWheel);
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el.removeEventListener("wheel", onWheel);
      };
    }
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
  const floating = React.useMemo(() => ({
    onKeyDown() {
      controlledScrollingRef.current = true;
    },
    onWheel() {
      controlledScrollingRef.current = false;
    },
    onPointerMove() {
      controlledScrollingRef.current = false;
    },
    onScroll() {
      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
      if (!overflowRef.current || !el || !controlledScrollingRef.current) {
        return;
      }
      if (prevScrollTopRef.current !== null) {
        const scrollDiff = el.scrollTop - prevScrollTopRef.current;
        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
          ReactDOM.flushSync(() => onChange((d2) => d2 + scrollDiff));
        }
      }
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el.scrollTop;
      });
    }
  }), [elements.floating, onChange, overflowRef, scrollRef]);
  return React.useMemo(() => enabled ? {
    floating
  } : {}, [enabled, floating]);
}
let y$1 = createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$1.displayName = "FloatingContext";
let $ = createContext(null);
$.displayName = "PlacementContext";
function ye(e2) {
  return useMemo(() => e2 ? typeof e2 == "string" ? { to: e2 } : e2 : null, [e2]);
}
function Fe$1() {
  return useContext(y$1).setReference;
}
function Te$1() {
  let { getFloatingProps: e2, slot: t2 } = useContext(y$1);
  return useCallback((...n2) => Object.assign({}, e2(...n2), { "data-anchor": t2.anchor }), [e2, t2]);
}
function Re(e2 = null) {
  e2 === false && (e2 = null), typeof e2 == "string" && (e2 = { to: e2 });
  let t2 = useContext($), n2 = useMemo(() => e2, [JSON.stringify(e2, (l2, o4) => {
    var u2;
    return (u2 = o4 == null ? void 0 : o4.outerHTML) != null ? u2 : o4;
  })]);
  n$6(() => {
    t2 == null || t2(n2 != null ? n2 : null);
  }, [t2, n2]);
  let r2 = useContext(y$1);
  return useMemo(() => [r2.setFloating, e2 ? r2.styles : {}], [r2.setFloating, e2, r2.styles]);
}
let D$2 = 4;
function Ae$1({ children: e2, enabled: t2 = true }) {
  let [n2, r2] = useState(null), [l2, o4] = useState(0), u2 = useRef(null), [f2, s2] = useState(null);
  ce(f2);
  let i2 = t2 && n2 !== null && f2 !== null, { to: F2 = "bottom", gap: E2 = 0, offset: A2 = 0, padding: c2 = 0, inner: h2 } = ge(n2, f2), [a3, p2 = "center"] = F2.split(" ");
  n$6(() => {
    i2 && o4(0);
  }, [i2]);
  let { refs: b2, floatingStyles: S2, context: g2 } = useFloating({ open: i2, placement: a3 === "selection" ? p2 === "center" ? "bottom" : `bottom-${p2}` : p2 === "center" ? `${a3}` : `${a3}-${p2}`, strategy: "absolute", transform: false, middleware: [offset({ mainAxis: a3 === "selection" ? 0 : E2, crossAxis: A2 }), shift({ padding: c2 }), a3 !== "selection" && flip({ padding: c2 }), a3 === "selection" && h2 ? inner({ ...h2, padding: c2, overflowRef: u2, offset: l2, minItemsVisible: D$2, referenceOverflowThreshold: c2, onFallbackChange(P2) {
    var L2, N2;
    if (!P2) return;
    let d2 = g2.elements.floating;
    if (!d2) return;
    let M2 = parseFloat(getComputedStyle(d2).scrollPaddingBottom) || 0, I2 = Math.min(D$2, d2.childElementCount), W2 = 0, B = 0;
    for (let m2 of (N2 = (L2 = g2.elements.floating) == null ? void 0 : L2.childNodes) != null ? N2 : []) if (n$4(m2)) {
      let x2 = m2.offsetTop, k2 = x2 + m2.clientHeight + M2, H2 = d2.scrollTop, U2 = H2 + d2.clientHeight;
      if (x2 >= H2 && k2 <= U2) I2--;
      else {
        B = Math.max(0, Math.min(k2, U2) - Math.max(x2, H2)), W2 = m2.clientHeight;
        break;
      }
    }
    I2 >= 1 && o4((m2) => {
      let x2 = W2 * I2 - B + M2;
      return m2 >= x2 ? m2 : x2;
    });
  } }) : null, size({ padding: c2, apply({ availableWidth: P2, availableHeight: d2, elements: M2 }) {
    Object.assign(M2.floating.style, { overflow: "auto", maxWidth: `${P2}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${d2}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [w2 = a3, V2 = p2] = g2.placement.split("-");
  a3 === "selection" && (w2 = "selection");
  let G2 = useMemo(() => ({ anchor: [w2, V2].filter(Boolean).join(" ") }), [w2, V2]), K2 = useInnerOffset(g2, { overflowRef: u2, onChange: o4 }), { getReferenceProps: Q, getFloatingProps: X2 } = useInteractions([K2]), Y2 = o$5((P2) => {
    s2(P2), b2.setFloating(P2);
  });
  return React.createElement($.Provider, { value: r2 }, React.createElement(y$1.Provider, { value: { setFloating: Y2, setReference: b2.setReference, styles: S2, getReferenceProps: Q, getFloatingProps: X2, slot: G2 } }, e2));
}
function ce(e2) {
  n$6(() => {
    if (!e2) return;
    let t2 = new MutationObserver(() => {
      let n2 = window.getComputedStyle(e2).maxHeight, r2 = parseFloat(n2);
      if (isNaN(r2)) return;
      let l2 = parseInt(n2);
      isNaN(l2) || r2 !== l2 && (e2.style.maxHeight = `${Math.ceil(r2)}px`);
    });
    return t2.observe(e2, { attributes: true, attributeFilter: ["style"] }), () => {
      t2.disconnect();
    };
  }, [e2]);
}
function ge(e2, t2) {
  var o4, u2, f2;
  let n2 = O((o4 = e2 == null ? void 0 : e2.gap) != null ? o4 : "var(--anchor-gap, 0)", t2), r2 = O((u2 = e2 == null ? void 0 : e2.offset) != null ? u2 : "var(--anchor-offset, 0)", t2), l2 = O((f2 = e2 == null ? void 0 : e2.padding) != null ? f2 : "var(--anchor-padding, 0)", t2);
  return { ...e2, gap: n2, offset: r2, padding: l2 };
}
function O(e2, t2, n2 = void 0) {
  let r2 = p$6(), l2 = o$5((s2, i2) => {
    if (s2 == null) return [n2, null];
    if (typeof s2 == "number") return [s2, null];
    if (typeof s2 == "string") {
      if (!i2) return [n2, null];
      let F2 = J$1(s2, i2);
      return [F2, (E2) => {
        let A2 = q(s2);
        {
          let c2 = A2.map((h2) => window.getComputedStyle(i2).getPropertyValue(h2));
          r2.requestAnimationFrame(function h2() {
            r2.nextFrame(h2);
            let a3 = false;
            for (let [b2, S2] of A2.entries()) {
              let g2 = window.getComputedStyle(i2).getPropertyValue(S2);
              if (c2[b2] !== g2) {
                c2[b2] = g2, a3 = true;
                break;
              }
            }
            if (!a3) return;
            let p2 = J$1(s2, i2);
            F2 !== p2 && (E2(p2), F2 = p2);
          });
        }
        return r2.dispose;
      }];
    }
    return [n2, null];
  }), o4 = useMemo(() => l2(e2, t2)[0], [e2, t2]), [u2 = o4, f2] = useState();
  return n$6(() => {
    let [s2, i2] = l2(e2, t2);
    if (f2(s2), !!i2) return i2(f2);
  }, [e2, t2]), u2;
}
function q(e2) {
  let t2 = /var\((.*)\)/.exec(e2);
  if (t2) {
    let n2 = t2[1].indexOf(",");
    if (n2 === -1) return [t2[1]];
    let r2 = t2[1].slice(0, n2).trim(), l2 = t2[1].slice(n2 + 1).trim();
    return l2 ? [r2, ...q(l2)] : [r2];
  }
  return [];
}
function J$1(e2, t2) {
  let n2 = document.createElement("div");
  t2.appendChild(n2), n2.style.setProperty("margin-top", "0px", "important"), n2.style.setProperty("margin-top", e2, "important");
  let r2 = parseFloat(window.getComputedStyle(n2).marginTop) || 0;
  return t2.removeChild(n2), r2;
}
function f$3({ children: t2, freeze: e2 }, o4) {
  let n2 = u$3(e2, t2);
  return isValidElement(n2) ? cloneElement(n2, { ref: o4 }) : React__default.createElement(React__default.Fragment, null, n2);
}
const s$1 = React__default.forwardRef(f$3);
function u$3(t2, e2) {
  let [o4, n2] = useState(e2);
  return !t2 && o4 !== e2 && n2(e2), t2 ? o4 : e2;
}
let n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var i = ((e2) => (e2[e2.Open = 1] = "Open", e2[e2.Closed = 2] = "Closed", e2[e2.Closing = 4] = "Closing", e2[e2.Opening = 8] = "Opening", e2))(i || {});
function u$2() {
  return useContext(n$1);
}
function c$4({ value: o4, children: t2 }) {
  return React__default.createElement(n$1.Provider, { value: o4 }, t2);
}
function t(n2) {
  function e2() {
    document.readyState !== "loading" && (n2(), document.removeEventListener("DOMContentLoaded", e2));
  }
  typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e2), e2());
}
let n = [];
t(() => {
  function e2(t2) {
    if (!i$4(t2.target) || t2.target === document.body || n[0] === t2.target) return;
    let r2 = t2.target;
    r2 = r2.closest(E$1), n.unshift(r2 != null ? r2 : t2.target), n = n.filter((o4) => o4 != null && o4.isConnected), n.splice(10);
  }
  window.addEventListener("click", e2, { capture: true }), window.addEventListener("mousedown", e2, { capture: true }), window.addEventListener("focus", e2, { capture: true }), document.body.addEventListener("click", e2, { capture: true }), document.body.addEventListener("mousedown", e2, { capture: true }), document.body.addEventListener("focus", e2, { capture: true });
});
function u$1(l2) {
  throw new Error("Unexpected object: " + l2);
}
var c$3 = ((i2) => (i2[i2.First = 0] = "First", i2[i2.Previous = 1] = "Previous", i2[i2.Next = 2] = "Next", i2[i2.Last = 3] = "Last", i2[i2.Specific = 4] = "Specific", i2[i2.Nothing = 5] = "Nothing", i2))(c$3 || {});
function f$2(l2, n2) {
  let t2 = n2.resolveItems();
  if (t2.length <= 0) return null;
  let r2 = n2.resolveActiveIndex(), s2 = r2 != null ? r2 : -1;
  switch (l2.focus) {
    case 0: {
      for (let e2 = 0; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 1: {
      s2 === -1 && (s2 = t2.length);
      for (let e2 = s2 - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 2: {
      for (let e2 = s2 + 1; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 3: {
      for (let e2 = t2.length - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;
      return r2;
    }
    case 4: {
      for (let e2 = 0; e2 < t2.length; ++e2) if (n2.resolveId(t2[e2], e2, t2) === l2.id) return e2;
      return r2;
    }
    case 5:
      return null;
    default:
      u$1(l2);
  }
}
function c$2(t2) {
  let r2 = o$5(t2), e2 = useRef(false);
  useEffect(() => (e2.current = false, () => {
    e2.current = true, t$5(() => {
      e2.current && r2();
    });
  }), [r2]);
}
let e = createContext(false);
function a$1() {
  return useContext(e);
}
function W(e2) {
  let o4 = a$1(), l2 = useContext(c$1), [r2, p2] = useState(() => {
    var s2;
    if (!o4 && l2 !== null) return (s2 = l2.current) != null ? s2 : null;
    if (s$9.isServer) return null;
    let t2 = e2 == null ? void 0 : e2.getElementById("headlessui-portal-root");
    if (t2) return t2;
    if (e2 === null) return null;
    let n2 = e2.createElement("div");
    return n2.setAttribute("id", "headlessui-portal-root"), e2.body.appendChild(n2);
  });
  return useEffect(() => {
    r2 !== null && (e2 != null && e2.body.contains(r2) || e2 == null || e2.body.appendChild(r2));
  }, [r2, e2]), useEffect(() => {
    o4 || l2 !== null && p2(l2.current);
  }, [l2, p2, o4]), r2;
}
let _$1 = Fragment, j$1 = Y(function(o4, l2) {
  let { ownerDocument: r2 = null, ...p2 } = o4, t2 = useRef(null), n2 = y$4(T$3((a3) => {
    t2.current = a3;
  }), l2), s2 = u$5(t2.current), C2 = r2 != null ? r2 : s2, u2 = W(C2), y2 = useContext(m), g2 = p$6(), v2 = K();
  return c$2(() => {
    var a3;
    u2 && u2.childNodes.length <= 0 && ((a3 = u2.parentElement) == null || a3.removeChild(u2));
  }), u2 ? createPortal(React__default.createElement("div", { "data-headlessui-portal": "", ref: (a3) => {
    g2.dispose(), y2 && a3 && g2.add(y2.register(a3));
  } }, v2({ ourProps: { ref: n2 }, theirProps: p2, slot: {}, defaultTag: _$1, name: "Portal" })), u2) : null;
});
function S(e2, o4) {
  let l2 = y$4(o4), { enabled: r2 = true, ownerDocument: p2, ...t2 } = e2, n2 = K();
  return r2 ? React__default.createElement(j$1, { ...t2, ownerDocument: p2, ref: l2 }) : n2({ ourProps: { ref: l2 }, theirProps: t2, slot: {}, defaultTag: _$1, name: "Portal" });
}
let I$1 = Fragment, c$1 = createContext(null);
function D$1(e2, o4) {
  let { target: l2, ...r2 } = e2, t2 = { ref: y$4(o4) }, n2 = K();
  return React__default.createElement(c$1.Provider, { value: l2 }, n2({ ourProps: t2, theirProps: r2, defaultTag: I$1, name: "Popover.Group" }));
}
let m = createContext(null);
let J = Y(S), X$1 = Y(D$1), te$1 = Object.assign(J, { Group: X$1 });
const c = { Idle: { kind: "Idle" }, Tracked: (e2) => ({ kind: "Tracked", position: e2 }), Moved: { kind: "Moved" } };
function a2(e2) {
  let t2 = e2.getBoundingClientRect();
  return `${t2.x},${t2.y}`;
}
function p$1(e2, t2, i2) {
  let n2 = o$6();
  if (t2.kind === "Tracked") {
    let o4 = function() {
      d2 !== a2(e2) && (n2.dispose(), i2());
    };
    let { position: d2 } = t2, s2 = new ResizeObserver(o4);
    s2.observe(e2), n2.add(() => s2.disconnect()), n2.addEventListener(window, "scroll", o4, { passive: true }), n2.addEventListener(window, "resize", o4);
  }
  return () => n2.dispose();
}
var I = Object.defineProperty;
var h = (t2, i2, e2) => i2 in t2 ? I(t2, i2, { enumerable: true, configurable: true, writable: true, value: e2 }) : t2[i2] = e2;
var f$1 = (t2, i2, e2) => (h(t2, typeof i2 != "symbol" ? i2 + "" : i2, e2), e2);
var P = ((e2) => (e2[e2.Open = 0] = "Open", e2[e2.Closed = 1] = "Closed", e2))(P || {}), k = ((e2) => (e2[e2.Single = 0] = "Single", e2[e2.Multi = 1] = "Multi", e2))(k || {}), _ = ((n2) => (n2[n2.Pointer = 0] = "Pointer", n2[n2.Focus = 1] = "Focus", n2[n2.Other = 2] = "Other", n2))(_ || {}), D = ((l2) => (l2[l2.OpenCombobox = 0] = "OpenCombobox", l2[l2.CloseCombobox = 1] = "CloseCombobox", l2[l2.GoToOption = 2] = "GoToOption", l2[l2.SetTyping = 3] = "SetTyping", l2[l2.RegisterOption = 4] = "RegisterOption", l2[l2.UnregisterOption = 5] = "UnregisterOption", l2[l2.DefaultToFirstOption = 6] = "DefaultToFirstOption", l2[l2.SetActivationTrigger = 7] = "SetActivationTrigger", l2[l2.UpdateVirtualConfiguration = 8] = "UpdateVirtualConfiguration", l2[l2.SetInputElement = 9] = "SetInputElement", l2[l2.SetButtonElement = 10] = "SetButtonElement", l2[l2.SetOptionsElement = 11] = "SetOptionsElement", l2[l2.MarkInputAsMoved = 12] = "MarkInputAsMoved", l2))(D || {});
function v(t2, i2 = (e2) => e2) {
  let e2 = t2.activeOptionIndex !== null ? t2.options[t2.activeOptionIndex] : null, n2 = i2(t2.options.slice()), o4 = n2.length > 0 && n2[0].dataRef.current.order !== null ? n2.sort((u2, a3) => u2.dataRef.current.order - a3.dataRef.current.order) : G(n2, (u2) => u2.dataRef.current.domRef.current), r2 = e2 ? o4.indexOf(e2) : null;
  return r2 === -1 && (r2 = null), { options: o4, activeOptionIndex: r2 };
}
let j = { [1](t2) {
  var e2;
  if ((e2 = t2.dataRef.current) != null && e2.disabled || t2.comboboxState === 1) return t2;
  let i2 = t2.inputElement ? c.Tracked(a2(t2.inputElement)) : t2.inputPositionState;
  return { ...t2, activeOptionIndex: null, comboboxState: 1, isTyping: false, activationTrigger: 2, inputPositionState: i2, __demoMode: false };
}, [0](t2) {
  var i2, e2;
  if ((i2 = t2.dataRef.current) != null && i2.disabled || t2.comboboxState === 0) return t2;
  if ((e2 = t2.dataRef.current) != null && e2.value) {
    let n2 = t2.dataRef.current.calculateIndex(t2.dataRef.current.value);
    if (n2 !== -1) return { ...t2, activeOptionIndex: n2, comboboxState: 0, __demoMode: false, inputPositionState: c.Idle };
  }
  return { ...t2, comboboxState: 0, inputPositionState: c.Idle, __demoMode: false };
}, [3](t2, i2) {
  return t2.isTyping === i2.isTyping ? t2 : { ...t2, isTyping: i2.isTyping };
}, [2](t2, i2) {
  var r2, u2, a3, s2;
  if ((r2 = t2.dataRef.current) != null && r2.disabled || t2.optionsElement && !((u2 = t2.dataRef.current) != null && u2.optionsPropsRef.current.static) && t2.comboboxState === 1) return t2;
  if (t2.virtual) {
    let { options: p2, disabled: c2 } = t2.virtual, m2 = i2.focus === c$3.Specific ? i2.idx : f$2(i2, { resolveItems: () => p2, resolveActiveIndex: () => {
      var l2, x2;
      return (x2 = (l2 = t2.activeOptionIndex) != null ? l2 : p2.findIndex((S2) => !c2(S2))) != null ? x2 : null;
    }, resolveDisabled: c2, resolveId() {
      throw new Error("Function not implemented.");
    } }), b2 = (a3 = i2.trigger) != null ? a3 : 2;
    return t2.activeOptionIndex === m2 && t2.activationTrigger === b2 ? t2 : { ...t2, activeOptionIndex: m2, activationTrigger: b2, isTyping: false, __demoMode: false };
  }
  let e2 = v(t2);
  if (e2.activeOptionIndex === null) {
    let p2 = e2.options.findIndex((c2) => !c2.dataRef.current.disabled);
    p2 !== -1 && (e2.activeOptionIndex = p2);
  }
  let n2 = i2.focus === c$3.Specific ? i2.idx : f$2(i2, { resolveItems: () => e2.options, resolveActiveIndex: () => e2.activeOptionIndex, resolveId: (p2) => p2.id, resolveDisabled: (p2) => p2.dataRef.current.disabled }), o4 = (s2 = i2.trigger) != null ? s2 : 2;
  return t2.activeOptionIndex === n2 && t2.activationTrigger === o4 ? t2 : { ...t2, ...e2, isTyping: false, activeOptionIndex: n2, activationTrigger: o4, __demoMode: false };
}, [4]: (t2, i2) => {
  var r2, u2, a3, s2;
  if ((r2 = t2.dataRef.current) != null && r2.virtual) return { ...t2, options: [...t2.options, i2.payload] };
  let e2 = i2.payload, n2 = v(t2, (p2) => (p2.push(e2), p2));
  t2.activeOptionIndex === null && (a3 = (u2 = t2.dataRef.current).isSelected) != null && a3.call(u2, i2.payload.dataRef.current.value) && (n2.activeOptionIndex = n2.options.indexOf(e2));
  let o4 = { ...t2, ...n2, activationTrigger: 2 };
  return (s2 = t2.dataRef.current) != null && s2.__demoMode && t2.dataRef.current.value === void 0 && (o4.activeOptionIndex = 0), o4;
}, [5]: (t2, i2) => {
  var n2;
  if ((n2 = t2.dataRef.current) != null && n2.virtual) return { ...t2, options: t2.options.filter((o4) => o4.id !== i2.id) };
  let e2 = v(t2, (o4) => {
    let r2 = o4.findIndex((u2) => u2.id === i2.id);
    return r2 !== -1 && o4.splice(r2, 1), o4;
  });
  return { ...t2, ...e2, activationTrigger: 2 };
}, [6]: (t2, i2) => t2.defaultToFirstOption === i2.value ? t2 : { ...t2, defaultToFirstOption: i2.value }, [7]: (t2, i2) => t2.activationTrigger === i2.trigger ? t2 : { ...t2, activationTrigger: i2.trigger }, [8]: (t2, i2) => {
  var n2, o4;
  if (t2.virtual === null) return { ...t2, virtual: { options: i2.options, disabled: (n2 = i2.disabled) != null ? n2 : () => false } };
  if (t2.virtual.options === i2.options && t2.virtual.disabled === i2.disabled) return t2;
  let e2 = t2.activeOptionIndex;
  if (t2.activeOptionIndex !== null) {
    let r2 = i2.options.indexOf(t2.virtual.options[t2.activeOptionIndex]);
    r2 !== -1 ? e2 = r2 : e2 = null;
  }
  return { ...t2, activeOptionIndex: e2, virtual: { options: i2.options, disabled: (o4 = i2.disabled) != null ? o4 : () => false } };
}, [9]: (t2, i2) => t2.inputElement === i2.element ? t2 : { ...t2, inputElement: i2.element }, [10]: (t2, i2) => t2.buttonElement === i2.element ? t2 : { ...t2, buttonElement: i2.element }, [11]: (t2, i2) => t2.optionsElement === i2.element ? t2 : { ...t2, optionsElement: i2.element }, [12](t2) {
  return t2.inputPositionState.kind !== "Tracked" ? t2 : { ...t2, inputPositionState: c.Moved };
} };
class y extends T$2 {
  constructor(e2) {
    super(e2);
    f$1(this, "actions", { onChange: (e3) => {
      let { onChange: n2, compare: o4, mode: r2, value: u2 } = this.state.dataRef.current;
      return u$c(r2, { [0]: () => n2 == null ? void 0 : n2(e3), [1]: () => {
        let a3 = u2.slice(), s2 = a3.findIndex((p2) => o4(p2, e3));
        return s2 === -1 ? a3.push(e3) : a3.splice(s2, 1), n2 == null ? void 0 : n2(a3);
      } });
    }, registerOption: (e3, n2) => (this.send({ type: 4, payload: { id: e3, dataRef: n2 } }), () => {
      this.state.activeOptionIndex === this.state.dataRef.current.calculateIndex(n2.current.value) && this.send({ type: 6, value: true }), this.send({ type: 5, id: e3 });
    }), goToOption: (e3, n2) => (this.send({ type: 6, value: false }), this.send({ type: 2, ...e3, trigger: n2 })), setIsTyping: (e3) => {
      this.send({ type: 3, isTyping: e3 });
    }, closeCombobox: () => {
      var e3, n2;
      this.send({ type: 1 }), this.send({ type: 6, value: false }), (n2 = (e3 = this.state.dataRef.current).onClose) == null || n2.call(e3);
    }, openCombobox: () => {
      this.send({ type: 0 }), this.send({ type: 6, value: true });
    }, setActivationTrigger: (e3) => {
      this.send({ type: 7, trigger: e3 });
    }, selectActiveOption: () => {
      let e3 = this.selectors.activeOptionIndex(this.state);
      if (e3 !== null) {
        if (this.actions.setIsTyping(false), this.state.virtual) this.actions.onChange(this.state.virtual.options[e3]);
        else {
          let { dataRef: n2 } = this.state.options[e3];
          this.actions.onChange(n2.current.value);
        }
        this.actions.goToOption({ focus: c$3.Specific, idx: e3 });
      }
    }, setInputElement: (e3) => {
      this.send({ type: 9, element: e3 });
    }, setButtonElement: (e3) => {
      this.send({ type: 10, element: e3 });
    }, setOptionsElement: (e3) => {
      this.send({ type: 11, element: e3 });
    } });
    f$1(this, "selectors", { activeDescendantId: (e3) => {
      var o4, r2;
      let n2 = this.selectors.activeOptionIndex(e3);
      if (n2 !== null) return e3.virtual ? (r2 = e3.options.find((u2) => !u2.dataRef.current.disabled && e3.dataRef.current.compare(u2.dataRef.current.value, e3.virtual.options[n2]))) == null ? void 0 : r2.id : (o4 = e3.options[n2]) == null ? void 0 : o4.id;
    }, activeOptionIndex: (e3) => {
      if (e3.defaultToFirstOption && e3.activeOptionIndex === null && (e3.virtual ? e3.virtual.options.length > 0 : e3.options.length > 0)) {
        if (e3.virtual) {
          let { options: o4, disabled: r2 } = e3.virtual, u2 = o4.findIndex((a3) => {
            var s2;
            return !((s2 = r2 == null ? void 0 : r2(a3)) != null && s2);
          });
          if (u2 !== -1) return u2;
        }
        let n2 = e3.options.findIndex((o4) => !o4.dataRef.current.disabled);
        if (n2 !== -1) return n2;
      }
      return e3.activeOptionIndex;
    }, activeOption: (e3) => {
      var o4, r2;
      let n2 = this.selectors.activeOptionIndex(e3);
      return n2 === null ? null : e3.virtual ? e3.virtual.options[n2 != null ? n2 : 0] : (r2 = (o4 = e3.options[n2]) == null ? void 0 : o4.dataRef.current.value) != null ? r2 : null;
    }, isActive: (e3, n2, o4) => {
      var u2;
      let r2 = this.selectors.activeOptionIndex(e3);
      return r2 === null ? false : e3.virtual ? r2 === e3.dataRef.current.calculateIndex(n2) : ((u2 = e3.options[r2]) == null ? void 0 : u2.id) === o4;
    }, shouldScrollIntoView: (e3, n2, o4) => !(e3.virtual || e3.__demoMode || e3.comboboxState !== 0 || e3.activationTrigger === 0 || !this.selectors.isActive(e3, n2, o4)), didInputMove(e3) {
      return e3.inputPositionState.kind === "Moved";
    } });
    {
      let n2 = this.state.id, o4 = x$1.get(null);
      this.disposables.add(o4.on(k$2.Push, (r2) => {
        !o4.selectors.isTop(r2, n2) && this.state.comboboxState === 0 && this.actions.closeCombobox();
      })), this.on(0, () => o4.actions.push(n2)), this.on(1, () => o4.actions.pop(n2));
    }
    this.disposables.group((n2) => {
      this.on(1, (o4) => {
        o4.inputElement && (n2.dispose(), n2.add(p$1(o4.inputElement, o4.inputPositionState, () => {
          this.send({ type: 12 });
        })));
      });
    });
  }
  static new({ id: e2, virtual: n2 = null, __demoMode: o4 = false }) {
    var r2;
    return new y({ id: e2, dataRef: { current: {} }, comboboxState: o4 ? 0 : 1, isTyping: false, options: [], virtual: n2 ? { options: n2.options, disabled: (r2 = n2.disabled) != null ? r2 : () => false } : null, activeOptionIndex: null, activationTrigger: 2, inputElement: null, buttonElement: null, optionsElement: null, __demoMode: o4, inputPositionState: c.Idle });
  }
  reduce(e2, n2) {
    return u$c(n2.type, j, e2, n2);
  }
}
const u = createContext(null);
function p(n2) {
  let o4 = useContext(u);
  if (o4 === null) {
    let e2 = new Error(`<${n2} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e2, b), e2;
  }
  return o4;
}
function b({ id: n2, virtual: o4 = null, __demoMode: e2 = false }) {
  let t2 = useMemo(() => y.new({ id: n2, virtual: o4, __demoMode: e2 }), []);
  return c$2(() => t2.dispose()), t2;
}
let de$1 = createContext(null);
de$1.displayName = "ComboboxDataContext";
function te(T3) {
  let O2 = useContext(de$1);
  if (O2 === null) {
    let e2 = new Error(`<${T3} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e2, te), e2;
  }
  return O2;
}
let Le$1 = createContext(null);
function Eo(T3) {
  let O2 = p("VirtualProvider"), e2 = te("VirtualProvider"), { options: o4 } = e2.virtual, E2 = S$3(O2, (a3) => a3.optionsElement), [R, y2] = useMemo(() => {
    let a3 = E2;
    if (!a3) return [0, 0];
    let u2 = window.getComputedStyle(a3);
    return [parseFloat(u2.paddingBlockStart || u2.paddingTop), parseFloat(u2.paddingBlockEnd || u2.paddingBottom)];
  }, [E2]), b2 = useVirtualizer({ enabled: o4.length !== 0, scrollPaddingStart: R, scrollPaddingEnd: y2, count: o4.length, estimateSize() {
    return 40;
  }, getScrollElement() {
    return O2.state.optionsElement;
  }, overscan: 12 }), [h2, p$12] = useState(0);
  n$6(() => {
    p$12((a3) => a3 + 1);
  }, [o4]);
  let f2 = b2.getVirtualItems(), n2 = S$3(O2, (a3) => a3.activationTrigger === _.Pointer), m2 = S$3(O2, O2.selectors.activeOptionIndex);
  return f2.length === 0 ? null : React__default.createElement(Le$1.Provider, { value: b2 }, React__default.createElement("div", { style: { position: "relative", width: "100%", height: `${b2.getTotalSize()}px` }, ref: (a3) => {
    a3 && (n2 || m2 !== null && o4.length > m2 && b2.scrollToIndex(m2));
  } }, f2.map((a3) => {
    var u2;
    return React__default.createElement(Fragment, { key: a3.key }, React__default.cloneElement((u2 = T3.children) == null ? void 0 : u2.call(T3, { ...T3.slot, option: o4[a3.index] }), { key: `${h2}-${a3.key}`, "data-index": a3.index, "aria-setsize": o4.length, "aria-posinset": a3.index + 1, style: { position: "absolute", top: 0, left: 0, transform: `translateY(${a3.start}px)`, overflowAnchor: "none" } }));
  })));
}
let ho = Fragment;
function Ao(T3, O2) {
  let e2 = useId$1(), o4 = a$a(), { value: E2, defaultValue: R, onChange: y2, form: b$12, name: h2, by: p2, invalid: f2 = false, disabled: n2 = o4 || false, onClose: m2, __demoMode: a3 = false, multiple: u$12 = false, immediate: A2 = false, virtual: d2 = null, nullable: X2, ...G2 } = T3, C2 = l$4(R), [x2 = u$12 ? [] : void 0, v2] = b$2(E2, y2, C2), c2 = b({ id: e2, virtual: d2, __demoMode: a3 }), z = useRef({ static: false, hold: false }), D$12 = u$8(p2), K$1 = o$5((i2) => d2 ? p2 === null ? d2.options.indexOf(i2) : d2.options.findIndex((M2) => D$12(M2, i2)) : c2.state.options.findIndex((M2) => D$12(M2.dataRef.current.value, i2))), W2 = useCallback((i2) => u$c(l2.mode, { [k.Multi]: () => x2.some((M2) => D$12(M2, i2)), [k.Single]: () => D$12(x2, i2) }), [x2]), S2 = S$3(c2, (i2) => i2.virtual), j2 = o$5(() => m2 == null ? void 0 : m2()), l2 = useMemo(() => ({ __demoMode: a3, immediate: A2, optionsPropsRef: z, value: x2, defaultValue: C2, disabled: n2, invalid: f2, mode: u$12 ? k.Multi : k.Single, virtual: d2 ? S2 : null, onChange: v2, isSelected: W2, calculateIndex: K$1, compare: D$12, onClose: j2 }), [a3, A2, z, x2, C2, n2, f2, u$12, d2, S2, v2, W2, K$1, D$12, j2]);
  n$6(() => {
    var i2;
    d2 && c2.send({ type: D.UpdateVirtualConfiguration, options: d2.options, disabled: (i2 = d2.disabled) != null ? i2 : null });
  }, [d2, d2 == null ? void 0 : d2.options, d2 == null ? void 0 : d2.disabled]), n$6(() => {
    c2.state.dataRef.current = l2;
  }, [l2]);
  let [k$22, Y2, s2, U2] = S$3(c2, (i2) => [i2.comboboxState, i2.buttonElement, i2.inputElement, i2.optionsElement]), $2 = x$1.get(null), ne = S$3($2, useCallback((i2) => $2.selectors.isTop(i2, e2), [$2, e2]));
  k$1(ne, [Y2, s2, U2], () => c2.actions.closeCombobox());
  let be = S$3(c2, c2.selectors.activeOptionIndex), ee = S$3(c2, c2.selectors.activeOption), q2 = n$5({ open: k$22 === P.Open, disabled: n2, invalid: f2, activeIndex: be, activeOption: ee, value: x2 }), [t2, V2] = V$1(), P$12 = O2 === null ? {} : { ref: O2 }, N2 = useCallback(() => {
    if (C2 !== void 0) return v2 == null ? void 0 : v2(C2);
  }, [v2, C2]), g2 = K();
  return React__default.createElement(V2, { value: t2, props: { htmlFor: s2 == null ? void 0 : s2.id }, slot: { open: k$22 === P.Open, disabled: n2 } }, React__default.createElement(Ae$1, null, React__default.createElement(de$1.Provider, { value: l2 }, React__default.createElement(u.Provider, { value: c2 }, React__default.createElement(c$4, { value: u$c(k$22, { [P.Open]: i.Open, [P.Closed]: i.Closed }) }, h2 != null && React__default.createElement(j$5, { disabled: n2, data: x2 != null ? { [h2]: x2 } : {}, form: b$12, onReset: N2 }), g2({ ourProps: P$12, theirProps: G2, slot: q2, defaultTag: ho, name: "Combobox" }))))));
}
let Io = "input";
function Ro(T3, O2) {
  var ee, q2;
  let e2 = p("Combobox.Input"), o4 = te("Combobox.Input"), E2 = useId$1(), R = u$b(), { id: y2 = R || `headlessui-combobox-input-${E2}`, onChange: b2, displayValue: h2, disabled: p$12 = o4.disabled || false, autoFocus: f2 = false, type: n$12 = "text", ...m2 } = T3, a3 = useRef(null), u2 = y$4(a3, O2, Fe$1(), e2.actions.setInputElement), [A2, d2] = S$3(e2, (t2) => [t2.comboboxState, t2.isTyping]), X2 = p$6(), G2 = o$5(() => {
    e2.actions.onChange(null), e2.state.optionsElement && (e2.state.optionsElement.scrollTop = 0), e2.actions.goToOption({ focus: c$3.Nothing });
  }), C2 = useMemo(() => {
    var t2;
    return typeof h2 == "function" && o4.value !== void 0 ? (t2 = h2(o4.value)) != null ? t2 : "" : typeof o4.value == "string" ? o4.value : "";
  }, [o4.value, h2]);
  m$1(([t2, V2], [P$12, N2]) => {
    if (e2.state.isTyping) return;
    let g2 = a3.current;
    g2 && ((N2 === P.Open && V2 === P.Closed || t2 !== P$12) && (g2.value = t2), requestAnimationFrame(() => {
      if (e2.state.isTyping || !g2 || d$1(g2)) return;
      let { selectionStart: i2, selectionEnd: M2 } = g2;
      Math.abs((M2 != null ? M2 : 0) - (i2 != null ? i2 : 0)) === 0 && i2 === 0 && g2.setSelectionRange(g2.value.length, g2.value.length);
    }));
  }, [C2, A2, d2]), m$1(([t2], [V2]) => {
    if (t2 === P.Open && V2 === P.Closed) {
      if (e2.state.isTyping) return;
      let P2 = a3.current;
      if (!P2) return;
      let N2 = P2.value, { selectionStart: g2, selectionEnd: i2, selectionDirection: M2 } = P2;
      P2.value = "", P2.value = N2, M2 !== null ? P2.setSelectionRange(g2, i2, M2) : P2.setSelectionRange(g2, i2);
    }
  }, [A2]);
  let x2 = useRef(false), v2 = o$5(() => {
    x2.current = true;
  }), c2 = o$5(() => {
    X2.nextFrame(() => {
      x2.current = false;
    });
  }), z = o$5((t2) => {
    switch (e2.actions.setIsTyping(true), t2.key) {
      case o$3.Enter:
        if (e2.state.comboboxState !== P.Open || x2.current) return;
        if (t2.preventDefault(), t2.stopPropagation(), e2.selectors.activeOptionIndex(e2.state) === null) {
          e2.actions.closeCombobox();
          return;
        }
        e2.actions.selectActiveOption(), o4.mode === k.Single && e2.actions.closeCombobox();
        break;
      case o$3.ArrowDown:
        return t2.preventDefault(), t2.stopPropagation(), u$c(e2.state.comboboxState, { [P.Open]: () => e2.actions.goToOption({ focus: c$3.Next }), [P.Closed]: () => e2.actions.openCombobox() });
      case o$3.ArrowUp:
        return t2.preventDefault(), t2.stopPropagation(), u$c(e2.state.comboboxState, { [P.Open]: () => e2.actions.goToOption({ focus: c$3.Previous }), [P.Closed]: () => {
          flushSync(() => e2.actions.openCombobox()), o4.value || e2.actions.goToOption({ focus: c$3.Last });
        } });
      case o$3.Home:
        if (e2.state.comboboxState === P.Closed || t2.shiftKey) break;
        return t2.preventDefault(), t2.stopPropagation(), e2.actions.goToOption({ focus: c$3.First });
      case o$3.PageUp:
        return t2.preventDefault(), t2.stopPropagation(), e2.actions.goToOption({ focus: c$3.First });
      case o$3.End:
        if (e2.state.comboboxState === P.Closed || t2.shiftKey) break;
        return t2.preventDefault(), t2.stopPropagation(), e2.actions.goToOption({ focus: c$3.Last });
      case o$3.PageDown:
        return t2.preventDefault(), t2.stopPropagation(), e2.actions.goToOption({ focus: c$3.Last });
      case o$3.Escape:
        return e2.state.comboboxState !== P.Open ? void 0 : (t2.preventDefault(), e2.state.optionsElement && !o4.optionsPropsRef.current.static && t2.stopPropagation(), o4.mode === k.Single && o4.value === null && G2(), e2.actions.closeCombobox());
      case o$3.Tab:
        if (e2.actions.setIsTyping(false), e2.state.comboboxState !== P.Open) return;
        o4.mode === k.Single && e2.state.activationTrigger !== _.Focus && e2.actions.selectActiveOption(), e2.actions.closeCombobox();
        break;
    }
  }), D2 = o$5((t2) => {
    b2 == null || b2(t2), o4.mode === k.Single && t2.target.value === "" && G2(), e2.actions.openCombobox();
  }), K$1 = o$5((t2) => {
    var P$12, N2, g2;
    let V2 = (P$12 = t2.relatedTarget) != null ? P$12 : n.find((i2) => i2 !== t2.currentTarget);
    if (!((N2 = e2.state.optionsElement) != null && N2.contains(V2)) && !((g2 = e2.state.buttonElement) != null && g2.contains(V2)) && e2.state.comboboxState === P.Open) return t2.preventDefault(), o4.mode === k.Single && o4.value === null && G2(), e2.actions.closeCombobox();
  }), W2 = o$5((t2) => {
    var P$12, N2, g2;
    let V2 = (P$12 = t2.relatedTarget) != null ? P$12 : n.find((i2) => i2 !== t2.currentTarget);
    (N2 = e2.state.buttonElement) != null && N2.contains(V2) || (g2 = e2.state.optionsElement) != null && g2.contains(V2) || o4.disabled || o4.immediate && e2.state.comboboxState !== P.Open && X2.microTask(() => {
      flushSync(() => e2.actions.openCombobox()), e2.actions.setActivationTrigger(_.Focus);
    });
  }), S2 = N$1(), j2 = w$3(), { isFocused: l2, focusProps: k$12 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: f2 }), { isHovered: Y2, hoverProps: s2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: p$12 }), U2 = S$3(e2, (t2) => t2.optionsElement), $2 = n$5({ open: A2 === P.Open, disabled: p$12, invalid: o4.invalid, hover: Y2, focus: l2, autofocus: f2 }), ne = V$2({ ref: u2, id: y2, role: "combobox", type: n$12, "aria-controls": U2 == null ? void 0 : U2.id, "aria-expanded": A2 === P.Open, "aria-activedescendant": S$3(e2, e2.selectors.activeDescendantId), "aria-labelledby": S2, "aria-describedby": j2, "aria-autocomplete": "list", defaultValue: (q2 = (ee = T3.defaultValue) != null ? ee : o4.defaultValue !== void 0 ? h2 == null ? void 0 : h2(o4.defaultValue) : null) != null ? q2 : o4.defaultValue, disabled: p$12 || void 0, autoFocus: f2, onCompositionStart: v2, onCompositionEnd: c2, onKeyDown: z, onChange: D2, onFocus: W2, onBlur: K$1 }, k$12, s2);
  return K()({ ourProps: ne, theirProps: m2, slot: $2, defaultTag: Io, name: "Combobox.Input" });
}
let _o = "button";
function Fo(T3, O2) {
  let e2 = p("Combobox.Button"), o4 = te("Combobox.Button"), [E2, R] = useState(null), y2 = y$4(O2, R, e2.actions.setButtonElement), b2 = useId$1(), { id: h2 = `headlessui-combobox-button-${b2}`, disabled: p$12 = o4.disabled || false, autoFocus: f2 = false, ...n2 } = T3, [m2, a3, u2] = S$3(e2, (l2) => [l2.comboboxState, l2.inputElement, l2.optionsElement]), A2 = v$1(a3), d2 = m2 === P.Open;
  L(d2, { trigger: E2, action: useCallback((l2) => {
    if (E2 != null && E2.contains(l2.target)) return S$2.Ignore;
    if (a3 != null && a3.contains(l2.target)) return S$2.Ignore;
    let k2 = l2.target.closest('[role="option"]:not([data-disabled])');
    return n$4(k2) ? S$2.Select(k2) : u2 != null && u2.contains(l2.target) ? S$2.Ignore : S$2.Close;
  }, [E2, a3, u2]), close: e2.actions.closeCombobox, select: e2.actions.selectActiveOption });
  let X2 = o$5((l2) => {
    switch (l2.key) {
      case o$3.Space:
      case o$3.Enter:
        l2.preventDefault(), l2.stopPropagation(), e2.state.comboboxState === P.Closed && flushSync(() => e2.actions.openCombobox()), A2();
        return;
      case o$3.ArrowDown:
        l2.preventDefault(), l2.stopPropagation(), e2.state.comboboxState === P.Closed && (flushSync(() => e2.actions.openCombobox()), e2.state.dataRef.current.value || e2.actions.goToOption({ focus: c$3.First })), A2();
        return;
      case o$3.ArrowUp:
        l2.preventDefault(), l2.stopPropagation(), e2.state.comboboxState === P.Closed && (flushSync(() => e2.actions.openCombobox()), e2.state.dataRef.current.value || e2.actions.goToOption({ focus: c$3.Last })), A2();
        return;
      case o$3.Escape:
        if (e2.state.comboboxState !== P.Open) return;
        l2.preventDefault(), e2.state.optionsElement && !o4.optionsPropsRef.current.static && l2.stopPropagation(), flushSync(() => e2.actions.closeCombobox()), A2();
        return;
      default:
        return;
    }
  }), G2 = s$4(() => {
    e2.state.comboboxState === P.Open ? e2.actions.closeCombobox() : e2.actions.openCombobox(), A2();
  }), C2 = N$1([h2]), { isFocusVisible: x2, focusProps: v2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: f2 }), { isHovered: c2, hoverProps: z } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: p$12 }), { pressed: D2, pressProps: K$1 } = w$4({ disabled: p$12 }), W2 = n$5({ open: m2 === P.Open, active: D2 || m2 === P.Open, disabled: p$12, invalid: o4.invalid, value: o4.value, hover: c2, focus: x2 }), S2 = V$2({ ref: y2, id: h2, type: e$1(T3, E2), tabIndex: -1, "aria-haspopup": "listbox", "aria-controls": u2 == null ? void 0 : u2.id, "aria-expanded": m2 === P.Open, "aria-labelledby": C2, disabled: p$12 || void 0, autoFocus: f2, onKeyDown: X2 }, G2, v2, z, K$1);
  return K()({ ourProps: S2, theirProps: n2, slot: W2, defaultTag: _o, name: "Combobox.Button" });
}
let Do = "div", So = A$2.RenderStrategy | A$2.Static;
function Mo(T3, O2) {
  var M2, Ce, ve;
  let e2 = useId$1(), { id: o4 = `headlessui-combobox-options-${e2}`, hold: E2 = false, anchor: R, portal: y2 = false, modal: b2 = true, transition: h2 = false, ...p$12 } = T3, f2 = p("Combobox.Options"), n2 = te("Combobox.Options"), m2 = ye(R);
  m2 && (y2 = true);
  let [a3, u2] = Re(m2), [A2, d2] = useState(null), X2 = Te$1(), G2 = y$4(O2, m2 ? a3 : null, f2.actions.setOptionsElement, d2), [C2, x$12, v2, c2, z] = S$3(f2, (_2) => [_2.comboboxState, _2.inputElement, _2.buttonElement, _2.optionsElement, _2.activationTrigger]), D2 = u$5(x$12 || v2), K$1 = u$5(c2), W2 = u$2(), [S2, j2] = N(h2, A2, W2 !== null ? (W2 & i.Open) === i.Open : C2 === P.Open);
  p$2(S2, x$12, f2.actions.closeCombobox);
  let l2 = n2.__demoMode ? false : b2 && C2 === P.Open;
  f$4(l2, K$1);
  let k$12 = n2.__demoMode ? false : b2 && C2 === P.Open;
  y$2(k$12, { allowed: useCallback(() => [x$12, v2, c2], [x$12, v2, c2]) });
  let s2 = S$3(f2, f2.selectors.didInputMove) ? false : S2;
  n$6(() => {
    var _2;
    n2.optionsPropsRef.current.static = (_2 = T3.static) != null ? _2 : false;
  }, [n2.optionsPropsRef, T3.static]), n$6(() => {
    n2.optionsPropsRef.current.hold = E2;
  }, [n2.optionsPropsRef, E2]), F(C2 === P.Open, { container: c2, accept(_2) {
    return _2.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : _2.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(_2) {
    _2.setAttribute("role", "none");
  } });
  let U2 = N$1([v2 == null ? void 0 : v2.id]), $2 = n$5({ open: C2 === P.Open, option: void 0 }), ne = o$5(() => {
    f2.actions.setActivationTrigger(_.Pointer);
  }), be = o$5((_$12) => {
    _$12.preventDefault(), f2.actions.setActivationTrigger(_.Pointer);
  }), ee = V$2(m2 ? X2() : {}, { "aria-labelledby": U2, role: "listbox", "aria-multiselectable": n2.mode === k.Multi ? true : void 0, id: o4, ref: G2, style: { ...p$12.style, ...u2, "--input-width": w$2(S2, x$12, true).width, "--button-width": w$2(S2, v2, true).width }, onWheel: z === _.Pointer ? void 0 : ne, onMouseDown: be, ...x(j2) }), q2 = S2 && C2 === P.Closed && !T3.static, t2 = u$3(q2, (M2 = n2.virtual) == null ? void 0 : M2.options), V2 = u$3(q2, n2.value), P$12 = useCallback((_2) => n2.compare(V2, _2), [n2.compare, V2]), N$2 = useMemo(() => {
    if (!n2.virtual) return n2;
    if (t2 === void 0) throw new Error("Missing `options` in virtual mode");
    return t2 !== n2.virtual.options ? { ...n2, virtual: { ...n2.virtual, options: t2 } } : n2;
  }, [n2, t2, (Ce = n2.virtual) == null ? void 0 : Ce.options]);
  n2.virtual && Object.assign(p$12, { children: React__default.createElement(de$1.Provider, { value: N$2 }, React__default.createElement(Eo, { slot: $2 }, p$12.children)) });
  let g2 = K(), i$12 = useMemo(() => n2.mode === k.Multi ? n2 : { ...n2, isSelected: P$12 }, [n2, P$12]);
  return React__default.createElement(te$1, { enabled: y2 ? T3.static || S2 : false, ownerDocument: D2 }, React__default.createElement(de$1.Provider, { value: i$12 }, g2({ ourProps: ee, theirProps: { ...p$12, children: React__default.createElement(s$1, { freeze: q2 }, typeof p$12.children == "function" ? (ve = p$12.children) == null ? void 0 : ve.call(p$12, $2) : p$12.children) }, slot: $2, defaultTag: Do, features: So, visible: s2, name: "Combobox.Options" })));
}
let Lo = "div";
function Vo(T3, O2) {
  var l2, k$12, Y2;
  let e2 = te("Combobox.Option"), o4 = p("Combobox.Option"), E2 = useId$1(), { id: R = `headlessui-combobox-option-${E2}`, value: y2, disabled: b2 = (Y2 = (k$12 = (l2 = e2.virtual) == null ? void 0 : l2.disabled) == null ? void 0 : k$12.call(l2, y2)) != null ? Y2 : false, order: h2 = null, ...p$12 } = T3, [f2] = S$3(o4, (s2) => [s2.inputElement]), n2 = v$1(f2), m2 = S$3(o4, useCallback((s2) => o4.selectors.isActive(s2, y2, R), [y2, R])), a3 = e2.isSelected(y2), u2 = useRef(null), A2 = s$8({ disabled: b2, value: y2, domRef: u2, order: h2 }), d2 = useContext(Le$1), X2 = y$4(O2, u2, d2 ? d2.measureElement : null), G2 = o$5(() => {
    o4.actions.setIsTyping(false), o4.actions.onChange(y2);
  });
  n$6(() => o4.actions.registerOption(R, A2), [A2, R]);
  let C2 = S$3(o4, useCallback((s2) => o4.selectors.shouldScrollIntoView(s2, y2, R), [y2, R]));
  n$6(() => {
    if (C2) return o$6().requestAnimationFrame(() => {
      var s2, U2;
      (U2 = (s2 = u2.current) == null ? void 0 : s2.scrollIntoView) == null || U2.call(s2, { block: "nearest" });
    });
  }, [C2, u2]);
  let x2 = o$5((s2) => {
    s2.preventDefault(), s2.button === g$1.Left && (b2 || (G2(), n$2() || requestAnimationFrame(() => n2()), e2.mode === k.Single && o4.actions.closeCombobox()));
  }), v2 = o$5(() => {
    if (b2) return o4.actions.goToOption({ focus: c$3.Nothing });
    let s2 = e2.calculateIndex(y2);
    o4.actions.goToOption({ focus: c$3.Specific, idx: s2 });
  }), c2 = u$4(), z = o$5((s2) => c2.update(s2)), D2 = o$5((s2) => {
    if (!c2.wasMoved(s2) || b2 || m2 && o4.state.activationTrigger === _.Pointer) return;
    let U2 = e2.calculateIndex(y2);
    o4.actions.goToOption({ focus: c$3.Specific, idx: U2 }, _.Pointer);
  }), K$1 = o$5((s2) => {
    c2.wasMoved(s2) && (b2 || m2 && (e2.optionsPropsRef.current.hold || o4.state.activationTrigger === _.Pointer && o4.actions.goToOption({ focus: c$3.Nothing })));
  }), W2 = n$5({ active: m2, focus: m2, selected: a3, disabled: b2 }), S2 = { id: R, ref: X2, role: "option", tabIndex: b2 === true ? void 0 : -1, "aria-disabled": b2 === true ? true : void 0, "aria-selected": a3, disabled: void 0, onMouseDown: x2, onFocus: v2, onPointerEnter: z, onMouseEnter: z, onPointerMove: D2, onMouseMove: D2, onPointerLeave: K$1, onMouseLeave: K$1 };
  return K()({ ourProps: S2, theirProps: p$12, slot: W2, defaultTag: Lo, name: "Combobox.Option" });
}
let wo = Y(Ao), Bo = Y(Fo), ko = Y(Ro), No = Z, Uo = Y(Mo), Ho = Y(Vo), Ht = Object.assign(wo, { Input: ko, Button: Bo, Label: No, Options: Uo, Option: Ho });
function s() {
  let r2 = typeof document == "undefined";
  return "useSyncExternalStore" in React ? ((o4) => o4.useSyncExternalStore)(React)(() => () => {
  }, () => false, () => !r2) : false;
}
function l() {
  let r2 = s(), [e2, n2] = React.useState(s$9.isHandoffComplete);
  return e2 && s$9.isHandoffComplete === false && n2(false), React.useEffect(() => {
    e2 !== true && n2(true);
  }, [e2]), React.useEffect(() => s$9.handoff(), []), r2 ? false : e2;
}
function f() {
  let e2 = useRef(false);
  return n$6(() => (e2.current = true, () => {
    e2.current = false;
  }), []), e2;
}
function ue(e2) {
  var t2;
  return !!(e2.enter || e2.enterFrom || e2.enterTo || e2.leave || e2.leaveFrom || e2.leaveTo) || !b$3((t2 = e2.as) != null ? t2 : de) || React__default.Children.count(e2.children) === 1;
}
let V = createContext(null);
V.displayName = "TransitionContext";
var De = ((n2) => (n2.Visible = "visible", n2.Hidden = "hidden", n2))(De || {});
function He() {
  let e2 = useContext(V);
  if (e2 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e2;
}
function Ae() {
  let e2 = useContext(w);
  if (e2 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e2;
}
let w = createContext(null);
w.displayName = "NestingContext";
function M(e2) {
  return "children" in e2 ? M(e2.children) : e2.current.filter(({ el: t2 }) => t2.current !== null).filter(({ state: t2 }) => t2 === "visible").length > 0;
}
function Te(e2, t2) {
  let n2 = s$8(e2), l2 = useRef([]), S2 = f(), R = p$6(), d2 = o$5((o4, i2 = C$5.Hidden) => {
    let a3 = l2.current.findIndex(({ el: s2 }) => s2 === o4);
    a3 !== -1 && (u$c(i2, { [C$5.Unmount]() {
      l2.current.splice(a3, 1);
    }, [C$5.Hidden]() {
      l2.current[a3].state = "hidden";
    } }), R.microTask(() => {
      var s2;
      !M(l2) && S2.current && ((s2 = n2.current) == null || s2.call(n2));
    }));
  }), y2 = o$5((o4) => {
    let i2 = l2.current.find(({ el: a3 }) => a3 === o4);
    return i2 ? i2.state !== "visible" && (i2.state = "visible") : l2.current.push({ el: o4, state: "visible" }), () => d2(o4, C$5.Unmount);
  }), C2 = useRef([]), p2 = useRef(Promise.resolve()), h2 = useRef({ enter: [], leave: [] }), g2 = o$5((o4, i2, a3) => {
    C2.current.splice(0), t2 && (t2.chains.current[i2] = t2.chains.current[i2].filter(([s2]) => s2 !== o4)), t2 == null || t2.chains.current[i2].push([o4, new Promise((s2) => {
      C2.current.push(s2);
    })]), t2 == null || t2.chains.current[i2].push([o4, new Promise((s2) => {
      Promise.all(h2.current[i2].map(([r2, f2]) => f2)).then(() => s2());
    })]), i2 === "enter" ? p2.current = p2.current.then(() => t2 == null ? void 0 : t2.wait.current).then(() => a3(i2)) : a3(i2);
  }), v2 = o$5((o4, i2, a3) => {
    Promise.all(h2.current[i2].splice(0).map(([s2, r2]) => r2)).then(() => {
      var s2;
      (s2 = C2.current.shift()) == null || s2();
    }).then(() => a3(i2));
  });
  return useMemo(() => ({ children: l2, register: y2, unregister: d2, onStart: g2, onStop: v2, wait: p2, chains: h2 }), [y2, d2, l2, g2, v2, h2, p2]);
}
let de = Fragment, fe = A$2.RenderStrategy;
function Fe(e2, t2) {
  var ee, te2;
  let { transition: n2 = true, beforeEnter: l$12, afterEnter: S2, beforeLeave: R, afterLeave: d2, enter: y2, enterFrom: C2, enterTo: p2, entered: h2, leave: g2, leaveFrom: v2, leaveTo: o4, ...i$12 } = e2, [a3, s2] = useState(null), r2 = useRef(null), f2 = ue(e2), U2 = y$4(...f2 ? [r2, t2, s2] : t2 === null ? [] : [t2]), H2 = (ee = i$12.unmount) == null || ee ? C$5.Unmount : C$5.Hidden, { show: u2, appear: z, initial: K$1 } = He(), [m2, j2] = useState(u2 ? "visible" : "hidden"), Q = Ae(), { register: A2, unregister: F2 } = Q;
  n$6(() => A2(r2), [A2, r2]), n$6(() => {
    if (H2 === C$5.Hidden && r2.current) {
      if (u2 && m2 !== "visible") {
        j2("visible");
        return;
      }
      return u$c(m2, { ["hidden"]: () => F2(r2), ["visible"]: () => A2(r2) });
    }
  }, [m2, r2, A2, F2, u2, H2]);
  let G2 = l();
  n$6(() => {
    if (f2 && G2 && m2 === "visible" && r2.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [r2, m2, G2, f2]);
  let ce2 = K$1 && !z, Y2 = z && u2 && K$1, B = useRef(false), I2 = Te(() => {
    B.current || (j2("hidden"), F2(r2));
  }, Q), Z2 = o$5((W2) => {
    B.current = true;
    let L2 = W2 ? "enter" : "leave";
    I2.onStart(r2, L2, (_2) => {
      _2 === "enter" ? l$12 == null || l$12() : _2 === "leave" && (R == null || R());
    });
  }), $2 = o$5((W2) => {
    let L2 = W2 ? "enter" : "leave";
    B.current = false, I2.onStop(r2, L2, (_2) => {
      _2 === "enter" ? S2 == null || S2() : _2 === "leave" && (d2 == null || d2());
    }), L2 === "leave" && !M(I2) && (j2("hidden"), F2(r2));
  });
  useEffect(() => {
    f2 && n2 || (Z2(u2), $2(u2));
  }, [u2, f2, n2]);
  let pe = /* @__PURE__ */ (() => !(!n2 || !f2 || !G2 || ce2))(), [, T3] = N(pe, a3, u2, { start: Z2, end: $2 }), Ce = m$4({ ref: U2, className: ((te2 = t$4(i$12.className, Y2 && y2, Y2 && C2, T3.enter && y2, T3.enter && T3.closed && C2, T3.enter && !T3.closed && p2, T3.leave && g2, T3.leave && !T3.closed && v2, T3.leave && T3.closed && o4, !T3.transition && u2 && h2)) == null ? void 0 : te2.trim()) || void 0, ...x(T3) }), N$12 = 0;
  m2 === "visible" && (N$12 |= i.Open), m2 === "hidden" && (N$12 |= i.Closed), u2 && m2 === "hidden" && (N$12 |= i.Opening), !u2 && m2 === "visible" && (N$12 |= i.Closing);
  let he = K();
  return React__default.createElement(w.Provider, { value: I2 }, React__default.createElement(c$4, { value: N$12 }, he({ ourProps: Ce, theirProps: i$12, defaultTag: de, features: fe, visible: m2 === "visible", name: "Transition.Child" })));
}
function Ie(e2, t2) {
  let { show: n2, appear: l$12 = false, unmount: S2 = true, ...R } = e2, d2 = useRef(null), y2 = ue(e2), C2 = y$4(...y2 ? [d2, t2] : t2 === null ? [] : [t2]);
  l();
  let p2 = u$2();
  if (n2 === void 0 && p2 !== null && (n2 = (p2 & i.Open) === i.Open), n2 === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [h2, g2] = useState(n2 ? "visible" : "hidden"), v2 = Te(() => {
    n2 || g2("hidden");
  }), [o4, i$12] = useState(true), a3 = useRef([n2]);
  n$6(() => {
    o4 !== false && a3.current[a3.current.length - 1] !== n2 && (a3.current.push(n2), i$12(false));
  }, [a3, n2]);
  let s2 = useMemo(() => ({ show: n2, appear: l$12, initial: o4 }), [n2, l$12, o4]);
  n$6(() => {
    n2 ? g2("visible") : !M(v2) && d2.current !== null && g2("hidden");
  }, [n2, v2]);
  let r2 = { unmount: S2 }, f2 = o$5(() => {
    var u2;
    o4 && i$12(false), (u2 = e2.beforeEnter) == null || u2.call(e2);
  }), U2 = o$5(() => {
    var u2;
    o4 && i$12(false), (u2 = e2.beforeLeave) == null || u2.call(e2);
  }), H2 = K();
  return React__default.createElement(w.Provider, { value: v2 }, React__default.createElement(V.Provider, { value: s2 }, H2({ ourProps: { ...r2, as: Fragment, children: React__default.createElement(me, { ref: C2, ...r2, ...R, beforeEnter: f2, beforeLeave: U2 }) }, theirProps: {}, defaultTag: Fragment, features: fe, visible: h2 === "visible", name: "Transition" })));
}
function Le(e2, t2) {
  let n2 = useContext(V) !== null, l2 = u$2() !== null;
  return React__default.createElement(React__default.Fragment, null, !n2 && l2 ? React__default.createElement(X, { ref: t2, ...e2 }) : React__default.createElement(me, { ref: t2, ...e2 }));
}
let X = Y(Ie), me = Y(Fe), Oe = Y(Le), Ke = Object.assign(X, { Child: Oe, Root: X });
const SearchBar = ({
  placeholder = "Search...",
  value,
  onChange,
  onSearch,
  suggestions = [],
  onSuggestionSelect,
  isLoading = false,
  size: size2 = "md",
  variant = "primary",
  color: color2 = "primary",
  radius = "md",
  className,
  showSearchIcon = true,
  leftIcon,
  rightIcon,
  isClearable = true,
  noSuggestionsText = "No results found.",
  isDisabled = false,
  ariaLabel,
  label,
  showLabel = true,
  labelMode = "top",
  labelClassName = "",
  id: idProp,
  showSuggestionsList = true,
  filterSuggestions = true
}) => {
  const [isFocused, setIsFocused] = useState(false);
  const inputId = idProp ?? `searchbar-${Math.random().toString(36).slice(2, 9)}`;
  const shouldShowDropdown = showSuggestionsList;
  const filteredSuggestions = useMemo(() => {
    if (!filterSuggestions) return suggestions;
    const trimmed = value.trim().toLowerCase();
    if (trimmed === "") return suggestions;
    return suggestions.filter(
      (s2) => s2.text.toLowerCase().includes(trimmed) || s2.description?.toLowerCase().includes(trimmed)
    );
  }, [suggestions, value, filterSuggestions]);
  const displaySuggestions = filterSuggestions ? filteredSuggestions : suggestions;
  const selectedSuggestion = useMemo(
    () => suggestions.find((s2) => s2.text === value) ?? null,
    [suggestions, value]
  );
  const sizeStyles = {
    xs: "h-8 text-xs",
    sm: "h-10 text-sm",
    md: "h-12 text-base",
    lg: "h-14 text-lg",
    xl: "h-16 text-xl"
  };
  const variantStyles = {
    primary: "border bg-bg-secondary dark:bg-dark-bg-secondary text-text-primary dark:text-dark-text-primary",
    secondary: "border bg-bg-tertiary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary",
    outline: "border-2 bg-transparent text-text-primary dark:text-dark-text-primary",
    ghost: "border border-transparent hover:bg-bg-secondary dark:hover:bg-dark-bg-secondary bg-transparent text-text-primary dark:text-dark-text-primary",
    filled: "border-0 bg-bg-primary dark:bg-dark-bg-primary text-text-primary dark:text-dark-text-primary"
  };
  const colorDefaultBorder = {
    primary: "border-border-color dark:border-dark-border-color",
    success: "border-border-color dark:border-dark-border-color",
    warning: "border-border-color dark:border-dark-border-color",
    danger: "border-border-color dark:border-dark-border-color",
    info: "border-border-color dark:border-dark-border-color"
  };
  const colorFocusStyles = {
    primary: "focus-within:border-brand-navy dark:focus-within:border-dark-brand-orange focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-brand-orange dark:focus-within:ring-dark-brand-orange",
    success: "focus-within:border-system-success dark:focus-within:border-system-success focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-system-success dark:focus-within:ring-system-success",
    warning: "focus-within:border-system-warning-dark dark:focus-within:border-system-warning focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-system-warning dark:focus-within:ring-system-warning",
    danger: "focus-within:border-system-error dark:focus-within:border-system-error focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-system-error dark:focus-within:ring-system-error",
    info: "focus-within:border-system-info dark:focus-within:border-system-info focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-system-info dark:focus-within:ring-system-info"
  };
  const ghostBorderStyles = "border-transparent hover:border-border-color dark:hover:border-dark-border-color";
  const radiusStyles = {
    none: "rounded-none",
    sm: "rounded-sm",
    md: "rounded",
    lg: "rounded-lg",
    xl: "rounded-xl",
    full: "rounded-full"
  };
  const radiusClass = radiusStyles[radius] ?? "rounded";
  const disabledClass = isDisabled ? "cursor-not-allowed opacity-70 pointer-events-none bg-gray-100 dark:bg-gray-900 border-gray-300 dark:border-gray-700" : "";
  const hasLabel = Boolean(label && showLabel);
  const isFloatingLabel = labelMode === "floating";
  const hasValue = value.trim() !== "";
  const shouldFloatLabel = isFloatingLabel && (hasValue || isFocused);
  const effectivePlaceholder = isFloatingLabel ? void 0 : placeholder;
  const handleSelect = (suggestion) => {
    if (!suggestion) return;
    onChange(suggestion.text);
    onSuggestionSelect?.(suggestion);
  };
  const handleSubmit = (e2) => {
    e2.preventDefault();
    onSearch?.(value);
  };
  const handleClear = (e2) => {
    e2.stopPropagation();
    onChange("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("relative w-full", className), children: [
    hasLabel && labelMode === "top" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "label",
      {
        htmlFor: inputId,
        className: cn(
          "block text-sm font-medium text-text-primary dark:text-dark-text-primary mb-1",
          isDisabled && "text-gray-500 dark:text-gray-500 opacity-70",
          labelClassName
        ),
        children: label
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Ht, { value: selectedSuggestion, onChange: handleSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: cn(
            "relative flex items-center w-full transition-all duration-200 ease-in-out",
            sizeStyles[size2],
            !isDisabled && variantStyles[variant],
            !isDisabled && (variant === "ghost" ? ghostBorderStyles : colorDefaultBorder[color2]),
            !isDisabled && colorFocusStyles[color2],
            radiusClass,
            disabledClass
          ),
          children: [
            hasLabel && isFloatingLabel && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: cn(
                  "absolute transition-all duration-200 pointer-events-none z-10 text-text-secondary dark:text-dark-text-secondary",
                  showSearchIcon || leftIcon ? "left-12" : "left-3",
                  shouldFloatLabel ? "-top-2.5 text-xs px-1 bg-bg-primary dark:bg-dark-bg-primary" : "top-1/2 -translate-y-1/2 text-inherit",
                  isDisabled && "text-gray-500 dark:text-gray-500 opacity-70"
                ),
                children: label
              }
            ),
            (showSearchIcon || leftIcon) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex items-center shrink-0", leftIcon ? "pl-3" : "ml-3"), children: leftIcon !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("flex items-center", isDisabled ? "text-gray-500 dark:text-gray-500" : "text-text-secondary dark:text-dark-text-secondary"), children: leftIcon }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Icon,
              {
                className: cn(
                  "w-5 h-5",
                  isDisabled ? "text-gray-500 dark:text-gray-500" : "text-text-secondary dark:text-dark-text-secondary"
                ),
                "aria-hidden": "true",
                children: "search"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Ht.Input,
              {
                id: inputId,
                className: cn(
                  "w-full bg-transparent border-0 focus:ring-0 text-inherit placeholder:text-text-secondary dark:placeholder:text-dark-text-secondary focus:outline-none disabled:cursor-not-allowed disabled:placeholder:opacity-70",
                  showSearchIcon || leftIcon ? "pl-2" : "pl-3",
                  "pr-10"
                ),
                placeholder: effectivePlaceholder,
                value,
                onChange: (event) => onChange(event.target.value),
                onFocus: () => setIsFocused(true),
                onBlur: () => setIsFocused(false),
                disabled: isDisabled,
                "aria-label": ariaLabel ?? label ?? placeholder ?? "Search"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute inset-y-0 right-0 flex items-center gap-1 pr-3", children: [
              rightIcon !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("flex items-center shrink-0", isDisabled ? "text-gray-500 dark:text-gray-500" : "text-text-secondary dark:text-dark-text-secondary"), children: rightIcon }),
              isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-4 h-4 border-2 border-text-tertiary dark:border-dark-text-tertiary border-t-transparent rounded-full animate-spin shrink-0" }),
              !isDisabled && !isLoading && isClearable && value && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: handleClear,
                  className: "p-1 -mr-1 rounded text-text-secondary dark:text-dark-text-secondary hover:text-text-primary dark:hover:text-dark-text-primary hover:bg-bg-tertiary dark:hover:bg-dark-bg-tertiary",
                  "aria-label": "Clear search",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "w-4 h-4", children: "close" })
                }
              )
            ] })
          ]
        }
      ),
      shouldShowDropdown && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Ke,
        {
          as: Fragment,
          leave: "transition ease-in duration-100",
          leaveFrom: "opacity-100",
          leaveTo: "opacity-0",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Ht.Options, { className: "absolute z-10 mt-1 w-full max-h-60 overflow-auto py-1 text-base sm:text-sm focus:outline-none bg-bg-primary dark:bg-dark-bg-primary border border-border-color dark:border-dark-border-color rounded-lg shadow-lg", children: displaySuggestions.length === 0 && value !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative cursor-default select-none py-2 px-4 text-text-secondary dark:text-dark-text-secondary", children: noSuggestionsText }) : displaySuggestions.map((suggestion) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Ht.Option,
            {
              className: ({ active }) => cn(
                "relative cursor-default select-none py-2 px-4",
                active ? "bg-bg-secondary dark:bg-dark-bg-secondary" : ""
              ),
              value: suggestion,
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [
                suggestion.icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "text-brand-orange dark:text-dark-brand-orange shrink-0", children: suggestion.icon }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium text-text-primary dark:text-dark-text-primary truncate", children: suggestion.text }),
                  suggestion.description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-text-secondary dark:text-dark-text-secondary truncate", children: suggestion.description })
                ] })
              ] })
            },
            suggestion.id
          )) })
        }
      )
    ] }) }) })
  ] });
};
const DefaultErrorFallback = ({
  error: error2,
  errorInfo,
  resetError,
  size: size2 = "md",
  variant = "default",
  color: color2 = "danger",
  showErrorDetails = false,
  errorMessage = "Something went wrong",
  showResetButton = true,
  showStackTrace = false,
  showComponentStack = false,
  showErrorCode = false,
  showTimestamp = false,
  showVersion = false,
  hasBackground = true,
  hasBorder = true,
  isRounded = true,
  hasShadow = false,
  isAnimated = true
}) => {
  const [showDetails, setShowDetails] = React__default.useState(showErrorDetails);
  const sizeClasses2 = {
    xs: "text-xs p-3",
    sm: "text-sm p-4",
    md: "text-sm p-6",
    lg: "text-base p-6",
    xl: "text-lg p-8"
  };
  const variantClasses2 = {
    default: "bg-white dark:bg-gray-900",
    minimal: "bg-transparent",
    elevated: "bg-white dark:bg-gray-900 shadow-lg",
    bordered: "bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700",
    filled: "bg-gray-50 dark:bg-gray-800"
  };
  const colorClasses2 = {
    primary: "bg-primary-50 dark:bg-primary-900/20 border-primary-200 dark:border-primary-800 text-primary-800 dark:text-primary-200",
    success: "bg-success-50 dark:bg-success-900/20 border-success-200 dark:border-success-800 text-success-800 dark:text-success-200",
    warning: "bg-warning-50 dark:bg-warning-900/20 border-warning-200 dark:border-warning-800 text-warning-800 dark:text-warning-200",
    danger: "bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-800 dark:text-red-200",
    info: "bg-info-50 dark:bg-info-900/20 border-info-200 dark:border-info-800 text-info-800 dark:text-info-200",
    neutral: "bg-gray-50 dark:bg-gray-900/20 border-gray-200 dark:border-gray-800 text-gray-800 dark:text-gray-200"
  };
  const iconColorClasses = {
    primary: "text-primary-400",
    success: "text-success-400",
    warning: "text-warning-400",
    danger: "text-red-400",
    info: "text-info-400",
    neutral: "text-gray-400"
  };
  const buttonColorClasses = {
    primary: "bg-primary-600 hover:bg-primary-700 focus:ring-brand-orange dark:focus:ring-dark-brand-orange",
    success: "bg-success-600 hover:bg-success-700 focus:ring-success-500",
    warning: "bg-warning-600 hover:bg-warning-700 focus:ring-warning-500",
    danger: "bg-red-600 hover:bg-red-700 focus:ring-red-500",
    info: "bg-info-600 hover:bg-info-700 focus:ring-info-500",
    neutral: "bg-gray-600 hover:bg-gray-700 focus:ring-gray-500"
  };
  const containerClasses = `
    ${sizeClasses2[size2]}
    ${hasBackground ? variantClasses2[variant] : ""}
    ${hasBorder ? colorClasses2[color2] : ""}
    ${isRounded ? "rounded-lg" : ""}
    ${hasShadow ? "shadow-md" : ""}
    ${isAnimated ? "transition-all duration-200" : ""}
  `.trim().replace(/\s+/g, " ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: containerClasses, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `h-6 w-6 ${iconColorClasses[color2]}`, fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 min-w-0", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium", children: errorMessage }),
      showTimestamp && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-1 text-sm opacity-80", children: [
        "Error occurred at: ",
        (/* @__PURE__ */ new Date()).toLocaleString()
      ] }),
      showErrorCode && error2.name && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "mt-1 text-sm opacity-80", children: [
        "Error Type: ",
        error2.name
      ] }),
      showVersion && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1 text-sm opacity-80", children: "Error Boundary v1.0.0" }),
      showErrorDetails && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            onClick: () => setShowDetails(!showDetails),
            className: "text-sm opacity-80 hover:opacity-100 underline transition-opacity",
            children: [
              showDetails ? "Hide" : "Show",
              " Error Details"
            ]
          }
        ),
        showDetails && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3 space-y-3", children: [
          showStackTrace && error2.stack && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium opacity-90", children: "Stack Trace:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-1 text-xs opacity-80 bg-black/5 dark:bg-white/5 p-2 rounded overflow-auto max-h-32", children: error2.stack })
          ] }),
          showComponentStack && errorInfo.componentStack && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-sm font-medium opacity-90", children: "Component Stack:" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-1 text-xs opacity-80 bg-black/5 dark:bg-white/5 p-2 rounded overflow-auto max-h-32", children: errorInfo.componentStack })
          ] })
        ] })
      ] }),
      showResetButton && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          onClick: resetError,
          className: `inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white ${buttonColorClasses[color2]} focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-brand-orange dark:focus:ring-dark-brand-orange transition-colors duration-200`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-4 w-4 mr-2", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" }) }),
            "Try Again"
          ]
        }
      ) })
    ] })
  ] }) });
};
class ErrorBoundary extends React__default.Component {
  constructor(props) {
    super(props);
    this.resetError = () => {
      this.setState({
        hasError: false,
        error: null,
        errorInfo: null,
        errorId: "",
        timestamp: /* @__PURE__ */ new Date()
      });
      if (this.props.onReset) {
        this.props.onReset();
      }
    };
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      errorId: "",
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  static getDerivedStateFromError(error2) {
    return {
      hasError: true,
      error: error2,
      errorId: `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  componentDidCatch(error2, errorInfo) {
    if (this.props.logErrors !== false) {
      console.error("ErrorBoundary caught an error:", error2, errorInfo);
    }
    this.setState({
      error: error2,
      errorInfo
    });
    if (this.props.onError) {
      this.props.onError(error2, errorInfo);
    }
    if (this.props.autoReset) {
      const delay3 = this.props.autoResetDelay || 5e3;
      setTimeout(() => {
        this.resetError();
      }, delay3);
    }
  }
  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        const FallbackComponent = this.props.fallback;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          FallbackComponent,
          {
            error: this.state.error,
            errorInfo: this.state.errorInfo,
            resetError: this.resetError
          }
        );
      }
      const fallbackProps = {
        error: this.state.error,
        errorInfo: this.state.errorInfo,
        resetError: this.resetError,
        size: this.props.size,
        variant: this.props.variant,
        color: this.props.color,
        showErrorDetails: this.props.showErrorDetails || this.props.hasErrorDetails,
        errorMessage: this.props.errorMessage,
        showResetButton: this.props.showResetButton || this.props.hasResetButton,
        showStackTrace: this.props.showStackTrace || this.props.hasStackTrace,
        showComponentStack: this.props.showComponentStack || this.props.hasComponentStack,
        showErrorCode: this.props.showErrorCode || this.props.hasErrorCode,
        showTimestamp: this.props.showTimestamp || this.props.hasTimestamp,
        showVersion: this.props.showVersion || this.props.hasVersion,
        hasBackground: this.props.hasBackground,
        hasBorder: this.props.hasBorder,
        isRounded: this.props.isRounded,
        hasShadow: this.props.hasShadow,
        isAnimated: this.props.isAnimated
      };
      const fallbackContent = /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultErrorFallback, { ...fallbackProps });
      if (this.props.hasContainer) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `${this.props.containerClassName || ""} ${this.props.className || "error-boundary-container"}`,
            style: this.props.style,
            onFocus: this.props.onFocus,
            onBlur: this.props.onBlur,
            onClick: this.props.onClick,
            children: fallbackContent
          }
        );
      }
      return fallbackContent;
    }
    return this.props.children;
  }
}
const useErrorBoundary = () => {
  const [hasError, setHasError] = React__default.useState(false);
  const [error2, setError] = React__default.useState(null);
  React__default.useEffect(() => {
    const handleError = (event) => {
      setHasError(true);
      setError(event.error);
    };
    const handleUnhandledRejection = (event) => {
      setHasError(true);
      setError(new Error(event.reason));
    };
    window.addEventListener("error", handleError);
    window.addEventListener("unhandledrejection", handleUnhandledRejection);
    return () => {
      window.removeEventListener("error", handleError);
      window.removeEventListener("unhandledrejection", handleUnhandledRejection);
    };
  }, []);
  const resetError = React__default.useCallback(() => {
    setHasError(false);
    setError(null);
  }, []);
  return { hasError, error: error2, resetError };
};
const withErrorBoundary = (Component2, errorBoundaryProps) => {
  const WrappedComponent = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { ...errorBoundaryProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Component2, { ...props }) });
  WrappedComponent.displayName = `withErrorBoundary(${Component2.displayName || Component2.name})`;
  return WrappedComponent;
};
const ErrorBoundaryFallback = ({ children, fallback, hasError }) => {
  if (hasError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: fallback });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
const Layout = ({
  children,
  containerClassName = "",
  contentClassName = "",
  className = "",
  style,
  size: size2,
  variant,
  color: color2,
  hasMinHeight = true,
  isColumn = true,
  isFullWidth = true,
  isCollapsed = false,
  isExpanded = false,
  isVisible = true,
  isHidden: isHidden3 = false,
  isTransparent = false,
  isOpaque = false,
  hasBackground = false,
  hasBorder = false,
  hasRoundedCorners = false,
  hasShadow = false,
  hasBackdropBlur = false,
  hasGlassEffect = false,
  hasGradient = false,
  hasFocusRing = false,
  hasHoverEffect = false,
  hasFocusEffect = false,
  hasActiveEffect = false,
  isDisabled = false,
  isReadOnly = false,
  isRequired = false,
  isValid: isValid2 = true,
  isInvalid = false,
  isPending = false,
  isBusy = false,
  isReady = false,
  isMounted = false,
  isUnmounted = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  onMouseDown,
  onMouseUp,
  onDoubleClick,
  onContextMenu,
  onScroll,
  ...props
}) => {
  const baseClasses = "flex";
  const minHeightClass = hasMinHeight ? "min-h-screen" : "";
  const directionClass = isColumn ? "flex-col" : "flex-col lg:flex-row";
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const backgroundClass = hasBackground ? "bg-bg-primary dark:bg-dark-bg-primary" : "";
  const borderClass = hasBorder ? "border border-border-color dark:border-dark-border-color" : "";
  const roundedClass = hasRoundedCorners ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const loadingClass = isLoading ? "animate-pulse" : "";
  const errorClass = isError ? "border-system-error" : "";
  const warningClass = isWarning ? "border-system-warning" : "";
  const successClass = isSuccess ? "border-system-success" : "";
  const infoClass = isInfo ? "border-system-info" : "";
  const combinedClasses = [
    baseClasses,
    minHeightClass,
    directionClass,
    widthClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    loadingClass,
    errorClass,
    warningClass,
    successClass,
    infoClass,
    className
  ].filter(Boolean).join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: combinedClasses,
      style,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      onMouseDown,
      onMouseUp,
      onDoubleClick,
      onContextMenu,
      onScroll,
      ...props,
      children
    }
  );
};
const LayoutHeader = ({
  children,
  className = "",
  style,
  isSticky = false,
  hasElevation = false,
  hasBackground = true,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  isFullWidth = true,
  hasBackdropBlur = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  ...props
}) => {
  const baseClasses = "bg-bg-primary dark:bg-dark-bg-primary";
  const stickyClass = isSticky ? "sticky top-0 z-50" : "";
  const elevatedClass = hasElevation ? "shadow-sm border-b border-border-color dark:border-dark-border-color" : "";
  const backgroundClass = hasBackground ? "bg-bg-primary dark:bg-dark-bg-primary" : "bg-transparent";
  const borderClass = isBordered ? "border border-border-color dark:border-dark-border-color" : "";
  const roundedClass = isRounded ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const backdropClass = hasBackdropBlur ? "backdrop-blur-sm" : "";
  const loadingClass = isLoading ? "animate-pulse" : "";
  const errorClass = isError ? "border-system-error" : "";
  const warningClass = isWarning ? "border-system-warning" : "";
  const successClass = isSuccess ? "border-system-success" : "";
  const infoClass = isInfo ? "border-system-info" : "";
  const combinedClasses = [
    baseClasses,
    stickyClass,
    elevatedClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    widthClass,
    backdropClass,
    loadingClass,
    errorClass,
    warningClass,
    successClass,
    infoClass,
    className
  ].filter(Boolean).join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "header",
    {
      className: combinedClasses,
      style,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      ...props,
      children
    }
  );
};
const Main = ({
  children,
  className = "",
  style,
  fullWidth = true,
  hasBackground = false,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  hasPadding = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  ...props
}) => {
  const baseClasses = "flex-1";
  const widthClass = fullWidth ? "w-full" : "w-full max-w-4xl sm:max-w-5xl md:max-w-6xl lg:max-w-7xl mx-auto";
  const backgroundClass = hasBackground ? "bg-bg-secondary dark:bg-dark-bg-secondary" : "";
  const borderClass = isBordered ? "border border-border-color dark:border-dark-border-color" : "";
  const roundedClass = isRounded ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const paddingClass = hasPadding ? "p-6" : "";
  const loadingClass = isLoading ? "animate-pulse" : "";
  const errorClass = isError ? "border-system-error" : "";
  const warningClass = isWarning ? "border-system-warning" : "";
  const successClass = isSuccess ? "border-system-success" : "";
  const infoClass = isInfo ? "border-system-info" : "";
  const hasOverflow = className.includes("overflow-auto") || className.includes("overflow-y-auto") || className.includes("overflow-x-auto") || className.includes("overflow-scroll");
  const scrollbarClass = hasOverflow && !className.includes("custom-scrollbar") && !className.includes("custom-scrollbar-hidden") ? "custom-scrollbar" : "";
  const combinedClasses = [
    baseClasses,
    widthClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    paddingClass,
    loadingClass,
    errorClass,
    warningClass,
    successClass,
    infoClass,
    scrollbarClass,
    className
  ].filter(Boolean).join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "main",
    {
      className: combinedClasses,
      style,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      ...props,
      children
    }
  );
};
const LayoutSidebar = ({
  children,
  className = "",
  style,
  width = "md",
  position = "left",
  isSticky = false,
  hasBackground = false,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  ...props
}) => {
  const widthClasses = {
    sm: "w-48 sm:w-56 md:w-64 lg:w-72",
    md: "w-56 sm:w-64 md:w-80 lg:w-96",
    lg: "w-64 sm:w-72 md:w-96 lg:w-[28rem]",
    xl: "w-72 sm:w-80 md:w-[28rem] lg:w-[32rem]"
  };
  const baseClasses = widthClasses[width];
  const stickyClass = isSticky ? "sticky top-0 h-screen overflow-y-auto" : "";
  const positionClass = position === "right" ? "order-last" : "order-first";
  const backgroundClass = hasBackground ? "bg-bg-tertiary dark:bg-dark-bg-tertiary" : "";
  const borderClass = isBordered ? "border border-border-color dark:border-dark-border-color" : "";
  const roundedClass = isRounded ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const loadingClass = isLoading ? "animate-pulse" : "";
  const errorClass = isError ? "border-system-error" : "";
  const warningClass = isWarning ? "border-system-warning" : "";
  const successClass = isSuccess ? "border-system-success" : "";
  const infoClass = isInfo ? "border-system-info" : "";
  const combinedClasses = [
    baseClasses,
    stickyClass,
    positionClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    loadingClass,
    errorClass,
    warningClass,
    successClass,
    infoClass,
    className
  ].filter(Boolean).join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "aside",
    {
      className: combinedClasses,
      style,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      ...props,
      children
    }
  );
};
const Content = ({
  children,
  className = "",
  style,
  padding = "md",
  hasBackground = false,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  isFullWidth = true,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  ...props
}) => {
  const paddingClasses = {
    none: "",
    sm: "p-4",
    md: "p-6",
    lg: "p-8",
    xl: "p-12"
  };
  const baseClasses = paddingClasses[padding];
  const backgroundClass = hasBackground ? "bg-bg-tertiary dark:bg-dark-bg-tertiary" : "";
  const borderClass = isBordered ? "border border-border-color dark:border-dark-border-color" : "";
  const roundedClass = isRounded ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const loadingClass = isLoading ? "animate-pulse" : "";
  const errorClass = isError ? "border-system-error" : "";
  const warningClass = isWarning ? "border-system-warning" : "";
  const successClass = isSuccess ? "border-system-success" : "";
  const infoClass = isInfo ? "border-system-info" : "";
  const combinedClasses = [
    baseClasses,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    widthClass,
    loadingClass,
    errorClass,
    warningClass,
    successClass,
    infoClass,
    className
  ].filter(Boolean).join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: combinedClasses,
      style,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      ...props,
      children
    }
  );
};
const TwoColumnLayout = ({
  children,
  className = "",
  style,
  sidebarPosition = "left",
  gap = "lg",
  hasBackground = false,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  isFullWidth = true,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  ...props
}) => {
  const gapClasses = {
    sm: "gap-3 sm:gap-4 md:gap-6",
    md: "gap-4 sm:gap-6 md:gap-8",
    lg: "gap-6 sm:gap-8 md:gap-12",
    xl: "gap-8 sm:gap-12 md:gap-16"
  };
  const baseClasses = "flex flex-col lg:flex-row";
  const gapClass = gapClasses[gap];
  const backgroundClass = hasBackground ? "bg-bg-tertiary dark:bg-dark-bg-tertiary" : "";
  const borderClass = isBordered ? "border border-border-color dark:border-dark-border-color" : "";
  const roundedClass = isRounded ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const loadingClass = isLoading ? "animate-pulse" : "";
  const errorClass = isError ? "border-system-error" : "";
  const warningClass = isWarning ? "border-system-warning" : "";
  const successClass = isSuccess ? "border-system-success" : "";
  const infoClass = isInfo ? "border-system-info" : "";
  const combinedClasses = [
    baseClasses,
    gapClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    widthClass,
    loadingClass,
    errorClass,
    warningClass,
    successClass,
    infoClass,
    className
  ].filter(Boolean).join(" ");
  const [sidebar, main] = React__default.Children.toArray(children);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: combinedClasses,
      style,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      ...props,
      children: sidebarPosition === "left" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        sidebar,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 w-full lg:w-auto", children: main })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 w-full lg:w-auto", children: main }),
        sidebar
      ] })
    }
  );
};
const ThreeColumnLayout = ({
  children,
  className = "",
  style,
  gap = "lg",
  hasBackground = false,
  isBordered = false,
  isRounded = false,
  hasShadow = false,
  isFullWidth = true,
  isLoading = false,
  isError = false,
  isWarning = false,
  isSuccess = false,
  isInfo = false,
  onClick,
  onFocus,
  onBlur,
  onMouseEnter,
  onMouseLeave,
  ...props
}) => {
  const gapClasses = {
    sm: "gap-3 sm:gap-4 md:gap-6",
    md: "gap-4 sm:gap-6 md:gap-8",
    lg: "gap-6 sm:gap-8 md:gap-12",
    xl: "gap-8 sm:gap-12 md:gap-16"
  };
  const baseClasses = "flex flex-col lg:flex-row";
  const gapClass = gapClasses[gap];
  const backgroundClass = hasBackground ? "bg-bg-tertiary dark:bg-dark-bg-tertiary" : "";
  const borderClass = isBordered ? "border border-border-color dark:border-dark-border-color" : "";
  const roundedClass = isRounded ? "rounded-lg" : "";
  const shadowClass = hasShadow ? "shadow-md" : "";
  const widthClass = isFullWidth ? "w-full" : "w-auto";
  const loadingClass = isLoading ? "animate-pulse" : "";
  const errorClass = isError ? "border-system-error" : "";
  const warningClass = isWarning ? "border-system-warning" : "";
  const successClass = isSuccess ? "border-system-success" : "";
  const infoClass = isInfo ? "border-system-info" : "";
  const combinedClasses = [
    baseClasses,
    gapClass,
    backgroundClass,
    borderClass,
    roundedClass,
    shadowClass,
    widthClass,
    loadingClass,
    errorClass,
    warningClass,
    successClass,
    infoClass,
    className
  ].filter(Boolean).join(" ");
  const [leftSidebar, main, rightSidebar] = React__default.Children.toArray(children);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: combinedClasses,
      style,
      onClick,
      onFocus,
      onBlur,
      onMouseEnter,
      onMouseLeave,
      ...props,
      children: [
        leftSidebar,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 w-full lg:w-auto", children: main }),
        rightSidebar
      ]
    }
  );
};
const FormErrorBoundary = (props) => {
  const {
    error: error2,
    resetError,
    size: size2 = "md",
    variant = "default",
    color: color2 = "warning",
    preserveFormData = true,
    showRecoveryOptions = true,
    recoveryMessage = "Your form encountered an error, but we've saved your progress.",
    showBackupOptions = true,
    showExportOptions = true,
    showResetOptions = true,
    children,
    className = "",
    style,
    ...otherProps
  } = props;
  const sizeClasses2 = {
    xs: "text-xs p-2",
    sm: "text-sm p-3",
    md: "text-base p-4",
    lg: "text-lg p-5",
    xl: "text-xl p-6"
  };
  const variantClasses2 = {
    default: "bg-white dark:bg-gray-900",
    minimal: "bg-transparent",
    elevated: "bg-white dark:bg-gray-900 shadow-lg",
    bordered: "bg-white dark:bg-gray-900 border border-gray-200 dark:border-gray-700",
    filled: "bg-gray-50 dark:bg-gray-800"
  };
  const colorClasses2 = {
    primary: "border-primary-500 text-primary-700 dark:text-primary-300",
    success: "border-green-500 text-green-700 dark:text-green-300",
    warning: "border-yellow-500 text-yellow-700 dark:text-yellow-300",
    danger: "border-red-500 text-red-700 dark:text-red-300",
    info: "border-blue-500 text-blue-700 dark:text-blue-300",
    neutral: "border-gray-500 text-gray-700 dark:text-gray-300"
  };
  const combinedClasses = [
    "rounded-lg border-l-4 p-4",
    sizeClasses2[size2],
    variantClasses2[variant],
    colorClasses2[color2],
    className
  ].filter(Boolean).join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: combinedClasses, style, ...otherProps, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "h-5 w-5 text-current", children: "error" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium", children: "Form Error" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 text-sm", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: error2.message }),
        recoveryMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-2 text-gray-600 dark:text-gray-400", children: recoveryMessage })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-4 flex flex-wrap gap-2", children: [
        showResetOptions && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            size: "sm",
            variant: "outline",
            onClick: resetError,
            className: "text-xs",
            children: "Try Again"
          }
        ),
        showRecoveryOptions && preserveFormData && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            size: "sm",
            variant: "outline",
            onClick: () => console.log("Recovery options clicked"),
            className: "text-xs",
            children: "Recovery Options"
          }
        ),
        showBackupOptions && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            size: "sm",
            variant: "outline",
            onClick: () => console.log("Backup options clicked"),
            className: "text-xs",
            children: "Backup Data"
          }
        ),
        showExportOptions && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button$1,
          {
            size: "sm",
            variant: "outline",
            onClick: () => console.log("Export options clicked"),
            className: "text-xs",
            children: "Export Data"
          }
        )
      ] })
    ] })
  ] }) });
};
const FOOTER_THEMES = {
  default: {
    background: "bg-bg-primary dark:bg-dark-bg-primary",
    text: "text-text-primary dark:text-dark-text-primary",
    textSecondary: "text-text-secondary dark:text-dark-text-secondary",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-border-color dark:border-dark-border-color",
    logo: "text-text-primary dark:text-dark-text-primary",
    link: "text-text-secondary dark:text-dark-text-secondary hover:text-brand-orange",
    social: "text-text-secondary dark:text-dark-text-secondary hover:text-brand-orange",
    copyright: "text-text-tertiary dark:text-dark-text-tertiary",
    button: "bg-brand-orange hover:bg-brand-orange-dark",
    buttonText: "text-white"
  },
  brand: {
    background: "bg-brand-navy",
    text: "text-white",
    textSecondary: "text-gray-200",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-brand-navy-dark",
    logo: "text-white",
    link: "text-gray-200 hover:text-brand-orange",
    social: "text-gray-200 hover:text-brand-orange",
    copyright: "text-gray-300",
    button: "bg-brand-orange hover:bg-brand-orange-dark",
    buttonText: "text-white"
  },
  minimal: {
    background: "bg-white",
    text: "text-gray-900",
    textSecondary: "text-gray-600",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-gray-200",
    logo: "text-gray-900",
    link: "text-gray-600 hover:text-brand-orange",
    social: "text-gray-600 hover:text-brand-orange",
    copyright: "text-gray-500",
    button: "bg-brand-orange hover:bg-brand-orange-dark",
    buttonText: "text-white"
  },
  grey: {
    background: "bg-gray-800",
    text: "text-white",
    textSecondary: "text-gray-300",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-gray-700",
    logo: "text-white",
    link: "text-gray-300 hover:text-brand-orange",
    social: "text-gray-300 hover:text-brand-orange",
    copyright: "text-gray-400",
    button: "bg-brand-orange hover:bg-brand-orange-dark",
    buttonText: "text-white"
  },
  dark: {
    background: "bg-gray-900 dark:bg-gray-900",
    text: "text-white dark:text-white",
    textSecondary: "text-gray-300 dark:text-gray-300",
    hover: "hover:text-brand-orange",
    active: "text-brand-orange",
    border: "border-gray-700 dark:border-gray-700",
    logo: "text-white dark:text-white",
    link: "text-gray-300 dark:text-gray-300 hover:text-brand-orange",
    social: "text-gray-300 dark:text-gray-300 hover:text-brand-orange",
    copyright: "text-gray-400 dark:text-gray-400",
    button: "bg-brand-orange hover:bg-brand-orange-dark",
    buttonText: "text-white"
  }
};
const getFooterThemeClasses = (theme, customColors) => {
  if (theme === "custom" && customColors) {
    return {
      background: customColors.backgroundColor ? `bg-[${customColors.backgroundColor}]` : FOOTER_THEMES.default.background,
      text: customColors.textColor ? `text-[${customColors.textColor}]` : FOOTER_THEMES.default.text,
      textSecondary: customColors.textSecondaryColor ? `text-[${customColors.textSecondaryColor}]` : FOOTER_THEMES.default.textSecondary,
      hover: customColors.hoverColor ? `hover:text-[${customColors.hoverColor}]` : FOOTER_THEMES.default.hover,
      active: customColors.activeColor ? `text-[${customColors.activeColor}]` : FOOTER_THEMES.default.active,
      border: customColors.borderColor ? `border-[${customColors.borderColor}]` : FOOTER_THEMES.default.border,
      logo: customColors.logoColor ? `text-[${customColors.logoColor}]` : FOOTER_THEMES.default.logo,
      link: customColors.linkColor ? `text-[${customColors.linkColor}]` : FOOTER_THEMES.default.link,
      social: customColors.socialColor ? `text-[${customColors.socialColor}]` : FOOTER_THEMES.default.social,
      copyright: customColors.copyrightColor ? `text-[${customColors.copyrightColor}]` : FOOTER_THEMES.default.copyright,
      button: customColors.buttonColor ? `bg-[${customColors.buttonColor}] hover:bg-[${customColors.buttonColor}]/80` : FOOTER_THEMES.default.button,
      buttonText: customColors.buttonTextColor ? `text-[${customColors.buttonTextColor}]` : FOOTER_THEMES.default.buttonText
    };
  }
  return FOOTER_THEMES[theme] || FOOTER_THEMES.default;
};
const FooterContext = createContext(null);
const useFooterContext = () => {
  const context = useContext(FooterContext);
  if (!context) {
    throw new Error("Footer sub-components must be used within a Footer component");
  }
  return context;
};
const FooterRoot = ({
  variant = "default",
  size: size2 = "md",
  theme = "default",
  customColors,
  sticky = false,
  className,
  children,
  ...htmlProps
}) => {
  const themeClasses = getFooterThemeClasses(theme, customColors);
  const variantClasses2 = {
    default: "py-8",
    minimal: "py-4",
    extended: "py-12",
    landing: "py-16",
    dashboard: "py-6"
  };
  const sizeClasses2 = {
    sm: "text-sm",
    md: "text-base",
    lg: "text-lg",
    xl: "text-xl"
  };
  const stickyClasses = sticky ? "sticky bottom-0 z-50" : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FooterContext.Provider, { value: { variant, size: size2, theme, customColors, themeClasses }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "footer",
    {
      className: cn(
        "w-full border-t",
        themeClasses.background,
        themeClasses.border,
        themeClasses.text,
        "[&>*]:text-inherit",
        // Ensure all direct children inherit text color
        "[&_h1]:!text-inherit",
        // Override global h1 styles
        "[&_h2]:!text-inherit",
        // Override global h2 styles
        "[&_h3]:!text-inherit",
        // Override global h3 styles
        "[&_h4]:!text-inherit",
        // Override global h4 styles
        "[&_h5]:!text-inherit",
        // Override global h5 styles
        "[&_h6]:!text-inherit",
        // Override global h6 styles
        variantClasses2[variant],
        sizeClasses2[size2],
        stickyClasses,
        className
      ),
      ...htmlProps,
      children
    }
  ) });
};
const FooterSection = ({
  title,
  children,
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useFooterContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("space-y-4", className), ...htmlProps, children: [
    title && /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: cn("text-sm font-semibold uppercase tracking-wider", themeClasses.text), children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children })
  ] });
};
const FooterLinks = ({
  links,
  columns = 1,
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useFooterContext();
  const gridClasses = {
    1: "grid-cols-1",
    2: "grid-cols-2",
    3: "grid-cols-3",
    4: "grid-cols-4"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("grid gap-2", gridClasses[columns], className), ...htmlProps, children: links.map((link, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      href: link.href,
      target: link.external ? "_blank" : void 0,
      rel: link.external ? "noopener noreferrer" : void 0,
      className: cn("text-sm transition-colors", themeClasses.link),
      children: link.label
    },
    index2
  )) });
};
const FooterSocial = ({
  socialLinks,
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useFooterContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("flex space-x-4", className), ...htmlProps, children: socialLinks.map((social, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "a",
    {
      href: social.href,
      target: "_blank",
      rel: "noopener noreferrer",
      className: cn("p-2 rounded-full transition-colors", themeClasses.social),
      "aria-label": social.name,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: social.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg", children: social.icon })
      ]
    },
    index2
  )) });
};
const FooterBrand = ({
  text,
  href = "#",
  isClickable = true,
  className,
  ...htmlProps
}) => {
  const { theme, themeClasses } = useFooterContext();
  const hasCustomText = text !== void 0 && text !== null && text !== "";
  const [isDarkMode, setIsDarkMode] = useState(
    () => theme === "dark" || theme === "default" && document.documentElement.classList.contains("dark")
  );
  React__default.useEffect(() => {
    if (theme !== "default") {
      setIsDarkMode(theme === "dark");
      return;
    }
    const handleThemeChange = () => {
      setIsDarkMode(document.documentElement.classList.contains("dark"));
    };
    window.addEventListener("storage", handleThemeChange);
    window.addEventListener("themeChanged", handleThemeChange);
    return () => {
      window.removeEventListener("storage", handleThemeChange);
      window.removeEventListener("themeChanged", handleThemeChange);
    };
  }, [theme]);
  const logoSrc = React__default.useMemo(() => {
    if (theme !== "default") {
      if (hasCustomText) {
        if (theme === "brand" || theme === "dark") return LOGO_URLS.dark.icon;
        if (theme === "minimal") return LOGO_URLS.grey.light.icon;
        if (theme === "grey") return LOGO_URLS.grey.dark.icon;
      } else {
        if (theme === "brand" || theme === "dark") return LOGO_URLS.dark.full;
        if (theme === "minimal") return LOGO_URLS.grey.light.full;
        if (theme === "grey") return LOGO_URLS.grey.dark.full;
      }
    }
    return hasCustomText ? isDarkMode ? LOGO_URLS.dark.icon : LOGO_URLS.light.icon : isDarkMode ? LOGO_URLS.dark.full : LOGO_URLS.light.full;
  }, [theme, hasCustomText, isDarkMode]);
  const content = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-3", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        src: logoSrc,
        alt: "Acutrack Logo",
        className: "h-8 w-auto"
      }
    ),
    hasCustomText && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: cn("text-xl font-bold", themeClasses.logo), children: text })
  ] });
  if (isClickable) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "a",
      {
        href,
        className: cn("inline-flex items-center", className),
        ...htmlProps,
        children: content
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("inline-flex items-center", className), ...htmlProps, children: content });
};
const FooterCopyright = ({
  text,
  year = (/* @__PURE__ */ new Date()).getFullYear(),
  company = "Acutrack",
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useFooterContext();
  const copyrightText = text || `© ${year} ${company}. All rights reserved.`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("text-sm", themeClasses.copyright, className), ...htmlProps, children: copyrightText });
};
const FooterContact = ({
  email,
  phone,
  address,
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useFooterContext();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("space-y-2", className), ...htmlProps, children: [
    email && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: themeClasses.textSecondary, children: "Email: " }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: `mailto:${email}`, className: cn("transition-colors", themeClasses.link), children: email })
    ] }),
    phone && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: themeClasses.textSecondary, children: "Phone: " }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: `tel:${phone}`, className: cn("transition-colors", themeClasses.link), children: phone })
    ] }),
    address && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: themeClasses.textSecondary, children: "Address: " }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: themeClasses.textSecondary, children: address })
    ] })
  ] });
};
const FooterNewsletter = ({
  title = "Newsletter",
  placeholder = "Enter your email",
  buttonText = "Subscribe",
  onSubmit,
  className,
  ...htmlProps
}) => {
  const { themeClasses } = useFooterContext();
  const [email, setEmail] = useState("");
  const handleSubmit = (e2) => {
    e2.preventDefault();
    if (onSubmit && email) {
      onSubmit(email);
      setEmail("");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn("space-y-4", className), ...htmlProps, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: cn("text-sm font-semibold uppercase tracking-wider", themeClasses.text), children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit, className: "flex space-x-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "email",
          value: email,
          onChange: (e2) => setEmail(e2.target.value),
          placeholder,
          className: cn(
            "flex-1 px-3 py-2 text-sm border rounded-md focus:ring-2 focus:ring-brand-orange focus:border-transparent",
            themeClasses.border,
            "bg-bg-secondary dark:bg-dark-bg-secondary",
            themeClasses.text
          ),
          required: true
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "submit",
          className: cn(
            "px-4 py-2 text-sm font-medium rounded-md transition-colors",
            themeClasses.button,
            themeClasses.buttonText,
            themeClasses.hover
          ),
          children: buttonText
        }
      )
    ] })
  ] });
};
const FooterContainer = ({
  children,
  className,
  ...htmlProps
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn("max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", className), ...htmlProps, children });
};
const Footer = Object.assign(FooterRoot, {
  Section: FooterSection,
  Links: FooterLinks,
  Social: FooterSocial,
  Brand: FooterBrand,
  Copyright: FooterCopyright,
  Contact: FooterContact,
  Newsletter: FooterNewsletter,
  Container: FooterContainer
});
const HeaderExample = () => {
  const handleLogin = () => {
    console.log("Login clicked");
  };
  const handleSignUp = () => {
    console.log("Sign up clicked");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "website", size: "md", sticky: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "Acutrack", href: "#home" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Header.Navigation, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header.NavItem, { href: "#home", isActive: true, children: "Home" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header.NavItem, { href: "#about", children: "About" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header.NavItem, { href: "#services", children: "Services" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header.NavItem, { href: "#contact", children: "Contact" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleLogin,
              className: "px-4 py-2 text-sm font-medium text-gray-700 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white",
              children: "Login"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleSignUp,
              className: "px-4 py-2 text-sm font-medium text-white bg-brand-orange rounded-md hover:bg-orange-600",
              children: "Sign Up"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Header.ThemeSwitcher, {})
        ] }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
const HeaderWithCustomLogo$1 = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "lg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "My Company", href: "#" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 5 }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
const HeaderWithUserMenu = () => {
  const user = {
    name: "John Doe",
    avatar: "https://via.placeholder.com/32"
  };
  const userLinks = [
    { href: "#profile", label: "Profile", icon: "person" },
    { href: "#settings", label: "Settings", icon: "settings" },
    { href: "#logout", label: "Logout", icon: "logout", color: "danger" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "lg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "Acutrack", href: "#" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Header.UserMenu, { user, links: userLinks })
        ] }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
const HeaderWithHiddenLogo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { variant: "default", size: "md", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Header.ResponsiveActions,
    {
      common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
      desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
      mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
    }
  ) });
};
const HeaderWithLogo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "Acutrack" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
const HeaderWithCustomLogo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "My App", href: "/" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
const HeaderWithConditionalLogo = () => {
  const [showLogo, setShowLogo] = React__default.useState(true);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => setShowLogo(!showLogo),
        className: "px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600",
        children: showLogo ? "Hide Logo" : "Show Logo"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "md", children: [
      showLogo && /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "Acutrack" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header.ResponsiveActions,
        {
          common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
          desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
          mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
        }
      )
    ] })
  ] });
};
const HeaderWithResponsiveLogo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "Acutrack", className: "hidden md:block" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
const HeaderWithTextOnlyLogo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "My App", href: "/" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
const HeaderWithCSSHiddenLogo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Logo, { text: "Acutrack", className: "opacity-0 pointer-events-none" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
const HeaderWithRoleBasedLogo = () => {
  const userRole = "guest";
  const shouldShowLogo = userRole !== "guest";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header, { variant: "default", size: "md", children: [
    shouldShowLogo,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Header.ResponsiveActions,
      {
        common: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Search, { placeholder: "Search..." }),
        desktop: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.Notifications, { count: 3 }),
        mobile: /* @__PURE__ */ jsxRuntimeExports.jsx(Header.MobileMenu, {})
      }
    )
  ] });
};
export {
  ACUTRACK_LOGO_DARK,
  ACUTRACK_LOGO_ICON_DARK,
  ACUTRACK_LOGO_ICON_LIGHT,
  ACUTRACK_LOGO_LIGHT,
  Accordion,
  Alert,
  AreaChart,
  Autocomplete,
  Avatar,
  Badge,
  Banner,
  BarChart,
  BreadcrumbCompound as Breadcrumb,
  BreadcrumbLink,
  BrowserCompatibility,
  Button$1 as Button,
  ButtonGroup,
  ButtonLink,
  Calendar$1 as Calendar,
  Card,
  Checkbox,
  CircularProgress,
  CodeBlock,
  ComponentPreview,
  Container,
  Content,
  CopiedFeedback,
  DEFAULT_LOGO_CONFIGS,
  DatePicker,
  DateRangePicker,
  DonutChart,
  Drawer,
  Dropdown,
  EmptyState,
  EnhancedDatePicker,
  ErrorBoundary,
  ErrorBoundaryFallback,
  FileUploader,
  Footer,
  FormErrorBoundary,
  Grid,
  Header,
  HeaderExample,
  HeaderWithCSSHiddenLogo,
  HeaderWithConditionalLogo,
  HeaderWithCustomLogo$1 as HeaderWithCustomLogo,
  HeaderWithCustomLogo as HeaderWithCustomLogoVisibility,
  HeaderWithHiddenLogo,
  HeaderWithLogo,
  HeaderWithResponsiveLogo,
  HeaderWithRoleBasedLogo,
  HeaderWithTextOnlyLogo,
  HeaderWithUserMenu,
  Icon,
  Input,
  LOGO_URLS,
  LanguageProvider,
  LanguageSelector,
  Layout,
  LayoutHeader,
  LayoutSidebar,
  LineChart,
  Link,
  Main,
  Modal,
  MultiSelect,
  NavLink,
  NumberInput,
  OTPInput,
  Pagination,
  PasswordInput,
  PieChart,
  Popover,
  PrimaryLink,
  Progress,
  PropsTable,
  Radio,
  ScatterPlot,
  SearchBar,
  SecondaryLink,
  SectionContainer,
  Select,
  Sidebar,
  Skeleton,
  SkeletonCard,
  SkeletonCircle,
  SkeletonText,
  Slider,
  SocialLink,
  Spinner,
  SplitButton,
  Stack,
  Stepper,
  SubSection,
  Table,
  Tabs,
  TextLink,
  Textarea,
  ThreeColumnLayout,
  Toast,
  ToastProvider,
  ToggleSwitch,
  Tooltip,
  TreeView,
  TwoColumnLayout,
  VirtualizedTable,
  VirtualizedTableErrorBoundary,
  dateFormatExamples,
  formatDate,
  formatDateWithOptions,
  formatString,
  getLanguageList,
  getPresetRanges,
  getTranslation,
  languageList,
  parseDateInput,
  useCopyToClipboard,
  useErrorBoundary,
  useLanguage,
  useOnClickOutside,
  useToast,
  withErrorBoundary
};
//# sourceMappingURL=acutrack-ds.es.js.map
